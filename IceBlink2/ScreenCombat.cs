using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using Bitmap = SharpDX.Direct2D1.Bitmap;
using Color = SharpDX.Color;

namespace IceBlink2
{
    public class ScreenCombat
    {
        //public Module gv.mod;
        public GameView gv;

        public bool creaturesHaveUpperHand = false;
        public bool partyHasUpperHand = false;


        //public List<int> originalAoEofSpells = new List<int>(); 
        public List<Coordinate> blockCreatureDrawLocations = new List<Coordinate>();

        public bool allDone = false;

        public Prop ThisProp = null;
        public int roundCounter = 1;
        public bool floatyTextEnlargerOn = false;

        public List<string> tagsOfTriggersAndPropTriggersCalledThisTurn = new List<string>();

        public List<string> alreadyTargetedCreatureTagsList = new List<string>();
        public int upperLeftInFastForwardX = -100;
        public int upperLeftInFastForwardY = -100;
        public int maxUsableCounterValue = 0;
        public int slowDownFastForwardCounter = 0;
        public int framesInFastForwardCounter = 0;
        public int attackAnimationDelayCounter = 0;
        public bool blockAnimationBridge = false;
        public IB2UILayout combatUiLayout = null;
        public bool showHP = false;
        public bool showSP = false;
        public bool showMoveKeys = false;
        public bool showMoveOrder = false;
        public bool showIniBar = true;
        public bool showArrows = true;
        public string nameOfPcTheCreatureMovesTowards = "NoPcTargetChosenYet";
        public Coordinate coordinatesOfPcTheCreatureMovesTowards = new Coordinate(-1, -1);
        public List<Coordinate> storedPathOfCurrentCreature = new List<Coordinate>();
        public int attackAnimationFrameCounter = 0;
        //public float glidedDistanceAcrossThisSquare = 0;
        public float currentPixelLocX = 0;
        public float currentPixelLocY = 0;
        public float destinationPixelLocX = 0;
        public float destinationPixelLocY = 0;
        public string moveDirection = ""; //available: N,NE,E,SE,S,SW,W,NW
        public int idx = 0;
        public int triggerIndexCombat = 0;
        public bool didTriggerEvent = false;

        //public int creatureCounter2 = 0;

        //INITIATIVE BAR STUFF
        //each bar holds 34 buttons deactivated at start
        //a bar can contain up to 17 living large or 34 living normal creatures or any mix of these
        //only as many buttons are activated as creatures are contained in current bar, large certaures counted double for this purpose (have 2 buttons)
        //only as many backgroundTiles are drawn as creatures are contained in current bar, normal cretaures counted half for this pupose (have 0.5 background tiles)

        public int numberOfCurrentlyShownBar = 1;

        public List<int> ListOfCreaturesDisplayedInBar1 = new List<int>();
        public List<int> ListOfCreaturesDisplayedInBar2 = new List<int>();
        public List<int> ListOfCreaturesDisplayedInBar3 = new List<int>();
        public List<int> ListOfCreaturesDisplayedInBar4 = new List<int>();
        public List<int> ListOfCreaturesDisplayedInBar5 = new List<int>();
        public List<int> ListOfCreaturesDisplayedInBar6 = new List<int>();

        public List<int> ListOfSizesOfCreaturesInBar1 = new List<int>();
        public List<int> ListOfSizesOfCreaturesInBar2 = new List<int>();
        public List<int> ListOfSizesOfCreaturesInBar3 = new List<int>();
        public List<int> ListOfSizesOfCreaturesInBar4 = new List<int>();
        public List<int> ListOfSizesOfCreaturesInBar5 = new List<int>();
        public List<int> ListOfSizesOfCreaturesInBar6 = new List<int>();

        public List<int> ListOfCreaturesDisplayedInCurrentBar = new List<int>();
        public List<int> ListOfSizesOfCreaturesInCurrentBar = new List<int>();

        public int NumberOfButtonsDisplayedInBar1 = 0;
        public int NumberOfButtonsDisplayedInBar2 = 0;
        public int NumberOfButtonsDisplayedInBar3 = 0;
        public int NumberOfButtonsDisplayedInBar4 = 0;
        public int NumberOfButtonsDisplayedInBar5 = 0;
        public int NumberOfButtonsDisplayedInBar6 = 0;

        public int NumberOfBackgroundTilesDisplayedInBar1 = 0;
        public int NumberOfBackgroundTilesDisplayedInBar2 = 0;
        public int NumberOfBackgroundTilesDisplayedInBar3 = 0;
        public int NumberOfBackgroundTilesDisplayedInBar4 = 0;
        public int NumberOfBackgroundTilesDisplayedInBar5 = 0;
        public int NumberOfBackgroundTilesDisplayedInBar6 = 0;

        public List<int> moverOrdersOfAllLivingCreatures = new List<int>();
        public List<int> moverOrdersOfAllFallenCreatures = new List<int>();
        public List<int> moverOrdersOfLargeLivingCreatures = new List<int>();
        public List<int> moverOrdersOfLargeFallenCreatures = new List<int>();
        public List<int> moverOrdersOfNormalLivingCreatures = new List<int>();
        public List<int> moverOrdersOfNormalFallenCreatures = new List<int>();

        //public List<int> moverOrdersOfWideLivingCreatures = new List<int>();
        //public List<int> moverOrdersOfWideFallenCreatures = new List<int>();
        //public List<int> moverOrdersOfTallLivingCreatures = new List<int>();
        //public List<int> moverOrdersOfTallFallenCreatures = new List<int>();

        //COMBAT STUFF
        public bool adjustCamToRangedCreature = false;
        public bool isPlayerTurn = false;
        public bool dontEndTurn = false;
        public bool dontEndCreatureTurn = false;
        public bool continueTurn = false;
        public bool canMove = true;
        public int currentPlayerIndex = 0;
        public int creatureIndex = 0;
        public int currentMoveOrderIndex = 0;
        public List<MoveOrder> moveOrderList = new List<MoveOrder>();
        public int initialMoveOrderListSize = 0;
        public float currentMoves = 0;
        public float creatureMoves = 0;
        public Coordinate UpperLeftSquare = new Coordinate();
        public Coordinate FormerUpperLeftSquare = new Coordinate();

        public string currentCombatMode = "info"; //info, move, cast, attack
        public Coordinate targetHighlightCenterLocation = new Coordinate();
        public Coordinate creatureTargetLocation = new Coordinate();
        public int encounterXP = 0;
        private List<Creature> creatureToAnimate = new List<Creature>();
        private Player playerToAnimate = null;
        //private bool drawHitAnimation = false;
        //private bool drawMissAnimation = false;
        private Coordinate hitAnimationLocation = new Coordinate();
        public int spellSelectorIndex = 0;
        public List<string> spellSelectorSpellTagList = new List<string>();
        //private bool drawProjectileAnimation = false;
        private Coordinate projectileAnimationLocation = new Coordinate();
        //private bool drawEndingAnimation = false;
        private Coordinate endingAnimationLocation = new Coordinate();
        public bool drawDeathAnimation = true;
        public List<Coordinate> deathAnimationLocations = new List<Coordinate>();
        private int animationFrameIndex = 0;
        public PathFinderEncounters pf;
        public bool floatyTextOn = false;
        public AnimationState animationState = AnimationState.None;
        //private Bitmap projectile;
        //private bool projectileFacingUp = true;
        //private Bitmap ending_fx;
        private Bitmap mapBitmap;

        /*private IbbButton btnSelect = null;
	    private IbbButton btnMove = null;
	    private IbbButton btnAttack = null;
	    private IbbButton btnCast = null;
	    private IbbButton btnSkipTurn = null;
	    private IbbButton btnSwitchWeapon = null;
        private IbbButton btnMoveCounter = null;
	    public IbbToggleButton tglHP = null;
	    public IbbToggleButton tglSP = null;
        public IbbToggleButton tglMoveOrder = null;
	    public IbbToggleButton tglSpeed = null;
	    public IbbToggleButton tglSoundFx = null;
	    public IbbToggleButton tglKill = null;
	    public IbbToggleButton tglHelp = null;
	    public IbbToggleButton tglGrid = null;*/
        public int mapStartLocXinPixels;
        public float moveCost = 1.0f;
        public List<Sprite> spriteList = new List<Sprite>();
        public List<AnimationSequence> animationSeqStack = new List<AnimationSequence>();
        public bool animationsOn = false;
        public bool stepAnimationsOn = false;
        public int attackAnimationTimeElapsed = 0;
        public int attackAnimationLengthInMilliseconds = 250;

        public ScreenCombat(Module m, GameView g)
        {
            //mod = m;
            gv = g;
            mapStartLocXinPixels = 0 * gv.squareSize;
            loadMainUILayout();
            //CalculateUpperLeft();
            //setControlsStart();
            //setToggleButtonsStart();
        }

        public void saveUILayout()
        {
            try
            {
                //string filepath = gv.mainDirectory + "\\CombatUILayout.json";
                string filepath = gv.cc.GetModulePath() + "\\data\\CombatUILayout.json";
                string json = JsonConvert.SerializeObject(combatUiLayout, Newtonsoft.Json.Formatting.Indented);
                using (StreamWriter sw = new StreamWriter(filepath))
                {
                    sw.Write(json.ToString());
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
            }
        }

        public void loadMainUILayout()
        {
            try
            {
                if (File.Exists(gv.cc.GetModulePath() + "\\data\\CombatUILayout.json"))
                {
                    using (StreamReader file = File.OpenText(gv.cc.GetModulePath() + "\\data\\CombatUILayout.json"))
                    {
                        JsonSerializer serializer = new JsonSerializer();
                        combatUiLayout = (IB2UILayout)serializer.Deserialize(file, typeof(IB2UILayout));
                        combatUiLayout.setupIB2UILayout(gv);
                    }
                }
                else
                {
                    using (StreamReader file = File.OpenText(gv.mainDirectory + "\\default\\NewModule\\data\\CombatUILayout.json"))
                    {
                        JsonSerializer serializer = new JsonSerializer();
                        combatUiLayout = (IB2UILayout)serializer.Deserialize(file, typeof(IB2UILayout));
                        combatUiLayout.setupIB2UILayout(gv);
                    }
                }

                IB2ToggleButton tgl = combatUiLayout.GetToggleByTag("tglHP");
                if (tgl != null)
                {
                    showHP = tgl.toggleOn;
                }
                IB2ToggleButton tgl2 = combatUiLayout.GetToggleByTag("tglSP");
                if (tgl2 != null)
                {
                    showSP = tgl2.toggleOn;
                }
                IB2ToggleButton tgl3 = combatUiLayout.GetToggleByTag("tglMoveKeys");
                if (tgl3 != null)
                {
                    showMoveKeys = tgl3.toggleOn;
                }
                foreach (IB2Panel pnlC in combatUiLayout.panelList)
                {
                    if (pnlC.tag.Equals("logPanel"))
                    {
                        foreach (IB2Panel pnlM in gv.screenMainMap.mainUiLayout.panelList)
                        {
                            if (pnlM.tag.Equals("logPanel"))
                            {
                                pnlC.logList[0] = pnlM.logList[0];
                            }
                        }
                    }

                    if (gv.mod.useMinimalisticUI)
                    {
                        if (pnlC.tag.Equals("arrowPanel"))
                        {
                            pnlC.hiding = true;
                            pnlC.showing = false;
                            showArrows = false;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error Loading CombatUILayout.json: " + ex.ToString());
                gv.errorLog(ex.ToString());
            }
        }

        /*public void setControlsStart()
	    {		
		    int pW = (int)((float)gv.screenWidth / 100.0f);
		    int pH = (int)((float)gv.screenHeight / 100.0f);
		    int padW = gv.squareSize/6;
            int hotkeyShift = 0;
            if (gv.useLargeLayout)
            {
                hotkeyShift = 1;
            }


            if (btnSelect == null)
		    {
			    btnSelect = new IbbButton(gv, 0.8f);	
			    btnSelect.Text = "SELECT";
			    btnSelect.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
			    btnSelect.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                btnSelect.X = gv.cc.pnlArrows.LocX + 1 * gv.squareSize + gv.squareSize / 2;
                btnSelect.Y = gv.cc.pnlArrows.LocY + 1 * gv.squareSize + gv.pS;
                btnSelect.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSelect.Width = (int)(gv.ibbwidthR * gv.screenDensity);
		    }			
		    if (btnMove == null)
		    {
			    btnMove = new IbbButton(gv, 0.8f);
			    btnMove.Img = gv.cc.LoadBitmap("btn_small");
                btnMove.ImgOn = gv.cc.LoadBitmap("btn_small_on");
                btnMove.ImgOff = gv.cc.LoadBitmap("btn_small_off");
			    btnMove.Glow = gv.cc.LoadBitmap("btn_small_glow");
			    btnMove.Text = "MOVE";
                btnMove.HotKey = "M";
                btnMove.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 3) * gv.squareSize;
                btnMove.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnMove.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnMove.Width = (int)(gv.ibbwidthR * gv.screenDensity);			
		    }
            if (btnMoveCounter == null)
            {
                btnMoveCounter = new IbbButton(gv, 1.2f);
                btnMoveCounter.Img = gv.cc.LoadBitmap("btn_small_off"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnMoveCounter.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                btnMoveCounter.Text = "0";
                btnMoveCounter.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 6) * gv.squareSize;
                btnMoveCounter.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnMoveCounter.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnMoveCounter.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
		    if (btnAttack == null)
		    {
			    btnAttack = new IbbButton(gv, 0.8f);
			    btnAttack.Img = gv.cc.LoadBitmap("btn_small");
                btnAttack.ImgOn = gv.cc.LoadBitmap("btn_small_on");
                btnAttack.ImgOff = gv.cc.LoadBitmap("btn_small_off");
			    btnAttack.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
			    btnAttack.Text = "ATTACK";
                btnAttack.HotKey = "A";
                btnAttack.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 4) * gv.squareSize;
                btnAttack.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnAttack.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnAttack.Width = (int)(gv.ibbwidthR * gv.screenDensity);			
		    }
		    if (btnCast == null)
		    {
			    btnCast = new IbbButton(gv, 0.8f);
			    btnCast.Img = gv.cc.LoadBitmap("btn_small");
                btnCast.ImgOn = gv.cc.LoadBitmap("btn_small_on");
                btnCast.ImgOff = gv.cc.LoadBitmap("btn_small_off");
			    btnCast.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
			    btnCast.Text = "CAST";
                btnCast.HotKey = "C";
                btnCast.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 5) * gv.squareSize;
                btnCast.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnCast.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnCast.Width = (int)(gv.ibbwidthR * gv.screenDensity);			
		    }
		    if (btnSkipTurn == null)
		    {
			    btnSkipTurn = new IbbButton(gv, 0.8f);
			    btnSkipTurn.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
			    btnSkipTurn.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
			    btnSkipTurn.Text = "SKIP";
                btnSkipTurn.HotKey = "S";
                btnSkipTurn.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 2) * gv.squareSize;
                btnSkipTurn.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnSkipTurn.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSkipTurn.Width = (int)(gv.ibbwidthR * gv.screenDensity);			
		    }
		    if (btnSwitchWeapon == null)
		    {
			    btnSwitchWeapon = new IbbButton(gv, 0.8f);
                btnSwitchWeapon.HotKey = "P";
			    btnSwitchWeapon.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
			    btnSwitchWeapon.Img2 = gv.cc.LoadBitmap("btnparty"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnparty);
			    btnSwitchWeapon.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                btnSwitchWeapon.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 0) * gv.squareSize;
                btnSwitchWeapon.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnSwitchWeapon.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSwitchWeapon.Width = (int)(gv.ibbwidthR * gv.screenDensity);			
					
		    }
	    }*/
        /*public void setToggleButtonsStart()
        {
    	    int pW = (int)((float)gv.screenWidth / 100.0f);
		    int pH = (int)((float)gv.screenHeight / 100.0f);
		    int padW = gv.squareSize/6;
			
		    if (tglGrid == null)
		    {
			    tglGrid = new IbbToggleButton(gv);
			    tglGrid.ImgOn = gv.cc.LoadBitmap("tgl_grid_on");
			    tglGrid.ImgOff = gv.cc.LoadBitmap("tgl_grid_off");
                tglGrid.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglGrid.Y = gv.cc.pnlToggles.LocY + 1 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglGrid.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglGrid.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
			    tglGrid.toggleOn = true;
		    }
		    if (tglHP == null)
		    {
			    tglHP = new IbbToggleButton(gv);
			    tglHP.ImgOn = gv.cc.LoadBitmap("tgl_hp_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_hp_on);
			    tglHP.ImgOff = gv.cc.LoadBitmap("tgl_hp_off"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_hp_off);
                tglHP.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglHP.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglHP.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglHP.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
		    }
		    if (tglSP == null)
		    {
			    tglSP = new IbbToggleButton(gv);
			    tglSP.ImgOn = gv.cc.LoadBitmap("tgl_sp_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_on);
			    tglSP.ImgOff = gv.cc.LoadBitmap("tgl_sp_off"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_off);
                tglSP.X = gv.cc.pnlToggles.LocX + 2 * gv.squareSize + gv.squareSize / 4;
                tglSP.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglSP.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglSP.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
		    }
            if (tglMoveOrder == null)
            {
                tglMoveOrder = new IbbToggleButton(gv);
                tglMoveOrder.ImgOn = gv.cc.LoadBitmap("tgl_mo_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_on);
                tglMoveOrder.ImgOff = gv.cc.LoadBitmap("tgl_mo_off"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_off);
                tglMoveOrder.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglMoveOrder.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglMoveOrder.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglMoveOrder.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
            }
		    if (tglSpeed == null)
		    {
			    tglSpeed = new IbbToggleButton(gv);
			    tglSpeed.ImgOn = gv.cc.LoadBitmap("tgl_speed_4"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_on);
			    tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_4"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_off);
                tglSpeed.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglSpeed.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglSpeed.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglSpeed.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
		    }
		    if (tglSoundFx == null)
		    {
			    tglSoundFx = new IbbToggleButton(gv);
			    tglSoundFx.ImgOn = gv.cc.LoadBitmap("tgl_sound_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_on);
			    tglSoundFx.ImgOff = gv.cc.LoadBitmap("tgl_sound_off"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_off);
                tglSoundFx.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglSoundFx.Y = gv.cc.pnlToggles.LocY + 1 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglSoundFx.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglSoundFx.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
		    }
		    if (tglHelp == null)
		    {
			    tglHelp = new IbbToggleButton(gv);
			    tglHelp.ImgOn = gv.cc.LoadBitmap("tgl_help_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_on);
			    tglHelp.ImgOff = gv.cc.LoadBitmap("tgl_help_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_off);
                tglHelp.X = gv.cc.pnlToggles.LocX + 2 * gv.squareSize + gv.squareSize / 4;
                tglHelp.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglHelp.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglHelp.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
		    }
		    if (tglKill == null)
		    {
			    tglKill = new IbbToggleButton(gv);
			    tglKill.ImgOn = gv.cc.LoadBitmap("tgl_kill_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_on);
			    tglKill.ImgOff = gv.cc.LoadBitmap("tgl_kill_on"); // BitmapFactory.decodeResource(getResources(), R.drawable.tgl_sp_off);
                tglKill.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglKill.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglKill.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglKill.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
		    }
        }*/
        /*public void resetToggleButtons()
        {
            if (gv.mod.combatAnimationSpeed == 100)
            {
                gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_1");
            }
            else if (gv.mod.combatAnimationSpeed == 50)
            {
                gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_2");
            }
            else if (gv.mod.combatAnimationSpeed == 25)
            {
                gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_4");
            }
            else if (gv.mod.combatAnimationSpeed == 10)
            {
                gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_10");
            }

            if (gv.mod.playMusic)
            {
                gv.cc.tglSound.toggleOn = true;
            }
            else
            {
                gv.cc.tglSound.toggleOn = false;
            }

            if (gv.mod.playSoundFx)
            {
                tglSoundFx.toggleOn = true;
            }
            else
            {
                tglSoundFx.toggleOn = false;
            }
        }*/
        public void tutorialMessageCombat(bool helpCall)
        {
            if ((gv.mod.showTutorialCombat) || (helpCall))
            {
                gv.sf.MessageBoxHtml(
                        "<big><b>COMBAT</b></big><br><br>" +

                        "<b>1. Player's Turn:</b> Each player takes a turn. The current player will be highlighted with a" +
                        " light blue box. You can Move one square (or stay put) and make one additional action such" +
                        " as ATTACK, CAST, use item, or end turn (SKIP button).<br><br>" +

                        "<b>2. Info gv.mode:</b> Info gv.mode is the default gv.mode. In this gv.mode you can tap on a token (player or enemy image) to show" +
                        " some of their stats (HP, SP, etc.). If none of the buttons are highlighted, then you are in 'Info' gv.mode. If you are" +
                        " in 'move' gv.mode and want to return to 'info' gv.mode, tap on the move button to unselect it and return to 'info' gv.mode. Same" +
                        " concept works for 'attack' gv.mode back to 'info' gv.mode.<br><br>" +

                        "<b>3. Move:</b> After pressing move, you may move one square and then do one more action or press 'SKIP' to end this Player's" +
                        " turn. You move by pressing one of the arrow direction buttons or tapping on a square adjacent to the PC.<br><br>" +

                        "<b>3. Attack:</b> After pressing attack, move the target selection square by pressing the arrow keys or tapping on any map square." +
                        " Once you have selected a valid target (box will be green), press the 'TARGET' button or tap on the targeted map square (green box)" +
                        " again to complete the action.<br><br>" +

                        "<b>4. Cast:</b> After pressing cast and selecting a spell from the spell selection screen, move the target selection square by" +
                        " pressing the arrow keys or tapping on any map square. Once you have selected a valid target (box will be green), press the" +
                        " 'TARGET' button or tap on the targeted map square (green box) again to complete the action.<br><br>" +

                        "<b>5. Skip:</b> The 'SKIP' button will end the current player's turn.<br><br>" +

                        "<b>6. Use Item:</b> press the inventory button (image of a bag) to show the party inventory screen. Only the current Player" +
                        " may use an item from this screen during combat.<br><br>" +

                        "<small><b>Note:</b> Also, check out the 'Player's Guide' in the settings menu (the rusty gear looking button)</small>"
                        );
                gv.mod.showTutorialCombat = false;
            }
        }

        public void doAnimationController()
        {
            if (animationState == AnimationState.None)
            {
                return;
            }
            else if (animationState == AnimationState.CreatureThink)
            {
                creatureToAnimate.Clear();
                playerToAnimate = null;
                doCreatureTurnAfterDelay();
            }
            else if (animationState == AnimationState.CreatureMove)
            {
                creatureToAnimate.Clear();
                playerToAnimate = null;
                Creature crt = new Creature();
                int highestLivingCrtMoveOrderfound = 0;
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (currentMoveOrderIndex == 0)
                    {
                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                        {
                            highestLivingCrtMoveOrderfound = c.moveOrder;
                            crt = c;
                        }
                    }
                    else
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            crt = c;
                            break;
                        }
                    }
                }
                //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
                if (moveCost == gv.mod.diagonalMoveCost)
                {
                    creatureMoves += gv.mod.diagonalMoveCost;
                    moveCost = 1.0f;
                }
                else
                {
                    creatureMoves++;
                }

                //do triggers and anything else needed after each creature or PC move
                afterEachMoveCalls();
                floatyTextOn = true;
                checkEndEncounter();
                if (crt.hp <= 0 || crt.isHeld())
                {
                    endCreatureTurn(crt);
                }

                doCreatureNextAction();
            }
        }

        public void doCombatSetup()
        {
            gv.cc.addLogText("<font color='yellow'>" + "Encounter setup" + "</font><BR><BR>");

            //spawn and despawn system for triggers (and props later)
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            int spawnCounter = 0;
            /*
            int spawnCounterParty = 0;
            string pcName = "none";
            string traitUsedLeader1 = "none";
            string traitUsedLeader2 = "none";
            string traitUsedLeader3 = "none";
            string traitUsedParty1 = "none";
            string traitUsedParty2 = "none";
            string traitUsedParty3 = "none";
            */
            int numberOFBeneficialSpotsOnMap = 0;
            foreach (Trigger trig in gv.mod.currentEncounter.Triggers)
            {
                //spawning
                if (trig.txtTrigSpawningTraitTag != "none" && trig.txtTrigSpawningTraitTag != "None" && trig.txtTrigSpawningTraitTag != "" && trig.txtTrigSpawningTraitTag != null)
                {
                    numberOFBeneficialSpotsOnMap++;
                    string traitMethod = "leader";
                    foreach (Trait t in gv.mod.moduleTraitsList)
                    {
                        if (t.tag.Contains(trig.txtTrigSpawningTraitTag))
                        {
                            traitMethod = t.methodOfChecking;
                        }
                    }
                    int parm1 = gv.mod.selectedPartyLeader;
                    if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                    {
                        parm1 = gv.mod.selectedPartyLeader;
                    }
                    else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                    {
                        parm1 = -2;
                    }
                    else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                    {
                        parm1 = -3;
                    }
                    else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                    {
                        parm1 = -4;
                    }
                    else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                    {
                        parm1 = -5;
                    }
                    else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                    {
                        parm1 = -6;
                    }


                    if (gv.sf.CheckPassSkill(parm1, trig.txtTrigSpawningTraitTag, Convert.ToInt32(trig.txtTrigSpawningDC), true, false))
                    {
                        spawnCounter++;
                        //if (parm1 > -2)
                        //{
                        //pcName = gv.mod.playerList[gv.mod.selectedPartyLeader].name;
                        //}
                        //

                        //if ()
                        trig.Enabled = true;
                        trig.chkTrigHidden = false;
                    }
                }
            }

            if (numberOFBeneficialSpotsOnMap > 0)
            {
                gv.cc.addLogText("Party found " + spawnCounter + " of " + numberOFBeneficialSpotsOnMap + " optional, beneficial spot(s) </font><BR><BR>");
            }

            spawnCounter = 0;
            numberOFBeneficialSpotsOnMap = 0;
            foreach (Trigger trig in gv.mod.currentEncounter.Triggers)
            {

                //despawning
                if (trig.txtTrigDespawningTraitTag != "none" && trig.txtTrigDespawningTraitTag != "None" && trig.txtTrigDespawningTraitTag != "" && trig.txtTrigDespawningTraitTag != null)
                {
                    numberOFBeneficialSpotsOnMap++;
                    string traitMethod = "leader";
                    foreach (Trait t in gv.mod.moduleTraitsList)
                    {
                        if (t.tag.Contains(trig.txtTrigDespawningTraitTag))
                        {
                            traitMethod = t.methodOfChecking;
                        }
                    }
                    int parm1 = gv.mod.selectedPartyLeader;
                    if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                    {
                        parm1 = gv.mod.selectedPartyLeader;
                    }
                    else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                    {
                        parm1 = -2;
                    }
                    else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                    {
                        parm1 = -3;
                    }
                    else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                    {
                        parm1 = -4;
                    }
                    else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                    {
                        parm1 = -5;
                    }
                    else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                    {
                        parm1 = -6;
                    }

                    if (gv.sf.CheckPassSkill(parm1, trig.txtTrigDespawningTraitTag, Convert.ToInt32(trig.txtTrigDespawningDC), true, true))
                    {
                        spawnCounter++;
                        trig.Enabled = false;
                        trig.chkTrigHidden = true;
                    }
                }
            }
            if (numberOFBeneficialSpotsOnMap > 0)
            {
                gv.cc.addLogText("Party avoided " + spawnCounter + " of " + numberOFBeneficialSpotsOnMap + " optional, harmful spot(s) </font><BR><BR>");
            }


            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxXXXXX

            //surprise round system
            creaturesHaveUpperHand = false;
            partyHasUpperHand = false;
            bool advantageCreatures = false;
            bool advantageParty = false;
            //comparisons between two upperhand potentials
            //1. get party upperhand potential
            //make party roll spot enemy against DC: prop stealth + 10 + 5
            //if successful, party has upperhand
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


            if (gv.mod.useFlatFootedSystem)
            {
                string traitMethod = "leader";
                foreach (Trait t in gv.mod.moduleTraitsList)
                {
                    if (t.tag.Contains(gv.mod.tagOfStealthMainTrait))
                    {
                        traitMethod = t.methodOfChecking;
                    }
                }
                int parm1 = gv.mod.selectedPartyLeader;
                if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                {
                    parm1 = gv.mod.selectedPartyLeader;
                }
                else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                {
                    parm1 = -2;
                }
                else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                {
                    parm1 = -3;
                }
                else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                {
                    parm1 = -4;
                }
                else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                {
                    parm1 = -5;
                }
                else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                {
                    parm1 = -6;
                }

                int propEncSpot = 0;
                if (gv.sf.ThisProp != null)
                {
                    if (gv.sf.ThisProp.spotEnemy != -1)
                    {
                        propEncSpot = gv.sf.ThisProp.spotEnemy;
                    }
                    else
                    {
                        propEncSpot = gv.mod.currentEncounter.encSpotEnemy;
                    }
                }
                else
                {
                    propEncSpot = gv.mod.currentEncounter.encSpotEnemy;
                }

                if (gv.sf.CheckPassSkill(parm1, gv.mod.tagOfStealthMainTrait, propEncSpot, false, true))
                {
                    advantageParty = true;
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //do same excercise for prop

                int propEncStealth = 0;
                if (gv.sf.ThisProp != null)
                {
                    if (gv.sf.ThisProp.stealth != -1)
                    {
                        propEncStealth = gv.sf.ThisProp.stealth;
                    }
                    else
                    {
                        propEncStealth = gv.mod.currentEncounter.encStealth;
                    }
                }
                else
                {
                    propEncStealth = gv.mod.currentEncounter.encStealth;
                }


                foreach (Trait t in gv.mod.moduleTraitsList)
                {
                    if (t.tag.Contains(gv.mod.tagOfSpotEnemyTrait))
                    {
                        traitMethod = t.methodOfChecking;
                    }
                }
                parm1 = gv.mod.selectedPartyLeader;
                if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                {
                    parm1 = gv.mod.selectedPartyLeader;
                }
                else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                {
                    parm1 = -2;
                }
                else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                {
                    parm1 = -3;
                }
                else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                {
                    parm1 = -4;
                }
                else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                {
                    parm1 = -5;
                }
                else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                {
                    parm1 = -6;
                }

                if (!gv.sf.CheckPassSkill(parm1, gv.mod.tagOfSpotEnemyTrait, propEncStealth, false, true))
                {
                    advantageCreatures = true;
                }

                if (gv.sf.ThisProp != null)
                {
                    if (gv.sf.ThisProp.isStealthed)
                    {
                        creaturesHaveUpperHand = true;
                        gv.cc.addLogText("<font color='white'>" + "Ambush - party is flat-footed" + "</font><BR><BR>");
                    }
                    else if ((advantageCreatures && advantageParty) || (!advantageCreatures && !advantageParty))
                    {
                        //no advantage in summ, ie no surprise round
                    }
                    else if (advantageCreatures && !advantageParty)
                    {
                        creaturesHaveUpperHand = true;
                        gv.cc.addLogText("<font color='white'>" + "Party is flat-footed" + "</font><BR><BR>");
                    }
                    else if (!advantageCreatures && advantageParty)
                    {
                        partyHasUpperHand = true;
                        gv.cc.addLogText("<font color='white'>" + "Enemy is flat-footed" + "</font><BR><BR>");
                    }
                }
                //not called from prop
                else
                {
                    if ((advantageCreatures && advantageParty) || (!advantageCreatures && !advantageParty))
                    {
                        //no advantage in summ, ie no surprise round
                    }
                    else if (advantageCreatures && !advantageParty)
                    {
                        creaturesHaveUpperHand = true;
                        gv.cc.addLogText("<font color='white'>" + "Party is flat-footed" + "</font><BR><BR>");
                    }
                    else if (!advantageCreatures && advantageParty)
                    {
                        partyHasUpperHand = true;
                        gv.cc.addLogText("<font color='white'>" + "Enemy is flat-footed" + "</font><BR><BR>");
                    }
                }
            }

            if (gv.mod.currentEncounter.allSpellsSPCostDoubled)
            {
                foreach (Spell sp in gv.mod.moduleSpellsList)
                {
                    sp.costSP *= 2;
                }
            }

            if (gv.mod.currentEncounter.allSpellsWithoutAoE)
            {
                //1. clear list with backup AoE of Spells
                gv.mod.currentEncounter.originalAoEofSpells.Clear();
                //2. fill list with backup AoE of Spells, readin in all spells
                foreach (Spell sp in gv.mod.moduleSpellsList)
                {
                    gv.mod.currentEncounter.originalAoEofSpells.Add(sp.aoeRadius);
                }
                //3. set all spples AoE to 0
                foreach (Spell sp in gv.mod.moduleSpellsList)
                {
                    sp.aoeRadius = 0;
                }
            }
            //4. restore original AoE of Spells from checkendencounter

            if (gv.mod.playMusic)
            {
                gv.stopMusic();
                gv.stopAmbient();
                gv.startCombatMusic();
            }
            gv.screenType = "combat";
            gv.mod.currentEncounter.isOver = false;
            continueTurn = false;
            allDone = false;
            roundCounter = 1;
            //langbein
            gv.screenCombat.animationSeqStack.Clear();
            gv.screenCombat.deathAnimationLocations.Clear();
            gv.screenCombat.blockCreatureDrawLocations.Clear();
            gv.screenCombat.hitAnimationLocation = null;
            gv.screenCombat.endingAnimationLocation = null;
            gv.cc.floatyTextList.Clear();

            //resetToggleButtons();
            //Load map if used
            if (gv.mod.currentEncounter.UseMapImage)
            {
                gv.cc.DisposeOfBitmap(ref mapBitmap);
                mapBitmap = gv.cc.LoadBitmap(gv.mod.currentEncounter.MapImage);
            }
            else //loads only the tiles that are used on this encounter map
            {
                //TODO gv.cc.LoadTileBitmapList();
            }
            //swipe the old creature list of current encounter
            gv.mod.currentEncounter.encounterCreatureList.Clear();

            //Load up all creature stuff
            foreach (CreatureRefs crf in gv.mod.currentEncounter.encounterCreatureRefsList)
            {
                //find this creatureRef in gv.mod creature list
                foreach (Creature c in gv.mod.moduleCreaturesList)
                {
                    if (crf.creatureResRef.Equals(c.cr_resref))
                    {
                        if (crf.spawnAtStartOfRoundX == 0 || crf.spawnAtStartOfRoundX == 1)
                        {
                            //copy it and add to encounters creature object list
                            try
                            {
                                Creature copy = c.DeepCopy();
                                copy.cr_tag = crf.creatureTag;
                                gv.cc.DisposeOfBitmap(ref copy.token);
                                copy.token = gv.cc.LoadBitmap(copy.cr_tokenFilename);
                                copy.combatLocX = crf.creatureStartLocationX;
                                copy.combatLocY = crf.creatureStartLocationY;
                                //factionsystem: faction buff
                                if (copy.factionTag != null)
                                {
                                    if (copy.factionTag != "none" && copy.factionTag != "None" && copy.factionTag != "")
                                    {
                                        //Faction tempFaction = new Faction();

                                        //creature's faction
                                        foreach (Faction f in gv.mod.moduleFactionsList)
                                        {
                                            if (f.tag == copy.factionTag)
                                            {
                                                if (f.rank == 1)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank1;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank1;
                                                    copy.will += f.accumulatedBuffStrengthRank1;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank1;
                                                    copy.reflex += f.accumulatedBuffStrengthRank1;
                                                    if (f.accumulatedBuffStrengthRank1 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank1.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank1 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank1.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    //birthday
                                                    //let's limit the faction buff effect a bit for starters
                                                    //copy.hpMax = copy.hpMax + copy.hpMax * (f.accumulatedBuffStrengthRank1 * 10 / 100);
                                                }
                                                if (f.rank == 2)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank2;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank2;
                                                    copy.will += f.accumulatedBuffStrengthRank2;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank2;
                                                    copy.reflex += f.accumulatedBuffStrengthRank2;
                                                    if (f.accumulatedBuffStrengthRank2 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank2.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank2 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank2.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 3)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank3;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank3;
                                                    copy.will += f.accumulatedBuffStrengthRank3;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank3;
                                                    copy.reflex += f.accumulatedBuffStrengthRank3;
                                                    if (f.accumulatedBuffStrengthRank3 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank3.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank3 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank3.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 4)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank4;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank4;
                                                    copy.will += f.accumulatedBuffStrengthRank4;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank4;
                                                    copy.reflex += f.accumulatedBuffStrengthRank4;
                                                    if (f.accumulatedBuffStrengthRank4 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank4.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank4 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank4.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 5)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank5;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank5;
                                                    copy.will += f.accumulatedBuffStrengthRank5;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank5;
                                                    copy.reflex += f.accumulatedBuffStrengthRank5;
                                                    if (f.accumulatedBuffStrengthRank5 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank5.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank5 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank5.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 6)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank6;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank6;
                                                    copy.will += f.accumulatedBuffStrengthRank6;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank6;
                                                    copy.reflex += f.accumulatedBuffStrengthRank6;
                                                    if (f.accumulatedBuffStrengthRank6 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "</font><font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank6.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank6 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "</font><font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank6.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 7)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank7;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank7;
                                                    copy.will += f.accumulatedBuffStrengthRank7;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank7;
                                                    copy.reflex += f.accumulatedBuffStrengthRank7;
                                                    if (f.accumulatedBuffStrengthRank7 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank7.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank7 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank7.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 8)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank8;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank8;
                                                    copy.will += f.accumulatedBuffStrengthRank8;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank8;
                                                    copy.reflex += f.accumulatedBuffStrengthRank8;
                                                    if (f.accumulatedBuffStrengthRank8 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank8.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank8 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank8.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 9)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank9;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank9;
                                                    copy.will += f.accumulatedBuffStrengthRank9;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank9;
                                                    copy.reflex += f.accumulatedBuffStrengthRank9;
                                                    if (f.accumulatedBuffStrengthRank9 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank9.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank9 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank9.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }
                                                if (f.rank == 10)
                                                {
                                                    copy.AC += f.accumulatedBuffStrengthRank10;
                                                    copy.cr_att += f.accumulatedBuffStrengthRank10;
                                                    copy.will += f.accumulatedBuffStrengthRank10;
                                                    copy.fortitude += f.accumulatedBuffStrengthRank10;
                                                    copy.reflex += f.accumulatedBuffStrengthRank10;
                                                    if (f.accumulatedBuffStrengthRank10 > 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + " , +" + f.accumulatedBuffStrengthRank10.ToString() + " buff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                    else if (f.accumulatedBuffStrengthRank10 < 0)
                                                    {
                                                        gv.cc.addLogText("<font color='red'>" + copy.cr_name + "<font color='white'> belongs to " + f.name + ", -" + f.accumulatedBuffStrengthRank10.ToString() + " debuff to AC, Hitroll and Saves" + "</font><BR><BR>");
                                                    }
                                                }

                                                break;
                                            }
                                        }
                                    }
                                }


                                gv.mod.currentEncounter.encounterCreatureList.Add(copy);
                            }
                            catch (Exception ex)
                            {
                                gv.errorLog(ex.ToString());
                            }
                        }
                    }
                }
            }

            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {

                if (gv.mod.useCombatSmoothMovement)
                {
                    crt.inactiveTimer = gv.sf.RandInt(200);
                }
                int decider = gv.sf.RandInt(2);
                if (decider == 1)
                {
                    crt.goDown = false;
                }
                else
                {
                    crt.goDown = true;
                }

                decider = gv.sf.RandInt(2);
                if (decider == 1)
                {
                    crt.goRight = false;
                }
                else
                {
                    crt.goRight = true;
                }
            }

            //IBScript Setup Combat Hook (run only once)
            //could be used for placing temporary allies
            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnSetupCombatIBScript, gv.mod.currentEncounter.OnSetupCombatIBScriptParms);

            //Place and preapre all PCs
            for (int index = 0; index < gv.mod.playerList.Count; index++)
            {
                gv.mod.playerList[index].coolDownTimes.Clear();
                gv.mod.playerList[index].coolingSpellsByTag.Clear();

                //place regular pc
                if (!gv.mod.playerList[index].isTemporaryAllyForThisEncounterOnly)
                {
                    gv.mod.playerList[index].combatLocX = gv.mod.currentEncounter.encounterPcStartLocations[index].X;
                    gv.mod.playerList[index].combatLocY = gv.mod.currentEncounter.encounterPcStartLocations[index].Y;
                }
                //place temporary allies
                else
                {
                    //no entry needed,directly use combatLocX and combatLocY in tooolset (enable fields for them)
                    //or maybe a script does this, called at start of encounter
                }
            }

            //ad effects for night and darkness fights
            if (gv.sf.CheckIsInDarkness("party", "night"))
            {
                if (gv.mod.nightFightModifier != 0)
                {
                    gv.mod.poorVisionModifier = gv.mod.nightFightModifier;
                    gv.cc.addLogText("<font color='white'>Low light debuff of " + gv.mod.nightFightModifier.ToString() + " applied on party." + "<BR><BR></font>");
                    for (int index = 0; index < gv.mod.playerList.Count; index++)
                    {
                        gv.sf.UpdateStats(gv.mod.playerList[index]);
                    }
                }

                /*
                for (int index = 0; index < gv.mod.playerList.Count; index++)
                {
                    gv.mod.poorVisionModifier = gv.mod.nightFightModifier;
                    gv.mod.playerList[index].ACBase += gv.mod.nightFightModifier;
                    gv.mod.playerList[index].playerClass.babTable[gv.mod.playerList[index].classLevel] += gv.mod.nightFightModifier;
                    gv.mod.playerList[index].baseWill += gv.mod.nightFightModifier;
                    gv.mod.playerList[index].baseReflex += gv.mod.nightFightModifier;
                    gv.mod.playerList[index].baseFortitude += gv.mod.nightFightModifier;
                    gv.sf.UpdateStats(gv.mod.playerList[index]);
                    gv.cc.addLogText("<font color='yellow'>Night debuff of "+ gv.mod.nightFightModifier.ToString() + " applied on " + gv.mod.playerList[index].name + ".<BR></font>");
                }
                */
            }
            else if (gv.sf.CheckIsInDarkness("party", "noLight"))
            {
                if (gv.mod.darkFightModifier != 0)
                {
                    gv.mod.poorVisionModifier = gv.mod.darkFightModifier;
                    gv.cc.addLogText("<font color='white'>Darkness debuff of " + gv.mod.darkFightModifier.ToString() + " applied on party" + ".<BR><BR></font>");
                    for (int index = 0; index < gv.mod.playerList.Count; index++)
                    {
                        gv.sf.UpdateStats(gv.mod.playerList[index]);
                    }
                }
                /*
                                for (int index = 0; index < gv.mod.playerList.Count; index++)
                                {
                                    gv.mod.playerList[index].ACBase += gv.mod.darkFightModifier;
                                    gv.mod.playerList[index].playerClass.babTable[gv.mod.playerList[index].classLevel] += gv.mod.darkFightModifier;
                                    gv.mod.playerList[index].baseWill += gv.mod.darkFightModifier;
                                    gv.mod.playerList[index].baseReflex += gv.mod.darkFightModifier;
                                    gv.mod.playerList[index].baseFortitude += gv.mod.darkFightModifier;
                                    gv.sf.UpdateStats(gv.mod.playerList[index]);
                                    gv.cc.addLogText("<font color='yellow'>Darkness debuff of " + gv.mod.nightFightModifier.ToString() + " applied on " + gv.mod.playerList[index].name + ".<BR></font>");
                                }
                                */
            }
            else
            {
                gv.mod.poorVisionModifier = 0;
            }

            isPlayerTurn = true;
            currentPlayerIndex = 0;
            creatureIndex = 0;
            currentMoveOrderIndex = 0;
            currentCombatMode = "info";
            drawDeathAnimation = false;
            encounterXP = 0;
            if (gv.mod.useManualCombatCam)
            {
                CenterScreenOnPC();
            }
            foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList)
            {
                encounterXP += crtr.cr_XP;
            }
            pf = new PathFinderEncounters(gv, gv.mod);
            tutorialMessageCombat(false);

            //duisdorf
            //get name of assassination target
            foreach (Creature at in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (at.cr_tag == gv.mod.currentEncounter.assassinationTargetTag)
                {
                    gv.mod.currentEncounter.assassinationTargetName = at.cr_name;
                }
            }

            if (gv.mod.currentEncounter.standGroundVictory)
            {
                gv.mod.currentEncounter.standGroundInternalTimer = gv.mod.currentEncounter.standGroundTimer;
            }

            if (gv.mod.currentEncounter.timeLimitDefeat)
            {
                gv.mod.currentEncounter.timeLimitInternalTimer = gv.mod.currentEncounter.timeLimitTimer;
            }

            string battleStartMessage = "";
            if (gv.sf.ThisProp != null)
            {
                if (gv.sf.ThisProp.moved2)
                {
                    battleStartMessage = "A very fast moving enemy (double move) has caught the party. <br><br>";
                }

                if (gv.sf.ThisProp.isStealthed)
                {
                    battleStartMessage += "A stealthy enemy steps out of the shadows. <br><br>";
                }
            }

            if (gv.mod.currentEncounter.customTextforMessageBoxAtStartOfEncounter != "none" && gv.mod.currentEncounter.customTextforMessageBoxAtStartOfEncounter != "None" && gv.mod.currentEncounter.customTextforMessageBoxAtStartOfEncounter != "")
            {
                gv.sf.MessageBox(battleStartMessage + gv.mod.currentEncounter.customTextforMessageBoxAtStartOfEncounter);
            }
            else if (gv.mod.currentEncounter.showDefaultMessageBoxAtStartOfEncounter)
            {
                //to do: adjust to victory/loss conditions and battlefield modifiers
                //gv.sf.MessageBox("Win this battle by defeating all enemies.");
                //string battleStartMessage = "";

                if (gv.mod.currentEncounter.assassinationVictory || gv.mod.currentEncounter.standGroundVictory || gv.mod.currentEncounter.conquerVictory)
                {
                    battleStartMessage += "Additional victory term(s):<br><br>";
                }

                if (gv.mod.currentEncounter.assassinationVictory)
                {
                    battleStartMessage += "- win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".<br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.standGroundVictory)
                {
                    battleStartMessage += "- win this battle instantly by surviving " + gv.mod.currentEncounter.standGroundInternalTimer + " rounds.<br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.conquerVictory)
                {
                    if (gv.mod.currentEncounter.conquerTargetsCumulative)
                    {
                        //1 and 2 and 3
                        if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget2Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying ALL of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                        //1+2
                        else if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget2Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying ALL of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]" + ".<br><br>";
                        }
                        //1+3
                        else if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying ALL of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                        //2+3
                        else if (gv.mod.currentEncounter.conquerTarget2Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying ALL of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                        //1
                        else if (gv.mod.currentEncounter.conquerTarget1Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]" + ".<br><br>";
                        }
                        //2
                        else if (gv.mod.currentEncounter.conquerTarget2Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]" + ".<br><br>";
                        }
                        //3
                        else if (gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                    }
                    //alternative target locations
                    else
                    {
                        //1 and 2 and 3
                        if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget2Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying at least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                        //1+2
                        else if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget2Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying at least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]" + ".<br><br>";
                        }
                        //1+3
                        else if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying at least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                        //2+3
                        else if (gv.mod.currentEncounter.conquerTarget2Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying at least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]," + " [" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                        //1
                        else if (gv.mod.currentEncounter.conquerTarget1Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget1X + "," + gv.mod.currentEncounter.conquerTarget1Y + "]" + ".<br><br>";
                        }
                        //2
                        else if (gv.mod.currentEncounter.conquerTarget2Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget2X + "," + gv.mod.currentEncounter.conquerTarget2Y + "]" + ".<br><br>";
                        }
                        //3
                        else if (gv.mod.currentEncounter.conquerTarget3Y != -1)
                        {
                            battleStartMessage += "- win this battle instantly by occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.conquerTarget3X + "," + gv.mod.currentEncounter.conquerTarget3Y + "]" + ".<br><br>";
                        }
                    }
                }

                if (gv.mod.currentEncounter.timeLimitDefeat || gv.mod.currentEncounter.protectionDefeat || gv.mod.currentEncounter.holdDefeat)
                {
                    battleStartMessage += "Additional defeat term(s): <br><br>";
                }

                if (gv.mod.currentEncounter.timeLimitDefeat)
                {
                    battleStartMessage += "- loose this battle instantly after " + gv.mod.currentEncounter.timeLimitInternalTimer + " rounds.<br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.protectionDefeat)
                {
                    battleStartMessage += "- loose this battle instantly if " + gv.mod.currentEncounter.protectionTargetName + " drops to 0 or less hit points.<br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.holdDefeat)
                {
                    //battleStartMessage += "- loose this battle instantly if " + gv.mod.currentEncounter.protectionTargetName + " drops to 0 or less hit points.<br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    //gv.sf.MessageBox(battleStartMessage);
                    if (gv.mod.currentEncounter.holdTargetsCumulative)
                    {
                        //1 and 2 and 3
                        if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget2Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy ANY of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]," + " [" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]," + " [" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                        //1+2
                        else if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget2Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy ANY of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]," + " [" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]" + ".<br><br>";
                        }
                        //1+3
                        else if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy ANY of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]," + " [" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                        //2+3
                        else if (gv.mod.currentEncounter.holdTarget2Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy ANY of the following locations simultaneously with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]," + " [" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                        //1
                        else if (gv.mod.currentEncounter.holdTarget1Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]" + ".<br><br>";
                        }
                        //2
                        else if (gv.mod.currentEncounter.holdTarget2Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]" + ".<br><br>";
                        }
                        //3
                        else if (gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly by failing to occupy the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                    }
                    //alternative target locations
                    else
                    {
                        //1 and 2 and 3
                        if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget2Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]," + " [" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]," + " [" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                        //1+2
                        else if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget2Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]," + " [" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]" + ".<br><br>";
                        }
                        //1+3
                        else if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]," + " [" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                        //2+3
                        else if (gv.mod.currentEncounter.holdTarget2Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying least ONE of the following locations with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]," + " [" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                        //1
                        else if (gv.mod.currentEncounter.holdTarget1Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget1X + "," + gv.mod.currentEncounter.holdTarget1Y + "]" + ".<br><br>";
                        }
                        //2
                        else if (gv.mod.currentEncounter.holdTarget2Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget2X + "," + gv.mod.currentEncounter.holdTarget2Y + "]" + ".<br><br>";
                        }
                        //3
                        else if (gv.mod.currentEncounter.holdTarget3Y != -1)
                        {
                            battleStartMessage += "- loose this battle instantly if not occupying the following location with a conscious pc at the start of a round: ";
                            battleStartMessage += "[" + gv.mod.currentEncounter.holdTarget3X + "," + gv.mod.currentEncounter.holdTarget3Y + "]" + ".<br><br>";
                        }
                    }
                }

                //battle modfiers
                if (gv.mod.currentEncounter.noSpellCastModifier || gv.mod.currentEncounter.noTraitUseModifier || gv.mod.currentEncounter.noItemUseModifier || gv.mod.currentEncounter.onlyOneMoveModifier || gv.mod.currentEncounter.reducedDamageofPcMeleeAttack || gv.mod.currentEncounter.reducedDamageofPcRangedAttack || gv.mod.currentEncounter.allSpellsWithoutAoE || gv.mod.currentEncounter.allSpellsSPCostDoubled || gv.mod.currentEncounter.noHealingAllowed || gv.mod.currentEncounter.hpDamageEachRound > 0 || gv.mod.currentEncounter.spDamageEachRound > 0)
                {
                    battleStartMessage += "Additional battle rule(s): <br><br>";
                }
                if (gv.mod.currentEncounter.spDamageEachRound > 0)
                {
                    battleStartMessage += "- player characters are drained by " + gv.mod.currentEncounter.spDamageEachRound + " sp each round. <br><br>";
                }
                if (gv.mod.currentEncounter.hpDamageEachRound > 0)
                {
                    battleStartMessage += "- player characters are damaged for " + gv.mod.currentEncounter.hpDamageEachRound + " hp each round. <br><br>";
                }
                if (gv.mod.currentEncounter.noHealingAllowed)
                {
                    battleStartMessage += "- player characters cannot be healed by spell, trait or item. <br><br>";
                }
                if (gv.mod.currentEncounter.allSpellsSPCostDoubled)
                {
                    battleStartMessage += "- all spells and traits cost twice the amount of sp than usually. <br><br>";
                }
                if (gv.mod.currentEncounter.allSpellsWithoutAoE)
                {
                    battleStartMessage += "- all spells and traits have their area of effect reduced to a single target square. <br><br>";
                }
                if (gv.mod.currentEncounter.reducedDamageofPcRangedAttack)
                {
                    battleStartMessage += "- all player characters do only 1/3 of their normal damage with ranged weapons. <br><br>";
                }
                if (gv.mod.currentEncounter.reducedDamageofPcMeleeAttack)
                {
                    battleStartMessage += "- all player characters do only 1/3 of their normal damage with melee weapons. <br><br>";
                }
                if (gv.mod.currentEncounter.noSpellCastModifier)
                {
                    battleStartMessage += "- casting of spells not possible for the party in this encounter. <br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.noTraitUseModifier)
                {
                    battleStartMessage += "- using of traits not possible for the party in this encounter. <br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.noItemUseModifier)
                {
                    battleStartMessage += "- using of items not possible for the party in this encounter. <br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (gv.mod.currentEncounter.onlyOneMoveModifier)
                {
                    battleStartMessage += "- every player character has only one move per turn in this encounter. <br><br>";
                    //gv.sf.MessageBox("Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + ".");
                    ///gv.sf.MessageBox(battleStartMessage);
                }

                if (battleStartMessage != "")
                {
                    gv.sf.MessageBox(battleStartMessage);
                }
            }

            if (gv.mod.currentEncounter.customTextforLogTextAtStartOfEncounter != "none" && gv.mod.currentEncounter.customTextforLogTextAtStartOfEncounter != "None" && gv.mod.currentEncounter.customTextforLogTextAtStartOfEncounter != "")
            {
                gv.cc.addLogText(gv.mod.currentEncounter.customTextforLogTextAtStartOfEncounter);
            }
            else if (gv.mod.currentEncounter.showDefaultMessageBoxAtStartOfEncounter)
            {
                /*
                //to do: adjust to victory/loss conditions and battlefield modifiers
                if (gv.mod.currentEncounter.assassinationVictory)
                {
                    gv.cc.addLogText("<font color='yellow'>" + "Win this battle instantly by slaying " + gv.mod.currentEncounter.assassinationTargetName + "." + "<BR></font>");
                }
                else
                {
                    gv.cc.addLogText("<font color='yellow'>" + "Win this battle by defeating all enemies." + "<BR></font>");
                }
                */
                gv.cc.addLogText("<font color='white'>" + battleStartMessage + "<BR></font>");
            }

            //IBScript Setup Combat Hook (run only once)
            //gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnSetupCombatIBScript, gv.mod.currentEncounter.OnSetupCombatIBScriptParms);
            //IBScript Start Combat Round Hook
            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnStartCombatRoundIBScript, gv.mod.currentEncounter.OnStartCombatRoundIBScriptParms);
            //determine initiative
            calcualteMoveOrder();
            //do turn controller
            recalculateCreaturesShownInInitiativeBar();
            floatyTextOn = false;
            if (!creaturesHaveUpperHand && !partyHasUpperHand)
            {
                gv.cc.addFloatyText(new Coordinate(0, 0), "Round " + roundCounter, "yellow");
                gv.cc.addLogText("<font color='yellow'>" + "Round " + roundCounter + "</font><BR>");
            }
            else if (partyHasUpperHand)
            {
                gv.cc.addFloatyText(new Coordinate(0, 0), "Enemy is caught flat-footed, Round " + roundCounter, "yellow");
                gv.cc.addLogText("<font color='yellow'>" + "Round " + roundCounter + "</font><BR>");
            }
            else if (creaturesHaveUpperHand)
            {
                gv.cc.addFloatyText(new Coordinate(0, 0), "Party is caught flat-footed, Round " + roundCounter, "yellow");
                gv.cc.addLogText("<font color='yellow'>" + "Round " + roundCounter + "</font><BR>");
            }
            if (gv.mod.currentEncounter.standGroundVictory)
            {
                gv.cc.addLogText("<font color='white'>" + "Survive " + gv.mod.currentEncounter.standGroundInternalTimer + " more round(s).</font><BR>");
            }
            if (gv.mod.currentEncounter.timeLimitDefeat)
            {
                gv.cc.addLogText("<font color='white'>" + "You have to win within " + gv.mod.currentEncounter.timeLimitInternalTimer + " round(s) or this battle is lost.</font><BR>");
            }
            floatyTextEnlargerOn = true;
            //floatyTextOn = true;
            foreach (Trigger t in gv.mod.currentEncounter.Triggers)
            {
                //Convert.ToInt32(cr.creatureStartLocationX);
                if (t.vanishInXTurns != null && t.vanishInXTurns != "" && t.vanishInXTurns != "none" && t.vanishInXTurns != "None" && Convert.ToInt32(t.vanishInXTurns) > 0)
                {
                    if (t.vanishCounter >= Convert.ToInt32(t.vanishInXTurns))
                    {
                        t.Enabled = false;
                        t.chkTrigHidden = true;
                        if (t.changeWalkableStateOnEnabledStateChange)
                        {
                            foreach (Coordinate coord in t.TriggerSquaresList)
                            {
                                if (gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable)
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = false;
                                }
                                else
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = true;
                                }
                            }
                        }
                    }
                    t.vanishCounter++;
                }
            }

            foreach (Trigger t in gv.mod.currentEncounter.Triggers)
            {
                if (t.appearInXTurns != null && t.appearInXTurns != "" && t.appearInXTurns != "none" && t.appearInXTurns != "None" && Convert.ToInt32(t.appearInXTurns) > 0)
                {
                    if (t.appearCounter >= Convert.ToInt32(t.appearInXTurns))
                    {
                        t.Enabled = false;
                        t.chkTrigHidden = true;
                        if (t.changeWalkableStateOnEnabledStateChange)
                        {
                            foreach (Coordinate coord in t.TriggerSquaresList)
                            {
                                if (gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable)
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = false;
                                }
                                else
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = true;
                                }
                            }
                        }
                    }
                    t.appearCounter++;
                }
            }
            roundCounter++;
            turnController();
        }
        public void calcualteMoveOrder()
        {
            moveOrderList.Clear();
            //creatureCounter2 = 0;
            //go through each PC and creature and make initiative roll
            foreach (Player pc in gv.mod.playerList)
            {

                int roll = gv.sf.RandInt(100) + (((pc.dexterity - 10) / 2) * 5);
                MoveOrder newMO = new MoveOrder();
                newMO.PcOrCreature = pc;
                newMO.rank = roll;
                moveOrderList.Add(newMO);


            }
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {


                int roll = gv.sf.RandInt(100) + (crt.initiativeBonus * 5);
                MoveOrder newMO = new MoveOrder();
                newMO.PcOrCreature = crt;
                newMO.rank = roll;
                moveOrderList.Add(newMO);

            }
            initialMoveOrderListSize = moveOrderList.Count;
            //sort PCs and creatures based on results
            moveOrderList = moveOrderList.OrderByDescending(x => x.rank).ToList();
            //assign moveOrder to PC and Creature property
            int cnt = 0;
            foreach (MoveOrder m in moveOrderList)
            {
                if (m.PcOrCreature is Player)
                {
                    Player pc = (Player)m.PcOrCreature;
                    pc.moveOrder = cnt;
                }
                else
                {
                    Creature crt = (Creature)m.PcOrCreature;
                    crt.moveOrder = cnt;
                }
                cnt++;
            }
        }
        /*
        public void recalcualteMoveOrder()
        {
            moveOrderList.Clear();
            //creatureCounter2 = 0;
            //go through each PC and creature and make initiative roll
            foreach (Player pc in gv.mod.playerList)
            {
                if (pc.hp > 0)
                {
                    int roll = gv.sf.RandInt(100) + (((pc.dexterity - 10) / 2) * 5);
                    MoveOrder newMO = new MoveOrder();
                    newMO.PcOrCreature = pc;
                    newMO.rank = roll;
                    moveOrderList.Add(newMO);
                }

            }
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crt.hp > 0)
                {
                    int roll = gv.sf.RandInt(100) + (crt.initiativeBonus * 5);
                    MoveOrder newMO = new MoveOrder();
                    newMO.PcOrCreature = crt;
                    newMO.rank = roll;
                    moveOrderList.Add(newMO);
                }
            }
            initialMoveOrderListSize = moveOrderList.Count;
            //sort PCs and creatures based on results
            moveOrderList = moveOrderList.OrderByDescending(x => x.rank).ToList();
            //assign moveOrder to PC and Creature property
            int cnt = 0;
            foreach (MoveOrder m in moveOrderList)
            {
                if (m.PcOrCreature is Player)
                {
                    Player pc = (Player)m.PcOrCreature;
                    pc.moveOrder = cnt;
                }
                else
                {
                    Creature crt = (Creature)m.PcOrCreature;
                    crt.moveOrder = cnt;
                }
                cnt++;
            }
        }
        */
        public void turnController()
        {
            if ((animationSeqStack.Count == 0) && (!continueTurn) && !gv.mod.currentEncounter.isOver && !allDone)
            //if ((!continueTurn) && !gv.mod.currentEncounter.isOver && !allDone)
            //if (animationSeqStack.Count == 0)
            {
                //zulaufen

                recalculateCreaturesShownInInitiativeBar();
                attackAnimationFrameCounter = 0;
                attackAnimationDelayCounter = 0;
                //redraw screen
                //KArl
                //gv.Render();

                foreach (Player p in gv.mod.playerList)
                {
                    gv.sf.UpdateStats(p);
                }

                if (currentMoveOrderIndex >= initialMoveOrderListSize)
                {
                    for (int i = gv.mod.playerList.Count - 1; i >= 0; i--)
                    {
                        if (gv.mod.playerList[i].isTemporaryAllyForThisEncounterOnly)
                        {
                            gv.mod.playerList[i].stayDurationInTurns--;
                            if (gv.mod.playerList[i].stayDurationInTurns <= 0)
                            {
                                gv.cc.addLogText("<font color='blue'>" + gv.mod.playerList[i].name + " vanishes." + "</font><BR>");
                                gv.mod.playerList[i].hp = -20;
                                //recalculateCreaturesShownInInitiativeBar();
                                gv.mod.playerList.RemoveAt(i);

                                recalculateCreaturesShownInInitiativeBar();
                            }
                            else if (gv.mod.playerList[i].stayDurationInTurns < 10)
                            {
                                gv.cc.addLogText("<font color='blue'>" + gv.mod.playerList[i].name + " has " + gv.mod.playerList[i].stayDurationInTurns + " turns left." + "</font><BR>");
                            }
                        }
                    }

                    for (int i = gv.mod.currentEncounter.encounterCreatureList.Count - 1; i >= 0; i--)
                    {
                        gv.mod.currentEncounter.encounterCreatureList[i].stayDurationInTurns--;
                        if (gv.mod.currentEncounter.encounterCreatureList[i].stayDurationInTurns <= 0)
                        {
                            gv.cc.addLogText("<font color='blue'>" + gv.mod.currentEncounter.encounterCreatureList[i].cr_name + " vanishes." + "</font><BR>");
                            gv.mod.currentEncounter.encounterCreatureList[i].hp = -20;

                            recalculateCreaturesShownInInitiativeBar();
                            int deadIdx = (gv.mod.currentEncounter.encounterCreatureList.Count - 1) - i;
                            if (deadIdx < idx)
                            {
                                idx--;
                                if (idx < 0)
                                {
                                    idx = 0;
                                }
                            }
                            if (gv.mod.currentEncounter.assassinationVictory && gv.mod.currentEncounter.assassinationTargetTag == gv.mod.currentEncounter.encounterCreatureList[i].cr_tag)
                            {
                                gv.mod.currentEncounter.assassinationConditionMet = true;
                            }

                            gv.mod.currentEncounter.encounterCreatureList.RemoveAt(i);
                        }
                        else if (gv.mod.currentEncounter.encounterCreatureList[i].stayDurationInTurns < 10)
                        {
                            gv.cc.addLogText("<font color='blue'>" + gv.mod.currentEncounter.encounterCreatureList[i].cr_name + " has " + gv.mod.currentEncounter.encounterCreatureList[i].stayDurationInTurns + " turns left." + "</font><BR>");
                        }
                    }

                    foreach (Player p in gv.mod.playerList)
                    {
                        if (gv.mod.currentEncounter.protectionDefeat && gv.mod.currentEncounter.protectionTargetName == p.name)
                        {
                            if (p.hp <= 0)
                            {
                                gv.mod.currentEncounter.protectionConditionMet = true;
                            }
                        }
                    }
                    //hit the end so start the next round
                    startNextRoundStuff();
                    return;
                }
                //get the next PC or Creature based on currentMoveOrderIndex and moveOrder property
                idx = 0;
                foreach (Player pc in gv.mod.playerList)
                {
                    if (pc.moveOrder == currentMoveOrderIndex)
                    {
                        //tiereimpark
                        //nastybug
                        gv.screenCombat.animationSeqStack.Clear();
                        checkEndEncounter();
                        if (!allDone)
                        {
                            //deathAnimationLocations.Clear();
                            //write the pc's name to log whsoe turn it is
                            //if (pc.hp > 0)
                            //{
                            //gv.cc.addLogText("<font color='blue'>Turn of " + pc.name + ". </font><BR>");
                            gv.cc.addLogText("Turn of " + "<font color='lime'>" + pc.name + "</font><BR>");
                            //}

                            if ((pc.hp <= 0) && (pc.hp > -20) && !pc.hasDelayedAlready)
                            {
                                pc.hp -= 1;
                                gv.cc.addLogText("Unconscious and bleeding, <font color='red'> -1 <font color='white'>HP</font><BR>");
                                pc.charStatus = "Dead";
                                if (pc.hp <= -20)
                                {
                                    gv.cc.addLogText("<font color='red'>" + pc.name + " has DIED!" + "</font><BR>");
                                }
                            }

                            /*
                            //add code for interrupting the caster of a spell with long duration here
                            if ((pc.hp < pc.hpLastTurn) && (pc.hp > 0) && (!pc.isHeld()))
                            {
                                foreach (Effect ef in pc.effectsList)
                                {
                                    if (ef.allowCastingWithoutRiskOfInterruption)
                                    {
                                        pc.thisCasterCanBeInterrupted = false;
                                        break;
                                    }
                                }

                                if (pc.isPreparingSpell && pc.thisCasterCanBeInterrupted)
                                {
                                    #region Do Calc Save and DC
                                    int saveChkRoll = gv.sf.RandInt(20);
                                    int saveChk = 0;
                                    int DC = 100 + (pc.hpLastTurn - pc.hp);
                                    int saveChkAdder = pc.will;

                                    saveChk = saveChkRoll + saveChkAdder;
                                    #endregion

                                    if (saveChk >= DC)
                                    {
                                        gv.cc.addLogText("<font color='yellow'>" + pc.name + " makes will save(" + saveChkRoll + "+" + saveChkAdder + " >= " + DC + ") and " + pc.playerClass.labelForCastAction + " still despite damage during last turn." + "</font><BR>");
                                    }
                                    else
                                    {
                                        gv.cc.addLogText("<font color='yellow'>" + pc.name + " fails will save(" + saveChkRoll + "+" + saveChkAdder + " <= " + DC + ") - " + pc.playerClass.spellLabelSingular + " cancelled due to damage during last turn." + "</font><BR>");

                                        //reset all relevant values to default
                                        pc.isPreparingSpell = false;
                                        pc.doCastActionInXFullTurns = 0;
                                        pc.tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                        pc.thisCastIsFreeOfCost = false;
                                        pc.thisCasterCanBeInterrupted = true;
                                        currentCombatMode = "info";
                                        animationSeqStack.Clear();
                                        endPcTurn(true);
                                    }
                                }
                            }
                            */

                            spriteList.Clear();
                            if (!floatyTextEnlargerOn)
                            {
                                gv.cc.floatyTextList.Clear();
                            }
                            //highlight the portrait of the pc whose current turn it is
                            //ratti

                            gv.cc.ptrPc0.glowOn = false;
                            gv.cc.ptrPc1.glowOn = false;
                            gv.cc.ptrPc2.glowOn = false;
                            gv.cc.ptrPc3.glowOn = false;
                            gv.cc.ptrPc4.glowOn = false;
                            gv.cc.ptrPc5.glowOn = false;

                            if (idx == 0)
                            {
                                if (gv.mod.playerList.Count > 0)
                                {
                                    if (!gv.mod.playerList[0].isTemporaryAllyForThisEncounterOnly)
                                    {
                                        gv.cc.ptrPc0.glowOn = true;
                                    }
                                }
                            }
                            if (idx == 1)
                            {
                                if (gv.mod.playerList.Count > 1)
                                {
                                    if (!gv.mod.playerList[1].isTemporaryAllyForThisEncounterOnly)
                                    {
                                        gv.cc.ptrPc1.glowOn = true;
                                    }
                                }
                            }
                            if (idx == 2)
                            {
                                if (gv.mod.playerList.Count > 2)
                                {
                                    if (!gv.mod.playerList[2].isTemporaryAllyForThisEncounterOnly)
                                    {
                                        gv.cc.ptrPc2.glowOn = true;
                                    }
                                }
                            }
                            if (idx == 3)
                            {
                                if (gv.mod.playerList.Count > 3)
                                {
                                    if (!gv.mod.playerList[3].isTemporaryAllyForThisEncounterOnly)
                                    {
                                        gv.cc.ptrPc3.glowOn = true;
                                    }
                                }
                            }
                            if (idx == 4)
                            {
                                if (gv.mod.playerList.Count > 4)
                                {
                                    if (!gv.mod.playerList[4].isTemporaryAllyForThisEncounterOnly)
                                    {
                                        gv.cc.ptrPc4.glowOn = true;
                                    }
                                }
                            }
                            if (idx == 5)
                            {
                                if (gv.mod.playerList.Count > 5)
                                {
                                    if (!gv.mod.playerList[5].isTemporaryAllyForThisEncounterOnly)
                                    {
                                        gv.cc.ptrPc5.glowOn = true;
                                    }
                                }
                            }
                            //blubb

                            //switching to a system where effects last from turn they are applied to start of the target creature's next turn (multiplied with duration of effect)
                            //moved to after prop triggers
                            if (!pc.hasDelayedAlready)
                            {
                                applyEffectsFromSquare(pc.combatLocX, pc.combatLocY);
                                applyEffectsCombat(pc, false);
                            }
                            //applyEffectsFromSquare(pc.combatLocX, pc.combatLocY);

                            //tiereimpark
                            checkEndEncounter();

                            //reduce existing cooldown times
                            if (!pc.hasDelayedAlready)
                            {
                                if (pc.coolingSpellsByTag.Count > 0)
                                {
                                    for (int i = pc.coolingSpellsByTag.Count - 1; i >= 0; i--)
                                    {
                                        pc.coolDownTimes[i]--;
                                        if (pc.coolDownTimes[i] <= -1)
                                        {
                                            pc.coolDownTimes.RemoveAt(i);
                                            pc.coolingSpellsByTag.RemoveAt(i);
                                        }
                                    }
                                }
                            }

                            //change creatureIndex or currentPlayerIndex
                            currentPlayerIndex = idx;
                            //set isPlayerTurn 
                            isPlayerTurn = true;

                            currentCombatMode = "info";
                            currentMoveOrderIndex++;
                            tagsOfTriggersAndPropTriggersCalledThisTurn.Clear();
                            triggerIndexCombat = 0;

                            //flackern
                            if (pc.hp > 0)
                            {
                                //CalculateUpperLeft();
                            }

                            if (!pc.hasDelayedAlready)
                            {
                                doPropTriggers();
                            }
                            //if (!pc.hasDelayedAlready)
                            //{
                            //applyEffectsFromSquare(pc.combatLocX, pc.combatLocY);
                            //applyEffectsCombat(pc, false);
                            //}

                            //tiereimpark
                            checkEndEncounter();
                            floatyTextOn = true;
                            gv.mod.enteredFirstTime = false;
                            //Karl
                            //gv.Render();
                            //go to start PlayerTurn or start CreatureTurn

                            //surprise round

                            bool partySkipDueToSurprise = false;
                            if (roundCounter <= 2 && creaturesHaveUpperHand)
                            {
                                //gv.cc.addLogText("<font color='white'> </font>");
                                gv.cc.addLogText("<font color='white'>Flat-footed</font>" + "<BR>");
                                partySkipDueToSurprise = true;
                            }
                            if (roundCounter > 2)
                            {
                                partySkipDueToSurprise = false;
                            }
                            //partySkipDueToSurprise = true;
                            if ((pc.isDead()) || partySkipDueToSurprise)
                            {
                                pc.thisCastIsFreeOfCost = false;
                                pc.isPreparingSpell = false;
                                pc.doCastActionInXFullTurns = 0;
                                pc.tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                pc.thisCasterCanBeInterrupted = true;
                                endPcTurn(true);
                            }
                            else
                            {
                                //********************************************************************
                                /*
                                //add code for interrupting the caster of a spell with long duration here
                                if ((pc.hp < pc.hpLastTurn) && (pc.hp > 0) && (!pc.isHeld()))
                                {
                                    foreach (Effect ef in pc.effectsList)
                                    {
                                        if (ef.allowCastingWithoutRiskOfInterruption)
                                        {
                                            pc.thisCasterCanBeInterrupted = false;
                                            break;
                                        }
                                    }

                                    if (pc.isPreparingSpell && pc.thisCasterCanBeInterrupted)
                                    {
                                        #region Do Calc Save and DC
                                        int saveChkRoll = gv.sf.RandInt(20);
                                        int saveChk = 0;
                                        int DC = 10 + (pc.hpLastTurn - pc.hp);
                                        int saveChkAdder = pc.will;

                                        saveChk = saveChkRoll + saveChkAdder;
                                        #endregion

                                        if (saveChk >= DC)
                                        {
                                            gv.cc.addLogText("<font color='yellow'>" + pc.name + " makes will save(" + saveChkRoll + "+" + saveChkAdder + " >= " + DC + ") and " + pc.playerClass.labelForCastAction + " still despite damage during last turn." + "</font><BR>");
                                        }
                                        else
                                        {
                                            gv.cc.addLogText("<font color='yellow'>" + pc.name + " fails will save(" + saveChkRoll + "+" + saveChkAdder + " <= " + DC + ") - " + pc.playerClass.spellLabelSingular + " cancelled due to damage during last turn." + "</font><BR>");

                                            //reset all relevant values to default
                                            pc.isPreparingSpell = false;
                                            pc.doCastActionInXFullTurns = 0;
                                            pc.tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                            pc.thisCastIsFreeOfCost = false;
                                            pc.thisCasterCanBeInterrupted = true;
                                            //currentCombatMode = "info";
                                            //animationSeqStack.Clear();
                                            endPcTurn(true);
                                        }
                                    }
                                }
                                */

                                //**********************************************************************
                                //no normal turn if player is preparing spell
                                //it is either passing move while reducing remaining cast time by 1
                                //it is doing the cast of the stored spell, jumping to select target mode ("cast") (note: without spell cost that was paid upfront)
                                if (pc.isPreparingSpell)
                                {
                                    //AoO code
                                    foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (gv.screenCombat.CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) == 1)
                                        {
                                            bool triggersAoO = false;
                                            foreach (Spell sp in gv.mod.moduleSpellsList)
                                            {
                                                if (sp.tag == pc.tagOfSpellToBeCastAfterCastTimeIsDone)
                                                {
                                                    if (sp.triggersAoO)
                                                    {
                                                        triggersAoO = true;
                                                    }
                                                    break;
                                                }
                                            }

                                            foreach (Effect ef in pc.effectsList)
                                            {
                                                if (ef.allowCastingWithoutTriggeringAoO)
                                                {
                                                    triggersAoO = false;
                                                    break;
                                                }
                                            }

                                            if (triggersAoO)
                                            {
                                                gv.cc.addLogText("<font color='blue'>Attack of Opportunity by: " + crt.cr_name + "</font><BR>");
                                                //int dcForSaveAdder = pc.hp;
                                                //gv.screenCombat.doStandardCreatureAttackAoO(pc, crt, 1);
                                                //gv.screenType = "combat";
                                                gv.sf.CombatTarget = pc;
                                                gv.screenCombat.CreatureDoesAttack(crt, false, pc);
                                                if ((pc.hp <= 0) || (pc.isHeld()))
                                                {
                                                    gv.screenType = "combat";
                                                    gv.screenCombat.endPcTurn(true);
                                                }
                                            }
                                        }
                                    }
                                    //TODO check flow from here (interruption?)
                                    //add code for interrupting the caster of a spell with long duration here
                                    if ((pc.hp < pc.hpLastTurn) && (pc.hp > 0) && (!pc.isHeld()))
                                    {
                                        foreach (Effect ef in pc.effectsList)
                                        {
                                            if (ef.allowCastingWithoutRiskOfInterruption)
                                            {
                                                pc.thisCasterCanBeInterrupted = false;
                                                break;
                                            }
                                        }

                                        if (pc.isPreparingSpell && pc.thisCasterCanBeInterrupted)
                                        {
                                            #region Do Calc Save and DC
                                            int saveChkRoll = gv.sf.RandInt(20);
                                            int saveChk = 0;
                                            int DC = 10 + (pc.hpLastTurn - pc.hp);
                                            int saveChkAdder = pc.will;

                                            saveChk = saveChkRoll + saveChkAdder;
                                            #endregion

                                            if (saveChk >= DC)
                                            {
                                                gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>makes will save(" + saveChkRoll + "+" + saveChkAdder + " >= " + DC + ") and " + pc.playerClass.labelForCastAction + " still despite damage during last turn." + "</font><BR>");
                                            }
                                            else
                                            {
                                                gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>fails will save(" + saveChkRoll + "+" + saveChkAdder + " <= " + DC + ") - " + pc.playerClass.spellLabelSingular + " cancelled due to damage during last turn." + "</font><BR>");

                                                //reset all relevant values to default
                                                pc.isPreparingSpell = false;
                                                pc.doCastActionInXFullTurns = 0;
                                                pc.tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                                pc.thisCastIsFreeOfCost = false;
                                                pc.thisCasterCanBeInterrupted = true;
                                                //currentCombatMode = "info";
                                                //animationSeqStack.Clear();
                                                endPcTurn(true);
                                            }
                                        }
                                    }

                                    //takes this full turn still to prepare spell
                                    if (pc.doCastActionInXFullTurns > 1)
                                    {

                                        //reduce cast timer by 1
                                        pc.doCastActionInXFullTurns--;

                                        //log
                                        gv.cc.addLogText("<font color='lime'>" + pc.name + "<font color='white'> prepares a " + pc.playerClass.spellLabelSingular + " that takes still " + pc.doCastActionInXFullTurns + " full turn(s)..." + " </font><BR>");

                                        //end turn
                                        endPcTurn(true);
                                    }
                                    //the cast shall happen this turn, pc.doCastActionInXFullTurn is 1
                                    else
                                    {
                                        //preparation is over we come to the act of casting
                                        pc.isPreparingSpell = false;

                                        //setting cast timer to deafult zero again
                                        pc.doCastActionInXFullTurns--;

                                        //do a very special pc turn now, that directly begins with targeting the preselected spell
                                        startPcTurnPreparedCast();
                                    }
                                }
                                //a normal turn
                                else
                                {
                                    pc.thisCastIsFreeOfCost = false;
                                    pc.isPreparingSpell = false;
                                    pc.doCastActionInXFullTurns = 0;
                                    pc.tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                    pc.thisCasterCanBeInterrupted = true;
                                    startPcTurn();
                                }
                            }
                            return;
                        }
                    }
                    idx++;
                }
                idx = 0;
                foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (crt.moveOrder == currentMoveOrderIndex)
                    {
                        //tiereimpark
                        gv.screenCombat.animationSeqStack.Clear();
                        checkEndEncounter();
                        spriteList.Clear();
                        if (!floatyTextEnlargerOn)
                        {
                            gv.cc.floatyTextList.Clear();
                        }
                        coordinatesOfPcTheCreatureMovesTowards.X = -1;
                        coordinatesOfPcTheCreatureMovesTowards.Y = -1;
                        storedPathOfCurrentCreature.Clear();
                        //deathAnimationLocations.Clear();
                        gv.cc.addLogText("Turn of " + "<font color='red'>" + crt.cr_name + "</font> <BR>");
                        //switching to a system where effects last from turn they are applied to start of the target creature's next turn (multiplied with duration of effect)
                        //moved to after prop triggers
                        applyEffectsFromSquare(crt.combatLocX, crt.combatLocY);
                        applyEffectsCombat(crt, false);

                        //tiereimpark
                        checkEndEncounter();
                        //change creatureIndex or currentPlayerIndex
                        creatureIndex = idx;
                        //set isPlayerTurn
                        isPlayerTurn = false;

                        if (!gv.mod.useManualCombatCam)
                        {
                            gv.touchEnabled = false;
                        }

                        currentCombatMode = "info";
                        currentMoveOrderIndex++;
                        tagsOfTriggersAndPropTriggersCalledThisTurn.Clear();
                        triggerIndexCombat = 0;
                        gv.mod.combatScrollingTimer = 0;
                        gv.mod.combatScrollingTimerY = 0;
                        CalculateUpperLeftCreature(crt);
                        //CalculateUpperLeft();
                        doPropTriggers();
                        //applyEffectsFromSquare(crt.combatLocX, crt.combatLocY);
                        //applyEffectsCombat(crt, false);
                        //tiereimpark
                        checkEndEncounter();
                        floatyTextOn = true;
                        //Karl
                        //gv.Render();
                        //go to start PlayerTurn or start CreatureTurn
                        bool skipDueToSurprise = false;
                        if (roundCounter <= 2 && partyHasUpperHand)
                        {
                            //gv.cc.addLogText("<font color='white'> </font>");
                            gv.cc.addLogText("<font color='white'>Flat-footed</font>" + "<BR>");
                            skipDueToSurprise = true;
                        }
                        if (roundCounter > 2)
                        {
                            skipDueToSurprise = false;
                        }
                        //skipDueToSurprise = false;
                        if ((crt.hp > 0) && (!crt.isHeld()) && !skipDueToSurprise)
                        {
                            //upperLeftInFastForwardX = -100;
                            //upperLeftInFastForwardY = -100;
                            blockAnimationBridge = false;
                            doCreatureTurn();
                        }
                        else
                        {
                            endCreatureTurn(crt);
                        }
                        return;
                    }
                    idx++;
                }
                //didn't find one so increment moveOrderIndex and try again
                if (animationSeqStack.Count == 0)
                {
                    currentMoveOrderIndex++;
                    //tagsOfTriggersAndPropTriggersCalledThisTurn.Clear();
                    //triggerIndexCombat = 0;
                    //doPropTriggers();
                }
                turnController();
            }

            else
            {
                int ghhg = 0;
            }
            /*
             else if ((animationSeqStack.Count > 0)  && (!continueTurn) && !gv.mod.currentEncounter.isOver && !allDone)
             {
                 turnController();
             }
             */

            //else
            //{
            //animationsOn = true;
            //Update2(gv.elapsed);
            //turnController();
            //}
        }

        public void startNextRoundStuff()
        {

            foreach (Trigger t in gv.mod.currentEncounter.Triggers)
            {
                if (t.vanishInXTurns != null && t.vanishInXTurns != "" && t.vanishInXTurns != "none" && t.vanishInXTurns != "None" && Convert.ToInt32(t.vanishInXTurns) > 0)
                {
                    if (t.vanishCounter >= Convert.ToInt32(t.vanishInXTurns))
                    {
                        t.Enabled = false;
                        t.chkTrigHidden = true;
                        if (t.changeWalkableStateOnEnabledStateChange)
                        {
                            foreach (Coordinate coord in t.TriggerSquaresList)
                            {
                                if (gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable)
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = false;
                                }
                                else
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = true;
                                }
                            }
                        }
                    }
                    t.vanishCounter++;
                }
            }

            foreach (Trigger t in gv.mod.currentEncounter.Triggers)
            {
                if (t.appearInXTurns != null && t.appearInXTurns != "" && t.appearInXTurns != "none" && t.appearInXTurns != "None" && Convert.ToInt32(t.appearInXTurns) > 0)
                {
                    if (t.appearCounter >= Convert.ToInt32(t.appearInXTurns))
                    {
                        t.Enabled = false;
                        t.chkTrigHidden = true;
                        if (t.changeWalkableStateOnEnabledStateChange)
                        {
                            foreach (Coordinate coord in t.TriggerSquaresList)
                            {
                                if (gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable)
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = false;
                                }
                                else
                                {
                                    gv.mod.currentEncounter.encounterTiles[coord.X + coord.Y * gv.mod.currentEncounter.MapSizeX].Walkable = true;
                                }
                            }
                        }
                    }
                    t.appearCounter++;
                }
            }

            foreach (Player p in gv.mod.playerList)
            {
                p.hasDelayedAlready = false;
            }
            if (gv.mod.currentEncounter.conquerVictory)
            {
                //bool conquerConditionMet = false;
                if (gv.mod.currentEncounter.conquerVictory)
                {
                    int locationsConquered = 0;
                    int locationsRequired = 0;

                    foreach (Player p in gv.mod.playerList)
                    {
                        if (p.hp >= 0)
                        {
                            if (p.combatLocX == gv.mod.currentEncounter.conquerTarget1X && p.combatLocY == gv.mod.currentEncounter.conquerTarget1Y)
                            {
                                locationsConquered++;
                            }
                            if (p.combatLocX == gv.mod.currentEncounter.conquerTarget2X && p.combatLocY == gv.mod.currentEncounter.conquerTarget2Y)
                            {
                                locationsConquered++;
                            }
                            if (p.combatLocX == gv.mod.currentEncounter.conquerTarget3X && p.combatLocY == gv.mod.currentEncounter.conquerTarget3Y)
                            {
                                locationsConquered++;
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                            if (gv.mod.currentEncounter.conquerTargetsCumulative)
                            {
                                //1 and 2 and 3
                                if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget2Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                                {
                                    locationsRequired = 3;
                                }
                                //1+2
                                else if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget2Y != -1)
                                {
                                    locationsRequired = 2;
                                }
                                //1+3
                                else if (gv.mod.currentEncounter.conquerTarget1Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                                {
                                    locationsRequired = 2;
                                }
                                //2+3
                                else if (gv.mod.currentEncounter.conquerTarget2Y != -1 && gv.mod.currentEncounter.conquerTarget3Y != -1)
                                {
                                    locationsRequired = 2;
                                }
                                //1
                                else if (gv.mod.currentEncounter.conquerTarget1Y != -1)
                                {
                                    locationsRequired = 1;
                                }
                                //2
                                else if (gv.mod.currentEncounter.conquerTarget2Y != -1)
                                {
                                    locationsRequired = 1;
                                }
                                //3
                                else if (gv.mod.currentEncounter.conquerTarget3Y != -1)
                                {
                                    locationsRequired = 1;
                                }
                            }
                            //alternative target locations
                            else
                            {
                                locationsRequired = 1;
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        }
                    }

                    if (locationsConquered > 0 && locationsConquered >= locationsRequired)
                    {
                        gv.mod.currentEncounter.conquerConditionMet = true;
                    }
                }
                checkEndEncounter();
            }

            if (gv.mod.currentEncounter.holdDefeat)
            {
                //bool holdConditionMet = false;
                if (gv.mod.currentEncounter.holdDefeat)
                {
                    int locationsholded = 0;
                    int locationsRequired = 0;

                    foreach (Player p in gv.mod.playerList)
                    {
                        if (p.hp >= 0)
                        {
                            if (p.combatLocX == gv.mod.currentEncounter.holdTarget1X && p.combatLocY == gv.mod.currentEncounter.holdTarget1Y)
                            {
                                locationsholded++;
                            }
                            if (p.combatLocX == gv.mod.currentEncounter.holdTarget2X && p.combatLocY == gv.mod.currentEncounter.holdTarget2Y)
                            {
                                locationsholded++;
                            }
                            if (p.combatLocX == gv.mod.currentEncounter.holdTarget3X && p.combatLocY == gv.mod.currentEncounter.holdTarget3Y)
                            {
                                locationsholded++;
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                            if (gv.mod.currentEncounter.holdTargetsCumulative)
                            {
                                //1 and 2 and 3
                                if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget2Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                                {
                                    locationsRequired = 3;
                                }
                                //1+2
                                else if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget2Y != -1)
                                {
                                    locationsRequired = 2;
                                }
                                //1+3
                                else if (gv.mod.currentEncounter.holdTarget1Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                                {
                                    locationsRequired = 2;
                                }
                                //2+3
                                else if (gv.mod.currentEncounter.holdTarget2Y != -1 && gv.mod.currentEncounter.holdTarget3Y != -1)
                                {
                                    locationsRequired = 2;
                                }
                                //1
                                else if (gv.mod.currentEncounter.holdTarget1Y != -1)
                                {
                                    locationsRequired = 1;
                                }
                                //2
                                else if (gv.mod.currentEncounter.holdTarget2Y != -1)
                                {
                                    locationsRequired = 1;
                                }
                                //3
                                else if (gv.mod.currentEncounter.holdTarget3Y != -1)
                                {
                                    locationsRequired = 1;
                                }
                            }
                            //alternative target locations
                            else
                            {
                                locationsRequired = 1;
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        }
                    }

                    if (locationsholded < locationsRequired)
                    {
                        gv.mod.currentEncounter.holdConditionMet = true;
                    }
                }
                checkEndEncounter();
            }

            if (gv.mod.currentEncounter.standGroundVictory)
            {
                gv.mod.currentEncounter.standGroundInternalTimer--;
                checkEndEncounter();
            }

            if (gv.mod.currentEncounter.timeLimitDefeat)
            {
                gv.mod.currentEncounter.timeLimitInternalTimer--;
                checkEndEncounter();
            }
            //summe
            //gv.sf.MessageBox("New round started.");
            floatyTextOn = false;
            gv.cc.addFloatyText(new Coordinate(0, 0), "Round " + roundCounter, "yellow");
            gv.cc.addLogText("<font color='yellow'>" + "Round " + roundCounter + "</font><BR>");
            if (gv.mod.currentEncounter.standGroundVictory)
            {
                //gv.mod.currentEncounter.standGroundInternalTimer--;
                gv.cc.addLogText("<font color='lime'>" + "Survive " + gv.mod.currentEncounter.standGroundInternalTimer + " more round(s).</font><BR>");
            }
            if (gv.mod.currentEncounter.timeLimitDefeat)
            {
                //gv.mod.currentEncounter.standGroundInternalTimer--;
                gv.cc.addLogText("<font color='red'>" + "You have to win within " + gv.mod.currentEncounter.timeLimitInternalTimer + " round(s) or this battle is lost.</font><BR>");
            }
            floatyTextEnlargerOn = true;
            //floatyTextOn = true;

            currentMoveOrderIndex = 0;
            //gv.sf.dsWorldTime();

            //add new wave / delayed spawn here
            foreach (CreatureRefs cr in gv.mod.currentEncounter.encounterCreatureRefsList)
            {
                if (roundCounter != 1)
                {
                    if (roundCounter == cr.spawnAtStartOfRoundX)
                    {
                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        Coordinate target = new Coordinate();
                        target.X = Convert.ToInt32(cr.creatureStartLocationX);
                        target.Y = Convert.ToInt32(cr.creatureStartLocationY);

                        bool foundPlace = true;

                        //holla
                        //we must determine the size of the summoned creature
                        Creature summon = new Creature();
                        foreach (Creature c in gv.mod.moduleCreaturesList)
                        {
                            if (c.cr_resref == cr.creatureResRef)
                            {
                                summon.creatureSize = c.creatureSize;
                            }
                        }

                        Coordinate plusX = new Coordinate();
                        plusX.X = target.X + 1;
                        plusX.Y = target.Y;
                        Coordinate plusY = new Coordinate();
                        plusY.X = target.X;
                        plusY.Y = target.Y + 1;
                        Coordinate plusXandY = new Coordinate();
                        plusXandY.X = target.X + 1;
                        plusXandY.Y = target.Y + 1;

                        if (summon.creatureSize == 1)
                        {
                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }
                        }

                        if (summon.creatureSize == 2)
                        {

                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }

                            if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.sf.IsSquareOpen(plusX))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }
                        }

                        if (summon.creatureSize == 3)
                        {

                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }

                            if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.sf.IsSquareOpen(plusY))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }
                        }

                        if (summon.creatureSize == 4)
                        {

                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }

                            if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.sf.IsSquareOpen(plusX))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }

                            if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.sf.IsSquareOpen(plusY))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }

                            if (plusXandY.X < gv.mod.currentEncounter.MapSizeX && plusXandY.Y < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.sf.IsSquareOpen(plusXandY))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }
                        }

                        //try to find a nearby square
                        if (foundPlace)
                        {
                            //AddCreatureToCurrentEncounter(p1, target.X.ToString(), target.Y.ToString(), p4);
                            gv.sf.AddCreatureToCurrentEncounter(cr.creatureResRef, target.X.ToString(), target.Y.ToString(), "10000");
                        }
                        else
                        {
                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                            //find correct summon spot, replace with nearest location if neccessary  

                            bool changeSummonLocation = false;// used as switch for cycling through all tiles in case the originally intended spot was occupied/not-walkable  
                            int targetTile = target.Y * gv.mod.currentEncounter.MapSizeX + target.X;//the index of the original target spot in the encounter's tiles list  
                            List<int> freeTilesByIndex = new List<int>();// a new list used to store the indices of all free tiles in the enocunter  
                            int tileLocX = 0;//just temporary storage in for locations of tiles  
                            int tileLocY = 0;//just temporary storage in for locations of tiles  
                            double floatTileLocY = 0;//was uncertain about rounding and conversion details, therefore need this one (see below)  
                            bool tileIsFree = true;//identify a tile suited as new summon loaction  
                            int nearestTileByIndex = -1;//store the nearest tile by index; as the relevant loop runs this will be replaced several times likely with ever nearer tiles  
                            int dist = 0;//distance between the orignally intended summon location and a free tile  
                            int lowestDist = 10000;//this storest the lowest ditance found while the loop runs  
                            int deltaX = 0;//temporary value used for distance calculation   
                            int deltaY = 0;//temporary value used for distance calculation   

                            //Check whether the target tile is free (then it's not neccessary to loop through any other tiles)  
                            //three checks are done in the following: walkable, occupied by creature, occupied by pc  

                            //TODO: for oversized cretaures
                            //which squares will the cretaure cover

                            //first check: check walkable  
                            //if (gv.mod.currentEncounter.encounterTiles[targetTile].Walkable == false)
                            /*
                            if (gv.mod.currentEncounter.encounterTiles[targetTile].Walkable == false)
                            {
                                changeSummonLocation = true;
                            }

                            //second check: check occupied by creature (only necceessary if walkable)  
                            if (changeSummonLocation == false)
                            {
                                foreach (Creature cr in gv.mod.currentEncounter.encounterCreatureList)
                                {
                                    if ((cr.combatLocX == target.X) && (cr.combatLocY == target.Y))
                                    {
                                        changeSummonLocation = true;
                                        break;
                                    }
                                }
                            }

                            //third check: check occupied by pc (only necceessary if walkable and not occupied by creature)  
                            if (changeSummonLocation == false)
                            {
                                foreach (Player pc in gv.mod.playerList)
                                {
                                    if ((pc.combatLocX == target.X) && (pc.combatLocY == target.Y))
                                    {
                                        changeSummonLocation = true;
                                        break;
                                    }
                                }
                            }
                            */
                            changeSummonLocation = true;
                            Coordinate target2 = new Coordinate();
                            //target square was already occupied/non-walkable, so all other tiles are searched for the NEAREST FREE tile to switch the summon location to  
                            if (changeSummonLocation == true)
                            {
                                //FIRST PART: get all FREE tiles in the current encounter  
                                for (int i = 0; i < gv.mod.currentEncounter.encounterTiles.Count; i++)
                                {
                                    //get the x and y location of current tile by calculation derived from index number, assuming that counting starts at top left corner of a map (0x, 0y)  
                                    //and that each horizintal x-line is counted first, then counting next horizonal x-line starting from the left again  
                                    tileIsFree = true;
                                    //Note: When e.g. MapsizeY is 7, the y values range from 0 to 6  
                                    //MODULO
                                    tileLocX = i % gv.mod.currentEncounter.MapSizeX;
                                    //Note: ensure rounding down here   
                                    floatTileLocY = i / gv.mod.currentEncounter.MapSizeX;
                                    tileLocY = (int)Math.Floor(floatTileLocY);
                                    target2.X = tileLocX;
                                    target2.Y = tileLocY;

                                    //code for large summons goes here, see above
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    plusX.X = target2.X + 1;
                                    plusX.Y = target2.Y;
                                    plusY.X = target2.X;
                                    plusY.Y = target2.Y + 1;
                                    plusXandY.X = target2.X + 1;
                                    plusXandY.Y = target2.Y + 1;

                                    foundPlace = true;

                                    if (summon.creatureSize == 1)
                                    {
                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }
                                    }

                                    if (summon.creatureSize == 2)
                                    {

                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusX))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }
                                    }

                                    if (summon.creatureSize == 3)
                                    {

                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusY))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }
                                    }

                                    if (summon.creatureSize == 4)
                                    {

                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusX))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusY))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusXandY.X < gv.mod.currentEncounter.MapSizeX && plusXandY.Y < gv.mod.currentEncounter.MapSizeY)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusXandY))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }
                                    }


                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                    if (foundPlace)
                                    {
                                        tileIsFree = true;
                                    }
                                    else
                                    {
                                        tileIsFree = false;
                                    }
                                    /*
                                        //look at content of currently checked tile, again with three checks for walkable, occupied by creature, occupied by pc  
                                        //walkbale check  
                                        if (gv.mod.currentEncounter.encounterTiles[i].Walkable == false)
                                    {
                                        tileIsFree = false;
                                    }

                                    //creature occupied check  
                                    if (tileIsFree == true)
                                    {
                                        foreach (Creature cr in gv.mod.currentEncounter.encounterCreatureList)
                                        {
                                            if ((cr.combatLocX == tileLocX) && (cr.combatLocY == tileLocY))
                                            {
                                                tileIsFree = false;
                                                break;
                                            }
                                        }
                                    }

                                    //pc occupied check  
                                    if (tileIsFree == true)
                                    {
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if ((pc.combatLocX == tileLocX) && (pc.combatLocY == tileLocY))
                                            {
                                                tileIsFree = false;
                                                break;
                                            }
                                        }
                                    }
                                    */

                                    //this writes all free tiles into a fresh list; please note that the values of the elements of this new list are our relevant index values  
                                    //therefore it's not the index (which doesnt correalte to locations) in this list that's relevant, but the value of the element at that index  
                                    if (tileIsFree == true)
                                    {
                                        freeTilesByIndex.Add(i);
                                    }
                                }

                                //SECOND PART: find the free tile NEAREST to originally intended summon location  
                                for (int i = 0; i < freeTilesByIndex.Count; i++)
                                {
                                    dist = 0;

                                    //get location x and y of the tile stored at the index number i, i.e. get the value of elment indexed with i and transform to x and y location  
                                    tileLocX = freeTilesByIndex[i] % gv.mod.currentEncounter.MapSizeX;
                                    floatTileLocY = freeTilesByIndex[i] / gv.mod.currentEncounter.MapSizeX;
                                    tileLocY = (int)Math.Floor(floatTileLocY);

                                    //get distance between the current free tile and the originally intended summon location  
                                    deltaX = (int)Math.Abs((tileLocX - target.X));
                                    deltaY = (int)Math.Abs((tileLocY - target.Y));
                                    if (deltaX > deltaY)
                                    {
                                        dist = deltaX;
                                    }
                                    else
                                    {
                                        dist = deltaY;
                                    }

                                    //filter out the nearest tile by remembering it and its distance for further comparison while the loop runs through all free tiles  
                                    if (dist < lowestDist)
                                    {
                                        lowestDist = dist;
                                        nearestTileByIndex = freeTilesByIndex[i];
                                    }
                                }

                                if (nearestTileByIndex != -1)
                                {
                                    //get the nearest tile's x and y location and use it as creature summon coordinates  
                                    tileLocX = nearestTileByIndex % gv.mod.currentEncounter.MapSizeX;
                                    floatTileLocY = nearestTileByIndex / gv.mod.currentEncounter.MapSizeX;
                                    tileLocY = (int)Math.Floor(floatTileLocY);

                                    target.X = tileLocX;
                                    target.Y = tileLocY;
                                }

                            }

                            //just check whether a free squre does exist at all; if not, do not complete the summon  
                            if ((nearestTileByIndex != -1) || (changeSummonLocation == false))
                            {
                                gv.sf.AddCreatureToCurrentEncounter(cr.creatureResRef, target.X.ToString(), target.Y.ToString(), "10000");
                            }
                            else
                            {
                                gv.cc.addLogText("<yl>" + "Creature fails to appear, no valid space.</yl><BR>");
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        }


                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                        //gv.sf.AddCreatureToCurrentEncounter(cr.creatureResRef, cr.creatureStartLocationX.ToString(), cr.creatureStartLocationY.ToString(), "10000");


                        string name = "";
                        foreach (Creature c in gv.mod.moduleCreaturesList)
                        {
                            if (cr.creatureResRef == c.cr_resref)
                            {
                                name = c.cr_name;
                            }
                        }
                        gv.cc.addLogText("<font color='lime'>" + name + " has just appeared. </font><BR>");
                    }

                    else if (cr.spawnAnotherEveryXRoundsAfterFirstSpawn != 0 && (roundCounter > cr.spawnAtStartOfRoundX) && (((roundCounter - cr.spawnAtStartOfRoundX) % cr.spawnAnotherEveryXRoundsAfterFirstSpawn) == 0))
                    {
                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        Coordinate target = new Coordinate();
                        target.X = Convert.ToInt32(cr.creatureStartLocationX);
                        target.Y = Convert.ToInt32(cr.creatureStartLocationY);

                        bool foundPlace = true;

                        //holla
                        //we must determine the size of the summoned creature
                        Creature summon = new Creature();
                        foreach (Creature c in gv.mod.moduleCreaturesList)
                        {
                            if (c.cr_resref == cr.creatureResRef)
                            {
                                summon.creatureSize = c.creatureSize;
                            }
                        }

                        Coordinate plusX = new Coordinate();
                        plusX.X = target.X + 1;
                        plusX.Y = target.Y;
                        Coordinate plusY = new Coordinate();
                        plusY.X = target.X;
                        plusY.Y = target.Y + 1;
                        Coordinate plusXandY = new Coordinate();
                        plusXandY.X = target.X + 1;
                        plusXandY.Y = target.Y + 1;

                        if (summon.creatureSize == 1)
                        {
                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }
                        }

                        if (summon.creatureSize == 2)
                        {

                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }

                            if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.sf.IsSquareOpen(plusX))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }
                        }

                        if (summon.creatureSize == 3)
                        {

                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }

                            if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.sf.IsSquareOpen(plusY))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }
                        }

                        if (summon.creatureSize == 4)
                        {

                            if (!gv.sf.IsSquareOpen(target))
                            {
                                foundPlace = false;
                            }

                            if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.sf.IsSquareOpen(plusX))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }

                            if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.sf.IsSquareOpen(plusY))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }

                            if (plusXandY.X < gv.mod.currentEncounter.MapSizeX && plusXandY.Y < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.sf.IsSquareOpen(plusXandY))
                                {
                                    foundPlace = false;
                                }
                            }
                            else
                            {
                                foundPlace = false;
                            }
                        }

                        //try to find a nearby square
                        if (foundPlace)
                        {
                            //AddCreatureToCurrentEncounter(p1, target.X.ToString(), target.Y.ToString(), p4);
                            gv.sf.AddCreatureToCurrentEncounter(cr.creatureResRef, target.X.ToString(), target.Y.ToString(), "10000");
                        }
                        else
                        {
                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                            //find correct summon spot, replace with nearest location if neccessary  

                            bool changeSummonLocation = false;// used as switch for cycling through all tiles in case the originally intended spot was occupied/not-walkable  
                            int targetTile = target.Y * gv.mod.currentEncounter.MapSizeX + target.X;//the index of the original target spot in the encounter's tiles list  
                            List<int> freeTilesByIndex = new List<int>();// a new list used to store the indices of all free tiles in the enocunter  
                            int tileLocX = 0;//just temporary storage in for locations of tiles  
                            int tileLocY = 0;//just temporary storage in for locations of tiles  
                            double floatTileLocY = 0;//was uncertain about rounding and conversion details, therefore need this one (see below)  
                            bool tileIsFree = true;//identify a tile suited as new summon loaction  
                            int nearestTileByIndex = -1;//store the nearest tile by index; as the relevant loop runs this will be replaced several times likely with ever nearer tiles  
                            int dist = 0;//distance between the orignally intended summon location and a free tile  
                            int lowestDist = 10000;//this storest the lowest ditance found while the loop runs  
                            int deltaX = 0;//temporary value used for distance calculation   
                            int deltaY = 0;//temporary value used for distance calculation   

                            //Check whether the target tile is free (then it's not neccessary to loop through any other tiles)  
                            //three checks are done in the following: walkable, occupied by creature, occupied by pc  

                            //TODO: for oversized cretaures
                            //which squares will the cretaure cover

                            //first check: check walkable  
                            //if (gv.mod.currentEncounter.encounterTiles[targetTile].Walkable == false)
                            /*
                            if (gv.mod.currentEncounter.encounterTiles[targetTile].Walkable == false)
                            {
                                changeSummonLocation = true;
                            }

                            //second check: check occupied by creature (only necceessary if walkable)  
                            if (changeSummonLocation == false)
                            {
                                foreach (Creature cr in gv.mod.currentEncounter.encounterCreatureList)
                                {
                                    if ((cr.combatLocX == target.X) && (cr.combatLocY == target.Y))
                                    {
                                        changeSummonLocation = true;
                                        break;
                                    }
                                }
                            }

                            //third check: check occupied by pc (only necceessary if walkable and not occupied by creature)  
                            if (changeSummonLocation == false)
                            {
                                foreach (Player pc in gv.mod.playerList)
                                {
                                    if ((pc.combatLocX == target.X) && (pc.combatLocY == target.Y))
                                    {
                                        changeSummonLocation = true;
                                        break;
                                    }
                                }
                            }
                            */
                            changeSummonLocation = true;
                            Coordinate target2 = new Coordinate();
                            //target square was already occupied/non-walkable, so all other tiles are searched for the NEAREST FREE tile to switch the summon location to  
                            if (changeSummonLocation == true)
                            {
                                //FIRST PART: get all FREE tiles in the current encounter  
                                for (int i = 0; i < gv.mod.currentEncounter.encounterTiles.Count; i++)
                                {
                                    //get the x and y location of current tile by calculation derived from index number, assuming that counting starts at top left corner of a map (0x, 0y)  
                                    //and that each horizintal x-line is counted first, then counting next horizonal x-line starting from the left again  
                                    tileIsFree = true;
                                    //Note: When e.g. MapsizeY is 7, the y values range from 0 to 6  
                                    //MODULO
                                    tileLocX = i % gv.mod.currentEncounter.MapSizeX;
                                    //Note: ensure rounding down here   
                                    floatTileLocY = i / gv.mod.currentEncounter.MapSizeX;
                                    tileLocY = (int)Math.Floor(floatTileLocY);
                                    target2.X = tileLocX;
                                    target2.Y = tileLocY;

                                    //code for large summons goes here, see above
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    plusX.X = target2.X + 1;
                                    plusX.Y = target2.Y;
                                    plusY.X = target2.X;
                                    plusY.Y = target2.Y + 1;
                                    plusXandY.X = target2.X + 1;
                                    plusXandY.Y = target2.Y + 1;

                                    foundPlace = true;

                                    if (summon.creatureSize == 1)
                                    {
                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }
                                    }

                                    if (summon.creatureSize == 2)
                                    {

                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusX))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }
                                    }

                                    if (summon.creatureSize == 3)
                                    {

                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusY))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }
                                    }

                                    if (summon.creatureSize == 4)
                                    {

                                        if (!gv.sf.IsSquareOpen(target2))
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusX.X < gv.mod.currentEncounter.MapSizeX)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusX))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusY.Y < gv.mod.currentEncounter.MapSizeY)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusY))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }

                                        if (plusXandY.X < gv.mod.currentEncounter.MapSizeX && plusXandY.Y < gv.mod.currentEncounter.MapSizeY)
                                        {
                                            if (!gv.sf.IsSquareOpen(plusXandY))
                                            {
                                                foundPlace = false;
                                            }
                                        }
                                        else
                                        {
                                            foundPlace = false;
                                        }
                                    }


                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                    if (foundPlace)
                                    {
                                        tileIsFree = true;
                                    }
                                    else
                                    {
                                        tileIsFree = false;
                                    }
                                    /*
                                        //look at content of currently checked tile, again with three checks for walkable, occupied by creature, occupied by pc  
                                        //walkbale check  
                                        if (gv.mod.currentEncounter.encounterTiles[i].Walkable == false)
                                    {
                                        tileIsFree = false;
                                    }

                                    //creature occupied check  
                                    if (tileIsFree == true)
                                    {
                                        foreach (Creature cr in gv.mod.currentEncounter.encounterCreatureList)
                                        {
                                            if ((cr.combatLocX == tileLocX) && (cr.combatLocY == tileLocY))
                                            {
                                                tileIsFree = false;
                                                break;
                                            }
                                        }
                                    }

                                    //pc occupied check  
                                    if (tileIsFree == true)
                                    {
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if ((pc.combatLocX == tileLocX) && (pc.combatLocY == tileLocY))
                                            {
                                                tileIsFree = false;
                                                break;
                                            }
                                        }
                                    }
                                    */

                                    //this writes all free tiles into a fresh list; please note that the values of the elements of this new list are our relevant index values  
                                    //therefore it's not the index (which doesnt correalte to locations) in this list that's relevant, but the value of the element at that index  
                                    if (tileIsFree == true)
                                    {
                                        freeTilesByIndex.Add(i);
                                    }
                                }

                                //SECOND PART: find the free tile NEAREST to originally intended summon location  
                                for (int i = 0; i < freeTilesByIndex.Count; i++)
                                {
                                    dist = 0;

                                    //get location x and y of the tile stored at the index number i, i.e. get the value of elment indexed with i and transform to x and y location  
                                    tileLocX = freeTilesByIndex[i] % gv.mod.currentEncounter.MapSizeX;
                                    floatTileLocY = freeTilesByIndex[i] / gv.mod.currentEncounter.MapSizeX;
                                    tileLocY = (int)Math.Floor(floatTileLocY);

                                    //get distance between the current free tile and the originally intended summon location  
                                    deltaX = (int)Math.Abs((tileLocX - target.X));
                                    deltaY = (int)Math.Abs((tileLocY - target.Y));
                                    if (deltaX > deltaY)
                                    {
                                        dist = deltaX;
                                    }
                                    else
                                    {
                                        dist = deltaY;
                                    }

                                    //filter out the nearest tile by remembering it and its distance for further comparison while the loop runs through all free tiles  
                                    if (dist < lowestDist)
                                    {
                                        lowestDist = dist;
                                        nearestTileByIndex = freeTilesByIndex[i];
                                    }
                                }

                                if (nearestTileByIndex != -1)
                                {
                                    //get the nearest tile's x and y location and use it as creature summon coordinates  
                                    tileLocX = nearestTileByIndex % gv.mod.currentEncounter.MapSizeX;
                                    floatTileLocY = nearestTileByIndex / gv.mod.currentEncounter.MapSizeX;
                                    tileLocY = (int)Math.Floor(floatTileLocY);

                                    target.X = tileLocX;
                                    target.Y = tileLocY;
                                }

                            }

                            //just check whether a free squre does exist at all; if not, do not complete the summon  
                            if ((nearestTileByIndex != -1) || (changeSummonLocation == false))
                            {
                                gv.sf.AddCreatureToCurrentEncounter(cr.creatureResRef, target.X.ToString(), target.Y.ToString(), "10000");
                            }
                            else
                            {
                                gv.cc.addLogText("<yl>" + "Creature fails to appear, no valid space.</yl><BR>");
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        }


                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        //gv.sf.AddCreatureToCurrentEncounter(cr.creatureResRef, cr.creatureStartLocationX.ToString(), cr.creatureStartLocationY.ToString(), "10000");
                        string name = "";
                        foreach (Creature c in gv.mod.moduleCreaturesList)
                        {
                            if (cr.creatureResRef == c.cr_resref)
                            {
                                name = c.cr_name;
                            }
                        }
                        gv.cc.addLogText("<font color='lime'>" + name + " has just appeared. </font><BR>");
                    }
                }
            }
            roundCounter++;

            doHardToKillTrait();
            doBattleRegenTrait();
            foreach (Player pc in gv.mod.playerList)
            {
                if (pc.hp > -20)
                {
                    RunAllItemCombatRegenerations(pc);
                    int regenSP = gv.sf.CalcPcSpRegenInCombat(pc);
                    if (regenSP > 0)
                    {
                        doRegenSp(pc, regenSP);
                    }
                    int regenHP = gv.sf.CalcPcHpRegenInCombat(pc);
                    if (regenHP > 0)
                    {
                        doRegenHp(pc, regenHP);
                    }
                }

            }

            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crt.hp > 0)
                {
                    int regenSP = gv.sf.CalcCrtSpRegenInCombat(crt);
                    regenSP += crt.spRegenerationPerRound;
                    if (regenSP > 0)
                    {
                        doRegenSp(crt, regenSP);
                    }

                    int regenHP = gv.sf.CalcCrtHpRegenInCombat(crt);
                    regenHP += crt.hpRegenerationPerRound;
                    if (regenHP > 0)
                    {
                        doRegenHp(crt, regenHP);
                    }
                }

            }
            //TODO:creature regeneration!


            //burning man
            //applyEffectsFromSquares();

            //applyEffectsCombat();
            timerForLingeringEffects();

            //IBScript Start Combat Round Hook
            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnStartCombatRoundIBScript, gv.mod.currentEncounter.OnStartCombatRoundIBScriptParms);
            turnController();
        }

        public void timerForLingeringEffects()
        {
            for (int i = gv.mod.currentEncounter.effectsList.Count; i > 0; i--)
            {
                gv.mod.currentEncounter.effectsList[i - 1].durationOnSquareInUnits -= gv.mod.TimePerRound;
                if (gv.mod.currentEncounter.effectsList[i - 1].durationOnSquareInUnits <= 0)
                {
                    gv.mod.currentEncounter.effectsList.RemoveAt(i - 1);
                }
            }
        }

        public void applyEffectsFromSquare(int x, int y)
        {
            if (gv.mod.currentEncounter.effectsList.Count > 0)
            {
                foreach (Effect ef in gv.mod.currentEncounter.effectsList)
                {
                    if (ef.combatLocX == x && ef.combatLocY == y)
                    {
                        foreach (Player pc in gv.mod.playerList)
                        {
                            if ((pc.combatLocX == x) && (pc.combatLocY == y) && pc.hp > 0)
                            {
                                if (!ef.usedForUpdateStats) //not used for stat updates
                                {

                                    bool skip = false;
                                    //go through creature local vars and compare with this spellEffect's affectOnly and affectNever lists

                                    //when finding a matching apply never, skip
                                    foreach (LocalImmunityString s in ef.affectNeverList)
                                    {
                                        foreach (string ls in pc.knownTraitsTags)
                                        {
                                            if (s.Value.Equals(ls))
                                            {
                                                skip = true;
                                                gv.cc.addLogText(ef.name + " not added due to immunity of <font color='lime'>" + pc.name + "</font><BR>");
                                                break;
                                            }
                                        }

                                        if (skip)
                                        {
                                            break;
                                        }
                                    }

                                    //when finding an entry in affectOnlyList, skip unless it matches
                                    if (!skip)
                                    {
                                        if (ef.affectOnlyList.Count > 0)
                                        {
                                            skip = true;

                                            foreach (LocalImmunityString s in ef.affectOnlyList)
                                            {
                                                foreach (string ls in pc.knownTraitsTags)
                                                {
                                                    if (s.Value.Equals(ls))
                                                    {
                                                        skip = false;
                                                        break;
                                                    }
                                                }
                                                if (skip)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    if (!skip)
                                    {
                                        //nerdlove
                                        if (ef.durationInUnits > 0 || ef.doBuff || ef.doDeBuff)
                                        {
                                            pc.AddEffectByObject(ef, ef.classLevelOfSender);

                                            /*
                                            #region Do Calc Save and DC
                                            int saveChkRoll = gv.sf.RandInt(20);
                                            int saveChk = 0;
                                            int DC = 0;
                                            int saveChkAdder = 0;
                                            if (ef.saveCheckType.Equals("will"))
                                            {
                                                saveChkAdder = pc.will;
                                            }
                                            else if (ef.saveCheckType.Equals("reflex"))
                                            {
                                                saveChkAdder = pc.reflex;
                                            }
                                            else if (ef.saveCheckType.Equals("fortitude"))
                                            {
                                                saveChkAdder = pc.fortitude;
                                            }
                                            else
                                            {
                                                saveChkAdder = -99;
                                            }
                                            saveChk = saveChkRoll + saveChkAdder;
                                            DC = ef.saveCheckDC;
                                            #endregion
                                            if (saveChk >= DC) //passed save check
                                            {
                                                //if ((ef.doBuff || ef.doDeBuff) && (currentMoves == 0))
                                                //{
                                                //do notshow in log
                                                //}
                                                //else
                                                //{
                                                gv.cc.addLogText("Adding prevented: <font color='lime'>" + pc.name + "<font color='white'> makes successful " + ef.saveCheckType + " saving roll (" + saveChkRoll.ToString() + "+" + saveChkAdder + ">=" + DC.ToString() + ")" + " and avoids " + ef.name + " </font><BR>");
                                                //}
                                            }
                                            else//failed save roll or no roll allowed
                                            {
                                                //failed save roll
                                                if (saveChkAdder > -99)
                                                {
                                                    //if ((ef.doBuff || ef.doDeBuff) && (currentMoves == 0))
                                                    //{
                                                    //do notshow in log
                                                    //}
                                                    //else
                                                    //{
                                                    gv.cc.addLogText("Effect added: <font color='lime'>" + pc.name + "<font color='white'> failed " + ef.saveCheckType + " saving roll for " + ef.name + "(" + saveChkRoll.ToString() + "+" + saveChkAdder + " < " + DC.ToString() + ")" + "</font><BR>");
                                                    //}
                                                    //gv.cc.addLogText("<font color='yellow'>" + pc.name + " failed " + thisSpellEffect.saveCheckType + " saving roll against " + thisSpellEffect.name + "</font><BR>");
                                                    //gv.cc.addLogText("<font color='yellow'>" + "(" + saveChkRoll.ToString() + "+" + saveChkAdder.ToString() + "<" + DC.ToString() + ")" + "</font><BR>");
                                                }
                                                else//no save roll allowed
                                                {
                                                    //gv.cc.addLogText("<font color='yellow'>" + "No saving roll allowed against longer lasting effect of " + thisSpellEffect.name + "</font><BR>");
                                                }
                                                int numberOfRounds = ef.durationInUnits / gv.mod.TimePerRound;
                                                //gv.cc.addLogText("<font color='lime'>" + thisSpellEffect.name + " is applied on " + pc.name + " for " + numberOfRounds + " round(s)</font><BR>");

                                                if (ef.durationInUnits > 0 || ef.doBuff || ef.doDeBuff)
                                                {
                                                    //if ((ef.doBuff || ef.doDeBuff) && (currentMoves == 0))
                                                    //{
                                                    //do not add as it cannot be used
                                                    //}
                                                    //else
                                                    //{
                                                    pc.AddEffectByObject(ef, ef.classLevelOfSender);
                                                    //}
                                                }
                                                else
                                                {
                                                    //if ((ef.doBuff || ef.doDeBuff) && (currentMoves == 0))
                                                    //{
                                                    //do not add as it cannot be used
                                                    //}
                                                    //else
                                                    //{
                                                    gv.cc.doEffectScript(pc, ef);
                                                    //}
                                                }
                                                //gv.cc.doEffectScript(pc, ef);

                                              


                                            }
                                            */
                                        }
                                        else
                                        {
                                            gv.cc.doEffectScript(pc, ef);
                                        }
                                    }


                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                    //gv.cc.doEffectScript(pc, ef);
                                    //todo: ad eath/ending anmations here?
                                    //freedom
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    if (!isPlayerTurn)
                                    {
                                        //string filename = ef.spriteFilename;
                                        AnimationSequence newSeq = new AnimationSequence();
                                        gv.screenCombat.animationSeqStack.Add(newSeq);
                                        AnimationStackGroup newGroup = new AnimationStackGroup();
                                        gv.screenCombat.animationSeqStack[0].AnimationSeq.Add(newGroup);
                                        foreach (Coordinate coor in gv.sf.AoeSquaresList)
                                        {
                                            //gv.screenCombat.addEndingAnimation(newGroup, new Coordinate(gv.screenCombat.getPixelLocX(coor.X), gv.screenCombat.getPixelLocY(coor.Y)), filename);
                                        }

                                        //add floaty text  
                                        //add death animations

                                        newGroup = new AnimationStackGroup();
                                        gv.screenCombat.animationSeqStack[0].AnimationSeq.Add(newGroup);
                                        gv.screenCombat.deathAnimationLocations.Clear();
                                        gv.screenCombat.blockCreatureDrawLocations.Clear();

                                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                        {
                                            if (c.hp <= 0)
                                            {
                                                Coordinate coord = new Coordinate();
                                                coord.X = c.combatLocX;
                                                coord.Y = c.combatLocY;
                                                gv.screenCombat.deathAnimationLocations.Add(coord);
                                                gv.screenCombat.blockCreatureDrawLocations.Add(coord);
                                            }
                                        }
                                        foreach (Coordinate coor in gv.screenCombat.deathAnimationLocations)
                                        {
                                            gv.screenCombat.addDeathAnimation(newGroup, new Coordinate(gv.screenCombat.getPixelLocX(coor.X), gv.screenCombat.getPixelLocY(coor.Y)));
                                        }

                                        //gv.screenCombat.animationsOn = true;
                                        gv.screenCombat.stepAnimationsOn = true;
                                    }
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                }
                            }
                        }
                        foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            //foreach (Coordinate coord in crtr.tokenCoveredSquares)
                            //{
                            ///if ((coord.X == ef.combatLocX) && (coord.Y == ef.combatLocY))
                            if ((crtr.combatLocX == x) && (crtr.combatLocY == y))
                            {
                                if (!ef.usedForUpdateStats) //not used for stat updates
                                {
                                    //to do: add immunities
                                    bool skip = false;
                                    //go through creature local vars and compare with this spellEffect's affectOnly and affectNever lists

                                    //when finding a matching apply never, skip
                                    foreach (LocalImmunityString s in ef.affectNeverList)
                                    {
                                        foreach (LocalString ls in crtr.CreatureLocalStrings)
                                        {
                                            if (s.Value.Equals(ls.Value))
                                            {
                                                skip = true;
                                                gv.cc.addLogText(ef.name + " not added due to immunity of <font color='red'>" + crtr.cr_name + "</font><BR>");
                                                break;
                                            }
                                        }

                                        if (skip)
                                        {
                                            break;
                                        }
                                    }

                                    //when finding an entry in affectOnlyList, skip unless it matches
                                    if (!skip)
                                    {
                                        if (ef.affectOnlyList.Count > 0)
                                        {
                                            skip = true;

                                            foreach (LocalImmunityString s in ef.affectOnlyList)
                                            {
                                                foreach (LocalString ls in crtr.CreatureLocalStrings)
                                                {
                                                    if (s.Value.Equals(ls.Value))
                                                    {
                                                        skip = false;
                                                        break;
                                                    }
                                                }
                                                if (skip)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    if (!skip)
                                    {
                                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                        if (ef.durationInUnits > 0 || ef.doBuff || ef.doDeBuff)
                                        {
                                            crtr.AddEffectByObject(ef, ef.classLevelOfSender);

                                            /*
                                            #region Do Calc Save and DC
                                            int saveChkRoll = gv.sf.RandInt(20);
                                            int saveChk = 0;
                                            int DC = 0;
                                            int saveChkAdder = 0;
                                            if (ef.saveCheckType.Equals("will"))
                                            {
                                                saveChkAdder = crtr.getWill();
                                            }
                                            else if (ef.saveCheckType.Equals("reflex"))
                                            {
                                                saveChkAdder = crtr.getReflex();
                                            }
                                            else if (ef.saveCheckType.Equals("fortitude"))
                                            {
                                                saveChkAdder = crtr.getFortitude();
                                            }
                                            else
                                            {
                                                saveChkAdder = -99;
                                            }
                                            saveChk = saveChkRoll + saveChkAdder;
                                            DC = ef.saveCheckDC;
                                            #endregion
                                            //europa
                                            if (saveChk >= DC) //passed save check
                                            {

                                                gv.cc.addLogText("Adding prevented: <font color='red'>" + crtr.cr_name + "<font color='white'> makes successful " + ef.saveCheckType + " saving roll (" + saveChkRoll.ToString() + "+" + saveChkAdder + ">=" + DC.ToString() + ")" + " and avoids " + ef.name + " </font><BR>");
                                            }
                                            else//failed save roll or no roll allowed
                                            {
                                                //failed save roll 
                                                if (saveChkAdder > -99)
                                                {
                                                    gv.cc.addLogText("Effect added: <font color='red'>" + crtr.cr_name + "<font color='white'> failed " + ef.saveCheckType + " saving roll for " + ef.name + "(" + saveChkRoll.ToString() + "+" + saveChkAdder + " < " + DC.ToString() + ")" + "</font><BR>");
                                                }
                                                
                                                int numberOfRounds = ef.durationInUnits / gv.mod.TimePerRound;
                                                
                                                if (ef.durationInUnits > 0 || ef.doBuff || ef.doDeBuff)
                                                {
                                                   
                                                    crtr.AddEffectByObject(ef, ef.classLevelOfSender);
                                                    
                                                }
                                                else
                                                {
                                                    
                                                    gv.cc.doEffectScript(crtr, ef);
                                                    
                                                }

                                            }
                                            */

                                        }
                                        else
                                        {
                                            gv.cc.doEffectScript(crtr, ef);
                                        }

                                    }


                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx




                                    //gv.cc.doEffectScript(crtr, ef);
                                    //break;
                                    //todo: ad eath/ending anmations here?
                                    //freedom
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    if (!isPlayerTurn)
                                    {
                                        //string filename = ef.spriteFilename;
                                        AnimationSequence newSeq = new AnimationSequence();
                                        gv.screenCombat.animationSeqStack.Add(newSeq);
                                        AnimationStackGroup newGroup = new AnimationStackGroup();
                                        gv.screenCombat.animationSeqStack[0].AnimationSeq.Add(newGroup);
                                        foreach (Coordinate coor in gv.sf.AoeSquaresList)
                                        {
                                            //gv.screenCombat.addEndingAnimation(newGroup, new Coordinate(gv.screenCombat.getPixelLocX(coor.X), gv.screenCombat.getPixelLocY(coor.Y)), filename);
                                        }

                                        //add floaty text  
                                        //add death animations

                                        newGroup = new AnimationStackGroup();
                                        gv.screenCombat.animationSeqStack[0].AnimationSeq.Add(newGroup);
                                        gv.screenCombat.deathAnimationLocations.Clear();
                                        gv.screenCombat.blockCreatureDrawLocations.Clear();

                                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                        {
                                            if (c.hp <= 0)
                                            {
                                                Coordinate coord = new Coordinate();
                                                coord.X = c.combatLocX;
                                                coord.Y = c.combatLocY;
                                                gv.screenCombat.deathAnimationLocations.Add(coord);
                                                gv.screenCombat.blockCreatureDrawLocations.Add(coord);
                                            }
                                        }
                                        foreach (Coordinate coor in gv.screenCombat.deathAnimationLocations)
                                        {
                                            gv.screenCombat.addDeathAnimation(newGroup, new Coordinate(gv.screenCombat.getPixelLocX(coor.X), gv.screenCombat.getPixelLocY(coor.Y)));
                                        }

                                        //gv.screenCombat.animationsOn = true;
                                        gv.screenCombat.stepAnimationsOn = true;
                                    }
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                }
                            }
                            //}
                        }
                    }
                }
                /*
                for (int i = gv.mod.currentEncounter.effectsList.Count; i > 0; i--)
                {
                    //decrement duration of all effects on the encounter map squares
                    if (gv.mod.currentEncounter.effectsList[i - 1].combatLocX == x && gv.mod.currentEncounter.effectsList[i - 1].combatLocY == y)
                    {
                        gv.mod.currentEncounter.effectsList[i - 1].durationInUnits -= gv.mod.TimePerRound;
                        if (gv.mod.currentEncounter.effectsList[i - 1].durationInUnits <= 0)
                        {
                            gv.mod.currentEncounter.effectsList.RemoveAt(i - 1);
                        }
                    }
                }
                */
            }
        }

        public void applyEffectsFromSquares()
        {

            foreach (Effect ef in gv.mod.currentEncounter.effectsList)
            {
                //decrement duration of all effects on the encounter map squares
                ef.durationInUnits -= gv.mod.TimePerRound;

                foreach (Player pc in gv.mod.playerList)
                {
                    if ((pc.combatLocX == ef.combatLocX) && (pc.combatLocY == ef.combatLocY))
                    {
                        if (!ef.usedForUpdateStats) //not used for stat updates
                        {
                            gv.cc.doEffectScript(pc, ef);
                        }
                    }
                }
                foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if ((crtr.combatLocX == ef.combatLocX) && (crtr.combatLocY == ef.combatLocY))
                    {
                        if (!ef.usedForUpdateStats) //not used for stat updates
                        {
                            gv.cc.doEffectScript(crtr, ef);
                        }
                    }
                }
            }

            for (int i = gv.mod.currentEncounter.effectsList.Count; i > 0; i--)
            {
                if (gv.mod.currentEncounter.effectsList[i - 1].durationInUnits <= 0)
                {
                    gv.mod.currentEncounter.effectsList.RemoveAt(i - 1);
                }
            }
        }

        public void doBattleRegenTrait()
        {
            foreach (Player pc in gv.mod.playerList)
            {
                if (gv.sf.hasTrait(pc, "battleregen"))
                {
                    if (pc.hp <= -20)
                    {
                        //MessageBox("Can't heal a dead character!");
                        gv.cc.addLogText("<font color='red'>" + "BattleRegen off for dead character!" + "</font>" +
                                "<BR>");
                    }
                    else
                    {
                        pc.hp += 1;
                        if (pc.hp > pc.hpMax)
                        {
                            pc.hp = pc.hpMax;
                        }
                        if ((pc.hp > 0) && (pc.charStatus.Equals("Dead")))
                        {
                            pc.charStatus = "Alive";
                        }
                        gv.cc.addLogText("<font color='lime'>" + pc.name + "<font color='white'> gains 1 HPs (BattleRegen Trait)" + "</font><BR>");
                    }
                }
            }
        }
        public void doHardToKillTrait()
        {
            foreach (Player pc in gv.mod.playerList)
            {
                if (gv.sf.hasTrait(pc, "hardtokill"))
                {
                    //hard to kill
                    if (pc.hp < 0)
                    {
                        //50% chance to jump back up to 1/4 hpMax
                        int roll = gv.sf.RandInt(100);
                        if (roll > 50)
                        {
                            pc.charStatus = "Alive";
                            pc.hp = pc.hpMax / 10;
                            //do damage to all
                            gv.cc.addLogText("<font color='lime'>" + pc.name + "<font color='white'> jumps back up (Hard to Kill trait).</font><br>");
                            if (gv.mod.debugMode)
                            {
                                gv.cc.addLogText("<font color='white'>" + "roll = " + roll + " (" + roll + " > 50)</font><BR>");
                            }
                        }
                        else
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + "<font color='white'> stays down (Hard to Kill trait).</font><br>");
                            if (gv.mod.debugMode)
                            {
                                gv.cc.addLogText("<font color='white'>" + "roll = " + roll + " (" + roll + " < 51)</font><BR>");
                            }
                        }
                    }
                }
            }
        }
        public void RunAllItemCombatRegenerations(Player pc)
        {
            try
            {
                if (gv.mod.getItemByResRefForInfo(pc.BodyRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.BodyRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.BodyRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.BodyRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.RingRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.RingRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.RingRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.RingRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.HeadRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.HeadRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.HeadRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.HeadRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.GlovesRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.GlovesRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.GlovesRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.GlovesRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.NeckRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.NeckRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.NeckRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.NeckRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.FeetRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.FeetRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.FeetRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.FeetRefs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.Ring2Refs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.Ring2Refs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.Ring2Refs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.Ring2Refs.resref).hpRegenPerRoundInCombat);
                }

                if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).spRegenPerRoundInCombat > 0)
                {
                    doRegenSp(pc, gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).spRegenPerRoundInCombat);
                }
                if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).hpRegenPerRoundInCombat > 0)
                {
                    doRegenHp(pc, gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).hpRegenPerRoundInCombat);
                }
            }
            catch (Exception ex)
            {
                gv.errorLog(ex.ToString());
            }
        }
        public void doRegenSp(Player pc, int increment)
        {
            pc.sp += increment;
            if (pc.sp > pc.spMax)
            {
                increment = increment - (pc.sp - pc.spMax);
                pc.sp = pc.spMax;
            }
            if (increment > 0)
            {
                gv.cc.addLogText("<font color='lime'>" + pc.name + "<font color='white'> regens <font color='lime'>" + increment + "<font color='white'> sp</font><br>");
            }

        }
        public void doRegenHp(Player pc, int increment)
        {
            pc.hp += increment;
            if (pc.hp > pc.hpMax)
            {
                increment = increment - (pc.hp - pc.hpMax);
                pc.hp = pc.hpMax;
            }
            if (increment > 0)
            {
                gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>regens <font color='lime'>" + increment + " <font color='white'>hp</font><br>");
            }
        }

        public void doRegenSp(Creature crt, int increment)
        {
            crt.sp += increment;
            gv.cc.addLogText("<font color='lime'>" + crt.cr_name + " regens " + increment + "sp</font><br>");

        }
        public void doRegenHp(Creature crt, int increment)
        {
            crt.hp += increment;
            if (crt.hp > crt.hpMax)
            {
                increment = increment - (crt.hp - crt.hpMax);
                crt.hp = crt.hpMax;
            }
            if (increment > 0)
            {
                gv.cc.addLogText("<font color='lime'>" + crt.cr_name + " regens " + increment + "hp</font><br>");
            }
        }

        //not used
        /*
        public void applyEffectsCombat()
        {
            try
            {
                //maybe reorder all based on their order property            
                foreach (Player pc in gv.mod.playerList)
                {
                    foreach (Effect ef in pc.effectsList)
                    {
                        //decrement duration of all
                        if (!ef.isPermanent)
                        {
                            ef.durationInUnits -= gv.mod.TimePerRound;
                        }
                        if ((!ef.usedForUpdateStats) && (!ef.isPermanent)) //not used for stat updates nor permanent effect of trait 
                        {
                            gv.cc.doEffectScript(pc, ef);
                        }
                    }
                }
                foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList)
                {
                    foreach (Effect ef in crtr.cr_effectsList)
                    {
                        //increment duration of all
                        if (!ef.isPermanent)
                        {
                            ef.durationInUnits -= gv.mod.TimePerRound;
                        }
                        if ((!ef.usedForUpdateStats) && (!ef.isPermanent)) //not used for stat updates
                        {
                            //do script for each effect
                            gv.cc.doEffectScript(crtr, ef);
                        }
                    }
                }
                //if remaining duration <= 0, remove from list
                //returnkarl
                foreach (Player pc in gv.mod.playerList)
                {
                    for (int i = pc.effectsList.Count; i > 0; i--)
                    {
                        if (pc.effectsList[i - 1].durationInUnits <= 0)
                        {
                            if (!pc.effectsList[i - 1].isPermanent)
                            {
                                pc.effectsList.RemoveAt(i - 1);
                            }
                        }
                    }
                }
                foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList)
                {
                    for (int i = crtr.cr_effectsList.Count; i > 0; i--)
                    {
                        if (crtr.cr_effectsList[i - 1].durationInUnits <= 0)
                        {
                            if (!crtr.cr_effectsList[i - 1].isPermanent)
                            {
                                crtr.cr_effectsList.RemoveAt(i - 1);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                IBMessageBox.Show(gv, ex.ToString());
                gv.errorLog(ex.ToString());
            }
            checkEndEncounter();
        }
        */

        public void applyEffectsCombat(Creature crtr, bool onlyStepBasedEffects)
        {

            if (!onlyStepBasedEffects)
            {
                if (crtr.hp < crtr.hpLastTurn)
                {
                    for (int i = crtr.cr_effectsList.Count - 1; i >= 0; i--)
                    {
                        if (crtr.cr_effectsList[i].endEffectWhenCarrierTakesDamage)
                        {
                            gv.cc.addLogText("<font color='red'>" + crtr.cr_name + " <font color='white'>took damage and is freed from " + crtr.cr_effectsList[i].name + "</font><BR>");
                            crtr.cr_effectsList.Remove(crtr.cr_effectsList[i]);
                        }
                    }
                }
            }

            try
            {

                for (int i = crtr.cr_effectsList.Count - 1; i >= 0; i--)
                {
                    if (crtr.cr_effectsList[i].repeatTerminalSaveEachRound && !onlyStepBasedEffects)
                    {
                        //sean
                        #region Do Calc Save and DC
                        int saveChkRoll = gv.sf.RandInt(20);
                        int saveChk = 0;
                        int DC = 0;
                        int saveChkAdder = 0;
                        if (crtr.cr_effectsList[i].saveCheckType.Equals("will"))
                        {
                            saveChkAdder = crtr.getWill();
                        }
                        else if (crtr.cr_effectsList[i].saveCheckType.Equals("reflex"))
                        {
                            saveChkAdder = crtr.getReflex();
                        }
                        else if (crtr.cr_effectsList[i].saveCheckType.Equals("fortitude"))
                        {
                            saveChkAdder = crtr.getFortitude();
                        }
                        else
                        {
                            saveChkAdder = -99;
                        }
                        saveChk = saveChkRoll + saveChkAdder;
                        DC = crtr.cr_effectsList[i].saveCheckDC;
                        #endregion

                        if (saveChk >= DC)
                        {
                            gv.cc.addLogText("<font color='white'>" + "The " + crtr.cr_effectsList[i].name + " effect on <font color='red'>" + crtr.cr_name + " <font color='white'>has been shrugged off" + " </font><BR>");
                            crtr.cr_effectsList.RemoveAt(i);
                        }
                        else
                        {
                            gv.cc.addLogText("<font color='red'>" + crtr.cr_name + " <font color='white'>fails to shrug off " + crtr.cr_effectsList[i].name + " </font><BR>");
                        }
                    }
                }



                foreach (Effect ef in crtr.cr_effectsList)
                {
                    if (!ef.isPermanent && !onlyStepBasedEffects)
                    {
                        ef.durationInUnits -= gv.mod.TimePerRound;
                    }
                }

                if (!onlyStepBasedEffects)
                {
                    //if remaining duration <= 0, remove from list
                    for (int i = crtr.cr_effectsList.Count - 1; i >= 0; i--)
                    {
                        //if (crtr.cr_effectsList[i].doBuff || crtr.cr_effectsList[i].doDeBuff)
                        //{
                        if (crtr.cr_effectsList[i].durationInUnits <= -gv.mod.TimePerRound)
                        //if (crtr.cr_effectsList[i].durationInUnits <= 0)
                        {
                            if (!crtr.cr_effectsList[i].isPermanent)
                            {
                                gv.cc.addLogText("<font color='white'>" + "The " + crtr.cr_effectsList[i].name + " effect on <font color='red'>" + crtr.cr_name + " <font color='white'>has just ended." + " </font><BR>");
                                crtr.cr_effectsList.RemoveAt(i);
                            }
                        }
                        else if (crtr.cr_effectsList[i].numberOfHitPointDamageAbsorptionLeft < 0)
                        {
                            gv.cc.addLogText("<font color='white'>" + "The " + crtr.cr_effectsList[i].name + " effect on <font color='red'>" + crtr.cr_name + " <font color='white'>has just ended." + " </font><BR>");
                            crtr.cr_effectsList.RemoveAt(i);
                        }
                        else if (crtr.cr_effectsList[i].numberOfMirrorImagesLeft < 0)
                        {
                            gv.cc.addLogText("<font color='white'>" + "The " + crtr.cr_effectsList[i].name + " effect on <font color='red'>" + crtr.cr_name + " <font color='white'>has just ended." + " </font><BR>");
                            crtr.cr_effectsList.RemoveAt(i);
                        }
                        //}
                        /*
                        else
                        {
                            if (crtr.cr_effectsList[i].durationInUnits <= 0)
                            {
                                if (!crtr.cr_effectsList[i].isPermanent)
                                {
                                    gv.cc.addLogText("<font color='white'>" + "The " + crtr.cr_effectsList[i].name + " effect on <font color='red'>" + crtr.cr_name + " <font color='white'>has just ended." + " </font><BR>");
                                    crtr.cr_effectsList.RemoveAt(i);
                                }
                            }
                        }
                        */
                    }
                }


                //maybe reorder all based on their order property            
                foreach (Effect ef in crtr.cr_effectsList)
                {
                    //increment duration of all
                    //ef.durationInUnits -= gv.mod.TimePerRound;
                    if ((!ef.usedForUpdateStats) && (!ef.isPermanent)) //not used for stat updates
                    {
                        //do script for each effect
                        if (onlyStepBasedEffects)
                        {
                            if (ef.triggeredEachStepToo)
                            {
                                gv.cc.doEffectScript(crtr, ef);
                            }
                        }
                        else
                        {
                            gv.cc.doEffectScript(crtr, ef);
                        }
                    }

                    //if (!ef.isPermanent && !onlyStepBasedEffects)
                    //{
                    //ef.durationInUnits -= gv.mod.TimePerRound;
                    //}
                }

            }
            catch (Exception ex)
            {
                IBMessageBox.Show(gv, ex.ToString());
                gv.errorLog(ex.ToString());
            }
            checkEndEncounter();
        }

        public void applyEffectsCombat(Player pc, bool onlyStepBasedEffects)
        {
            if (!onlyStepBasedEffects)
            {
                if (pc.hp < pc.hpLastTurn)
                {
                    for (int i = pc.effectsList.Count - 1; i >= 0; i--)
                    {
                        if (pc.effectsList[i].endEffectWhenCarrierTakesDamage)
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + "<font color='white'> took damage and is freed from " + pc.effectsList[i].name + "</font><BR>");
                            pc.effectsList.Remove(pc.effectsList[i]);
                        }
                    }
                }
            }
            try
            {

                //**********************************************************
                for (int i = pc.effectsList.Count - 1; i >= 0; i--)
                {
                    if (pc.effectsList[i].repeatTerminalSaveEachRound && !onlyStepBasedEffects)
                    {
                        //sean
                        #region Do Calc Save and DC
                        int saveChkRoll = gv.sf.RandInt(20);
                        int saveChk = 0;
                        int DC = 0;
                        int saveChkAdder = 0;
                        if (pc.effectsList[i].saveCheckType.Equals("will"))
                        {
                            saveChkAdder = pc.will;
                        }
                        else if (pc.effectsList[i].saveCheckType.Equals("reflex"))
                        {
                            saveChkAdder = pc.reflex;
                        }
                        else if (pc.effectsList[i].saveCheckType.Equals("fortitude"))
                        {
                            saveChkAdder = pc.fortitude;
                        }
                        else
                        {
                            saveChkAdder = -99;
                        }
                        saveChk = saveChkRoll + saveChkAdder;
                        DC = pc.effectsList[i].saveCheckDC;
                        #endregion

                        if (saveChk >= DC)
                        {
                            gv.cc.addLogText("<font color='white'>" + "The " + pc.effectsList[i].name + " effect on <font color='lime'>" + pc.name + " <font color='white'>has been shrugged off" + " </font><BR>");
                            pc.effectsList.RemoveAt(i);
                        }
                        else
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>fails to shrug off " + pc.effectsList[i].name + "</font><BR>");
                        }
                    }
                }


                //**********************************************************
                //europa3


                foreach (Effect ef in pc.effectsList)
                {
                    if (!ef.isPermanent && !onlyStepBasedEffects)
                    {
                        ef.durationInUnits -= gv.mod.TimePerRound;
                    }
                }

                if (!onlyStepBasedEffects)
                {
                    for (int i = pc.effectsList.Count - 1; i >= 0; i--)
                    {
                        //pc.effectsList[i].durationOnSquareInUnits
                        //if (pc.effectsList[i].doBuff || pc.effectsList[i].doDeBuff)
                        //{
                        //if (pc.effectsList[i].durationInUnits <= 0)
                        if (pc.effectsList[i].durationInUnits <= -gv.mod.TimePerRound)
                        {
                            if (!pc.effectsList[i].isPermanent)
                            {
                                gv.cc.addLogText("<font color='white'>" + "The " + pc.effectsList[i].name + " effect on <font color='lime'>" + pc.name + " <font color='white'>has just ended" + " </font><BR>");
                                pc.effectsList.RemoveAt(i);
                            }
                        }
                        else if (pc.effectsList[i].numberOfHitPointDamageAbsorptionLeft < 0)
                        {
                            gv.cc.addLogText("<font color='white'>" + "The " + pc.effectsList[i].name + " effect on <font color='lime'>" + pc.name + " <font color='white'>has just ended" + " </font><BR>");
                            pc.effectsList.RemoveAt(i);
                        }
                        else if (pc.effectsList[i].numberOfMirrorImagesLeft < 0)
                        {
                            gv.cc.addLogText("<font color='white'>" + "The " + pc.effectsList[i].name + " effect on <font color='lime'>" + pc.name + " <font color='white'>has just ended" + " </font><BR>");
                            pc.effectsList.RemoveAt(i);
                        }
                        //}

                        /*
                        else
                        {
                            if (pc.effectsList[i].durationInUnits <= 0)
                            {
                                if (!pc.effectsList[i].isPermanent)
                                {
                                    gv.cc.addLogText("<font color='white'>" + "The " + pc.effectsList[i].name + " effect on <font color='lime'>" + pc.name + " <font color='white'>has just ended" + " </font><BR>");
                                    pc.effectsList.RemoveAt(i);
                                }
                            }
                        }
                        */
                    }
                }



                //maybe reorder all based on their order property            
                foreach (Effect ef in pc.effectsList)
                {

                    //decrement duration of all
                    //ef.durationInUnits -= gv.mod.TimePerRound;
                    if ((!ef.usedForUpdateStats) && (!ef.isPermanent)) //not used for stat updates
                    {
                        if (onlyStepBasedEffects)
                        {
                            if (ef.triggeredEachStepToo)
                            {
                                gv.cc.doEffectScript(pc, ef);
                            }
                        }
                        else
                        {
                            gv.cc.doEffectScript(pc, ef);
                        }
                    }

                    //if (!ef.isPermanent && !onlyStepBasedEffects)
                    //{
                    //ef.durationInUnits -= gv.mod.TimePerRound;
                    //}
                }


            }
            catch (Exception ex)
            {
                IBMessageBox.Show(gv, ex.ToString());
                gv.errorLog(ex.ToString());
            }
            checkEndEncounter();
        }

        //COMBAT	
        #region PC Combat Stuff
        public void decrementAmmo(Player pc)
        {
            if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged"))
                    && (!gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
            {
                ItemRefs itr = gv.mod.getItemRefsInInventoryByResRef(pc.AmmoRefs.resref);
                if (itr != null)
                {
                    //decrement by one
                    int numOfAtt = gv.sf.CalcNumberOfRangedAttacks(pc);
                    if (numOfAtt > 0)
                    {
                        //itr.quantity--;
                        itr.quantity -= numOfAtt;
                    }

                    //if equal to zero, remove from party inventory and from all PCs ammo slot
                    if (itr.quantity < 1)
                    {
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.AmmoRefs.resref.Equals(itr.resref))
                            {
                                p.AmmoRefs = new ItemRefs();
                            }
                        }
                        gv.mod.partyInventoryRefsList.Remove(itr);
                    }
                }
            }
        }

        public void startPcTurnPreparedCast()
        {
            CalculateUpperLeft();
            //karl
            //gv.Render();
            isPlayerTurn = true;
            gv.touchEnabled = true;
            Player pc = gv.mod.playerList[currentPlayerIndex];
            foreach (Spell sp in gv.mod.moduleSpellsList)
            {
                if (sp.tag == gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone)
                {
                    gv.cc.currentSelectedSpell = sp;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    break;
                }
            }
            //jump directly to cast mode
            currentCombatMode = "cast";
            gv.sf.UpdateStats(pc);
            currentMoves = 0;
            //do onTurn IBScript
            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnStartCombatTurnIBScript, gv.mod.currentEncounter.OnStartCombatTurnIBScriptParms);

            if ((pc.isHeld()) || (pc.isDead()) || (pc.isUnconcious()))
            {
                endPcTurn(false);
            }
            else
            {
                pc.thisCastIsFreeOfCost = true;
            }
            if (pc.isImmobile())
            {
                currentMoves = 99;
            }
        }

        public void startPcTurn()
        {
            if (gv.mod.playerList.Count > 0)
            {
                gv.mod.combatScrollingTimer = 0;
                gv.mod.combatScrollingTimerY = 0;
                gv.mod.nonRepeatableFreeActionsUsedThisTurnBySpellTag.Clear();
                gv.mod.swiftActionHasBeenUsedThisTurn = false;
                CalculateUpperLeft();
                //karl
                //gv.Render();
                isPlayerTurn = true;
                gv.touchEnabled = true;
                currentCombatMode = "move";
                Player pc = gv.mod.playerList[currentPlayerIndex];
                gv.sf.UpdateStats(pc);
                currentMoves = 0;
                if (gv.mod.currentEncounter.onlyOneMoveModifier)
                {
                    currentMoves = pc.moveDistance - 1.5f;
                }
                //do onTurn IBScript
                if (!pc.hasDelayedAlready)
                {
                    gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnStartCombatTurnIBScript, gv.mod.currentEncounter.OnStartCombatTurnIBScriptParms);
                }
                //damage battle conditions
                if (!pc.hasDelayedAlready)
                {
                    if (gv.mod.currentEncounter.hpDamageEachRound > 0)
                    {
                        if (pc.hp > -20)
                        {
                            pc.hp -= gv.mod.currentEncounter.hpDamageEachRound;
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>lost <font color='red'>" + gv.mod.currentEncounter.hpDamageEachRound + " <font color='white'>hp.</font><BR>");
                        }
                    }

                    if (gv.mod.currentEncounter.spDamageEachRound > 0)
                    {
                        if (pc.sp > 0)
                        {
                            pc.sp -= gv.mod.currentEncounter.spDamageEachRound;
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>lost <font color='red'>" + gv.mod.currentEncounter.spDamageEachRound + " <font color='white'>sp.</font><BR>");
                            if (pc.sp < 0)
                            {
                                pc.sp = 0;
                            }
                        }
                    }
                }

                if ((pc.isHeld()) || (pc.isDead()) || (pc.isUnconcious()))
                {
                    endPcTurn(false);
                }
                if (pc.isImmobile())
                {
                    currentMoves = 99;
                }
            }
        }
        public void doCombatAttack(Player pc)
        {
            //requiredWeaponTypesToHarmCreature

            dontEndTurn = false;
            if (isInRange(pc))
            {

                foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                {
                    //if ((crt.combatLocX == targetHighlightCenterLocation.X) && (crt.combatLocY == targetHighlightCenterLocation.Y))
                    foreach (Coordinate coor in crt.tokenCoveredSquares)
                    {
                        /*
                        int attResult = 0; //0=missed, 1=hit, 2=killed
                        int numAtt = 1;
                        int crtLocX = crt.combatLocX;
                        int crtLocY = crt.combatLocY;

                        if ((gv.sf.hasTrait(pc, "twoAttack")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee")))
                        {
                            numAtt = 2;
                        }
                        if ((gv.sf.hasTrait(pc, "rapidshot")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged")))
                        {
                            numAtt = 2;
                        }
                        if ((gv.sf.hasTrait(pc, "rapidshot2")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged")))
                        {
                            numAtt = 3;
                        }
                        for (int i = 0; i < numAtt; i++)
                        */
                        if ((coor.X == targetHighlightCenterLocation.X) && (coor.Y == targetHighlightCenterLocation.Y))
                        {
                            int attResult = 0; //0=missed, 1=hit, 2=killed
                            bool attResultHit = false;
                            int numAtt = 1;
                            int crtLocX = crt.combatLocX;
                            int crtLocY = crt.combatLocY;

                            //if ((gv.sf.hasTrait(pc, "twoAttack")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee")))
                            numAtt = gv.sf.CalcNumberOfAttacks(pc);
                            if (numAtt < 1)
                            {
                                //???
                                numAtt = 1;
                            }
                            //if ((gv.sf.hasTrait(pc, "rapidshot")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged")))

                            //reset the already targeted creatures list  
                            alreadyTargetedCreatureTagsList.Clear();
                            int numSweep = gv.sf.CalcNumberOfSweepAttackTargets(pc);
                            //do sweep attacks if any                          
                            if ((numSweep > 0) && (gv.sf.isMeleeAttack(pc)))

                            //if ((gv.sf.hasTrait(pc, "cleave")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee")))
                            {
                                attResult = doActualCombatAttack(pc, crt, 0, true);
                                if (attResult > 0) { attResultHit = true; }
                                for (int j = 1; j < numSweep; j++)
                                {
                                    Creature crt2 = GetNextAdjacentCreature(pc);
                                    if (crt2 != null && crt2 != crt)
                                    {
                                        crtLocX = crt2.combatLocX;
                                        crtLocY = crt2.combatLocY;
                                        gv.cc.addFloatyText(new Coordinate(pc.combatLocX, pc.combatLocY), "sweep", "green");
                                        int attResult2 = doActualCombatAttack(pc, crt2, 0, true);
                                        if (attResult2 > 0) { attResultHit = true; }
                                    }
                                }
                            }

                            //for (int i = 0; i < numAtt; i++)
                            else //do multiple attack and cleave attack 
                            {
                                //if ((gv.sf.hasTrait(pc, "cleave")) && (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee")))
                                int numCleave = gv.sf.CalcNumberOfCleaveAttackTargets(pc);
                                for (int i = 0; i < numAtt; i++)
                                {
                                    //do cleave attacks if any                          
                                    if ((numCleave > 0) && (gv.sf.isMeleeAttack(pc)))
                                    {
                                        attResult = doActualCombatAttack(pc, crt, i, true);
                                        if (attResult > 0) { attResultHit = true; }
                                        if (attResult == 2) //2=killed, 1=hit, 0=missed  
                                        {
                                            for (int j = 0; j < numCleave; j++)
                                            {
                                                Creature crt2 = GetNextAdjacentCreature(pc);
                                                if (crt2 != null && crt2 != crt)
                                                {
                                                    crtLocX = crt2.combatLocX;
                                                    crtLocY = crt2.combatLocY;
                                                    gv.cc.addFloatyText(new Coordinate(pc.combatLocX, pc.combatLocY), "cleave", "green");
                                                    int attResult2 = doActualCombatAttack(pc, crt2, i, true);
                                                    if (attResult2 > 0) { attResultHit = true; }
                                                    if (attResult2 != 2)
                                                    {
                                                        //didn't kill this creature so stop with the cleaves  
                                                        break;
                                                    }
                                                }
                                            }
                                            break; //do not try and attack same creature that was just killed  

                                        }

                                    }


                                    else
                                    {
                                        attResult = doActualCombatAttack(pc, crt, i, true);
                                        if (attResult > 0) { attResultHit = true; }
                                        if (attResult == 2) //2=killed, 1=hit, 0=missed  
                                        {
                                            break; //do not try and attack same creature that was just killed  
                                        }
                                    }
                                }
                                if (hasWeaponInOffHand(pc))
                                {
                                    if (attResult != 2)
                                    {
                                        attResult = doActualCombatAttack(pc, crt, numAtt + 1, false);
                                        if (attResult > 0) { attResultHit = true; }                                        
                                    }
                                }
                            }
                            //if (attResult > 0) //2=killed, 1=hit, 0=missed  
                            if (attResultHit) //2=killed, 1=hit, 0=missed 
                            {
                                hitAnimationLocation = new Coordinate(getPixelLocX(crtLocX), getPixelLocY(crtLocY));
                                //new system  
                                AnimationStackGroup newGroup = new AnimationStackGroup();
                                animationSeqStack[0].AnimationSeq.Add(newGroup);
                                addHitAnimation(newGroup);
                            }
                            else
                            {
                                hitAnimationLocation = new Coordinate(getPixelLocX(crtLocX), getPixelLocY(crtLocY));
                                //new system  
                                AnimationStackGroup newGroup = new AnimationStackGroup();
                                animationSeqStack[0].AnimationSeq.Add(newGroup);
                                addMissAnimation(newGroup);
                            }

                            return;
                        }
                        //break here?
                    }

                }
            }
        }

        public int doActualCombatAttack(Player pc, Creature crt, int attackNumber, bool isMainHand)
        {
            //always decrement ammo by one whether a hit or miss
            this.decrementAmmo(pc);

            //pay attack cost in sp or hp
            Item item = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
            bool attackPenaltyForCostNotPaid = false;
            bool paidSpCost = false;
            bool paidHpCost = false;
            if (item.hpCostPerAttack > 0)
            {
                if (pc.hp > item.hpCostPerAttack)
                {
                    paidHpCost = true;
                    pc.hp -= item.hpCostPerAttack;
                }
                else
                {
                    attackPenaltyForCostNotPaid = true;
                }
            }
            if (item.spCostPerAttack > 0)
            {
                if (pc.sp > item.spCostPerAttack)
                {
                    paidSpCost = true;
                    pc.sp -= item.spCostPerAttack;
                }
                else
                {
                    attackPenaltyForCostNotPaid = true;
                }
            }

            int attackRoll = gv.sf.RandInt(20);
            int attackMod = CalcPcAttackModifier(pc, crt, isMainHand);
            if (attackPenaltyForCostNotPaid)
            {
                attackMod -= 10;
            }

            int attack = attackRoll + attackMod;
            int defense = CalcCreatureDefense(pc, crt);
            int damage = CalcPcDamageToCreature(pc, crt, isMainHand);
            //int damage = CalcPcDamageToCreature(pc, crt);
            //int damage = 0;            
            bool criticalHit = false;
            int critAttackRoll = gv.sf.RandInt(20);
            int threatRange = 20;

            Item itChk = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
            if (!isMainHand)
            {
                itChk = gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref);
            }
            /*if (itChk != null)
            {
                threatRange = itChk.threatRange;
                //threatRange = 15;
            }*/

            if (isMainHand)
            {
                threatRange = gv.sf.CalcPcThreatRange(pc, true);
            }
            else
            {
                threatRange = gv.sf.CalcPcThreatRange(pc, false);
            }

            if (attackRoll >= threatRange)
            {
                //determine if a critical hit is applied
                if (critAttackRoll + attackMod >= defense)
                {
                    criticalHit = true;
                    if (itChk != null)
                    {
                        damage *= itChk.criticalMultiplier;
                    }
                }
            }

            bool automaticallyHits = false;
            if (itChk != null)
            {
                automaticallyHits = itChk.automaticallyHitsTarget;
            }

            //natural 20 always hits
            if ((attack >= defense) || (attackRoll == 20) || (automaticallyHits == true)) //HIT
            {                
                //crt.hp = crt.hp - damage;
                if (paidHpCost)
                {
                    gv.cc.addLogText("<font color='lime'>" + pc.name + "</font><font color='white'> is damaged for " + itChk.hpCostPerAttack + "HP by attacking." + "</font><BR>");
                }
                if (paidSpCost)
                {
                    gv.cc.addLogText("<font color='lime'>" + pc.name + "</font><font color='white'> is drained for " + itChk.spCostPerAttack + " SP by attacking." + "</font><BR>");
                }
                if (attackPenaltyForCostNotPaid)
                {
                    gv.cc.addLogText("<font color='lime'>" + pc.name + "</font><font color='white'> could not pay cost for attack, -10 to hit." + "</font><BR>");
                }

                if(isMainHand)
                {
                    gv.cc.addLogText("Attacks <font color='red'>" + crt.cr_name + " (Main Hand)</font><br>");
                }
                else
                {
                    gv.cc.addLogText("Attacks <font color='red'>" + crt.cr_name + " (Off Hand)</font><br>");
                }

                //check if have mirror image
                if (gv.sf.removeOneMirrorImageIfHasOne(null, crt))
                {
                    gv.cc.addLogText("<font color='red'>" + "HITS (one mirror image removed)</font><BR>");
                    gv.cc.addLogText("<font color='white'>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</font><BR>");
                    return 1;
                }
                //check if has damage absorption
                int ret = gv.sf.removeHitPointDamageAbsorptionIfHasAny(null, crt, damage);
                if (ret != -1)
                {
                    int absorbed = damage - ret;
                    damage = ret;
                    gv.cc.addLogText("<font color='red'>" + "(absorbed " + absorbed + " damage)</font><BR>");
                }

                crt.hp = crt.hp - damage;

                if (!automaticallyHits)
                {
                    if (criticalHit)
                    {
                        gv.cc.addLogText("<font color='lime'>CRITICAL HIT (-" + damage + "hp)</font><br>");
                        gv.cc.addLogText("<font color='white'>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</font><BR>");
                        gv.cc.addLogText("<font color='white'>CRIT: " + critAttackRoll + "+" + attackMod + ">=" + defense + "</font><BR>");
                    }
                    else
                    {
                        gv.cc.addLogText("<font color='lime'>HITS (-" + damage + "hp)</font><br>");
                        gv.cc.addLogText("<font color='white'>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</font><BR>");
                        if (attackRoll >= threatRange)
                        {
                            gv.cc.addLogText("<font color='white'>CRIT: " + critAttackRoll + "+" + attackMod + " < " + defense + "</font><BR>");
                        }
                    }
                    /*if (attackMod >= 0)
                    {
                        gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " >= " + defense + ", hit for <font color='red'>" + damage + "<font color='white'>hp</font>");
                    }
                    else
                    {
                        gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " >= " + defense + ", hit for <font color='red'>" + damage + "<font color='white'>hp</font>");
                    }*/
                }
                else
                {
                    gv.cc.addLogText("<font color='white'>" + "Automatic hit for <font color='red'>" + damage + "<font color='white'>hp</font><BR> ");
                }

                Item it = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
                if (!isMainHand)
                {
                    it = gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref);
                }
                if (it != null)
                {
                    doOnHitScriptBasedOnFilename(it.onScoringHit, crt, pc);
                    if (!it.onScoringHitCastSpellTag.Equals("none"))
                    {
                        doItemOnHitCastSpell(it.onScoringHitCastSpellTag, it, crt, pc);
                    }
                }

                it = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
                if (it != null)
                {
                    doOnHitScriptBasedOnFilename(it.onScoringHit, crt, pc);
                    if (!it.onScoringHitCastSpellTag.Equals("none"))
                    {
                        doItemOnHitCastSpell(it.onScoringHitCastSpellTag, it, crt, pc);
                    }
                }

                //play attack sound for melee (not ranged)
                if (isMainHand)
                {
                    if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee"))
                    {
                        gv.PlaySound(gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).itemOnUseSound);
                    }
                }
                else
                {
                    if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).category.Equals("Melee"))
                    {
                        gv.PlaySound(gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).itemOnUseSound);
                    }
                }
                //Draw floaty text showing damage above Creature
                int txtH = (int)gv.drawFontRegHeight;
                int shiftUp = 0 - (attackNumber * txtH);
                gv.cc.addFloatyText(new Coordinate(crt.combatLocX, crt.combatLocY), damage + "", shiftUp);

                if (crt.hp <= 0)
                {
                    //deathAnimationLocations.Add(new Coordinate(crt.combatLocX, crt.combatLocY));
                    foreach (Coordinate coor in crt.tokenCoveredSquares)
                    {
                        deathAnimationLocations.Add(new Coordinate(coor.X, coor.Y));
                        //gv.screenCombat.blockCreatureDrawLocations.Add();
                    }
                    gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>has been killed</font><BR>");
                    return 2; //killed
                }
                else
                {
                    return 1; //hit
                }
            }
            else //MISSED
            {
                //play attack sound for melee (not ranged)
                if (isMainHand)
                {
                    if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee"))
                    {
                        gv.PlaySound(gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).itemOnUseSound);
                    }
                }
                else
                {
                    if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).category.Equals("Melee"))
                    {
                        gv.PlaySound(gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).itemOnUseSound);
                    }
                }
                if (paidHpCost)
                {
                    gv.cc.addLogText("<font color='lime'>" + pc.name + "</font><font color='white'> is damaged for " + itChk.hpCostPerAttack + "HP by attacking." + "</font><BR>");
                }
                if (paidSpCost)
                {
                    gv.cc.addLogText("<font color='lime'>" + pc.name + "</font><font color='white'> is drained for " + itChk.spCostPerAttack + " SP by attacking." + "</font><BR>");
                }
                if (attackPenaltyForCostNotPaid)
                {
                    gv.cc.addLogText("<font color='lime'>" + pc.name + "</font><font color='white'> could not pay cost for attack, -10 to hit." + "</font><BR>");
                }
                gv.cc.addLogText("Attacks <font color='red'>" + crt.cr_name + "</font>");
                if (attackMod >= 0)
                {
                    if (isMainHand)
                    {
                        gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " < " + defense + ", miss (Main Hand)</font><BR>");
                    }
                    else
                    {
                        gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " < " + defense + ", miss (Off Hand)</font><BR>");
                    }
                }
                else
                {
                    if (isMainHand)
                    {
                        gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " < " + defense + ", miss (Main Hand)</font><BR>");
                    }
                    else
                    {
                        gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " < " + defense + ", miss (Off Hand)</font><BR>");
                    }                    
                }
                return 0; //missed
            }
        }
        public void doItemOnHitCastSpell(string tag, Item it, object trg, Player pc)
        {
            gv.cc.currentSelectedSpell = gv.mod.getSpellByTag(tag);
            if (gv.cc.currentSelectedSpell == null) { return; }
            gv.screenCombat.TargetCastPressed(pc, it);
            //gv.cc.doSpellBasedOnScriptOrEffectTag(sp, it, trg, false, false);
        }

        public void endPcTurn(bool endStealthMode)
        {
            /*
            if (currentPlayerIndex <= gv.mod.playerList.Count - 1)
            {
                for (int i = gv.mod.playerList[currentPlayerIndex].effectsList.Count - 1; i >= 0; i--)
                {
                    //pc.effectsList[i].durationOnSquareInUnits
                    if (gv.mod.playerList[currentPlayerIndex].effectsList[i].durationInUnits <= 0)
                    {
                        if (!gv.mod.playerList[currentPlayerIndex].effectsList[i].isPermanent)
                        {
                            gv.cc.addLogText("<font color='yellow'>" + "The " + gv.mod.playerList[currentPlayerIndex].effectsList[i].name + " effect on " + gv.mod.playerList[currentPlayerIndex].name + " has just ended." + " </font><BR>");
                            gv.mod.playerList[currentPlayerIndex].effectsList.RemoveAt(i);
                        }
                    }
                }
            }
            */

            updateStatsAllCreatures();
            currentMoves = 0;
            creatureMoves = 0;
            //if (currentCombatMode != "cast")
            if ((!gv.cc.currentSelectedSpell.usesTurnToActivate && currentCombatMode == "cast") || currentCombatMode != "cast")
            {

                /*
                while (animationSeqStack.Count > 0)
                {
                    int c = 0;
                    while (c < 500000000)
                    {
                        c++;
                    }
                    animationSeqStack.RemoveAt(animationSeqStack.Count -1);
                }
                */
                //animationSeqStack.Clear();
                //remove stealth if endStealthMode = true
                if (currentPlayerIndex <= gv.mod.playerList.Count - 1)
                {
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    /*
                    if (pc.charStatus == "Held" && pc.hp > 0)
                    {
                        pc.charStatus = "Alive";
                    }
                    */
                    if (pc.hp >= 0)
                    {
                        pc.hpLastTurn = pc.hp;
                    }
                    if (endStealthMode)
                    {
                        pc.steathModeOn = false;
                    }
                    else //else test to see if enter/stay in stealth gv.mode if has trait
                    {
                        if (roundCounter <= 2 && creaturesHaveUpperHand)
                        {
                            //no stealthing during surprise round of creatures
                        }
                        else
                        {
                            doStealthModeCheck(pc);
                        }
                    }
                    canMove = true;
                }
                //if (!continueTurn)
                //{
                deathAnimationLocations.Clear();
                gv.cc.addLogText("<font color='blue'> </font><BR>");
                turnController();
                //}
                //else
                //{
                //continueTurn = false;
                //}
            }
        }
        public void doStealthModeCheck(Player pc)
        {
            int skillMod = 0;
            if (pc.knownTraitsTags.Contains(gv.mod.tagOfStealthCombatTrait + "6"))
            {
                Trait tr = gv.mod.getTraitByTag(gv.mod.tagOfStealthCombatTrait + "6");
                skillMod = tr.skillModifier;
            }
            else if (pc.knownTraitsTags.Contains(gv.mod.tagOfStealthCombatTrait + "5"))
            {
                Trait tr = gv.mod.getTraitByTag(gv.mod.tagOfStealthCombatTrait + "5");
                skillMod = tr.skillModifier;
            }
            else if (pc.knownTraitsTags.Contains(gv.mod.tagOfStealthCombatTrait + "4"))
            {
                Trait tr = gv.mod.getTraitByTag(gv.mod.tagOfStealthCombatTrait + "4");
                skillMod = tr.skillModifier;
            }
            else if (pc.knownTraitsTags.Contains(gv.mod.tagOfStealthCombatTrait + "3"))
            {
                Trait tr = gv.mod.getTraitByTag(gv.mod.tagOfStealthCombatTrait + "3");
                skillMod = tr.skillModifier;
            }
            else if (pc.knownTraitsTags.Contains(gv.mod.tagOfStealthCombatTrait + "2"))
            {
                Trait tr = gv.mod.getTraitByTag(gv.mod.tagOfStealthCombatTrait + "2");
                skillMod = tr.skillModifier;
            }
            else if (pc.knownTraitsTags.Contains(gv.mod.tagOfStealthCombatTrait))
            {
                Trait tr = gv.mod.getTraitByTag(gv.mod.tagOfStealthCombatTrait);
                skillMod = tr.skillModifier;
            }
            else
            {
                //PC doesn't have stealth trait
                pc.steathModeOn = false;
                return;
            }
            int attMod = (pc.dexterity - 10) / 2;
            int roll = gv.sf.RandInt(20);
            int DC = 18; //eventually change to include area modifiers, proximity to enemies, etc.
            if (pc.hp <= 0 || pc.isHeld())
            {
                pc.steathModeOn = false;
            }
            else if (roll + attMod + skillMod >= DC)
            {
                pc.steathModeOn = true;
                gv.cc.addLogText("Stealthed: " + roll + "+" + attMod + "+" + skillMod + ">=" + DC + "<BR>");
            }
            else
            {
                pc.steathModeOn = false;
                gv.cc.addLogText("<Unstealthed: " + roll + "+" + attMod + "+" + skillMod + " < " + DC + "<BR>");
            }
        }
        public void doPlayerCombatFacing(Player pc, int tarX, int tarY)
        {
            if ((tarX == pc.combatLocX) && (tarY > pc.combatLocY)) { pc.combatFacing = 2; }
            if ((tarX > pc.combatLocX) && (tarY > pc.combatLocY)) { pc.combatFacing = 3; }
            if ((tarX < pc.combatLocX) && (tarY > pc.combatLocY)) { pc.combatFacing = 1; }
            if ((tarX == pc.combatLocX) && (tarY < pc.combatLocY)) { pc.combatFacing = 8; }
            if ((tarX > pc.combatLocX) && (tarY < pc.combatLocY)) { pc.combatFacing = 9; }
            if ((tarX < pc.combatLocX) && (tarY < pc.combatLocY)) { pc.combatFacing = 7; }
            if ((tarX > pc.combatLocX) && (tarY == pc.combatLocY)) { pc.combatFacing = 6; }
            if ((tarX < pc.combatLocX) && (tarY == pc.combatLocY)) { pc.combatFacing = 4; }
        }
        #endregion

        #region Creature Combat Stuff
        public void doCreatureTurn()
        {
            canMove = true;
            Creature crt = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        crt = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        crt = c;
                        break;
                    }
                }
            }
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
            crt.targetPcTag = "none";

            //do onStartTurn IBScript
            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnStartCombatTurnIBScript, gv.mod.currentEncounter.OnStartCombatTurnIBScriptParms);

            creatureMoves = 0;
            if (crt.creatureSize == 3)
            {
                int g = 0;
            }
            doCreatureNextAction();
        }
        public void doCreatureNextAction()
        {
            Creature crt = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        crt = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        crt = c;
                        break;
                    }
                }
            }
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
            CalculateUpperLeftCreature(crt);
            if ((crt.hp > 0) && (!crt.isHeld()))
            {
                creatureToAnimate.Clear();
                playerToAnimate = null;
                //Karl
                //gv.Render();
                animationState = AnimationState.CreatureThink;
                if (!gv.mod.useManualCombatCam)
                {
                    gv.postDelayed("doAnimation", (int)(2.5f * gv.mod.combatAnimationSpeed));
                }
                else
                {
                    if (((crt.combatLocX + 1) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 1) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 1) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 1) >= (UpperLeftSquare.Y)))
                    {
                        //gv.animationTimer.Enabled = true;
                        gv.postDelayed("doAnimation", (int)(2.5f * gv.mod.combatAnimationSpeed));
                        ///while (gv.animationTimer.Enabled)
                        //{
                        //gv.postDelayed("doAnimation", (int)(2.5f * gv.mod.combatAnimationSpeed));
                        //}
                        //doCreatureTurnAfterDelay();
                    }
                    else
                    {
                        //gv.postDelayed("doAnimation", 1);
                        doCreatureTurnAfterDelay();
                    }
                }

            }
            else
            {
                endCreatureTurn(crt);
            }
        }
        public void doCreatureTurnAfterDelay()
        {
            Creature crt = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        crt = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        crt = c;
                        break;
                    }
                }
            }
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];

            gv.sf.ActionToTake = null;
            gv.sf.SpellToCast = null;

            if (crt.isImmobile())
            {
                creatureMoves = 99;
            }

            //determine the action to take
            doCreatureAI(crt);

            //do the action (melee/ranged, cast spell, use trait, etc.)
            if (gv.sf.ActionToTake == null)
            {
                endCreatureTurn(crt);
            }
            else if (gv.sf.ActionToTake.Equals("Attack"))
            {
                Player pc = targetClosestPC(crt);
                if (crt.cr_ai == "bloodHunter")
                {
                    pc = targetPCWithLeastHPInAttackRange(crt);
                }
                if (crt.cr_ai == "mindHunter")
                {
                    pc = targetPCWithLeastSPInRange(crt);
                }
                if (crt.cr_ai == "softTargetHunter")
                {
                    pc = targetPCWithWorstACInRange(crt);
                }

                gv.sf.CombatTarget = pc;
                CreatureDoesAttack(crt, true);
            }
            else if (gv.sf.ActionToTake.Equals("Move"))
            {
                //if ((creatureMoves + 0.5f) < crt.getMoveDistance)
                if ((creatureMoves + 0.5f) < crt.getMoveDistance())
                {
                    CreatureMoves();
                }
                else
                {
                    endCreatureTurn(crt);
                }
            }
            else if (gv.sf.ActionToTake.Equals("Cast"))
            {
                if ((gv.sf.SpellToCast != null) && (gv.sf.CombatTarget != null))
                {
                    CreatureCastsSpell(crt);
                }
            }
        }
        public void CreatureMoves()
        {
            Creature crt = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        crt = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        crt = c;
                        break;
                    }
                }
            }

            //CalculateUpperLeftCreature(crt);
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];

            foreach (string eTag in crt.tagsOfEffectsToRemoveOnMove)
            {
                for (int i = crt.cr_effectsList.Count - 1; i >= 0; i--)
                {
                    if (crt.cr_effectsList[i].tag == eTag)
                    {
                        crt.cr_effectsList.RemoveAt(i);
                        //logmessage
                        //tatsächlichliebe
                        gv.cc.addLogText("<yl>" + crt.cr_name + " lost effect due to moving" + "</yl><BR>");
                    }
                }
            }
            //burning man
            //updateStatsAllCreatures();
            //update stats
            crt.tagsOfEffectsToRemoveOnMove.Clear();

            if (crt.creatureSize == 3)
            {
                int ghgj = 0;
            }
            if (creatureMoves + 0.5f < crt.getMoveDistance())
            {
                /*
                Player pc = targetClosestPC(crt);
                Coordinate newCoor = new Coordinate(-1, -1);
                if (pc != null)
                {
                    if ((pc.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (pc.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                    {
                        coordinatesOfPcTheCreatureMovesTowards.X = pc.combatLocX;
                        coordinatesOfPcTheCreatureMovesTowards.Y = pc.combatLocY;
                        //run pathFinder to get new location
                        pf.resetGrid(crt);
                        storedPathOfCurrentCreature.Clear();
                        storedPathOfCurrentCreature = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y));
                    }
                }
                */

                Player pc = targetClosestPC(crt);
                Coordinate newCoor = new Coordinate(-1, -1);
                float shortestPath = 999;
                List<Coordinate> InterimPath = new List<Coordinate>();
                List<Coordinate> InterimPath2 = new List<Coordinate>();

                if ((crt.cr_ai == "BasicAttacker") || (crt.cr_ai == "simpleHunter") || (crt.cr_ai == "GeneralCaster"))
                {
                    foreach (Player p in gv.mod.playerList)
                    {
                        //EXPI: add stealth to the conditions
                        if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                        {
                            //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                            //{
                            coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //run pathFinder to get new location
                            pf.resetGrid(crt);
                            InterimPath.Clear();
                            InterimPath2.Clear();
                            InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                            foreach (Coordinate cord in InterimPath2)
                            {
                                InterimPath.Add(cord);
                            }
                            if (InterimPath != null)
                            {
                                if ((InterimPath.Count < shortestPath) && (InterimPath.Count > 0))
                                {
                                    //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                    //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                    shortestPath = InterimPath.Count;
                                    pc = p;
                                    storedPathOfCurrentCreature.Clear();
                                    foreach (Coordinate c in InterimPath)
                                    {
                                        storedPathOfCurrentCreature.Add(c);
                                    }
                                }//if inner
                            }//if outer
                             //}//if
                        }//if
                    }//foreach
                }
                //new AI, start with bloodHunter
                else if ((crt.cr_ai == "bloodHunter"))
                {
                    //determine move range and add melee/ranged attack range
                    float range = crt.moveDistance + crt.cr_attRange - creatureMoves;
                    int lowestHPFound = 1000000;
                    float interimPathCountAdjustForDiagonalMoves = 999;

                    if (crt.targetPcTag == "none")
                    {
                        //check players in range (facor in attack range)
                        foreach (Player p in gv.mod.playerList)
                        {
                            //only still conscious targets
                            if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                            {
                                //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                                //{
                                coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                //run pathFinder to get new location
                                pf.resetGrid(crt);
                                InterimPath.Clear();
                                InterimPath2.Clear();
                                InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                                foreach (Coordinate cord in InterimPath2)
                                {
                                    InterimPath.Add(cord);
                                }
                                if (InterimPath != null)
                                {
                                    interimPathCountAdjustForDiagonalMoves = 0;
                                    if (InterimPath.Count > 2)
                                    {
                                        for (int i = 1; i < InterimPath.Count - 1; i++)
                                        {
                                            //it a horizontal/vertical move
                                            if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                            {
                                                interimPathCountAdjustForDiagonalMoves++;
                                            }
                                            //it is a diagonal move
                                            else
                                            {
                                                interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                            }
                                        }
                                    }

                                    if ((interimPathCountAdjustForDiagonalMoves > 0) && (p.hp < lowestHPFound) && ((interimPathCountAdjustForDiagonalMoves + 1) <= range) && p.hp > 0 && !p.steathModeOn)
                                    {
                                        //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                        //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                        //shortestPath = interimPathCountAdjustForDiagonalMoves;
                                        lowestHPFound = p.hp;
                                        pc = p;
                                        crt.targetPcTag = pc.tag;
                                        storedPathOfCurrentCreature.Clear();
                                        foreach (Coordinate c in InterimPath)
                                        {
                                            storedPathOfCurrentCreature.Add(c);
                                        }
                                    }//if inner
                                }//if outer
                                 //}//if
                            }//if
                        }
                    }
                    //known target
                    else
                    {
                        //TODO: path to original target!
                        //check players in range (facor in attack range)
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.tag == crt.targetPcTag)
                            {
                                //only still conscious targets
                                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                                {
                                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                                    //{
                                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                    //run pathFinder to get new location
                                    pf.resetGrid(crt);
                                    InterimPath.Clear();
                                    InterimPath2.Clear();
                                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                                    foreach (Coordinate cord in InterimPath2)
                                    {
                                        InterimPath.Add(cord);
                                    }
                                    if (InterimPath != null)
                                    {
                                        interimPathCountAdjustForDiagonalMoves = 0;
                                        if (InterimPath.Count > 2)
                                        {
                                            for (int i = 1; i < InterimPath.Count - 1; i++)
                                            {
                                                //it a horizontal/vertical move
                                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                                {
                                                    interimPathCountAdjustForDiagonalMoves++;
                                                }
                                                //it is a diagonal move
                                                else
                                                {
                                                    interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                                }
                                            }
                                        }

                                        if ((interimPathCountAdjustForDiagonalMoves > 0) && p.hp > 0 && !p.steathModeOn)
                                        {
                                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                                            pc = p;
                                            crt.targetPcTag = pc.tag;
                                            storedPathOfCurrentCreature.Clear();
                                            foreach (Coordinate c in InterimPath)
                                            {
                                                storedPathOfCurrentCreature.Add(c);
                                            }
                                        }//if inner
                                    }//if outer
                                     //}//if
                                }//if
                            }
                        }
                    }
                    //if only one, target this pc

                    //if more than one, target the pc with lowest hp in this group

                    //if none,jump to check below

                    //check all player characters on the battlefield and target nearest (nomral routine below)
                }

                //mindHunter AI
                else if ((crt.cr_ai == "mindHunter"))
                {
                    //determine move range and add melee/ranged attack range
                    float range = crt.moveDistance + crt.cr_attRange - creatureMoves;
                    int highestSPFound = 1000000;
                    float interimPathCountAdjustForDiagonalMoves = 999;

                    if (crt.targetPcTag == "none")
                    {
                        //check players in range (facor in attack range)
                        foreach (Player p in gv.mod.playerList)
                        {
                            //only still conscious targets
                            if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                            {
                                //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                                //{
                                coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                //run pathFinder to get new location
                                pf.resetGrid(crt);
                                InterimPath.Clear();
                                InterimPath2.Clear();
                                InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                                foreach (Coordinate cord in InterimPath2)
                                {
                                    InterimPath.Add(cord);
                                }
                                if (InterimPath != null)
                                {
                                    interimPathCountAdjustForDiagonalMoves = 0;
                                    if (InterimPath.Count > 2)
                                    {
                                        for (int i = 1; i < InterimPath.Count - 1; i++)
                                        {
                                            //it a horizontal/vertical move
                                            if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                            {
                                                interimPathCountAdjustForDiagonalMoves++;
                                            }
                                            //it is a diagonal move
                                            else
                                            {
                                                interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                            }
                                        }
                                    }

                                    if ((interimPathCountAdjustForDiagonalMoves > 0) && (p.sp > highestSPFound) && ((interimPathCountAdjustForDiagonalMoves + 1) <= range) && p.hp > 0 && !p.steathModeOn)
                                    {
                                        //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                        //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                        //shortestPath = interimPathCountAdjustForDiagonalMoves;
                                        highestSPFound = p.sp;
                                        pc = p;
                                        crt.targetPcTag = pc.tag;
                                        storedPathOfCurrentCreature.Clear();
                                        foreach (Coordinate c in InterimPath)
                                        {
                                            storedPathOfCurrentCreature.Add(c);
                                        }
                                    }//if inner
                                }//if outer
                                 //}//if
                            }//if
                        }
                    }
                    //known target
                    else
                    {
                        //TODO: path to original target!
                        //check players in range (facor in attack range)
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.tag == crt.targetPcTag)
                            {
                                //only still conscious targets
                                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                                {
                                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                                    //{
                                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                    //run pathFinder to get new location
                                    pf.resetGrid(crt);
                                    InterimPath.Clear();
                                    InterimPath2.Clear();
                                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                                    foreach (Coordinate cord in InterimPath2)
                                    {
                                        InterimPath.Add(cord);
                                    }
                                    if (InterimPath != null)
                                    {
                                        interimPathCountAdjustForDiagonalMoves = 0;
                                        if (InterimPath.Count > 2)
                                        {
                                            for (int i = 1; i < InterimPath.Count - 1; i++)
                                            {
                                                //it a horizontal/vertical move
                                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                                {
                                                    interimPathCountAdjustForDiagonalMoves++;
                                                }
                                                //it is a diagonal move
                                                else
                                                {
                                                    interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                                }
                                            }
                                        }

                                        if ((interimPathCountAdjustForDiagonalMoves > 0) && p.hp > 0 && !p.steathModeOn)
                                        {
                                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                                            pc = p;
                                            crt.targetPcTag = pc.tag;
                                            storedPathOfCurrentCreature.Clear();
                                            foreach (Coordinate c in InterimPath)
                                            {
                                                storedPathOfCurrentCreature.Add(c);
                                            }
                                        }//if inner
                                    }//if outer
                                     //}//if
                                }//if
                            }
                        }
                    }
                    //if only one, target this pc

                    //if more than one, target the pc with lowest hp in this group

                    //if none,jump to check below

                    //check all player characters on the battlefield and target nearest (nomral routine below)
                }
                //softTargetHunter AI
                else if ((crt.cr_ai == "softTargetHunter"))
                {
                    //determine move range and add melee/ranged attack range
                    float range = crt.moveDistance + crt.cr_attRange - creatureMoves;
                    int worstACFound = 1000000;
                    float interimPathCountAdjustForDiagonalMoves = 999;

                    if (crt.targetPcTag == "none")
                    {
                        //check players in range (facor in attack range)
                        foreach (Player p in gv.mod.playerList)
                        {
                            //only still conscious targets
                            if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                            {
                                //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                                //{
                                coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                //run pathFinder to get new location
                                pf.resetGrid(crt);
                                InterimPath.Clear();
                                InterimPath2.Clear();
                                InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                                foreach (Coordinate cord in InterimPath2)
                                {
                                    InterimPath.Add(cord);
                                }
                                if (InterimPath != null)
                                {
                                    interimPathCountAdjustForDiagonalMoves = 0;
                                    if (InterimPath.Count > 2)
                                    {
                                        for (int i = 1; i < InterimPath.Count - 1; i++)
                                        {
                                            //it a horizontal/vertical move
                                            if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                            {
                                                interimPathCountAdjustForDiagonalMoves++;
                                            }
                                            //it is a diagonal move
                                            else
                                            {
                                                interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                            }
                                        }
                                    }

                                    if ((interimPathCountAdjustForDiagonalMoves > 0) && (p.AC < worstACFound) && ((interimPathCountAdjustForDiagonalMoves + 1) <= range) && p.hp > 0 && !p.steathModeOn)
                                    {
                                        //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                        //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                        //shortestPath = interimPathCountAdjustForDiagonalMoves;
                                        worstACFound = p.AC;
                                        pc = p;
                                        crt.targetPcTag = pc.tag;
                                        storedPathOfCurrentCreature.Clear();
                                        foreach (Coordinate c in InterimPath)
                                        {
                                            storedPathOfCurrentCreature.Add(c);
                                        }
                                    }//if inner
                                }//if outer
                                 //}//if
                            }//if
                        }
                    }
                    //known target
                    else
                    {
                        //TODO: path to original target!
                        //check players in range (facor in attack range)
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.tag == crt.targetPcTag)
                            {
                                //only still conscious targets
                                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                                {
                                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                                    //{
                                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                    //run pathFinder to get new location
                                    pf.resetGrid(crt);
                                    InterimPath.Clear();
                                    InterimPath2.Clear();
                                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                                    foreach (Coordinate cord in InterimPath2)
                                    {
                                        InterimPath.Add(cord);
                                    }
                                    if (InterimPath != null)
                                    {
                                        interimPathCountAdjustForDiagonalMoves = 0;
                                        if (InterimPath.Count > 2)
                                        {
                                            for (int i = 1; i < InterimPath.Count - 1; i++)
                                            {
                                                //it a horizontal/vertical move
                                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                                {
                                                    interimPathCountAdjustForDiagonalMoves++;
                                                }
                                                //it is a diagonal move
                                                else
                                                {
                                                    interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                                }
                                            }
                                        }

                                        if ((interimPathCountAdjustForDiagonalMoves > 0) && p.hp > 0 && !p.steathModeOn)
                                        {
                                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                                            pc = p;
                                            crt.targetPcTag = pc.tag;
                                            storedPathOfCurrentCreature.Clear();
                                            foreach (Coordinate c in InterimPath)
                                            {
                                                storedPathOfCurrentCreature.Add(c);
                                            }
                                        }//if inner
                                    }//if outer
                                     //}//if
                                }//if
                            }
                        }
                    }
                    //if only one, target this pc

                    //if more than one, target the pc with lowest hp in this group

                    //if none,jump to check below

                    //check all player characters on the battlefield and target nearest (nomral routine below)
                }


                if (storedPathOfCurrentCreature.Count > 1)
                {
                    if (!containsPCorCrt(storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2].X, storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2].Y, crt))
                    {
                        crt.newCoor = storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2];
                    }
                    else
                    {
                        blockAnimationBridge = false;
                        endCreatureTurn(crt);
                        return;
                    }
                }
                else//add pathfinding toward target while ignoring temporaryobstacles
                {
                    //***************************************************
                    pc = targetClosestPC(crt);
                    newCoor = new Coordinate(-1, -1);
                    shortestPath = 999;
                    InterimPath = new List<Coordinate>();
                    InterimPath2 = new List<Coordinate>();
                    //if ((crt.cr_ai == "BasicAttacker") || (crt.cr_ai == "simpleHunter") || (crt.cr_ai == "GeneralCaster"))
                    //{
                    foreach (Player p in gv.mod.playerList)
                    {
                        //EXPI: add stealth to the conditions
                        if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                        {
                            //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                            //{
                            coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //run pathFinder to get new location
                            pf.resetGrid(crt);
                            InterimPath.Clear();
                            InterimPath2.Clear();
                            InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), true);
                            foreach (Coordinate cord in InterimPath2)
                            {
                                InterimPath.Add(cord);
                            }

                            //InterimPath = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), true);
                            if (InterimPath != null)
                            {
                                if ((InterimPath.Count < shortestPath) && (InterimPath.Count > 0))
                                {
                                    //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                                    //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                                    shortestPath = InterimPath.Count;
                                    pc = p;
                                    crt.targetPcTag = pc.tag;

                                    //trying jers way
                                    //storedPathOfCurrentCreature.Clear();
                                    //foreach (Coordinate c in InterimPath)
                                    //{
                                    //storedPathOfCurrentCreature.Add(c);
                                    //}


                                }//if inner
                            }//if outer
                             //}//if
                        }//if
                    }//foreach


                    List<Coordinate> bestPath = new List<Coordinate>();
                    for (int i = 0; i < InterimPath.Count - 2; i++)
                    {
                        //bestPath.Clear();
                        pf.resetGrid(crt);
                        foreach (Coordinate c in pf.findNewPoint(crt, new Coordinate(InterimPath[i].X, InterimPath[i].Y), false))
                        {
                            bestPath.Add(c);
                        }
                        //pf.resetGrid(crt);
                        //bestPath = pf.findNewPoint(crt, InterimPath[i], false);
                        if (bestPath.Count > 1)
                        {
                            storedPathOfCurrentCreature.Clear();
                            foreach (Coordinate c in bestPath)
                            {
                                storedPathOfCurrentCreature.Add(c);
                            }
                            break;
                        }
                    }
                    //}

                    //*************************************************
                    if (storedPathOfCurrentCreature.Count > 1)
                    {
                        if (!containsPCorCrt(storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2].X, storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2].Y, crt))
                        {
                            crt.newCoor = storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2];
                        }
                        else
                        {
                            blockAnimationBridge = false;
                            endCreatureTurn(crt);
                            return;
                        }
                    }
                    else
                    {
                        //didn't find a path, don't move
                        //KArl
                        blockAnimationBridge = false;
                        endCreatureTurn(crt);
                        return;
                    }
                }


                if (pc != null)
                {
                    //pf.resetGrid();
                    //newCoor = pf.findNewPoint(crt, new Coordinate(pc.combatLocX, pc.combatLocY));
                    if ((crt.newCoor.X == -1) && (crt.newCoor.Y == -1))
                    {
                        //didn't find a path, don't move
                        //blockAnimationBridge = false;
                        //endCreatureTurn(crt);
                        //return;

                        //didn't find a path, try other PCs
                        //EXPI: set this to true (below=  
                        bool foundOne = true;

                        //EXPI: disable the redundnat search
                        /*
                        //try each PC  
                        for (int d = 0; d < gv.mod.playerList.Count; d++)
                        {
                            if ((gv.mod.playerList[d].isAlive()) && (!gv.mod.playerList[d].steathModeOn) && (!gv.mod.playerList[d].isInvisible()))
                            {
                                pf.resetGrid(crt);
                                storedPathOfCurrentCreature.Clear();

                                storedPathOfCurrentCreature = pf.findNewPoint(crt, new Coordinate(gv.mod.playerList[d].combatLocX, gv.mod.playerList[d].combatLocY));

                                if (storedPathOfCurrentCreature.Count > 1)
                                {
                                    crt.newCoor = storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2];
                                }

                                //newCoor = pf.findNewPoint(crt, new Coordinate(gv.mod.playerList[d].combatLocX, gv.mod.playerList[d].combatLocY));
                                if ((crt.newCoor.X == -1) && (crt.newCoor.Y == -1))
                                {
                                    //didn't find a path so keep searching  
                                }
                                else
                                {
                                    //found a path so break 
                                    if (gv.mod.debugMode)
                                    {
                                        gv.cc.addLogText("<yl>player " + d + ":" + crt.newCoor.X + "," + crt.newCoor.Y + "</yl><BR>");
                                    }

                                    foundOne = true;
                                    break;
                                }
                            }
                        }
                        */

                        //EXPI note: this branch si nver called
                        if (!foundOne)
                        {
                            //try around the nearest PC  
                            int closestDist = 999;
                            for (int j = 1; j < 5; j++) //used for radius around PC  
                            {
                                for (int x = -j; x <= j; x++)
                                {
                                    for (int y = -j; y <= j; y++)
                                    {
                                        if (isSquareOnCombatMap(pc.combatLocX + x, pc.combatLocY + y))
                                        {
                                            pf.resetGrid(crt);
                                            storedPathOfCurrentCreature.Clear();
                                            //Coordinate testCoor = pf.findNewPoint(crt, new Coordinate(pc.combatLocX + x, pc.combatLocY + y));
                                            storedPathOfCurrentCreature = pf.findNewPoint(crt, new Coordinate(pc.combatLocX, pc.combatLocY), false);

                                            Coordinate testCoor = new Coordinate();
                                            testCoor.X = -1;
                                            testCoor.Y = -1;

                                            if (storedPathOfCurrentCreature.Count > 1)
                                            {
                                                testCoor = storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2];
                                            }

                                            if ((testCoor.X == -1) && (testCoor.Y == -1))
                                            {
                                                //didn't find a path so keep searching  
                                            }
                                            else
                                            {
                                                //found a path so check if closer distance  
                                                int dist = getDistance(new Coordinate(pc.combatLocX + x, pc.combatLocY + y), new Coordinate(crt.combatLocX, crt.combatLocY));
                                                if (dist < closestDist)
                                                {
                                                    closestDist = dist;
                                                    crt.newCoor.X = testCoor.X;
                                                    crt.newCoor.Y = testCoor.Y;
                                                    foundOne = true;
                                                    if (gv.mod.debugMode)
                                                    {
                                                        gv.cc.addLogText("<yl>dist: " + dist + " coor:" + crt.newCoor.X + "," + crt.newCoor.Y + "</yl><BR>");
                                                    }

                                                }
                                            }
                                        }
                                    }
                                }//for2
                            }//for1
                        }//found check

                        if (!foundOne)
                        {
                            //give up and end  
                            blockAnimationBridge = false;
                            endCreatureTurn(crt);
                            return;
                        }
                    }
                    if (gv.mod.debugMode)
                    {
                        gv.cc.addLogText("<yl>newCoor:" + crt.newCoor.X + "," + crt.newCoor.Y + "</yl><BR>");
                    }

                    //it's a diagonal move
                    if ((crt.combatLocX != crt.newCoor.X) && (crt.combatLocY != crt.newCoor.Y))
                    {
                        //enough  move points availbale to do the diagonal move
                        if ((crt.getMoveDistance() - creatureMoves) >= gv.mod.diagonalMoveCost)
                        {
                            if ((crt.newCoor.X < crt.combatLocX) && (!crt.combatFacingLeft)) //move left
                            {
                                crt.combatFacingLeft = true;
                            }
                            else if ((crt.newCoor.X > crt.combatLocX) && (crt.combatFacingLeft)) //move right
                            {
                                crt.combatFacingLeft = false;
                            }
                            //CHANGE FACING BASED ON MOVE
                            doCreatureCombatFacing(crt, crt.newCoor.X, crt.newCoor.Y);
                            moveCost = gv.mod.diagonalMoveCost;

                            /*
                            //set the currentPixel position of the props
                            int xOffSetInSquares = gv.mod.currentArea.Props[i].LocationX - gv.mod.PlayerLocationX;
                            int yOffSetInSquares = gv.mod.currentArea.Props[i].LocationY - gv.mod.PlayerLocationY;
                            int playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                            int playerPositionYInPix = gv.playerOffsetY * gv.squareSize;

                            gv.mod.currentArea.Props[i].currentPixelPositionX = playerPositionXInPix + (xOffSetInSquares * gv.squareSize);
                            gv.mod.currentArea.Props[i].currentPixelPositionY = playerPositionYInPix + (yOffSetInSquares * gv.squareSize);
                            */

                            //hurgh7777
                            /*
                            if (((crt.newCoor.X + 1) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 1) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 1) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 1) >= (UpperLeftSquare.Y)))
                            {
                                destinationPixelLocX = crt.newCoor.X * gv.squareSize;
                                destinationPixelLocY = crt.newCoor.Y * gv.squareSize;
                            }
                             * */
                            //if ((IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) && (crt == gv.mod.currentEncounter.encounterCreatureList[creatureIndex]) && (gv.mod.useCombatSmoothMovement))
                            if ((IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) && (gv.mod.useCombatSmoothMovement))

                            {
                                blockAnimationBridge = true;
                            }
                            else
                            {
                                blockAnimationBridge = false;
                                crt.combatLocX = crt.newCoor.X;
                                crt.combatLocY = crt.newCoor.Y;
                            }

                            if (storedPathOfCurrentCreature.Count > 1)
                            {
                                storedPathOfCurrentCreature.RemoveAt(storedPathOfCurrentCreature.Count - 2);
                            }
                            canMove = false;
                            animationState = AnimationState.CreatureMove;
                            //hurgh20!
                            if (gv.mod.useManualCombatCam)
                            {
                                if (((crt.combatLocX + 1) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 1) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 1) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 1) >= (UpperLeftSquare.Y)))
                                {
                                    gv.postDelayed("doAnimation", (int)(0.025f * gv.mod.combatAnimationSpeed));
                                }
                                else
                                {
                                    gv.postDelayed("doAnimation", 1);
                                }

                            }
                            else
                            {
                                gv.postDelayed("doAnimation", (int)(1f * gv.mod.combatAnimationSpeed));
                            }

                        }

                        //try to move horizontally or vertically instead if most points are not enough for diagonal move
                        //EXPI: best use the same pathfinding concpt as for diagonal above
                        else if ((crt.getMoveDistance() - creatureMoves) >= 1)
                        {

                            pf.resetGrid(crt);
                            //block the originial diagonal target square and calculate again
                            gv.mod.nonAllowedDiagonalSquareX = crt.newCoor.X;
                            gv.mod.nonAllowedDiagonalSquareY = crt.newCoor.Y;
                            //EXPI:line below
                            storedPathOfCurrentCreature.Clear();
                            storedPathOfCurrentCreature = pf.findNewPoint(crt, new Coordinate(pc.combatLocX, pc.combatLocY), false);

                            if (storedPathOfCurrentCreature.Count > 1)
                            {
                                crt.newCoor = storedPathOfCurrentCreature[storedPathOfCurrentCreature.Count - 2];
                            }
                            else
                            {
                                //didn't find a path, don't move
                                //KArl
                                //gv.Render();
                                blockAnimationBridge = false;
                                endCreatureTurn(crt);
                                return;
                            }

                            if ((crt.newCoor.X == -1) && (crt.newCoor.Y == -1))
                            {
                                //didn't find a path, don't move
                                //KARL
                                //gv.Render();
                                blockAnimationBridge = false;
                                endCreatureTurn(crt);
                                return;
                            }
                            if ((crt.newCoor.X < crt.combatLocX) && (!crt.combatFacingLeft)) //move left
                            {
                                crt.combatFacingLeft = true;
                            }
                            else if ((crt.newCoor.X > crt.combatLocX) && (crt.combatFacingLeft)) //move right
                            {
                                crt.combatFacingLeft = false;
                            }
                            //CHANGE FACING BASED ON MOVE
                            doCreatureCombatFacing(crt, crt.newCoor.X, crt.newCoor.Y);
                            moveCost = 1;
                            //if ((IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) && (crt == gv.mod.currentEncounter.encounterCreatureList[creatureIndex]) && (gv.mod.useCombatSmoothMovement))
                            if ((IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) && (gv.mod.useCombatSmoothMovement))
                            {
                                blockAnimationBridge = true;
                            }
                            else
                            {
                                blockAnimationBridge = false;
                                crt.combatLocX = crt.newCoor.X;
                                crt.combatLocY = crt.newCoor.Y;
                            }

                            if (storedPathOfCurrentCreature.Count > 1)
                            {
                                storedPathOfCurrentCreature.RemoveAt(storedPathOfCurrentCreature.Count - 2);
                            }
                            canMove = false;
                            animationState = AnimationState.CreatureMove;

                            if (gv.mod.useManualCombatCam)
                            {
                                if (((crt.combatLocX + 1) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 1) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 1) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 1) >= (UpperLeftSquare.Y)))
                                {
                                    gv.postDelayed("doAnimation", (int)(0.025f * gv.mod.combatAnimationSpeed));
                                }
                                else
                                {
                                    gv.postDelayed("doAnimation", 1);
                                }
                            }
                            else
                            {
                                gv.postDelayed("doAnimation", (int)(1f * gv.mod.combatAnimationSpeed));
                            }

                        }
                        //less than one move point, no move
                        else
                        {
                            canMove = false;
                            animationState = AnimationState.CreatureMove;
                            if (gv.mod.useManualCombatCam)
                            {
                                if (((crt.combatLocX + 1) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 1) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 1) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 1) >= (UpperLeftSquare.Y)))
                                {
                                    gv.postDelayed("doAnimation", (int)(0.025f * gv.mod.combatAnimationSpeed));
                                }
                                else
                                {
                                    gv.postDelayed("doAnimation", 1);
                                }
                            }
                            else
                            {
                                gv.postDelayed("doAnimation", (int)(1f * gv.mod.combatAnimationSpeed));
                            }

                        }
                    }
                    //it's a horizontal or vertical move
                    else
                    {
                        if ((crt.newCoor.X < crt.combatLocX) && (!crt.combatFacingLeft)) //move left
                        {
                            crt.combatFacingLeft = true;
                        }
                        else if ((crt.newCoor.X > crt.combatLocX) && (crt.combatFacingLeft)) //move right
                        {
                            crt.combatFacingLeft = false;
                        }
                        //CHANGE FACING BASED ON MOVE
                        doCreatureCombatFacing(crt, crt.newCoor.X, crt.newCoor.Y);

                        //if ((IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) && (crt == gv.mod.currentEncounter.encounterCreatureList[creatureIndex]) && (gv.mod.useCombatSmoothMovement))
                        if ((IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) && (gv.mod.useCombatSmoothMovement))
                        {
                            blockAnimationBridge = true;
                        }
                        else
                        {
                            blockAnimationBridge = false;
                            crt.combatLocX = crt.newCoor.X;
                            crt.combatLocY = crt.newCoor.Y;
                        }

                        if (storedPathOfCurrentCreature.Count > 1)
                        {
                            storedPathOfCurrentCreature.RemoveAt(storedPathOfCurrentCreature.Count - 2);
                        }
                        canMove = false;
                        animationState = AnimationState.CreatureMove;
                        if (gv.mod.useManualCombatCam)
                        {
                            if (((crt.combatLocX + 1) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 1) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 1) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 1) >= (UpperLeftSquare.Y)))
                            {
                                gv.postDelayed("doAnimation", (int)(0.025f * gv.mod.combatAnimationSpeed));
                            }
                            else
                            {
                                gv.postDelayed("doAnimation", 1);
                            }

                        }
                        else
                        {
                            gv.postDelayed("doAnimation", (int)(1f * gv.mod.combatAnimationSpeed));
                        }

                    }
                }
                else //no target found
                {
                    //KArl
                    //gv.Render();
                    blockAnimationBridge = false;
                    endCreatureTurn(crt);
                    return;
                }
            }
            //less than a move point left, no move
            else
            {
                //gv.Render();
                blockAnimationBridge = false;
                endCreatureTurn(crt);
                return;
            }
        }

        public bool isSquareOnCombatMap(int x, int y)
        {
            if (x >= gv.mod.currentEncounter.MapSizeX)
            {
                return false;
            }
            if (x < 0)
            {
                return false;
            }
            if (y >= gv.mod.currentEncounter.MapSizeY)
            {
                return false;
            }
            if (y < 0)
            {
                return false;
            }
            return true;
        }

        public void CreatureDoesAttack(Creature crt, bool allowAnimationActivation)
        {
            if (gv.sf.CombatTarget != null)
            {
                Player pc = (Player)gv.sf.CombatTarget;
                //Uses Map Pixel Locations
                int startX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int startY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                int endX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int endY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                // determine if ranged or melee
                if ((crt.cr_category.Equals("Ranged"))
                        && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) <= crt.cr_attRange)
                        && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                {
                    //play attack sound for ranged
                    gv.PlaySound(crt.cr_attackSound);
                    if ((pc.combatLocX < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                    {
                        crt.combatFacingLeft = true;
                    }
                    else if ((pc.combatLocX > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                    {
                        crt.combatFacingLeft = false;
                    }
                    //CHANGE FACING BASED ON ATTACK
                    doCreatureCombatFacing(crt, pc.combatLocX, pc.combatLocY);

                    if (crt.hp > 0)
                    {

                        //bali1
                        if (gv.mod.useManualCombatCam)
                        {
                            adjustCamToRangedCreature = true;
                            CalculateUpperLeftCreature(crt);
                            adjustCamToRangedCreature = false;

                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                //ATTAKCKI
                                gv.touchEnabled = false;
                            }
                        }

                        creatureToAnimate.Add(crt);
                        playerToAnimate = null;
                        creatureTargetLocation = new Coordinate(pc.combatLocX, pc.combatLocY);
                        //set attack animation and do a delay
                        attackAnimationTimeElapsed = 0;
                        //attackAnimationLengthInMilliseconds = (int) ( (5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f) );
                        attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);

                        //add projectile animation
                        startX = getPixelLocX(crt.combatLocX);
                        startY = getPixelLocY(crt.combatLocY);
                        endX = getPixelLocX(pc.combatLocX);
                        endY = getPixelLocY(pc.combatLocY);
                        string filename = crt.cr_projSpriteFilename;
                        //php
                        //animationSeqStack.Clear();
                        AnimationSequence newSeq = new AnimationSequence();
                        animationSeqStack.Add(newSeq);
                        AnimationStackGroup newGroup = new AnimationStackGroup();
                        newSeq.AnimationSeq.Add(newGroup);
                        launchProjectile(filename, startX, startY, endX, endY, newGroup);
                        //add ending projectile animation  
                        doStandardCreatureAttack(crt, pc);
                        //add hit or miss animation
                        //add floaty text
                        //add death animations
                        newGroup = new AnimationStackGroup();
                        animationSeqStack[0].AnimationSeq.Add(newGroup);
                        foreach (Coordinate coor in deathAnimationLocations)
                        {
                            if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                            {
                                continue;
                            }
                            addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                        }
                        if (!allowAnimationActivation)
                        {
                            //AoO situation
                            isPlayerTurn = true;
                        }
                        animationsOn = true;
                    }
                    else
                    {
                        //skip this guys turn
                    }
                }
                else if ((crt.cr_category.Equals("Melee"))
                        && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) <= crt.cr_attRange))
                {
                    if ((pc.combatLocX < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                    {
                        crt.combatFacingLeft = true;
                    }
                    else if ((pc.combatLocX > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                    {
                        crt.combatFacingLeft = false;
                    }
                    //CHANGE FACING BASED ON ATTACK
                    doCreatureCombatFacing(crt, pc.combatLocX, pc.combatLocY);
                    if (crt.hp > 0)
                    {

                        if (gv.mod.useManualCombatCam)
                        {
                            //adjustCamToRangedCreature = true;
                            //michael
                            //beckhelling
                            //CenterScreenOnPC(pc);
                            //CalculateUpperLeftCreature(crt);
                            //adjustCamToRangedCreature = false;

                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                //ATTACKI
                                gv.touchEnabled = false;
                            }
                        }

                        creatureToAnimate.Add(crt);
                        playerToAnimate = null;

                        attackAnimationTimeElapsed = 0;
                        attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f));
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);

                        //do melee attack stuff and animations
                        //php
                        //animationSeqStack.Clear();
                        AnimationSequence newSeq = new AnimationSequence();
                        animationSeqStack.Add(newSeq);
                        doStandardCreatureAttack(crt, pc);
                        //add hit or miss animation
                        //add floaty text
                        //add death animations
                        AnimationStackGroup newGroup = new AnimationStackGroup();
                        animationSeqStack[0].AnimationSeq.Add(newGroup);
                        foreach (Coordinate coor in deathAnimationLocations)
                        {
                            if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                            {
                                continue;
                            }
                            addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                        }

                        if (!allowAnimationActivation)
                        {
                            //AoO situation
                            isPlayerTurn = true;
                        }
                        animationsOn = true;
                    }
                    else
                    {
                        //skip this guys turn
                    }
                }
                else //not in range for attack so MOVE
                {
                    CreatureMoves();
                }
            }
            else //no target so move instead
            {
                CreatureMoves();
            }
        }


        //leavethretaned overload
        public void CreatureDoesAttack(Creature crt, bool allowAnimationActivation, Player pc, int futurePosX, int futurePosY)
        {
            if (pc != null)
            {
                //Player pc = (Player)gv.sf.CombatTarget;
                //Uses Map Pixel Locations
                int startX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int startY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                int endX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int endY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                // determine if ranged or melee
                if ((crt.cr_category.Equals("Ranged"))
                        && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) <= crt.cr_attRange)
                        && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                {
                    //play attack sound for ranged
                    gv.PlaySound(crt.cr_attackSound);
                    if ((pc.combatLocX < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                    {
                        crt.combatFacingLeft = true;
                    }
                    else if ((pc.combatLocX > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                    {
                        crt.combatFacingLeft = false;
                    }
                    //CHANGE FACING BASED ON ATTACK
                    doCreatureCombatFacing(crt, pc.combatLocX, pc.combatLocY);

                    if (crt.hp > 0)
                    {

                        //bali1
                        if (gv.mod.useManualCombatCam)
                        {
                            adjustCamToRangedCreature = true;
                            //CenterScreenOnPC();
                            //CalculateUpperLeftCreature(crt);
                            adjustCamToRangedCreature = false;

                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                //ATTACKI
                                gv.touchEnabled = false;
                            }
                        }

                        creatureToAnimate.Add(crt);
                        playerToAnimate = null;
                        creatureTargetLocation = new Coordinate(pc.combatLocX, pc.combatLocY);
                        //set attack animation and do a delay
                        attackAnimationTimeElapsed = 0;
                        //attackAnimationLengthInMilliseconds = (int) ( (5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f) );
                        attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);

                        //add projectile animation
                        startX = getPixelLocX(crt.combatLocX);
                        startY = getPixelLocY(crt.combatLocY);
                        endX = getPixelLocX(pc.combatLocX);
                        endY = getPixelLocY(pc.combatLocY);
                        string filename = crt.cr_projSpriteFilename;
                        //php
                        //animationSeqStack.Clear();
                        AnimationSequence newSeq = new AnimationSequence();
                        animationSeqStack.Add(newSeq);
                        AnimationStackGroup newGroup = new AnimationStackGroup();
                        newSeq.AnimationSeq.Add(newGroup);
                        launchProjectile(filename, startX, startY, endX, endY, newGroup);
                        //add ending projectile animation  
                        //onthewater
                        doStandardCreatureAttack(crt, pc, futurePosX, futurePosY);
                        //add hit or miss animation
                        //add floaty text
                        //add death animations
                        newGroup = new AnimationStackGroup();
                        animationSeqStack[0].AnimationSeq.Add(newGroup);
                        foreach (Coordinate coor in deathAnimationLocations)
                        {
                            if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                            {
                                continue;
                            }
                            addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                        }
                        if (!allowAnimationActivation)
                        {
                            //AoO situation
                            isPlayerTurn = true;
                        }
                        animationsOn = true;
                    }
                    else
                    {
                        //skip this guys turn
                    }
                }
                else if ((crt.cr_category.Equals("Melee"))
                        && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) <= crt.cr_attRange))
                {
                    if ((pc.combatLocX < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                    {
                        crt.combatFacingLeft = true;
                    }
                    else if ((pc.combatLocX > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                    {
                        crt.combatFacingLeft = false;
                    }
                    //CHANGE FACING BASED ON ATTACK
                    doCreatureCombatFacing(crt, pc.combatLocX, pc.combatLocY);
                    if (crt.hp > 0)
                    {

                        if (gv.mod.useManualCombatCam)
                        {
                            //adjustCamToRangedCreature = true;
                            //CenterScreenOnPC();
                            //CalculateUpperLeftCreature(crt);
                            //adjustCamToRangedCreature = false;

                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                //ATTACKI
                                gv.touchEnabled = false;
                            }
                        }

                        creatureToAnimate.Add(crt);
                        playerToAnimate = null;

                        attackAnimationTimeElapsed = 0;
                        attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f));
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);

                        //do melee attack stuff and animations
                        //php
                        //animationSeqStack.Clear();
                        AnimationSequence newSeq = new AnimationSequence();
                        animationSeqStack.Add(newSeq);
                        doStandardCreatureAttack(crt, pc, futurePosX, futurePosY);
                        //add hit or miss animation
                        //add floaty text
                        //add death animations
                        AnimationStackGroup newGroup = new AnimationStackGroup();
                        animationSeqStack[0].AnimationSeq.Add(newGroup);
                        foreach (Coordinate coor in deathAnimationLocations)
                        {
                            if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                            {
                                continue;
                            }
                            addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                        }

                        if (!allowAnimationActivation)
                        {
                            //AoO situation
                            isPlayerTurn = true;
                        }
                        animationsOn = true;
                    }
                    else
                    {
                        //skip this guys turn
                    }
                }
                else //not in range for attack so MOVE
                {
                    CreatureMoves();
                }
            }
            else //no target so move instead
            {
                CreatureMoves();
            }
        }
        //AoO overload (for non-moving situarions, like casting)
        public void CreatureDoesAttack(Creature crt, bool allowAnimationActivation, Player pc)
        {
            if (pc != null)
            {
                //Player pc = (Player)gv.sf.CombatTarget;
                //Uses Map Pixel Locations
                int startX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int startY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                int endX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int endY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                // determine if ranged or melee
                if ((crt.cr_category.Equals("Ranged"))
                        && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) <= crt.cr_attRange)
                        && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                {
                    //play attack sound for ranged
                    gv.PlaySound(crt.cr_attackSound);
                    if ((pc.combatLocX < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                    {
                        crt.combatFacingLeft = true;
                    }
                    else if ((pc.combatLocX > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                    {
                        crt.combatFacingLeft = false;
                    }
                    //CHANGE FACING BASED ON ATTACK
                    doCreatureCombatFacing(crt, pc.combatLocX, pc.combatLocY);

                    if (crt.hp > 0)
                    {

                        //bali1
                        if (gv.mod.useManualCombatCam)
                        {
                            adjustCamToRangedCreature = true;
                            //beckhelling
                            //CenterScreenOnPC();
                            //CalculateUpperLeftCreature(crt);
                            adjustCamToRangedCreature = false;

                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                //ATTACKI
                                gv.touchEnabled = false;
                            }
                        }

                        creatureToAnimate.Add(crt);
                        playerToAnimate = null;
                        creatureTargetLocation = new Coordinate(pc.combatLocX, pc.combatLocY);
                        //set attack animation and do a delay
                        attackAnimationTimeElapsed = 0;
                        //attackAnimationLengthInMilliseconds = (int) ( (5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f) );
                        attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);

                        //add projectile animation
                        startX = getPixelLocX(crt.combatLocX);
                        startY = getPixelLocY(crt.combatLocY);
                        endX = getPixelLocX(pc.combatLocX);
                        endY = getPixelLocY(pc.combatLocY);
                        string filename = crt.cr_projSpriteFilename;
                        //php
                        //animationSeqStack.Clear();
                        AnimationSequence newSeq = new AnimationSequence();
                        animationSeqStack.Add(newSeq);
                        AnimationStackGroup newGroup = new AnimationStackGroup();
                        newSeq.AnimationSeq.Add(newGroup);
                        launchProjectile(filename, startX, startY, endX, endY, newGroup);
                        //add ending projectile animation  
                        doStandardCreatureAttack(crt, pc);
                        //add hit or miss animation
                        //add floaty text
                        //add death animations
                        newGroup = new AnimationStackGroup();
                        animationSeqStack[0].AnimationSeq.Add(newGroup);
                        foreach (Coordinate coor in deathAnimationLocations)
                        {
                            if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                            {
                                continue;
                            }
                            addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                        }
                        if (!allowAnimationActivation)
                        {
                            //AoO situation
                            isPlayerTurn = true;
                        }
                        animationsOn = true;
                    }
                    else
                    {
                        //skip this guys turn
                    }
                }
                else if ((crt.cr_category.Equals("Melee"))
                        && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) <= crt.cr_attRange))
                {
                    if ((pc.combatLocX < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                    {
                        crt.combatFacingLeft = true;
                    }
                    else if ((pc.combatLocX > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                    {
                        crt.combatFacingLeft = false;
                    }
                    //CHANGE FACING BASED ON ATTACK
                    doCreatureCombatFacing(crt, pc.combatLocX, pc.combatLocY);
                    if (crt.hp > 0)
                    {

                        if (gv.mod.useManualCombatCam)
                        {
                            //adjustCamToRangedCreature = true;
                            //beckhelling
                            //CenterScreenOnPC();
                            //CalculateUpperLeftCreature(crt);
                            //adjustCamToRangedCreature = false;

                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                //ATTACKI
                                gv.touchEnabled = false;
                            }
                        }

                        creatureToAnimate.Add(crt);
                        playerToAnimate = null;

                        attackAnimationTimeElapsed = 0;
                        attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f));
                        //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);

                        //do melee attack stuff and animations
                        //php
                        //animationSeqStack.Clear();
                        AnimationSequence newSeq = new AnimationSequence();
                        animationSeqStack.Add(newSeq);
                        doStandardCreatureAttack(crt, pc);
                        //add hit or miss animation
                        //add floaty text
                        //add death animations
                        AnimationStackGroup newGroup = new AnimationStackGroup();
                        animationSeqStack[0].AnimationSeq.Add(newGroup);
                        foreach (Coordinate coor in deathAnimationLocations)
                        {
                            if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                            {
                                continue;
                            }
                            addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                        }

                        if (!allowAnimationActivation)
                        {
                            //AoO situation
                            isPlayerTurn = true;
                        }
                        animationsOn = true;
                    }
                    else
                    {
                        //skip this guys turn
                    }
                }
                else //not in range for attack so MOVE
                {
                    CreatureMoves();
                }
            }
            else //no target so move instead
            {
                CreatureMoves();
            }
        }
        public void CreatureCastsSpell(Creature crt)
        {
            //write casting action and spell name to log
            //gv.cc.addLogText("<font color='yellow'>" + crt.cr_name +  "creates" + gv.sf.SpellToCast + "</font><BR>");

            Coordinate pnt = new Coordinate();
            if (gv.sf.CombatTarget is Player)
            {
                Player pc = (Player)gv.sf.CombatTarget;
                pnt = new Coordinate(pc.combatLocX, pc.combatLocY);
                upperLeftInFastForwardX = pc.combatLocX - gv.playerOffsetX;
                upperLeftInFastForwardY = pc.combatLocY - gv.playerOffsetY;
            }
            else if (gv.sf.CombatTarget is Creature)
            {
                Creature crtTarget = (Creature)gv.sf.CombatTarget;
                pnt = new Coordinate(crtTarget.combatLocX, crtTarget.combatLocY);
                upperLeftInFastForwardX = crtTarget.combatLocX - gv.playerOffsetX;
                upperLeftInFastForwardY = crtTarget.combatLocY - gv.playerOffsetY;
            }
            else if (gv.sf.CombatTarget is Coordinate)
            {
                pnt = (Coordinate)gv.sf.CombatTarget;
                upperLeftInFastForwardX = pnt.X - gv.playerOffsetX;
                upperLeftInFastForwardY = pnt.Y - gv.playerOffsetY;
            }
            else //do not understand, what is the target
            {
                return;
            }
            //Using Map Pixel Locations
            int endX = pnt.X * gv.squareSize + (gv.squareSize / 2);
            int endY = pnt.Y * gv.squareSize + (gv.squareSize / 2);
            int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
            int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
            if ((getDistance(pnt, new Coordinate(crt.combatLocX, crt.combatLocY)) <= gv.sf.SpellToCast.range)
                    && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
            {

                if (gv.mod.useManualCombatCam)
                {
                    adjustCamToRangedCreature = true;
                    CalculateUpperLeftCreature(crt);
                    adjustCamToRangedCreature = false;

                    if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                    {
                        //ATTACKI
                        gv.touchEnabled = false;
                    }
                }

                if ((pnt.X < crt.combatLocX) && (!crt.combatFacingLeft)) //attack left
                {
                    crt.combatFacingLeft = true;
                }
                else if ((pnt.X > crt.combatLocX) && (crt.combatFacingLeft)) //attack right
                {
                    crt.combatFacingLeft = false;
                }
                //CHANGE FACING BASED ON ATTACK
                doCreatureCombatFacing(crt, pnt.X, pnt.Y);
                creatureTargetLocation = pnt;
                creatureToAnimate.Add(crt);
                playerToAnimate = null;

                //set attack animation and do a delay
                attackAnimationTimeElapsed = 0;
                attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) * (-1 + (int)crt.token.PixelSize.Height / 100f));
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)crt.token.PixelSize.Height / 100f) * 100);
                AnimationSequence newSeq = new AnimationSequence();
                animationSeqStack.Add(newSeq);
                //add projectile animation
                gv.PlaySound(gv.sf.SpellToCast.spellStartSound);
                startX = getPixelLocX(crt.combatLocX);
                startY = getPixelLocY(crt.combatLocY);
                endX = getPixelLocX(creatureTargetLocation.X);
                endY = getPixelLocY(creatureTargetLocation.Y);
                string filename = gv.sf.SpellToCast.spriteFilename;
                AnimationStackGroup newGroup = new AnimationStackGroup();
                newSeq.AnimationSeq.Add(newGroup);
                launchProjectile(filename, startX, startY, endX, endY, newGroup);
                //gv.PlaySound(gv.sf.SpellToCast.spellEndSound);
                gv.cc.doSpellBasedOnScriptOrEffectTag(gv.sf.SpellToCast, crt, gv.sf.CombatTarget, false, false, null);
                //add ending projectile animation
                newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                filename = gv.sf.SpellToCast.spriteEndingFilename;
                foreach (Coordinate coor in gv.sf.AoeSquaresList)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    addEndingAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)), filename);
                }
                //add floaty text
                //add death animations
                newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                foreach (Coordinate coor in deathAnimationLocations)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                }
                animationsOn = true;
            }
            else
            {
                //#region Do a Melee or Ranged Attack
                Player pc = targetClosestPC(crt);
                gv.sf.CombatTarget = pc;
                CreatureDoesAttack(crt, true);
            }
        }

        public bool containsPCorCrt(int x, int y, Creature pfcrt)
        {
            foreach (Player p in gv.mod.playerList)
            {
                if (p.isAlive())
                {
                    if ((p.combatLocX == x) && (p.combatLocY == y))
                    {
                        return true;
                    }
                }
            }

            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if ((c.hp > 0) && (c.cr_tag != pfcrt.cr_tag))
                {
                    if (c.creatureSize == 1)
                    {
                        if (c.combatLocX == x && c.combatLocY == y)
                        {
                            return true;
                        }
                    }

                    if (c.creatureSize == 2)
                    {
                        if ((c.combatLocX == x && c.combatLocY == y) || (c.combatLocX + 1 == x && c.combatLocY == y))
                        {
                            return true;
                        }
                    }

                    if (c.creatureSize == 3)
                    {
                        if ((c.combatLocX == x && c.combatLocY == y) || (c.combatLocX == x && c.combatLocY + 1 == y))
                        {
                            return true;
                        }
                    }

                    if (c.creatureSize == 4)
                    {
                        if ((c.combatLocX == x && c.combatLocY == y) || (c.combatLocX == x && c.combatLocY + 1 == y) || (c.combatLocX + 1 == x && c.combatLocY == y) || (c.combatLocX + 1 == x && c.combatLocY + 1 == y))
                        {
                            return true;
                        }
                    }


                }
            }

            return false;
        }

        public void doCreatureAI(Creature crt)
        {
            //These are the current generic AI types
            //BasicAttacker:          basic attack (ranged or melee) on nearest target, otherwise approach nearest
            //bloodHunter:            basic attack (ranged or melee) on target in range with least hp, otherwise approach nearest
            //mindHunter:             basic attack (ranged or melee) on target in range with most sp, otherwise approach nearest
            //softTargetHunter:       basic attack (ranged or melee) on target in range with worst AC, otherwise approach nearest
            //GeneralCaster:          cast any of their known spells, based on chance to cast that spell; if no spell is cast (), act like BasicAttacker

            //Healer:                 heal Friend(s) until out of SP
            //BattleHealer:           heal Friend(s) and/or attack
            //DamageCaster:           cast damage spells
            //BattleDamageCaster:     cast damage spells and/or attack
            //DebuffCaster:           cast debuff spells
            //BattleDebuffCaster:     cast debuff spells and/or attack
            //GeneralCaster:          cast any of their known spells by random
            //BattleGeneralCaster:    cast any of their known spells by random and/or attack

            if ((crt.cr_ai.Equals("BasicAttacker")) || (crt.cr_ai.Equals("bloodHunter")) || (crt.cr_ai.Equals("mindHunter")) || (crt.cr_ai.Equals("softTargetHunter")))
            {
                if (gv.mod.debugMode)
                {
                    gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>is a BasicAttacker</font><BR>");
                }
                BasicAttacker(crt);
            }
            else if (crt.cr_ai.Equals("GeneralCaster"))
            {
                if (gv.mod.debugMode)
                {
                    gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>is a GeneralCaster</font><BR>");
                }
                GeneralCaster(crt);
            }
            else
            {
                if (gv.mod.debugMode)
                {
                    gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>is a BasicAttacker</font><BR>");
                }
                BasicAttacker(crt);
            }
        }

        public void BasicAttacker(Creature crt)
        {
            Player pc = targetClosestPC(crt);
            if ((crt.cr_ai.Equals("bloodHunter")))
            {
                pc = targetPCWithLeastHPInCombinedRange(crt);
                if (pc == null)
                {
                    pc = targetClosestPC(crt);
                }
            }
            if ((crt.cr_ai.Equals("mindHunter")))
            {
                pc = targetPCWithHighestSPInCombinedRange(crt);
                if (pc == null)
                {
                    pc = targetClosestPC(crt);
                }
            }
            if ((crt.cr_ai.Equals("softTargetHunter")))
            {
                pc = targetPCWithWorstACInCombinedRange(crt);
                if (pc == null)
                {
                    pc = targetClosestPC(crt);
                }
            }

            if (pc == null)
            {
                endCreatureTurn(crt);
            }
            else
            {
                gv.sf.CombatTarget = pc;
                int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY);

                if (((crt.cr_ai.Equals("bloodHunter"))) || ((crt.cr_ai.Equals("mindHunter"))) || ((crt.cr_ai.Equals("softTargetHunter"))))
                {
                    if ((pc.tag == crt.targetPcTag) || (crt.targetPcTag == "none"))
                    {

                        int endX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                        int endY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                        int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                        int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);

                        if ((dist <= crt.cr_attRange) && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                        {
                            gv.sf.ActionToTake = "Attack";
                        }
                        else
                        {
                            gv.sf.ActionToTake = "Move";
                        }
                    }
                    else
                    {
                        int gotacha = 0;
                    }
                }
                else
                {
                    if (dist <= crt.cr_attRange)
                    {
                        gv.sf.ActionToTake = "Attack";
                    }
                    else
                    {
                        gv.sf.ActionToTake = "Move";
                    }
                }
            }
        }

        public void GeneralCaster(Creature crt)
        {

            /*
            //to do:add range and vis checks already here, more casting
               int endX = pnt.X * gv.squareSize + (gv.squareSize / 2);
            int endY = pnt.Y * gv.squareSize + (gv.squareSize / 2);
            int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
            int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
            if ((getDistance(pnt, new Coordinate(crt.combatLocX, crt.combatLocY)) <= gv.sf.SpellToCast.range)
                    && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))


            */
            gv.sf.SpellToCast = null;
            //check if should cast spell or attack/move  
            int castpercent = gv.sf.RandInt(100);
            if (crt.percentChanceToCastSpell < castpercent)
            {
                //don't cast this round, instead try and attack or move  
                //Player pc = targetClosestPC(crt);
                //gv.sf.CombatTarget = pc;
                //gv.sf.ActionToTake = "Attack";
                BasicAttacker(crt);
                return;
            }

            //List<int> existingSpellNumbers = new List<int>();
            List<int> usedSpellNumbers = new List<int>();
            int remainingCastCeiling = 100;

            /*
            for (int i = 0; i < crt.knownSpellsTags.Count; i++)
            {
                existingSpellNumbers.Add(i);
            }
            */

            //just pick a random spell from KnownSpells
            //try a few times to pick a random spell that has enough SP
            for (int i = 0; i < crt.knownSpellsTags.Count; i++)
            {
                int rnd = gv.sf.RandInt(crt.knownSpellsTags.Count) - 1;
                while (usedSpellNumbers.Contains(rnd))
                {
                    rnd = gv.sf.RandInt(crt.knownSpellsTags.Count) - 1;
                }
                usedSpellNumbers.Add(rnd);

                bool isRandomCaster = false;

                //list with cats chnces is empty (old creature, never touched again)
                if (crt.castChances.Count == 0)
                {
                    isRandomCaster = true;
                }

                //all existing cast chances at 0
                if (!isRandomCaster)
                {
                    isRandomCaster = true;
                    foreach (LocalInt l in crt.castChances)
                    {
                        if (l.Value > 0)
                        {
                            isRandomCaster = false;
                            break;
                        }
                    }
                }

                Spell sp = gv.mod.getSpellByTag(crt.knownSpellsTags[rnd]);
                if (!isRandomCaster)
                {
                    int castingChance = 0;
                    foreach (LocalInt lint in crt.castChances)
                    {
                        if (lint.Key == crt.knownSpellsTags[rnd])
                        {
                            castingChance = lint.Value;
                        }
                    }

                    int rnd2 = gv.sf.RandInt(remainingCastCeiling);
                    remainingCastCeiling -= castingChance;

                    if (remainingCastCeiling < 2)
                    {
                        remainingCastCeiling = 1;
                    }

                    if (rnd2 > castingChance)
                    {
                        continue;

                    }
                }

                if (sp != null)
                {
                    if (sp.costSP <= crt.sp)
                    {
                        //gv.sf.SpellToCast = sp;

                        if (sp.spellTargetType.Equals("Enemy"))
                        {
                            Player pc = targetClosestPC(crt);

                            bool inRange = false;
                            int endX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                            int endY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                            int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                            int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                            if ((getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), new Coordinate(crt.combatLocX, crt.combatLocY)) <= sp.range)
                                    && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                            {
                                inRange = true;
                            }

                            if (!inRange)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (p.hp > 0)
                                    {
                                        endX = p.combatLocX * gv.squareSize + (gv.squareSize / 2);
                                        endY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);

                                        if ((getDistance(new Coordinate(p.combatLocX, p.combatLocY), new Coordinate(crt.combatLocX, crt.combatLocY)) <= sp.range)
                                      && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                                        {
                                            inRange = true;
                                            pc = p;
                                            break;
                                        }
                                    }
                                }
                            }


                            if ((pc != null) && inRange)
                            {
                                gv.sf.SpellToCast = sp;
                                gv.sf.CombatTarget = pc;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                            else
                            {
                                //endCreatureTurn(crt);
                                //BasicAttacker(crt);
                                continue;
                            }
                        }
                        else if (sp.spellTargetType.Equals("PointLocation"))
                        {
                            gv.sf.SpellToCast = sp;
                            Coordinate bestLoc = targetBestPointLocation(crt);
                            if (bestLoc.X == -1 && bestLoc.Y == -1)
                            {
                                //didn't find a target so use closest PC
                                Player pc = targetClosestPC(crt);

                                bool inRange = false;
                                int endX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                                int endY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                                int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                                int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                                if ((getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), new Coordinate(crt.combatLocX, crt.combatLocY)) <= sp.range)
                                        && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                                {
                                    inRange = true;
                                }

                                if ((pc != null) && inRange)
                                {
                                    gv.sf.SpellToCast = sp;
                                    gv.sf.CombatTarget = new Coordinate(pc.combatLocX, pc.combatLocY);
                                }
                                else
                                {
                                    //endCreatureTurn(crt);
                                    //BasicAttacker(crt);
                                    gv.sf.SpellToCast = null;
                                    continue;
                                }
                            }
                            else
                            {
                                gv.sf.SpellToCast = sp;
                                gv.sf.CombatTarget = targetBestPointLocation(crt);
                            }
                            gv.sf.ActionToTake = "Cast";
                            break;
                        }
                        else if (sp.spellTargetType.Equals("Friend"))
                        {
                            bool isHPHealing = false;
                            bool isSPRestoring = false;
                            Effect effectToCheck = new Effect();
                            foreach (EffectTagForDropDownList efTFDDL in sp.spellEffectTagList)
                            {
                                effectToCheck = gv.mod.getEffectByTag(efTFDDL.tag);
                                if (effectToCheck.doHeal == true && effectToCheck.healHP == true)
                                {
                                    isHPHealing = true;
                                    break;
                                }
                            }

                            if (sp.spellScript == "spHeal")
                            {
                                isHPHealing = true;
                            }

                            if (sp.spellEffectTag != "none" && sp.spellEffectTag != "None" && sp.spellEffectTag != "")
                            {
                                effectToCheck = gv.mod.getEffectByTag(sp.spellEffectTag);
                                if (effectToCheck.doHeal == true && effectToCheck.healHP == true)
                                {
                                    isHPHealing = true;
                                    // break;
                                }
                            }

                            //if not healing, let us see if sp restoring
                            if (!isHPHealing)
                            {
                                foreach (EffectTagForDropDownList efTFDDL in sp.spellEffectTagList)
                                {
                                    effectToCheck = gv.mod.getEffectByTag(efTFDDL.tag);
                                    if (effectToCheck.doHeal == true && effectToCheck.healHP == false)
                                    {
                                        isSPRestoring = true;
                                        break;
                                    }
                                }

                                if (sp.spellEffectTag != "none" && sp.spellEffectTag != "None" && sp.spellEffectTag != "")
                                {
                                    effectToCheck = gv.mod.getEffectByTag(sp.spellEffectTag);
                                    if (effectToCheck.doHeal == true && effectToCheck.healHP == false)
                                    {
                                        isSPRestoring = true;
                                        //break;
                                    }
                                }

                            }

                            Creature targetCrt = new Creature();
                            //add sp healing
                            if (isHPHealing)
                            {
                                //also only have these helper functions only return cretaure in spell range and visible
                                gv.sf.SpellToCast = sp;
                                targetCrt = GetCreatureWithMostDamaged(crt);
                            }
                            else if (isSPRestoring)
                            {
                                //also only have these helper functions only return cretaure in spell range and visible

                                gv.sf.SpellToCast = sp;
                                targetCrt = GetCreatureWithMostSPMissing(crt);
                            }
                            else
                            {
                                //is buff, no heal hp or heal sp
                                //also only have these helper functions only return cretaure in spell range and visible
                                gv.sf.SpellToCast = sp;
                                targetCrt = targetClosestCreatureInRangeAndVisible(crt);
                            }

                            /*
                            if (targetCrt == null)
                            {
                                gv.sf.SpellToCast = null;
                            }
                            */

                            if (targetCrt != null)
                            {
                                gv.sf.SpellToCast = sp;
                                gv.sf.CombatTarget = targetCrt;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                            else //didn't find a target that needs HP
                            {
                                gv.sf.SpellToCast = null;
                                continue;
                            }

                            /*
                            //target is another creature (currently assumed that spell is a heal spell)
                            Creature targetCrt = GetCreatureWithMostDamaged();
                            if (targetCrt != null)
                            {
                                gv.sf.CombatTarget = targetCrt;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                            else //didn't find a target that needs HP
                            {
                                gv.sf.SpellToCast = null;
                                continue;
                            }
                            */
                        }
                        else if (sp.spellTargetType.Equals("Self"))
                        {
                            //target is self (currently assumed that spell is a heal spell)
                            Creature targetCrt = crt;
                            if (targetCrt != null)
                            {
                                gv.sf.SpellToCast = sp;
                                gv.sf.CombatTarget = targetCrt;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                        }
                        else //didn't find a target so set to null so that will use attack instead
                        {
                            gv.sf.SpellToCast = null;
                        }
                    }
                }
            }

            if (gv.sf.SpellToCast == null) //didn't find a spell that matched the criteria so use attack instead
            {
                BasicAttacker(crt);
                /*
                Player pc = targetClosestPC(crt);
                if (pc == null)
                {
                    endCreatureTurn(crt);
                }
                else
                {
                    gv.sf.CombatTarget = pc;
                    gv.sf.ActionToTake = "Attack";
                }
                */
            }
        }

        public void ChanceBasedCaster(Creature crt)
        {
            gv.sf.SpellToCast = null;
            //check if should cast spell or attack/move  
            int castpercent = gv.sf.RandInt(100);
            if (crt.percentChanceToCastSpell < castpercent)
            {
                //don't cast this round, instead try and attack or move  
                //Player pc = targetClosestPC(crt);
                //gv.sf.CombatTarget = pc;
                //gv.sf.ActionToTake = "Attack";
                BasicAttacker(crt);
                return;
            }

            //just pick a random spell from KnownSpells
            //try a few times to pick a random spell that has enough SP
            for (int i = 0; i < 10; i++)
            {
                int rnd = gv.sf.RandInt(crt.knownSpellsTags.Count);
                Spell sp = gv.mod.getSpellByTag(crt.knownSpellsTags[rnd - 1]);
                if (sp != null)
                {
                    if (sp.costSP <= crt.sp)
                    {
                        gv.sf.SpellToCast = sp;

                        if (gv.sf.SpellToCast.spellTargetType.Equals("Enemy"))
                        {
                            Player pc = targetClosestPC(crt);
                            if (pc != null)
                            {
                                gv.sf.CombatTarget = pc;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                            else
                            {
                                //endCreatureTurn(crt);
                                BasicAttacker(crt);
                            }
                        }
                        else if (gv.sf.SpellToCast.spellTargetType.Equals("PointLocation"))
                        {
                            Coordinate bestLoc = targetBestPointLocation(crt);
                            if (bestLoc == new Coordinate(-1, -1))
                            {
                                //didn't find a target so use closest PC
                                Player pc = targetClosestPC(crt);
                                if (pc != null)
                                {
                                    gv.sf.CombatTarget = new Coordinate(pc.combatLocX, pc.combatLocY);
                                }
                                else
                                {
                                    //endCreatureTurn(crt);
                                    BasicAttacker(crt);
                                }
                            }
                            else
                            {
                                gv.sf.CombatTarget = targetBestPointLocation(crt);
                            }
                            gv.sf.ActionToTake = "Cast";
                            break;
                        }
                        else if (gv.sf.SpellToCast.spellTargetType.Equals("Friend"))
                        {
                            //Neumarkt
                            Creature targetCrt = targetClosestCreature(crt);
                            if (targetCrt != null)
                            {
                                gv.sf.CombatTarget = targetCrt;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                            else //didn't find a target that needs HP
                            {
                                gv.sf.SpellToCast = null;
                                continue;
                            }

                            /*
                            //target is another creature (currently assumed that spell is a heal spell)
                            Creature targetCrt = GetCreatureWithMostDamaged();
                            if (targetCrt != null)
                            {
                                gv.sf.CombatTarget = targetCrt;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                            else //didn't find a target that needs HP
                            {
                                gv.sf.SpellToCast = null;
                                continue;
                            }
                            */
                        }
                        else if (gv.sf.SpellToCast.spellTargetType.Equals("Self"))
                        {
                            //target is self (currently assumed that spell is a heal spell)
                            Creature targetCrt = crt;
                            if (targetCrt != null)
                            {
                                gv.sf.CombatTarget = targetCrt;
                                gv.sf.ActionToTake = "Cast";
                                break;
                            }
                        }
                        else //didn't find a target so set to null so that will use attack instead
                        {
                            gv.sf.SpellToCast = null;
                        }
                    }
                }
            }

            if (gv.sf.SpellToCast == null) //didn't find a spell that matched the criteria so use attack instead
            {
                BasicAttacker(crt);
                /*
                Player pc = targetClosestPC(crt);
                if (pc == null)
                {
                    endCreatureTurn(crt);
                }
                else
                {
                    gv.sf.CombatTarget = pc;
                    gv.sf.ActionToTake = "Attack";
                }
                */
            }
        }


        public void updateStatsAllCreatures()
        {
            //called at end of turn of pc or cretaure
            //used for:
            //ef.modifyHpMax


            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                foreach (Creature crtOrg in gv.mod.moduleCreaturesList)
                {
                    if (crt.cr_resref == crtOrg.cr_resref)
                    {
                        crt.hpMax = crtOrg.hpMax + crt.getMaxHPModifier();

                    }
                }

            }
        }

        public void endCreatureTurn(Creature crt)
        {
            //gv.cc.addLogText("<font color='red'>" + "Reached end turn routine" + "</font><BR>");
            /*
            //if remaining duration <= 0, remove from list
            for (int i = crt.cr_effectsList.Count - 1; i >= 0; i--)
            {
                if (crt.cr_effectsList[i].durationInUnits <= 0)
                {
                    if (!crt.cr_effectsList[i].isPermanent)
                    {
                        gv.cc.addLogText("<font color='yellow'>" + "The " + crt.cr_effectsList[i].name + " effect on " + crt.cr_name + " has just ended." + " </font><BR>");
                        crt.cr_effectsList.RemoveAt(i);
                    }
                }
            }
            */
            gv.cc.addLogText("<font color='blue'> </font><BR>");
            crt.maxTurnTimeCounter = 0;
            crt.targetPcTag = "none";
            updateStatsAllCreatures();
            //gv.cc.addLogText("<font color='red'>" + "Updated stats" + "</font><BR>");
            creatureMoves = 0;
            currentMoves = 0;
            //store current hp of cretaure, use it at start of creature next turn to see whether damage occured in the meantime
            //if it ccured, effet prone too breaking on damage are removed from the creature
            /*
            if (animationSeqStack.Count > 0)
            {
                int c = 0;
                while (c < 500000)
                {
                    c++;
                }
            }
            animationSeqStack.Clear();
            */

            if (crt.hp >= 0)
            {
                crt.hpLastTurn = crt.hp;
            }
            /*
            if (crt.hp > 0)
            {
                if (crt.cr_status == "Held")
                {
                    crt.cr_status = "Alive";
                }
            }
            */
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            //remove any dead creatures
            if (!stepAnimationsOn)
            {
                for (int x = gv.mod.currentEncounter.encounterCreatureList.Count - 1; x >= 0; x--)
                {
                    if (gv.mod.currentEncounter.encounterCreatureList[x].hp <= 0)
                    {
                        try
                        {
                            //do OnDeath IBScript
                            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScript, gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScriptParms);
                            //project repeatable
                            int deadIdx = (gv.mod.currentEncounter.encounterCreatureList.Count - 1) - x;
                            if (deadIdx < idx)
                            {
                                idx--;
                                if (idx < 0)
                                {
                                    idx = 0;
                                }
                            }
                            if (gv.mod.currentEncounter.assassinationVictory && gv.mod.currentEncounter.assassinationTargetTag == gv.mod.currentEncounter.encounterCreatureList[x].cr_tag)
                            {
                                gv.mod.currentEncounter.assassinationConditionMet = true;
                            }
                            gv.mod.currentEncounter.encounterCreatureList.RemoveAt(x);
                            if (!gv.mod.currentEncounter.isRepeatable)
                            {
                                //gv.mod.currentEncounter.encounterCreatureRefsList.RemoveAt(x);
                            }
                        }
                        catch (Exception ex)
                        {
                            gv.errorLog(ex.ToString());
                        }
                    }
                }
                foreach (Player p in gv.mod.playerList)
                {
                    if (gv.mod.currentEncounter.protectionDefeat && gv.mod.currentEncounter.protectionTargetName == p.name)
                    {
                        if (p.hp <= 0)
                        {
                            gv.mod.currentEncounter.protectionConditionMet = true;
                        }
                    }
                }
            }

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            canMove = true;
            gv.sf.ActionToTake = null;
            gv.sf.SpellToCast = null;
            //coordinatesOfPcTheCreatureMovesTowards.X = -1;
            //coordinatesOfPcTheCreatureMovesTowards.Y = -1;
            if (checkEndEncounter())
            {
                return;
            }
            //animationSeqStack.Clear();
            if (animationSeqStack.Count > 0)
            {
                animationsOn = true;
            }
            //if (!gv.mod.useCombatSmoothMovement)
            ///{
            gv.screenCombat.blockAnimationBridge = false;
            //}
            crt.glideAdderX = 0;
            crt.glideAdderY = 0;
            //gv.cc.addLogText("<font color='red'>" + "Right before calling truncontroller" + "</font><BR>");
            turnController();
        }

        public void doStandardCreatureAttack(Creature crt, Player pc, int futureX, int futureY)
        {
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
            //Player pc = (Player)gv.sf.CombatTarget;

            upperLeftInFastForwardX = pc.combatLocX - gv.playerOffsetX;
            upperLeftInFastForwardY = pc.combatLocY - gv.playerOffsetY;

            bool hit = false;
            for (int i = 0; i < crt.getNumberOfAttacks(); i++)
            {
                //this reduces the to hit bonus for each further creature attack by an additional -5
                //creatureMultAttackPenalty = 5 * i;            
                bool hitreturn = doActualCreatureAttack(pc, crt, i, futureX, futureY);
                if (hitreturn) { hit = true; }
                if (pc.hp <= 0)
                {
                    break; //do not try and attack same PC that was just killed
                }
            }

            //play attack sound for melee
            if (!crt.cr_category.Equals("Ranged"))
            {
                gv.PlaySound(crt.cr_attackSound);
            }

            if (hit)
            {
                //hitAnimationLocation = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                //reversecodeneeded
                if (pc.hp > 0)
                {
                    hitAnimationLocation = new Coordinate(getPixelLocX(futureX), getPixelLocY(futureY));
                }

                else
                {
                    spriteList.Clear();
                    /*
                    int passX = pc.combatLocX;
                    int passY = pc.combatLocY;

                    if (pc.combatLocX > futureX)
                    {
                        passX = pc.combatLocX - 1;
                    }
                    else if (pc.combatLocX < futureX)
                    {
                        passX = pc.combatLocX + 1;
                    }

                    if (pc.combatLocY > futureY)
                    {
                        passY = pc.combatLocY - 1;
                    }
                    else if (pc.combatLocY < futureY)
                    {
                        passY = pc.combatLocY + 1;
                    }
                    hitAnimationLocation = new Coordinate(getPixelLocX(passX), getPixelLocY(passY));
                    */
                }

                //new system
                //AnimationStackGroup newGroup = new AnimationStackGroup();
                //animationSeqStack[0].AnimationSeq.Add(newGroup);
                //addHitAnimation(newGroup);
                //attackAnimationTimeElapsed = 100000;
                //if (gv.mod.AoOHitSymbolHasBeenDrawn == false)
                //{

                if (pc.hp > 0)
                {
                    int ttl = 8 * gv.mod.attackAnimationSpeed;
                    Sprite spr = new Sprite(gv, "hit_symbol", hitAnimationLocation.X, hitAnimationLocation.Y, 0, 0, 0, 0, 1.0f, ttl, false, ttl / 4);
                    int testX = UpperLeftSquare.X;
                    int testY = UpperLeftSquare.Y;
                    spriteList.Add(spr);
                }

                //gv.mod.AoOHitSymbolHasBeenDrawn = true;
                //}
            }
            else
            {
                //hitAnimationLocation = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                hitAnimationLocation = new Coordinate(getPixelLocX(futureX), getPixelLocY(futureY));
                //new system
                //AnimationStackGroup newGroup = new AnimationStackGroup();
                //animationSeqStack[0].AnimationSeq.Add(newGroup);
                //addMissAnimation(newGroup);
                //attackAnimationTimeElapsed = 100000;
                //if (gv.mod.numberOfAoOAttackers > 1)
                //{
                int ttl = 8 * gv.mod.attackAnimationSpeed;
                Sprite spr = new Sprite(gv, "miss_symbol", hitAnimationLocation.X, hitAnimationLocation.Y, 0, 0, 0, 0, 1.0f, ttl, false, ttl / 4);
                int testX = UpperLeftSquare.X;
                int testY = UpperLeftSquare.Y;
                spriteList.Add(spr);
                //}
            }
        }


        public void doStandardCreatureAttack(Creature crt, Player pc)
        {
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
            //Player pc = (Player)gv.sf.CombatTarget;

            upperLeftInFastForwardX = pc.combatLocX - gv.playerOffsetX;
            upperLeftInFastForwardY = pc.combatLocY - gv.playerOffsetY;

            bool hit = false;
            for (int i = 0; i < crt.getNumberOfAttacks(); i++)
            {
                //this reduces the to hit bonus for each further creature attack by an additional -5
                //creatureMultAttackPenalty = 5 * i;            
                bool hitreturn = doActualCreatureAttack(pc, crt, i);
                if (hitreturn) { hit = true; }
                if (pc.hp <= 0)
                {
                    break; //do not try and attack same PC that was just killed
                }
            }

            //play attack sound for melee
            if (!crt.cr_category.Equals("Ranged"))
            {
                gv.PlaySound(crt.cr_attackSound);
            }

            if (hit)
            {
                hitAnimationLocation = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                //new system
                AnimationStackGroup newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                addHitAnimation(newGroup);
            }
            else
            {
                hitAnimationLocation = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                //new system
                AnimationStackGroup newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                addMissAnimation(newGroup);
            }
        }

        //not used
        public void doStandardCreatureAttackAoO(Player pc, Creature crt, int attackNumber)
        {
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
            //Player pc = (Player)gv.sf.CombatTarget;

            upperLeftInFastForwardX = pc.combatLocX - gv.playerOffsetX;
            upperLeftInFastForwardY = pc.combatLocY - gv.playerOffsetY;

            bool hit = false;
            for (int i = 0; i < attackNumber; i++)
            {
                //this reduces the to hit bonus for each further creature attack by an additional -5
                //creatureMultAttackPenalty = 5 * i;            
                bool hitreturn = doActualCreatureAttack(pc, crt, i);
                if (hitreturn) { hit = true; }
                if (pc.hp <= 0)
                {
                    break; //do not try and attack same PC that was just killed
                }
            }

            //play attack sound for melee
            if (!crt.cr_category.Equals("Ranged"))
            {
                gv.PlaySound(crt.cr_attackSound);
            }

            //testing
            //animationsOn = true;

            if (hit)
            {
                hitAnimationLocation = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                //new system
                AnimationStackGroup newGroup = new AnimationStackGroup();

                //testing
                AnimationSequence newSequence = new AnimationSequence();
                animationSeqStack.Add(newSequence);

                animationSeqStack[0].AnimationSeq.Add(newGroup);
                addHitAnimation(newGroup);
            }
            else
            {
                hitAnimationLocation = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                //new system
                AnimationStackGroup newGroup = new AnimationStackGroup();

                //testing
                AnimationSequence newSequence = new AnimationSequence();
                animationSeqStack.Add(newSequence);

                animationSeqStack[0].AnimationSeq.Add(newGroup);
                addMissAnimation(newGroup);
            }
        }

        public bool doActualCreatureAttack(Player pc, Creature crt, int attackNumber)
        {
            int attackRoll = gv.sf.RandInt(20);
            int attackMod = CalcCreatureAttackModifier(crt, pc);
            int defense = CalcPcDefense(pc, crt);
            int damage = CalcCreatureDamageToPc(pc, crt);
            int attack = attackRoll + attackMod;
            bool criticalHit = false;
            int critAttackRoll = gv.sf.RandInt(20);
            if (attackRoll >= crt.threatRange)
            {
                //determine if a critical hit is applied
                if (critAttackRoll + attackMod >= defense)
                {
                    criticalHit = true;
                    damage *= crt.criticalMultiplier;
                }
            }

            if ((attack >= defense) || (attackRoll == 20))
            {
                //attackAnimationTimeElapsed = 500;
                //pc.hp = pc.hp - damage;
                gv.cc.addLogText("Attacks " + "<font color='lime'>" + pc.name + "</font><BR>");
                //check if have mirror image
                if (gv.sf.removeOneMirrorImageIfHasOne(pc, null))
                {
                    gv.cc.addLogText("<rd>" + "HITS (one mirror image removed)</rd><BR>");
                    gv.cc.addLogText("<wh>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</wh><BR>");
                    return true;
                }
                //check if has damage absorption
                int ret = gv.sf.removeHitPointDamageAbsorptionIfHasAny(pc, null, damage);
                if (ret != -1)
                {
                    int absorbed = damage - ret;
                    damage = ret;
                    gv.cc.addLogText("<gn>" + "(absorbed " + absorbed + " damage)</gn><BR>");
                }

                pc.hp = pc.hp - damage;

                if (criticalHit)
                {
                    gv.cc.addLogText("<rd>" + "CRITICAL HIT (-" + damage + "hp)</rd><BR>");
                    gv.cc.addLogText("<wh>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</wh><BR>");
                    gv.cc.addLogText("<wh>CRIT: " + critAttackRoll + "+" + attackMod + ">=" + defense + "</wh><BR>");
                }
                else
                {
                    gv.cc.addLogText("<rd>" + "HITS (-" + damage + "hp)</rd><BR>");
                    gv.cc.addLogText("<wh>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</wh><BR>");
                    if (attackRoll >= crt.threatRange)
                    {
                        gv.cc.addLogText("<wh>CRIT: " + critAttackRoll + "+" + attackMod + " < " + defense + "</wh><BR>");
                    }
                }
                
                /*if (attackMod >= 0)
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " >= " + defense + ", hit for <font color='red'>" + damage + "</font>" +
                            "<font color='white'>" + "hp" + "</font>");
                }
                else
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " >= " + defense + ", hit for <font color='red'>" + damage + "</font>" +
                            "<font color='white'>" + "hp" + "</font>");
                }*/

                doOnHitScriptBasedOnFilename(crt.onScoringHit, crt, pc);
                if (!crt.onScoringHitCastSpellTag.Equals("none"))
                {
                    doCreatureOnHitCastSpell(crt, pc);
                }

                //Draw floaty text showing damage above PC
                int txtH = (int)gv.drawFontRegHeight;
                int shiftUp = 0 - (attackNumber * txtH);
                gv.cc.addFloatyText(new Coordinate(pc.combatLocX, pc.combatLocY), damage + "", shiftUp);

                if (pc.hp <= 0)
                {
                    //gv.cc.addLogText("<font color='red'>" + pc.name + " is unconscious!" + "</font><BR>");
                    pc.charStatus = "Dead";
                }
                if (pc.hp <= -20)
                {
                    // deathAnimationLocations.Add(new Coordinate(pc.combatLocX, pc.combatLocY));
                }
                return true;
            }
            else
            {
                gv.cc.addLogText("Attacks " +
                        "<font color='lime'>" + pc.name + "</font><BR>");
                if (attackMod >= 0)
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " < " + defense + ", miss</font><BR>");
                }
                else
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " < " + defense + ", miss</font><BR>");
                }
                return false;
            }
        }

        //overload for AoO
        public bool doActualCreatureAttack(Player pc, Creature crt, int attackNumber, int futureX, int futureY)
        {
            int attackRoll = gv.sf.RandInt(20);
            int attackMod = CalcCreatureAttackModifier(crt, pc);
            int defense = CalcPcDefense(pc, crt);
            int damage = CalcCreatureDamageToPc(pc, crt);
            int attack = attackRoll + attackMod;

            if ((attack >= defense) || (attackRoll == 20))
            {
                //pc.hp = pc.hp - damage;
                gv.cc.addLogText("Attacks " + "<font color='lime'>" + pc.name + "</font><BR>");
                
                //check if have mirror image
                if (gv.sf.removeOneMirrorImageIfHasOne(pc, null))
                {
                    gv.cc.addLogText("<font color='red'>" + "HITS (one mirror image removed)</font><BR>");
                    gv.cc.addLogText("<font color='white'>ATT: " + attackRoll + "+" + attackMod + ">=" + defense + "</font><BR>");
                    return true;
                }
                //check if has damage absorption
                int ret = gv.sf.removeHitPointDamageAbsorptionIfHasAny(pc, null, damage);
                if (ret != -1)
                {
                    int absorbed = damage - ret;
                    damage = ret;
                    gv.cc.addLogText("<font color='lime'>" + "(absorbed " + absorbed + " damage)</font><BR>");
                }

                pc.hp = pc.hp - damage;
                
                if (attackMod >= 0)
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " >= " + defense + ", hit for <font color='red'>" + damage + "</font>" +
                            "<font color='white'>" + "hp</font>");
                }
                else
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " >= " + defense + ", hit for <font color='red'>" + damage + "</font>" +
                            "<font color='white'>" + "hp</font>");
                }

                doOnHitScriptBasedOnFilename(crt.onScoringHit, crt, pc);
                if (!crt.onScoringHitCastSpellTag.Equals("none"))
                {
                    doCreatureOnHitCastSpell(crt, pc);
                }

                //Draw floaty text showing damage above PC
                int txtH = (int)gv.drawFontRegHeight;
                int shiftUp = 0 - (attackNumber * txtH);


                int passX = pc.combatLocX;
                int passY = pc.combatLocY;

                if (pc.combatLocX > futureX)
                {
                    passX = pc.combatLocX + 1;
                }
                else if (pc.combatLocX < futureX)
                {
                    passX = pc.combatLocX - 1;
                }

                if (pc.combatLocY > futureY)
                {
                    passY = pc.combatLocY + 1;
                }
                else if (pc.combatLocY < futureY)
                {
                    passY = pc.combatLocY - 1;
                }
                //passX
                gv.cc.addFloatyText(new Coordinate(passX, passY), damage + "", shiftUp);
                //gv.cc.addFloatyText(new Coordinate(pc.combatLocX, pc.combatLocY), damage + "", shiftUp);

                if (pc.hp <= 0)
                {
                    //gv.cc.addLogText("<font color='red'>" + pc.name + " is unconscious!" + "</font><BR>");
                    pc.charStatus = "Dead";
                }
                if (pc.hp <= -20)
                {
                    // deathAnimationLocations.Add(new Coordinate(pc.combatLocX, pc.combatLocY));
                }
                return true;
            }
            else
            {
                gv.cc.addLogText("Attacks " +
                        "<font color='lime'>" + pc.name + "</font><BR>");
                if (attackMod >= 0)
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " + " + attackMod + " < " + defense + ", miss</font><BR>");
                }
                else
                {
                    gv.cc.addLogText("<font color='white'>" + attackRoll + " " + attackMod + " < " + defense + ", miss</font><BR>");
                }
                return false;
            }
        }

        public void doCreatureCombatFacing(Creature crt, int tarX, int tarY)
        {
            if ((tarX == crt.combatLocX) && (tarY > crt.combatLocY)) { crt.combatFacing = 2; }
            if ((tarX > crt.combatLocX) && (tarY > crt.combatLocY)) { crt.combatFacing = 3; }
            if ((tarX < crt.combatLocX) && (tarY > crt.combatLocY)) { crt.combatFacing = 1; }
            if ((tarX == crt.combatLocX) && (tarY < crt.combatLocY)) { crt.combatFacing = 8; }
            if ((tarX > crt.combatLocX) && (tarY < crt.combatLocY)) { crt.combatFacing = 9; }
            if ((tarX < crt.combatLocX) && (tarY < crt.combatLocY)) { crt.combatFacing = 7; }
            if ((tarX > crt.combatLocX) && (tarY == crt.combatLocY)) { crt.combatFacing = 6; }
            if ((tarX < crt.combatLocX) && (tarY == crt.combatLocY)) { crt.combatFacing = 4; }
        }
        #endregion

        public void doOnHitScriptBasedOnFilename(string filename, Creature crt, Player pc)
        {
            if (!filename.Equals("none"))
            {
                try
                {
                    if (filename.Equals("onHitBeetleFire.cs"))
                    {
                        float resist = (float)(1f - ((float)pc.damageTypeResistanceTotalFire / 100f));
                        float damage = (1 * gv.sf.RandInt(2)) + 0;
                        int fireDam = (int)(damage * resist);

                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='white'>" + "resist = " + resist + " damage = " + damage
                                        + " fireDam = " + fireDam + "</font>" +
                                        "<BR>");
                        }
                        gv.cc.addLogText("<font color='lime'>" + pc.name + "</font>" +
                                "<font color='white'>" + " is burned for " + "</font>" +
                                "<font color='red'>" + fireDam + "</font>" +
                                "<font color='white'>" + " hit point(s)" + "</font>" +
                                "<BR>");
                        pc.hp -= fireDam;
                    }

                    else if (filename.Equals("onHitMaceOfStunning.cs"))
                    {
                        int tryHold = gv.sf.RandInt(100);
                        if (tryHold > 50)
                        {
                            //attempt to hold PC
                            int saveChkRoll = gv.sf.RandInt(20);
                            int saveChk = saveChkRoll + crt.getFortitude();
                            int DC = 15;
                            if (saveChk >= DC) //passed save check
                            {
                                gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>avoids stun (" + saveChkRoll + " + " + crt.getFortitude() + " >= " + DC + ")</font><BR>");
                            }
                            else
                            {
                                gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>is stunned by mace (" + saveChkRoll + " + " + crt.getFortitude() + " < " + DC + ")</font><BR>");
                                crt.cr_status = "Held";
                                Effect ef = gv.mod.getEffectByTag("hold");
                                crt.AddEffectByObject(ef, 1);
                            }
                        }
                    }
                    else if (filename.Equals("onHitBeetleAcid.cs"))
                    {
                        float resist = (float)(1f - ((float)pc.damageTypeResistanceTotalAcid / 100f));
                        float damage = (1 * gv.sf.RandInt(2)) + 0;
                        int acidDam = (int)(damage * resist);

                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='white'>" + "resist = " + resist + " damage = " + damage
                                    + " acidDam = " + acidDam + "</font>" +
                                    "<BR>");
                        }
                        gv.cc.addLogText("<font color='lime'>" + pc.name + "</font>" +
                                "<font color='white'>" + " is burned for " + "</font>" +
                                "<font color='red'>" + acidDam + "</font>" +
                                "<font color='white'>" + " hit point(s)" + "</font>" +
                                "<BR>");
                        pc.hp -= acidDam;

                        //attempt to hold PC
                        int saveChkRoll = gv.sf.RandInt(20);
                        int saveChk = saveChkRoll + pc.fortitude;
                        int DC = 10;
                        if (saveChk >= DC) //passed save check
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>avoids the acid stun (" + saveChkRoll + " + " + pc.fortitude + " >= " + DC + ")</font><BR>");
                        }
                        else
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>is held by an acid stun (" + saveChkRoll + " + " + pc.fortitude + " < " + DC + ")</font><BR>");
                            pc.charStatus = "Held";
                            Effect ef = gv.mod.getEffectByTag("hold");
                            pc.AddEffectByObject(ef, 1);
                        }
                    }
                    else if (filename.Equals("onHitOneFire.cs"))
                    {
                        float resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueFire() / 100f));
                        float damage = 1.0f;
                        int fireDam = (int)(damage * resist);

                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='white'>" + "resist = " + resist + " damage = " + damage
                                        + " fireDam = " + fireDam + "</font>" +
                                        "<BR>");
                        }
                        gv.cc.addLogText("<font color='red'>" + crt.cr_name + "</font>" +
                                "<font color='white'>" + " is burned for " + "</font>" +
                                "<font color='red'>" + fireDam + "</font>" +
                                "<font color='white'>" + " hit point(s)" + "</font>" +
                                "<BR>");
                        crt.hp -= fireDam;
                    }
                    else if (filename.Equals("onHitOneTwoFire.cs"))
                    {
                        float resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueFire() / 100f));
                        float damage = (1 * gv.sf.RandInt(2)) + 0;
                        int fireDam = (int)(damage * resist);

                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='white'>" + "resist = " + resist + " damage = " + damage
                                        + " fireDam = " + fireDam + "</font>" +
                                        "<BR>");
                        }
                        gv.cc.addLogText("<font color='red'>" + crt.cr_name + "</font>" +
                                "<font color='white'>" + " is burned for " + "</font>" +
                                "<font color='red'>" + fireDam + "</font>" +
                                "<font color='white'>" + " hit point(s)" + "</font>" +
                                "<BR>");
                        crt.hp -= fireDam;
                    }
                    else if (filename.Equals("onHitTwoThreeFire.cs"))
                    {
                        float resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueFire() / 100f));
                        float damage = (1 * gv.sf.RandInt(2)) + 1;
                        int fireDam = (int)(damage * resist);

                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='white'>" + "resist = " + resist + " damage = " + damage
                                        + " fireDam = " + fireDam + "</font>" +
                                        "<BR>");
                        }
                        gv.cc.addLogText("<font color='red'>" + crt.cr_name + "</font>" +
                                "<font color='white'>" + " is burned for " + "</font>" +
                                "<font color='red'>" + fireDam + "</font>" +
                                "<font color='white'>" + " hit point(s)" + "</font>" +
                                "<BR>");
                        crt.hp -= fireDam;
                    }
                    else if (filename.Equals("onHitPcPoisonedLight.cs"))
                    {
                        int saveChkRoll = gv.sf.RandInt(20);
                        int saveChk = saveChkRoll + pc.reflex;
                        int DC = 13;
                        if (saveChk >= DC) //passed save check
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>avoids being poisoned" + "</font>" +
                                    "<BR>");
                            if (gv.mod.debugMode)
                            {
                                gv.cc.addLogText("<font color='white'>" + saveChkRoll + " + " + pc.reflex + " >= " + DC + "</font>" +
                                            "<BR>");
                            }
                        }
                        else //failed check
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>is poisoned" + "</font>" + "<BR>");
                            Effect ef = gv.mod.getEffectByTag("poisonedLight");
                            pc.AddEffectByObject(ef, 1);
                        }
                    }
                    else if (filename.Equals("onHitPcPoisonedMedium.cs"))
                    {
                        int saveChkRoll = gv.sf.RandInt(20);
                        int saveChk = saveChkRoll + pc.reflex;
                        int DC = 16;
                        if (saveChk >= DC) //passed save check
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>avoids being poisoned" + "</font>" +
                                    "<BR>");
                            if (gv.mod.debugMode)
                            {
                                gv.cc.addLogText("<font color='white'>" + saveChkRoll + " + " + pc.reflex + " >= " + DC + "</font>" +
                                            "<BR>");
                            }
                        }
                        else //failed check
                        {
                            gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>is poisoned" + "</font>" + "<BR>");
                            Effect ef = gv.mod.getEffectByTag("poisonedMedium");
                            pc.AddEffectByObject(ef, 1);
                        }
                    }
                }
                catch (Exception ex)
                {
                    gv.errorLog(ex.ToString());
                }
            }
        }
        public void doCreatureOnHitCastSpell(Creature crt, Player pc)
        {
            Spell sp = gv.mod.getSpellByTag(crt.onScoringHitCastSpellTag);
            if (sp == null) { return; }
            gv.cc.doSpellBasedOnScriptOrEffectTag(sp, crt, pc, false, false, null);
        }
        public bool checkEndEncounter()
        {
            //chaweng2
            int foundOneCrtr = 0;
            foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crtr.hp > 0)
                {
                    foundOneCrtr = 1;
                }
            }
            if (foundOneCrtr == 0)
            {
                gv.mod.currentEncounter.encounterCreatureList.Clear();
            }
            bool standGroundConditionMet = false;
            if (gv.mod.currentEncounter.standGroundVictory && gv.mod.currentEncounter.standGroundInternalTimer <= 0)
            {
                standGroundConditionMet = true;
            }

            bool timeLimitConditionMet = false;
            if (gv.mod.currentEncounter.timeLimitDefeat && gv.mod.currentEncounter.timeLimitInternalTimer <= 0)
            {
                timeLimitConditionMet = true;
                gv.mod.currentEncounter.timeLimitInternalTimer = gv.mod.currentEncounter.timeLimitTimer;
            }

            foreach (Player p in gv.mod.playerList)
            {
                if (gv.mod.currentEncounter.protectionDefeat && gv.mod.currentEncounter.protectionTargetName == p.name)
                {
                    if (p.hp <= 0)
                    {
                        gv.mod.currentEncounter.protectionConditionMet = true;
                    }
                }
            }

            //Victory:

            if (gv.screenType.Equals("combat") && (gv.mod.currentEncounter.assassinationConditionMet || foundOneCrtr == 0 || standGroundConditionMet) || gv.mod.currentEncounter.conquerConditionMet)
            {

                hideActorInfo();
                for (int i = gv.mod.currentEncounter.encounterCreatureList.Count - 1; i >= 0; i--)
                {
                    gv.mod.currentEncounter.encounterCreatureList.RemoveAt(i);
                }
                gv.mod.currentEncounter.encounterCreatureList.Clear();

                if (gv.mod.currentEncounter.allSpellsWithoutAoE)
                {
                    for (int i = 0; i < gv.mod.moduleSpellsList.Count; i++)
                    {
                        gv.mod.moduleSpellsList[i].aoeRadius = gv.mod.currentEncounter.originalAoEofSpells[i];
                    }
                }

                if (gv.mod.currentEncounter.allSpellsSPCostDoubled)
                {
                    foreach (Spell sp in gv.mod.moduleSpellsList)
                    {
                        sp.costSP /= 2;
                    }
                }

                /*
                //reset all conditions
                gv.mod.currentEncounter.assassinationConditionMet = false;

                //kill all creatures, check whether encounter is repeatable
                gv.mod.currentEncounter.encounterCreatureList.Clear();
                if (!gv.mod.currentEncounter.isRepeatable)
                {
                    gv.mod.currentEncounter.encounterCreatureRefsList.Clear();
                }
                */
                //zulaufen

                //gv.screenType = "main";
                gv.mod.currentEncounter.isOver = true;
                allDone = true;
                roundCounter = 1;
                gv.touchEnabled = true;
                animationsOn = false;
                stepAnimationsOn = false;

                //testing
                attackAnimationFrameCounter = 0;
                attackAnimationDelayCounter = 0;
                idx = 0;
                currentMoveOrderIndex = 0;
                currentPlayerIndex = 0;
                creatureIndex = 0;

                gv.screenCombat.animationSeqStack.Clear();
                gv.screenCombat.deathAnimationLocations.Clear();
                gv.screenCombat.hitAnimationLocation = null;
                gv.screenCombat.endingAnimationLocation = null;
                gv.cc.floatyTextList.Clear();


                //remove night and nolight debuffs
                gv.mod.poorVisionModifier = 0;
                for (int index = 0; index < gv.mod.playerList.Count; index++)
                {
                    gv.sf.UpdateStats(gv.mod.playerList[index]);
                }

                //remove temporary allies
                for (int i = gv.mod.playerList.Count - 1; i >= 0; i--)
                {
                    if (gv.mod.playerList[i].isTemporaryAllyForThisEncounterOnly)
                    {
                        gv.mod.playerList.RemoveAt(i);
                    }
                }

                //build the text, depending on victory conditions fullfilled and exp, gold, items gained

                //EXP
                int giveEachXP = encounterXP / gv.mod.playerList.Count;
                foreach (Player givePcXp in gv.mod.playerList)
                {
                    givePcXp.XP = givePcXp.XP + giveEachXP;
                }
                string expText = "";
                if (giveEachXP > 0)
                {
                    expText = "Each party member receives " + giveEachXP.ToString() + " XP.<BR>";
                }

                //Gold
                gv.mod.partyGold += gv.mod.currentEncounter.goldDrop;
                string goldText = "";
                if (gv.mod.currentEncounter.goldDrop > 0)
                {
                    goldText = "The party found " + gv.mod.currentEncounter.goldDrop.ToString() + " " + gv.mod.goldLabelPlural + ".<BR>";
                }

                //Items 
                string itemsText = "";
                if (gv.mod.currentEncounter.encounterInventoryRefsList.Count > 0)
                {
                    itemsText = "The party found the following item(s):<BR>";
                    foreach (ItemRefs itRef in gv.mod.currentEncounter.encounterInventoryRefsList)
                    {
                        gv.mod.partyInventoryRefsList.Add(itRef.DeepCopy());
                        itemsText += itRef.name + "<BR>";
                    }
                }

                //Vcitory type description: victoryText
                string victoryText = "The party has won the encounter. <BR>";
                if (foundOneCrtr == 0)
                {
                    victoryText += "All enemies have been defeated. <BR>";
                }
                else if (gv.mod.currentEncounter.assassinationConditionMet)
                {
                    victoryText += "The main target, " + gv.mod.currentEncounter.assassinationTargetName + ", has been defeated. <BR>";
                }
                else if (standGroundConditionMet)
                {
                    victoryText += "The party survived " + gv.mod.currentEncounter.standGroundTimer + " rounds. <BR>";
                }
                else if (gv.mod.currentEncounter.conquerConditionMet)
                {
                    victoryText += "The party has occupied the required location(s). <BR>";
                }

                //after all vicotry conditions...
                victoryText += expText + goldText + itemsText;

                if (gv.mod.currentEncounter.isFriendlyContest)
                {
                    foreach (Player pc in gv.mod.playerList)
                    {
                        if (pc.hp < 1)
                        {
                            pc.hp = 1;
                        }
                        pc.charStatus = "Alive";
                    }
                    gv.sf.MessageBox(victoryText + "The knocked out characters recover a bit as this was just a contest.<BR>");
                    gv.cc.addLogText("<font color='yellow'>" + "Your party has won this contest." + "<BR></font>");
                }
                else
                {
                    if (gv.mod.currentEncounter.customTextforMessageBoxAtEndOfEncounter != "none" && gv.mod.currentEncounter.customTextforMessageBoxAtEndOfEncounter != "None" && gv.mod.currentEncounter.customTextforMessageBoxAtEndOfEncounter != "")
                    {
                        gv.sf.MessageBox(gv.mod.currentEncounter.customTextforMessageBoxAtEndOfEncounter);
                    }
                    else if (gv.mod.currentEncounter.showDefaultMessageBoxAtEndOfEncounter)
                    {
                        gv.sf.MessageBox(victoryText);
                    }

                    if (gv.mod.currentEncounter.customTextforLogTextAtEndOfEncounter != "none" && gv.mod.currentEncounter.customTextforLogTextAtEndOfEncounter != "None" && gv.mod.currentEncounter.customTextforLogTextAtEndOfEncounter != "")
                    {
                        gv.cc.addLogText(gv.mod.currentEncounter.customTextforLogTextAtEndOfEncounter);
                    }
                    else if (gv.mod.currentEncounter.showDefaultLogTextAtEndOfEncounter)
                    {
                        gv.cc.addLogText("<font color='yellow'>" + victoryText + "<BR></font>");
                    }




                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                    //gv.sf.MessageBox("Your party has won this battle by defeating all enemies.<br> <br> Each character gained: " + giveEachXP + "XP.");
                    //gv.cc.addLogText("<font color='yellow'>" + "Your party has won this battle by defeating all enemies." + "<BR></font>");

                }

                //reset all conditions
                gv.mod.currentEncounter.assassinationConditionMet = false;
                gv.mod.currentEncounter.standGroundInternalTimer = gv.mod.currentEncounter.standGroundTimer;
                gv.mod.currentEncounter.conquerConditionMet = false;

                //kill all creatures, check whether encounter is repeatable
                gv.mod.currentEncounter.encounterCreatureList.Clear();
                if (!gv.mod.currentEncounter.isRepeatable)
                {
                    gv.mod.currentEncounter.encounterCreatureRefsList.Clear();
                    //clear encounters with same tag, tag, too (not only the copy that current encounter is)
                    foreach (Encounter e in gv.mod.moduleEncountersList)
                    {
                        if (e.encounterName == gv.mod.currentEncounter.encounterName)
                        {
                            e.encounterCreatureRefsList.Clear();
                        }
                    }
                }

                //prevent any auto scrolling

                gv.mod.blockRightKey = false;
                gv.mod.blockLeftKey = false;
                gv.mod.blockUpKey = false;
                gv.mod.blockDownKey = false;


                gv.aTimer.Stop();
                gv.a2Timer.Stop();
                gv.mod.scrollModeSpeed = 1.15f;

                //gv.mod.isScrollingNow = false;
                //gv.mod.doNotStartScrolling = true;
                //gv.mod.scrollingDirection = "none";

                //gv.blockMoveBecausOfCurrentScrolling = true;
                gv.mod.scrollingTimer = 100;
                if (gv.mod.mainMapMovementRelevantKeyPressed)
                {
                    gv.mod.justLeftCombat = true;
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                gv.screenType = "main";


                if (gv.mod.playMusic)
                {
                    gv.stopCombatMusic();
                    gv.startMusic();
                    gv.startAmbient();
                }
                //do END ENCOUNTER IBScript
                gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnEndCombatIBScript, gv.mod.currentEncounter.OnEndCombatIBScriptParms);

                gv.mod.comningFromBattle = true;
                //aegon2
                /*
                if (gv.cc.calledEncounterFromProp)
                {
                    if (gv.sf.ThisProp != null)
                    {
                        gv.sf.ThisProp.wasKilled = true;
                        gv.mod.PlayerLocationX = gv.sf.ThisProp.LocationX;
                        gv.mod.PlayerLocationY = gv.sf.ThisProp.LocationY;
                        gv.mod.EncounterOfTurnDone = false;
                        gv.cc.doPropTriggers();
                    }
                }
                */

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxx
                //was running good (minus chest)
                if (gv.cc.EncCalled)
                {
                    foreach (Prop pKill in gv.mod.currentArea.Props)
                    {
                        if (pKill.PropTag == gv.cc.TagOFPropToKill)
                        {
                            //aegon2
                            //gv.sf.ThisProp.wasKilled = true;
                            pKill.wasKilled = true;
                            gv.mod.PlayerLocationX = pKill.LocationX;
                            gv.mod.PlayerLocationY = pKill.LocationY;

                        }
                    }
                    //gv.mod.isRecursiveDoTriggerCallMovingProp = true;
                    //gv.mod.isRecursiveCall = true;
                    //gv.sf.ThisProp.wasKilled = true; 
                    gv.mod.EncounterOfTurnDone = false;
                    //gv.triggerPropIndex = 4;
                    gv.cc.doPropTriggers();
                    //gv.mod.isRecursiveCall = false;
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx

                else
                {
                    gv.mod.EncounterOfTurnDone = false;
                    //gv.triggerPropIndex = 4;
                    gv.cc.doTrigger();
                }
                return true;
            }

            //lost battle
            int foundOnePc = 0;
            foreach (Player pc in gv.mod.playerList)
            {
                if (pc.hp > 0)
                {
                    //at least one true player must remain above 0 hp or the battle is considered lost
                    if (!pc.isTemporaryAllyForThisEncounterOnly)
                    {
                        foundOnePc = 1;
                    }
                }
            }

            if (gv.screenType.Equals("combat") && (foundOnePc == 0 || timeLimitConditionMet || gv.mod.currentEncounter.protectionConditionMet || gv.mod.currentEncounter.holdConditionMet))
            {
                hideActorInfo();
                if (gv.mod.currentEncounter.allSpellsSPCostDoubled)
                {
                    foreach (Spell sp in gv.mod.moduleSpellsList)
                    {
                        sp.costSP /= 2;
                    }
                }

                if (gv.mod.currentEncounter.allSpellsWithoutAoE)
                {
                    for (int i = 0; i < gv.mod.moduleSpellsList.Count; i++)
                    {
                        gv.mod.moduleSpellsList[i].aoeRadius = gv.mod.currentEncounter.originalAoEofSpells[i];
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                gv.mod.currentEncounter.isOver = true;
                allDone = true;
                roundCounter = 1;
                gv.touchEnabled = true;
                animationsOn = false;
                stepAnimationsOn = false;

                //testing
                attackAnimationFrameCounter = 0;
                attackAnimationDelayCounter = 0;
                idx = 0;
                currentMoveOrderIndex = 0;
                currentPlayerIndex = 0;
                creatureIndex = 0;

                gv.screenCombat.animationSeqStack.Clear();
                gv.screenCombat.deathAnimationLocations.Clear();
                gv.screenCombat.hitAnimationLocation = null;
                gv.screenCombat.endingAnimationLocation = null;
                gv.cc.floatyTextList.Clear();

                //173
                //35571
                //remove night and nolight debuffs
                gv.mod.poorVisionModifier = 0;
                for (int index = 0; index < gv.mod.playerList.Count; index++)
                {
                    gv.sf.UpdateStats(gv.mod.playerList[index]);
                }

                //remove temporary allies
                for (int i = gv.mod.playerList.Count - 1; i >= 0; i--)
                {
                    if (gv.mod.playerList[i].isTemporaryAllyForThisEncounterOnly)
                    {
                        gv.mod.playerList.RemoveAt(i);
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx

                //roundCounter = 1;
                if (gv.mod.currentEncounter.isFriendlyContest)
                {

                    //if (!gv.mod.currentEncounter.isRepeatable)
                    //{
                    gv.mod.currentEncounter.isOver = true;
                    //}
                    gv.touchEnabled = true;

                    //remove temporary allies
                    for (int i = gv.mod.playerList.Count - 1; i >= 0; i--)
                    {
                        if (gv.mod.playerList[i].isTemporaryAllyForThisEncounterOnly)
                        {
                            gv.mod.playerList.RemoveAt(i);
                        }
                    }

                    foreach (Player pc in gv.mod.playerList)
                    {
                        if (pc.hp < 1)
                        {
                            pc.hp = 1;
                        }
                        pc.charStatus = "Alive";
                    }
                    string defeatText = "";

                    if (timeLimitConditionMet)
                    {
                        defeatText += "Time limit is over.<br>";
                        timeLimitConditionMet = false;
                        gv.mod.currentEncounter.timeLimitInternalTimer = gv.mod.currentEncounter.timeLimitTimer;
                    }

                    if (gv.mod.currentEncounter.protectionConditionMet)
                    {
                        defeatText += "Failed to protect " + gv.mod.currentEncounter.protectionTargetName + " from dropping to 0 or less hp.<br>";
                        gv.mod.currentEncounter.protectionConditionMet = false;
                    }

                    if (gv.mod.currentEncounter.holdConditionMet)
                    {
                        defeatText += "The party has failed to hold the required location(s). <BR>";
                        gv.mod.currentEncounter.holdConditionMet = false;
                    }

                    defeatText += "Your party has lost this contest - the knocked out characters recover a bit.<br>";

                    gv.sf.MessageBox(defeatText);
                    //gv.cc.addLogText("red", defeatText);
                    gv.cc.addLogText("<font color='red'>" + defeatText + "<BR></font>");

                    //chaweng

                    gv.screenType = "main";
                    gv.screenCombat.animationSeqStack.Clear();
                    gv.screenCombat.deathAnimationLocations.Clear();
                    gv.screenCombat.hitAnimationLocation = null;
                    gv.screenCombat.endingAnimationLocation = null;
                    gv.cc.floatyTextList.Clear();
                    roundCounter = 1;
                    if (gv.mod.playMusic)
                    {
                        gv.stopCombatMusic();
                        gv.startMusic();
                        gv.startAmbient();
                    }
                    //do END ENCOUNTER IBScript
                    gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.OnEndCombatIBScript, gv.mod.currentEncounter.OnEndCombatIBScriptParms);
                    if (gv.cc.calledEncounterFromProp)
                    {
                        //gv.mod.isRecursiveDoTriggerCallMovingProp = true;
                        //gv.mod.isRecursiveCall = true;
                        gv.mod.EncounterOfTurnDone = false;
                        //gv.triggerPropIndex = 4;
                        gv.cc.doPropTriggers();
                        //gv.mod.isRecursiveCall = false;
                    }
                    else
                    {
                        gv.mod.EncounterOfTurnDone = false;
                        //gv.triggerPropIndex = 4;
                        gv.cc.doTrigger();
                    }
                    return true;

                }

                //no friendly contest, but real battle
                else
                {
                    animationsOn = false;
                    stepAnimationsOn = false;
                    gv.touchEnabled = true;
                    string defeatText = "";

                    if (timeLimitConditionMet)
                    {
                        defeatText += "Time limit is over.<br>";
                        timeLimitConditionMet = false;
                        gv.mod.currentEncounter.timeLimitInternalTimer = gv.mod.currentEncounter.timeLimitTimer;
                    }

                    if (gv.mod.currentEncounter.protectionConditionMet)
                    {
                        defeatText += "Failed to protect " + gv.mod.currentEncounter.protectionTargetName + " from dropping to 0 or less hp.<br>";
                        gv.mod.currentEncounter.protectionConditionMet = false;
                    }

                    if (gv.mod.currentEncounter.holdConditionMet)
                    {
                        defeatText += "The party has failed to hold the required location(s). <BR>";
                        gv.mod.currentEncounter.holdConditionMet = false;
                    }

                    defeatText += "Your party has been defeated!<br>";

                    gv.sf.MessageBox(defeatText);
                    //gv.cc.addLogText("red", defeatText);
                    gv.cc.addLogText("<font color='red'>" + defeatText + "<BR></font>");

                    //gv.sf.MessageBox("Your party has been defeated!");
                    if (gv.mod.playMusic)
                    {
                        gv.stopCombatMusic();
                        gv.startMusic();
                        gv.startAmbient();
                    }
                    //gv.screenType = "title";
                    gv.resetGame();
                    gv.screenType = "title";
                    return true;
                }
            }
            return false;
        }

        public void afterEachMoveCalls()
        {
            if (isPlayerTurn)
            {
                Player pc = gv.mod.playerList[currentPlayerIndex];
                foreach (Effect e in gv.mod.currentEncounter.effectsList)
                {
                    if (e.combatLocX == pc.combatLocX && e.combatLocY == pc.combatLocY && e.triggeredEachStepToo)
                    {
                        applyEffectsFromSquare(pc.combatLocX, pc.combatLocY);
                        applyEffectsCombat(pc, true);
                    }
                }
            }
            else
            {
                Creature crt = new Creature();
                int highestLivingCrtMoveOrderfound = 0;
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (currentMoveOrderIndex == 0)
                    {
                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                        {
                            highestLivingCrtMoveOrderfound = c.moveOrder;
                            crt = c;
                        }
                    }
                    else
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            crt = c;
                            break;
                        }
                    }
                }
                //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
                foreach (Effect e in gv.mod.currentEncounter.effectsList)
                {
                    if (e.combatLocX == crt.combatLocX && e.combatLocY == crt.combatLocY && e.triggeredEachStepToo)
                    {
                        applyEffectsFromSquare(crt.combatLocX, crt.combatLocY);
                        applyEffectsCombat(crt, true);
                    }
                }
                if (crt.isHeld())
                {
                    endCreatureTurn(crt);
                }
                if (crt.isImmobile())
                {
                    creatureMoves = crt.moveDistance;
                }
            }
            triggerIndexCombat = 0;
            doPropTriggers();
            //tiereimpark
            //schnecke
            //endCreatureTurn(crt);
            checkEndEncounter();
            floatyTextOn = true;
            /*
            if (gv.mod.currentEncounter.encounterCreatureList[creatureIndex].hp <= 0)
            {
                AnimationStackGroup newGroup = new AnimationStackGroup();
                newGroup = new AnimationStackGroup();
                gv.screenCombat.animationSeqStack[0].AnimationSeq.Add(newGroup);
                foreach (Coordinate coor in gv.screenCombat.deathAnimationLocations)
                {
                    gv.screenCombat.addDeathAnimation(newGroup, new Coordinate(gv.screenCombat.getPixelLocX(coor.X), gv.screenCombat.getPixelLocY(coor.Y)));
                }

                gv.screenCombat.animationsOn = true;
            }
            */
        }

        public void doPropTriggers()
        {
            try
            {
                //reset the calling square loaction  
                gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX = 0;
                gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY = 0;

                Prop prp = gv.mod.currentEncounter.getPropByLocation(0, 0);
                if (isPlayerTurn)
                {
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    prp = gv.mod.currentEncounter.getPropByLocation(pc.combatLocX, pc.combatLocY);
                    ThisProp = prp;
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX = pc.combatLocX;
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY = pc.combatLocY;
                }
                else
                {
                    //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
                    Creature crt = new Creature();
                    int highestLivingCrtMoveOrderfound = 0;
                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (currentMoveOrderIndex == 0)
                        {
                            if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                            {
                                highestLivingCrtMoveOrderfound = c.moveOrder;
                                crt = c;
                            }
                        }
                        else
                        {
                            if (c.moveOrder == currentMoveOrderIndex - 1)
                            {
                                crt = c;
                                break;
                            }
                        }
                    }
                    prp = gv.mod.currentEncounter.getPropByLocation(crt.combatLocX, crt.combatLocY);
                    ThisProp = prp;
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX = crt.combatLocX;
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY = crt.combatLocY;
                }

                bool alreadyTriggered = false;
                foreach (string s in tagsOfTriggersAndPropTriggersCalledThisTurn)
                {
                    //rdr5
                    if (prp != null)
                    {
                        if (s == prp.PropTag)
                        {
                            alreadyTriggered = true;
                        }
                    }
                }

                if ((prp != null) && (prp.isActive) && !alreadyTriggered)
                {
                    if (!prp.encounterPropTriggerOnEveryStep)
                    {
                        tagsOfTriggersAndPropTriggersCalledThisTurn.Add(prp.PropTag);
                    }
                    //check to see if using an IBScript   
                    if (!prp.OnEnterSquareIBScript.Equals("none"))
                    {
                        //gv.cc.doIBScriptBasedOnFilename(prp.OnEnterSquareIBScript, prp.OnEnterSquareIBScriptParms);
                        if ((isPlayerTurn) && (prp.canBeTriggeredByPc)) //only do if PC can trigger  
                        {
                            gv.cc.doIBScriptBasedOnFilename(prp.OnEnterSquareIBScript, prp.OnEnterSquareIBScriptParms);
                            decrementAndRemoveProp(prp);
                        }
                        else if ((!isPlayerTurn) && (prp.canBeTriggeredByCreature)) //only do if creature can trigger  
                        {
                            /*
                            int i = 0;
                            while (i < 500000000)
                            {
                                i++;
                            }
                            */
                            gv.cc.doIBScriptBasedOnFilename(prp.OnEnterSquareIBScript, prp.OnEnterSquareIBScriptParms);
                            decrementAndRemoveProp(prp);
                        }
                    }
                    //check to see if using a Script  
                    else if (!prp.OnEnterSquareScript.Equals("none"))
                    {
                        if ((isPlayerTurn) && (prp.canBeTriggeredByPc)) //only do if PC can trigger  
                        {
                            gv.cc.doScriptBasedOnFilename(prp.OnEnterSquareScript, prp.OnEnterSquareScriptParm1, prp.OnEnterSquareScriptParm2, prp.OnEnterSquareScriptParm3, prp.OnEnterSquareScriptParm4);
                            decrementAndRemoveProp(prp);
                        }
                        else if ((!isPlayerTurn) && (prp.canBeTriggeredByCreature)) //only do if creature can trigger  
                        {
                            /*
                            int i = 0;
                            while (i < 500000000)
                            {
                                i++;
                            }
                            */
                            gv.cc.doScriptBasedOnFilename(prp.OnEnterSquareScript, prp.OnEnterSquareScriptParm1, prp.OnEnterSquareScriptParm2, prp.OnEnterSquareScriptParm3, prp.OnEnterSquareScriptParm4);
                            decrementAndRemoveProp(prp);
                        }
                    }
                }

                doTriggers();
            }
            catch (Exception ex)
            {
                if (gv.mod.debugMode)
                {
                    gv.sf.MessageBox("failed to do prop trigger: " + ex.ToString());
                    gv.errorLog(ex.ToString());
                }
            }
        }

        public void decrementAndRemoveProp(Prop prp)
        {
            prp.numberOfScriptCallsRemaining--;
            if (prp.numberOfScriptCallsRemaining < 1)
            {
                gv.cc.addLogText("lime", "Removing this square based trigger - no more charges");
                gv.mod.currentEncounter.propsList.Remove(prp);
            }
        }

        public void decrementAndRemoveTrigger(Trigger trg)
        {
            trg.numberOfScriptCallsRemaining--;
            if (trg.numberOfScriptCallsRemaining < 1)
            {
                gv.cc.addLogText("lime", "Removing this square based trigger - no more charges");
                gv.mod.currentEncounter.Triggers.Remove(trg);
            }
        }



        public void doTriggers()
        {
            try
            {
                //reset the calling square loaction  
                gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX = 0;
                gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY = 0;

                //Trigger trig = gv.mod.currentEncounter.getTriggerByLocation(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY);
                Trigger trig = gv.mod.currentEncounter.getTriggerByLocation(0, 0);
                if (isPlayerTurn)
                {
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    trig = gv.mod.currentEncounter.getTriggerByLocation(pc.combatLocX, pc.combatLocY);
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX = pc.combatLocX;
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY = pc.combatLocY;

                }
                else
                {
                    Creature crt = new Creature();
                    int highestLivingCrtMoveOrderfound = 0;
                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (currentMoveOrderIndex == 0)
                        {
                            if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                            {
                                highestLivingCrtMoveOrderfound = c.moveOrder;
                                crt = c;
                            }
                        }
                        else
                        {
                            if (c.moveOrder == currentMoveOrderIndex - 1)
                            {
                                crt = c;
                                break;
                            }
                        }
                    }
                    //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
                    trig = gv.mod.currentEncounter.getTriggerByLocation(crt.combatLocX, crt.combatLocY);
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX = crt.combatLocX;
                    gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY = crt.combatLocY;

                }

                bool alreadyTriggered = false;
                foreach (string s in tagsOfTriggersAndPropTriggersCalledThisTurn)
                {
                    if (trig != null)
                    {
                        if (s == trig.TriggerTag)
                        {
                            alreadyTriggered = true;
                        }
                    }
                }

                if ((trig != null) && (trig.Enabled) && !alreadyTriggered)
                {
                    if (!trig.encounterTriggerOnEveryStep)
                    {
                        tagsOfTriggersAndPropTriggersCalledThisTurn.Add(trig.TriggerTag);
                    }
                    //iterate through each event                  
                    #region Event1 stuff
                    //check to see if enabled and parm not "none"                    
                    triggerIndexCombat++;

                    if ((triggerIndexCombat == 1) && (trig.EnabledEvent1) && (!trig.Event1FilenameOrTag.Equals("none")))
                    {
                        /*
                        int i = 0;
                        while (i < 2000000000)
                        {
                            i++;
                        }
                        */
                        //check to see what type of event
                        if (trig.Event1Type.Equals("script"))
                        {


                            if (trig.Event1Parm1 == "spell_doubleStrike")
                            {
                                int g = 0;
                            }
                            //gv.cc.doScriptBasedOnFilename(trig.Event1FilenameOrTag, trig.Event1Parm1, trig.Event1Parm2, trig.Event1Parm3, trig.Event1Parm4);
                            if ((isPlayerTurn) && (trig.canBeTriggeredByPc)) //only do if PC can trigger  
                            {
                                gv.cc.doScriptBasedOnFilename(trig.Event1FilenameOrTag, trig.Event1Parm1, trig.Event1Parm2, trig.Event1Parm3, trig.Event1Parm4);
                                didTriggerEvent = true;
                            }
                            else if ((!isPlayerTurn) && (trig.canBeTriggeredByCreature)) //only do if creature can trigger  
                            {
                                gv.cc.doScriptBasedOnFilename(trig.Event1FilenameOrTag, trig.Event1Parm1, trig.Event1Parm2, trig.Event1Parm3, trig.Event1Parm4);
                                didTriggerEvent = true;
                            }
                            doTriggers();
                        }
                        else if (trig.Event1Type.Equals("ibscript"))
                        {
                            //gv.cc.doIBScriptBasedOnFilename(trig.Event1FilenameOrTag, trig.Event1Parm1);
                            if ((isPlayerTurn) && (trig.canBeTriggeredByPc)) //only do if PC can trigger  
                            {
                                gv.cc.doIBScriptBasedOnFilename(trig.Event1FilenameOrTag, trig.Event1Parm1);
                                didTriggerEvent = true;
                            }
                            else if ((!isPlayerTurn) && (trig.canBeTriggeredByCreature)) //only do if creature can trigger  
                            {
                                gv.cc.doIBScriptBasedOnFilename(trig.Event1FilenameOrTag, trig.Event1Parm1);
                                didTriggerEvent = true;
                            }
                            doTriggers();
                        }
                        //add container veent, maybe also transition?
                        else if (trig.Event1Type.Equals("container"))
                        {

                            //wohnraum
                            //must assure that container screen will retrun to combat screen
                            gv.cc.doContainerBasedOnTagCombat(trig.Event1FilenameOrTag);
                            didTriggerEvent = true;
                            doTriggers();
                        }
                        //do that event
                        if (trig.DoOnceOnlyEvent1)
                        {
                            trig.EnabledEvent1 = false;
                        }
                    }
                    #endregion
                    #region Event2 stuff
                    //check to see if enabled and parm not "none"
                    else if ((triggerIndexCombat == 2) && (trig.EnabledEvent2) && (!trig.Event2FilenameOrTag.Equals("none")))
                    {

                        if (!trig.event2RequiresTrueReturnCheck || (trig.event2RequiresTrueReturnCheck && gv.mod.returnCheck))
                        {
                            //check to see what type of event
                            if (trig.Event2Type.Equals("script"))
                            {
                                //gv.cc.doScriptBasedOnFilename(trig.Event2FilenameOrTag, trig.Event2Parm1, trig.Event2Parm2, trig.Event2Parm3, trig.Event2Parm4);
                                if ((isPlayerTurn) && (trig.canBeTriggeredByPc)) //only do if PC can trigger  
                                {
                                    gv.cc.doScriptBasedOnFilename(trig.Event2FilenameOrTag, trig.Event2Parm1, trig.Event2Parm2, trig.Event2Parm3, trig.Event2Parm4);
                                    didTriggerEvent = true;
                                }
                                else if ((!isPlayerTurn) && (trig.canBeTriggeredByCreature)) //only do if creature can trigger  
                                {
                                    gv.cc.doScriptBasedOnFilename(trig.Event2FilenameOrTag, trig.Event2Parm1, trig.Event2Parm2, trig.Event2Parm3, trig.Event2Parm4);
                                    didTriggerEvent = true;
                                }

                                doTriggers();
                            }
                            else if (trig.Event1Type.Equals("ibscript"))
                            {
                                //gv.cc.doIBScriptBasedOnFilename(trig.Event2FilenameOrTag, trig.Event2Parm1);
                                if ((isPlayerTurn) && (trig.canBeTriggeredByPc)) //only do if PC can trigger  
                                {
                                    gv.cc.doIBScriptBasedOnFilename(trig.Event2FilenameOrTag, trig.Event2Parm1);
                                    didTriggerEvent = true;
                                }
                                else if ((!isPlayerTurn) && (trig.canBeTriggeredByCreature)) //only do if creature can trigger  
                                {
                                    gv.cc.doIBScriptBasedOnFilename(trig.Event2FilenameOrTag, trig.Event2Parm1);
                                    didTriggerEvent = true;
                                }
                                doTriggers();
                            }
                            //do that event
                            if (trig.DoOnceOnlyEvent2)
                            {
                                trig.EnabledEvent2 = false;
                            }
                        }
                    }
                    #endregion
                    #region Event3 stuff
                    //check to see if enabled and parm not "none"
                    else if ((triggerIndexCombat == 3) && (trig.EnabledEvent3) && (!trig.Event3FilenameOrTag.Equals("none")))
                    {


                        if (!trig.event3RequiresFalseReturnCheck || (trig.event3RequiresFalseReturnCheck && !gv.mod.returnCheck))
                        {
                            //check to see what type of event
                            if (trig.Event3Type.Equals("script"))
                            {
                                //gv.cc.doScriptBasedOnFilename(trig.Event3FilenameOrTag, trig.Event3Parm1, trig.Event3Parm2, trig.Event3Parm3, trig.Event3Parm4);
                                if ((isPlayerTurn) && (trig.canBeTriggeredByPc)) //only do if PC can trigger  
                                {
                                    gv.cc.doScriptBasedOnFilename(trig.Event3FilenameOrTag, trig.Event3Parm1, trig.Event3Parm2, trig.Event3Parm3, trig.Event3Parm4);
                                    didTriggerEvent = true;
                                }
                                else if ((!isPlayerTurn) && (trig.canBeTriggeredByCreature)) //only do if creature can trigger  
                                {
                                    gv.cc.doScriptBasedOnFilename(trig.Event3FilenameOrTag, trig.Event3Parm1, trig.Event3Parm2, trig.Event3Parm3, trig.Event3Parm4);
                                    didTriggerEvent = true;
                                }

                                doTriggers();
                            }
                            else if (trig.Event3Type.Equals("ibscript"))
                            {
                                //gv.cc.doIBScriptBasedOnFilename(trig.Event3FilenameOrTag, trig.Event3Parm1);
                                if ((isPlayerTurn) && (trig.canBeTriggeredByPc)) //only do if PC can trigger  
                                {
                                    gv.cc.doIBScriptBasedOnFilename(trig.Event3FilenameOrTag, trig.Event3Parm1);
                                    didTriggerEvent = true;
                                }
                                else if ((!isPlayerTurn) && (trig.canBeTriggeredByCreature)) //only do if creature can trigger  
                                {
                                    gv.cc.doIBScriptBasedOnFilename(trig.Event3FilenameOrTag, trig.Event3Parm1);
                                    didTriggerEvent = true;
                                }
                                doTriggers();
                            }
                            //do that event
                            if (trig.DoOnceOnlyEvent3)
                            {
                                trig.EnabledEvent3 = false;
                            }
                        }
                    }
                    else if (triggerIndexCombat < 4)
                    {
                        doTriggers();
                    }
                    #endregion
                    if (triggerIndexCombat > 3)
                    {
                        if (didTriggerEvent)
                        {
                            decrementAndRemoveTrigger(trig);
                        }

                        triggerIndexCombat = 0;
                        didTriggerEvent = false;
                        if (trig.DoOnceOnly)
                        {
                            trig.Enabled = false;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                if (gv.mod.debugMode)
                {
                    gv.sf.MessageBox("failed to do trigger: " + ex.ToString());
                    gv.errorLog(ex.ToString());
                }
            }
        }

        public void doPropOrTriggerCastSpell(string tag)
        {
            Spell sp = gv.mod.getSpellByTag(tag);
            if (sp == null) { return; }
            Coordinate srcCoor = new Coordinate(gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX, gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY);
            //if spell target type is coor, use coor...else use creature or PC on square  
            if (sp.spellTargetType.Equals("PointLocation"))
            {
                gv.cc.doSpellBasedOnScriptOrEffectTag(sp, srcCoor, srcCoor, false, false, null);
            }
            else
            {
                foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if ((crt.combatLocX == gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX) && (crt.combatLocY == gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY))
                    {
                        gv.cc.doSpellBasedOnScriptOrEffectTag(sp, srcCoor, crt, false, false, null);
                    }
                }
                foreach (Player pc in gv.mod.playerList)
                {
                    if ((pc.combatLocX == gv.mod.currentEncounter.triggerScriptCalledFromSquareLocX) && (pc.combatLocY == gv.mod.currentEncounter.triggerScriptCalledFromSquareLocY))
                    {
                        gv.cc.doSpellBasedOnScriptOrEffectTag(sp, srcCoor, pc, false, false, null);
                    }
                }
            }

            //add ending animation  
            //ulrepforte
            string filename = sp.spriteEndingFilename;
            AnimationSequence newSeq = new AnimationSequence();
            animationSeqStack.Add(newSeq);
            AnimationStackGroup newGroup = new AnimationStackGroup();

            //ulrepforte

            animationSeqStack[0].AnimationSeq.Add(newGroup);
            foreach (Coordinate coor in gv.sf.AoeSquaresList)
            {
                addEndingAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)), filename);
            }

            /*
            foreach (Coordinate coor in gv.sf.AoeSquaresList)
            {
                Sprite spr = new Sprite(gv, filename, getPixelLocX(coor.X), getPixelLocY(coor.Y), 0,0,0,0,1,1000,false,500);
                spriteList.Add(spr);
            }
            */



            //add floaty text  
            //add death animations  
            newGroup = new AnimationStackGroup();
            animationSeqStack[0].AnimationSeq.Add(newGroup);
            foreach (Coordinate coor in deathAnimationLocations)
            {
                addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
            }
            animationsOn = true;

        }


        //COMBAT SCREEN UPDATE
        public void Update(int elapsed)
        {
            combatUiLayout.Update(elapsed);
            refreshCreatureCoveredSquares();



            #region PROP AMBIENT SPRITES
            foreach (Sprite spr in spriteList)
            {
                spr.Update(elapsed, gv);
            }
            //remove sprite if hit end of life
            for (int x = spriteList.Count - 1; x >= 0; x--)
            {
                if (spriteList[x].timeToLiveInMilliseconds <= 0)
                {
                    try
                    {
                        spriteList.RemoveAt(x);
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }
            }
            #endregion

            #region COMBAT ANIMATION SPRITES
            //projectmover
            //the creature gilde adders x aor y not equalling zero migth be good indictaors for displaying the walk animation (alternate frames)
            //crt.glideAdderX and  crt.glideAdderY
            //crt.inactiveTimer = 0 indicates a wiggling movement going on

            //Creatures
            //update(int elapsed) handles the animations

            //miantain two frame sprite support through all of this

            //check these conditions in update(int elapsed) of ScreenCombat  
            //breathing/idle: only animate creatures 1) whose turn it currently NOT is and 2) with hp > 0
            //walking: only animate cretaures with 1) hp > 0 and 2a) whose crt.glideAdderX/crt.glideAdderY are not 0 or 2b) whose crt.inactiveTimwe equals 0
            //I think inactiveTimer needs to be longer as otherwise not enough room is left for idle and breathe animations
            //assign and unassign(!) crt.show... values accordingly (only one can be true anytime, likely no use for the normal and attack one, as there are systems for those already)
            //might use frameNumber, like main map does, too (a bit redundant)

            //use drawMovingCombatCreatures crt.show... values in drawMovingCombatCreatures()
            //crt.show.. values determine which frame/part of the sprite to use as src here
            //factor in creature size dimensiosn for picking the correct part of the sprite
            //mainmap is using prp.currentFrameNumber, truned into framePosition, for picking correct part, maybe copy that fro crt and combat

            //PC
            //to do: plan

            //MapScrolling
            //to do: plan

            //turned inot frameposition
            //doPropAnimations used to determine the prp.currentFrameNumber there
            //setting prp.showWalkingFrame(2), prp.showIdlingFrame(3), prp.showBreathingFrame(4)
            //normal woulsd 0 then and attack 1

            //mirror tehse setting for cretaure, add prp.showAttckFrame(1)

            //lets add code for idling, breathing and walking
            //walking overides breathign and idling
            //idlign (more rare) overwrites breathing)

            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                //check walking first
                //all animation require hp > 0
                if (crt.hp > 0)
                {
                    //cretaure shoudl NOT be contained in lists for attack or dying animations
                    if (!creatureToAnimate.Contains(crt))
                    {
                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        if (crt.token != null)
                        {
                            if (!crt.token.IsDisposed)
                            {

                                int heightMultiplierDueToSize = 1;
                                if (crt.creatureSize == 3 || crt.creatureSize == 4)
                                {
                                    heightMultiplierDueToSize = 2;
                                }
                                //wolfmountain, look at draw player code
                                //if (p.currentWalkingSpeed != 0)
                                //{
                                if ((crt.glideAdderX != 0 || crt.glideAdderY != 0) || (crt.inactiveTimer == 0))
                                {

                                    //crt.showWalkingFrame = true;
                                    //}
                                    crt.showIdlingFrame = false;
                                    //p.idleAnimationDelayCounter = 0;
                                    crt.showBreathingFrame = false;
                                    //p.breathAnimationDelayCounter = 0;

                                    if (crt.token.PixelSize.Height / heightMultiplierDueToSize >= 300)
                                    {
                                        //use value form prop.currentWalkingSpeed
                                        //p.currentWalkingSpeed = elapsed / 30f * ((float)gv.squareSize / ((float)gv.mod.realTimeTimerLengthInMilliSeconds * 0.03f)) * (float)p.pixelMoveSpeed * 0.9f * p.propMovingHalfSpeedMulti;

                                        crt.walkAnimationDelayCounter += elapsed / 30f * ((float)gv.squareSize / 50f);
                                        float walkThreshold = 20f;
                                        if ((crt.glideAdderX != 0 || crt.glideAdderY != 0))
                                        {
                                            walkThreshold = 6f;
                                        }
                                        if (crt.walkAnimationDelayCounter >= walkThreshold)
                                        {
                                            //osgosg
                                            if (!crt.showWalkingFrame)
                                            {
                                                crt.showWalkingFrame = true;
                                            }
                                            else
                                            {
                                                crt.showWalkingFrame = false;
                                            }
                                            crt.walkAnimationDelayCounter = 0;
                                        }
                                    }
                                    else
                                    {
                                        crt.showWalkingFrame = false;
                                    }
                                }
                                //not walking, maybe idling or breathing?
                                else
                                {
                                    //reset counters
                                    crt.walkAnimationDelayCounter = 0;
                                    //show default sprite when not scrolling in any case
                                    crt.showWalkingFrame = false;

                                    //add idling code
                                    if (crt.token.PixelSize.Height / heightMultiplierDueToSize >= 400)
                                    {
                                        //TODO:
                                        //add idle frequency property in
                                        //randomize idlign a bit for different pc
                                        crt.idleAnimationDelayCounter += (1f * elapsed / 30f * gv.mod.idleAnimationFrequency / 100f);
                                        //gv.mod.hurdle = 3f + (float)gv.sf.RandInt(700) / 100f;
                                        if (crt.idleAnimationDelayCounter >= crt.hurdle)
                                        {
                                            //osgosg
                                            if (!crt.showIdlingFrame)
                                            {
                                                crt.showIdlingFrame = true;
                                                crt.hurdle = (2f + (float)gv.sf.RandInt(300) / 100f) / 1.5f;
                                            }
                                            else
                                            {
                                                crt.showIdlingFrame = false;
                                                crt.hurdle = (25f + (float)gv.sf.RandInt(2250) / 100f);
                                            }
                                            crt.idleAnimationDelayCounter = 0;
                                            //gv.mod.hurdle = 3f + (float)gv.sf.RandInt(700) / 100f;
                                        }
                                        //breathing code, hurdle for idle not reached
                                        else
                                        {
                                            if (crt.token.PixelSize.Height / heightMultiplierDueToSize >= 500)
                                            {
                                                crt.breathAnimationDelayCounter += (1f * elapsed / 30f * gv.mod.breathAnimationFrequency / 100f);
                                                if (crt.breathAnimationDelayCounter >= (4.0f + (float)gv.sf.RandInt(250) / 100f))
                                                {
                                                    //osgosg
                                                    if (!crt.showBreathingFrame)
                                                    {
                                                        crt.showBreathingFrame = true;
                                                        //gv.mod.hurdle = 2f + (float)gv.sf.RandInt(300) / 100f;
                                                    }
                                                    else
                                                    {
                                                        crt.showBreathingFrame = false;
                                                        //gv.mod.hurdle = 10f + (float)gv.sf.RandInt(1500) / 100f;
                                                    }
                                                    crt.breathAnimationDelayCounter = 0;
                                                }
                                            }
                                            else
                                            {
                                                crt.showBreathingFrame = false;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        crt.showIdlingFrame = false;
                                    }
                                }

                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                //walking
                                if (crt.showWalkingFrame)
                                {
                                    //just set teh correct p.framenumber here
                                    //0 is default, 1 is attack, 2 is walk, 3 is idle, 4 is breathe
                                    crt.currentFrameNumber = 2;

                                    //src = new IbRect(0, 2 * gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width);

                                    //src = new IbRect(0, gv.mod.selectedPartyLeader].token.PixelSize.Width * attackAnimationFrameCounter, pc.token.PixelSize.Width, pc.token.PixelSize.Width);
                                }
                                //idling
                                else if (crt.showIdlingFrame)
                                {
                                    crt.currentFrameNumber = 3;
                                    //src = new IbRect(0, 3 * gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width);

                                }
                                //breathing
                                else if (crt.showBreathingFrame)
                                {
                                    crt.currentFrameNumber = 4;
                                    //src = new IbRect(0, 4 * gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width);

                                }
                                //default
                                else
                                {
                                    crt.currentFrameNumber = 0;
                                    //src = new IbRect(0, 0, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width);

                                }
                            }
                        }

                        //no animation
                        else
                        {
                            crt.currentFrameNumber = 0;
                            //likely no code needed here
                        }



                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx

                        //check walking first
                        //2a) whose crt.glideAdderX / crt.glideAdderY are not 0 or 2b) whose crt.inactiveTimwe equals 0

                    }
                }
            }
            /*
            if (!isPlayerTurn)
            {
                Creature crt2 = new Creature();
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        crt2 = c;
                        break;
                    }
                }
                crt2.maxTurnTimeCounter += elapsed;

                if (crt2.maxTurnTimeCounter > 8000)
                {
                    animationState = AnimationState.None;
                    animationSeqStack.Clear();
                    endCreatureTurn(crt2);
                }
            }
            */
            /*
            foreach (AnimationSequence seq in animationSeqStack)
            {
                if (seq.AnimationSeq.Count > 0)
                {
                    animationsOn = true;
                    stepAnimationsOn = false;
                    break;
                }
            }
            */

            //stepAnimationsOn = false;
            // measure time opf each cretaure smove and after threshold end in any way
            if (animationsOn && !stepAnimationsOn)
            //if (animationsOn)
            //if (animationSeqStack.Count > 0)
            {
                attackAnimationTimeElapsed += elapsed;
                //
                //if ((attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds) && ((attackAnimationFrameCounter >= maxUsableCounterValue) || (isPlayerTurn)))
                //bewlo was working
                if ((attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds * 1.5f) && (attackAnimationFrameCounter >= maxUsableCounterValue))
                //if ((attackAnimationTimeElapsed >= 2*attackAnimationLengthInMilliseconds))

                //if ((attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds))
                {
                    //time is up, reset attack animations to null
                    creatureToAnimate.Clear();
                    playerToAnimate = null;
                    foreach (AnimationSequence seq in animationSeqStack)
                    {
                        //if(seq.AnimationSeq[0].turnFloatyTextOn)
                        if (seq.AnimationSeq.Count > 0)
                        {
                            /*
                            floatyTextOn = true; //show any floaty text in the pool
                        }
                        foreach (Sprite spr in seq.AnimationSeq[0].SpriteGroup)
                        {
                            //just update the group at the top of the stack, first in first
                            spr.Update(elapsed, gv);
                            */
                            //new
                            if (seq.AnimationSeq[0].turnFloatyTextOn)
                            {
                                floatyTextOn = true; //show any floaty text in the pool  
                            }
                            foreach (Sprite spr in seq.AnimationSeq[0].SpriteGroup)
                            {
                                //just update the group at the top of the stack, first in first  
                                spr.Update(elapsed, gv);
                            }
                            //new

                        }
                    }
                    //remove sprites if hit end of life
                    for (int aniseq = animationSeqStack.Count - 1; aniseq >= 0; aniseq--)
                    {
                        for (int stkgrp = animationSeqStack[aniseq].AnimationSeq.Count - 1; stkgrp >= 0; stkgrp--)
                        {
                            for (int sprt = animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup.Count - 1; sprt >= 0; sprt--)
                            {
                                if (animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup[sprt].timeToLiveInMilliseconds <= 0)
                                {
                                    try
                                    {
                                        animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup.RemoveAt(sprt);

                                    }
                                    catch (Exception ex)
                                    {
                                        gv.errorLog(ex.ToString());
                                    }
                                }
                            }
                            if (animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup.Count == 0)
                            {
                                try
                                {
                                    animationSeqStack[aniseq].AnimationSeq.RemoveAt(stkgrp);
                                }
                                catch (Exception ex)
                                {
                                    gv.errorLog(ex.ToString());
                                }
                            }
                        }
                        if (animationSeqStack[aniseq].AnimationSeq.Count == 0)
                        {
                            try
                            {
                                animationSeqStack.RemoveAt(aniseq);
                            }
                            catch (Exception ex)
                            {
                                gv.errorLog(ex.ToString());
                            }
                        }
                    }
                    //if all animation sequences are done, end this turn
                }
                if (animationSeqStack.Count == 0)
                {
                    animationsOn = false;
                    deathAnimationLocations.Clear();
                    blockCreatureDrawLocations.Clear();

                    //remove any dead creatures                        
                    for (int x = gv.mod.currentEncounter.encounterCreatureList.Count - 1; x >= 0; x--)
                    {
                        if (gv.mod.currentEncounter.encounterCreatureList[x].hp <= 0)
                        {
                            try
                            {
                                //do OnDeath IBScript
                                gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScript, gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScriptParms);
                                //project repeatable
                                int deadIdx = (gv.mod.currentEncounter.encounterCreatureList.Count - 1) - x;
                                if (deadIdx < idx)
                                {
                                    idx--;
                                    if (idx < 0)
                                    {
                                        idx = 0;
                                    }
                                }
                                if (gv.mod.currentEncounter.assassinationVictory && gv.mod.currentEncounter.assassinationTargetTag == gv.mod.currentEncounter.encounterCreatureList[x].cr_tag)
                                {
                                    gv.mod.currentEncounter.assassinationConditionMet = true;
                                }
                                gv.mod.currentEncounter.encounterCreatureList.RemoveAt(x);
                                if (!gv.mod.currentEncounter.isRepeatable)
                                {
                                    //gv.mod.currentEncounter.encounterCreatureRefsList.RemoveAt(x);
                                }
                            }
                            catch (Exception ex)
                            {
                                gv.errorLog(ex.ToString());
                            }
                        }
                    }
                    foreach (Player p in gv.mod.playerList)
                    {
                        if (gv.mod.currentEncounter.protectionDefeat && gv.mod.currentEncounter.protectionTargetName == p.name)
                        {
                            if (p.hp <= 0)
                            {
                                gv.mod.currentEncounter.protectionConditionMet = true;
                            }
                        }
                    }
                    if (isPlayerTurn)
                    {
                        checkEndEncounter();
                        gv.touchEnabled = true;
                        animationState = AnimationState.None;
                        //endPcTurn(true);
                        //update all player stats in case their was a recently added spell or trait effect that would change them  
                        foreach (Player p in gv.mod.playerList)
                        {
                            gv.sf.UpdateStats(p);
                        }

                        if (gv.mod.playerList[currentPlayerIndex].hp <= 0 || gv.mod.playerList[currentPlayerIndex].isHeld())
                        {
                            endPcTurn(true);
                        }

                        if (dontEndTurn && currentCombatMode != "move")
                        {
                            //don't end turn just yet..probably called from a trait that is meant to be used right away like Power Attack or Set Trap  
                            dontEndTurn = false;
                            if (currentCombatMode != "cast")
                            {
                                currentCombatMode = "move";
                            }
                            /*
                                //update all player stats in case their was a recently added spell or trait effect that would change them  
                                foreach (Player p in gv.mod.playerList)
                                {
                                    gv.sf.UpdateStats(p);
                                }
                                */
                        }
                        else
                        {

                            if (currentCombatMode != "move")
                            {
                                endPcTurn(true);
                            }

                        }
                    }
                    else
                    {
                        animationState = AnimationState.None;

                        //if (idx >= gv.mod.currentEncounter.encounterCreatureList.Count)
                        //{
                        //idx = gv.mod.currentEncounter.encounterCreatureList.Count - 1;
                        //}
                        //if (dontEndCreatureTurn && gv.mod.currentEncounter.encounterCreatureList[idx].hp > 0 && !gv.mod.currentEncounter.encounterCreatureList[idx].isHeld())
                        //{
                        //dontEndCreatureTurn = false;
                        //animationsOn = false;
                        //}
                        //else
                        //{
                        /*
                        for (int i = gv.mod.currentEncounter.encounterCreatureList.Count-1; i >= 0; i--)
                        {
                            if (gv.mod.currentEncounter.encounterCreatureList[i].moveOrder == currentMoveOrderIndex)
                            {
                                endCreatureTurn(gv.mod.currentEncounter.encounterCreatureList[i]);
                            }
                        }
                        */
                        /*
                        if (idx >= gv.mod.currentEncounter.encounterCreatureList.Count)
                        {
                            idx = gv.mod.currentEncounter.encounterCreatureList.Count - 1;
                        }
                        endCreatureTurn(gv.mod.currentEncounter.encounterCreatureList[idx]);
                        */
                        Creature crt = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    crt = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    crt = c;
                                    break;
                                }
                            }
                        }
                        endCreatureTurn(crt);

                        //}
                    }
                }
                //below removed in order to tackle all situations of not remaning anims, not only attack situaions
                //}
                if ((gv.mod.useManualCombatCam) && (animationSeqStack.Count == 0))
                {
                    gv.touchEnabled = true;
                }
            }//animationsonend

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            if (stepAnimationsOn)
            {
                attackAnimationTimeElapsed += elapsed;
                //hurgh1000
                //if ((attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds) && ((attackAnimationFrameCounter >= maxUsableCounterValue) || (isPlayerTurn)))
                //below worked
                if ((attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds * 1.5f))
                //if ((attackAnimationTimeElapsed >= 0))
                //if ((attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds))
                {
                    //time is up, reset attack animations to null
                    creatureToAnimate.Clear();
                    playerToAnimate = null;
                    foreach (AnimationSequence seq in animationSeqStack)
                    {
                        //if(seq.AnimationSeq[0].turnFloatyTextOn)
                        if (seq.AnimationSeq.Count > 0)
                        {
                            /*
                            floatyTextOn = true; //show any floaty text in the pool
                        }
                        foreach (Sprite spr in seq.AnimationSeq[0].SpriteGroup)
                        {
                            //just update the group at the top of the stack, first in first
                            spr.Update(elapsed, gv);
                            */
                            //new
                            if (seq.AnimationSeq[0].turnFloatyTextOn)
                            {
                                floatyTextOn = true; //show any floaty text in the pool  
                            }
                            foreach (Sprite spr in seq.AnimationSeq[0].SpriteGroup)
                            {
                                //just update the group at the top of the stack, first in first  
                                spr.Update(elapsed, gv);
                            }
                            //new

                        }
                    }
                    //remove sprites if hit end of life
                    for (int aniseq = animationSeqStack.Count - 1; aniseq >= 0; aniseq--)
                    {
                        for (int stkgrp = animationSeqStack[aniseq].AnimationSeq.Count - 1; stkgrp >= 0; stkgrp--)
                        {
                            for (int sprt = animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup.Count - 1; sprt >= 0; sprt--)
                            {
                                if (animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup[sprt].timeToLiveInMilliseconds <= 0)
                                {
                                    try
                                    {
                                        animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup.RemoveAt(sprt);

                                    }
                                    catch (Exception ex)
                                    {
                                        gv.errorLog(ex.ToString());
                                    }
                                }
                            }
                            if (animationSeqStack[aniseq].AnimationSeq[stkgrp].SpriteGroup.Count == 0)
                            {
                                try
                                {
                                    animationSeqStack[aniseq].AnimationSeq.RemoveAt(stkgrp);
                                }
                                catch (Exception ex)
                                {
                                    gv.errorLog(ex.ToString());
                                }
                            }
                        }
                        if (animationSeqStack[aniseq].AnimationSeq.Count == 0)
                        {
                            try
                            {
                                animationSeqStack.RemoveAt(aniseq);
                            }
                            catch (Exception ex)
                            {
                                gv.errorLog(ex.ToString());
                            }
                        }
                    }
                    //if all animation sequences are done, end this turn
                    //below worked
                    if (animationSeqStack.Count == 0)
                    {
                        stepAnimationsOn = false;
                        deathAnimationLocations.Clear();
                        blockCreatureDrawLocations.Clear();

                        /*
                        //Creature crt = new Creature();
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (c.hp <= 0 || c.isHeld())
                            {
                                endCreatureTurn(c);
                            }
                        }
                        */

                        if (isPlayerTurn)
                        {

                            //remove any dead creatures                        
                            for (int x = gv.mod.currentEncounter.encounterCreatureList.Count - 1; x >= 0; x--)
                            {
                                if (gv.mod.currentEncounter.encounterCreatureList[x].hp <= 0)
                                {
                                    try
                                    {
                                        //do OnDeath IBScript
                                        gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScript, gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScriptParms);
                                        //project repeatable
                                        int deadIdx = (gv.mod.currentEncounter.encounterCreatureList.Count - 1) - x;
                                        if (deadIdx < idx)
                                        {
                                            idx--;
                                            if (idx < 0)
                                            {
                                                idx = 0;
                                            }
                                        }
                                        if (gv.mod.currentEncounter.assassinationVictory && gv.mod.currentEncounter.assassinationTargetTag == gv.mod.currentEncounter.encounterCreatureList[x].cr_tag)
                                        {
                                            gv.mod.currentEncounter.assassinationConditionMet = true;
                                        }
                                        gv.mod.currentEncounter.encounterCreatureList.RemoveAt(x);
                                        if (!gv.mod.currentEncounter.isRepeatable)
                                        {
                                            //gv.mod.currentEncounter.encounterCreatureRefsList.RemoveAt(x);
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        gv.errorLog(ex.ToString());
                                    }
                                }
                            }
                            foreach (Player p in gv.mod.playerList)
                            {
                                if (gv.mod.currentEncounter.protectionDefeat && gv.mod.currentEncounter.protectionTargetName == p.name)
                                {
                                    if (p.hp <= 0)
                                    {
                                        gv.mod.currentEncounter.protectionConditionMet = true;
                                    }
                                }
                            }

                            checkEndEncounter();
                            gv.touchEnabled = true;
                            animationState = AnimationState.None;
                            //endPcTurn(true);
                            if (dontEndTurn)
                            {
                                //don't end turn just yet..probably called from a trait that is meant to be used right away like Power Attack or Set Trap  
                                dontEndTurn = false;
                                if (currentCombatMode != "cast")
                                {
                                    currentCombatMode = "move";
                                }
                                //update all player stats in case their was a recently added spell or trait effect that would change them  
                                foreach (Player p in gv.mod.playerList)
                                {
                                    gv.sf.UpdateStats(p);
                                }
                            }
                            else
                            {
                                if (currentCombatMode != "move")
                                {
                                    endPcTurn(true);
                                }
                            }
                            Player tempP = new Player();
                            foreach (Player p in gv.mod.playerList)
                            {
                                if (p.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    tempP = p;
                                    break;
                                }
                            }
                            if (tempP.hp <= 0 || tempP.isHeld())
                            {
                                endPcTurn(true);
                            }

                        }
                        else
                        {
                            //alarmknopf
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }

                            //belowworked
                            if (cr.hp <= 0 || cr.isHeld())
                            {
                                endCreatureTurn(cr);
                            }
                            //belowworked
                            else
                            {
                                //remove any dead creatures                        
                                for (int x = gv.mod.currentEncounter.encounterCreatureList.Count - 1; x >= 0; x--)
                                {
                                    if (gv.mod.currentEncounter.encounterCreatureList[x].hp <= 0 && gv.mod.currentEncounter.encounterCreatureList[x] != cr)
                                    {
                                        try
                                        {
                                            //do OnDeath IBScript
                                            gv.cc.doIBScriptBasedOnFilename(gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScript, gv.mod.currentEncounter.encounterCreatureList[x].onDeathIBScriptParms);
                                            //project repeatable
                                            int deadIdx = (gv.mod.currentEncounter.encounterCreatureList.Count - 1) - x;
                                            if (deadIdx < idx)
                                            {
                                                idx--;
                                                if (idx < 0)
                                                {
                                                    idx = 0;
                                                }
                                            }
                                            if (gv.mod.currentEncounter.assassinationVictory && gv.mod.currentEncounter.assassinationTargetTag == gv.mod.currentEncounter.encounterCreatureList[x].cr_tag)
                                            {
                                                gv.mod.currentEncounter.assassinationConditionMet = true;
                                            }
                                            gv.mod.currentEncounter.encounterCreatureList.RemoveAt(x);
                                            if (!gv.mod.currentEncounter.isRepeatable)
                                            {
                                                //gv.mod.currentEncounter.encounterCreatureRefsList.RemoveAt(x);
                                            }
                                        }
                                        catch (Exception ex)
                                        {
                                            gv.errorLog(ex.ToString());
                                        }
                                    }
                                }
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (gv.mod.currentEncounter.protectionDefeat && gv.mod.currentEncounter.protectionTargetName == p.name)
                                    {
                                        if (p.hp <= 0)
                                        {
                                            gv.mod.currentEncounter.protectionConditionMet = true;
                                        }
                                    }
                                }
                            }




                            //animationState = AnimationState.None;

                            //if (idx >= gv.mod.currentEncounter.encounterCreatureList.Count)
                            //{
                            //idx = gv.mod.currentEncounter.encounterCreatureList.Count - 1;
                            //}
                            //if (dontEndCreatureTurn && gv.mod.currentEncounter.encounterCreatureList[idx].hp > 0 && !gv.mod.currentEncounter.encounterCreatureList[idx].isHeld())
                            //{
                            //dontEndCreatureTurn = false;
                            //animationsOn = false;
                            //}
                            //else
                            //{
                            /*
                            for (int i = gv.mod.currentEncounter.encounterCreatureList.Count-1; i >= 0; i--)
                            {
                                if (gv.mod.currentEncounter.encounterCreatureList[i].moveOrder == currentMoveOrderIndex)
                                {
                                    endCreatureTurn(gv.mod.currentEncounter.encounterCreatureList[i]);
                                }
                            }
                            */
                            /*
                            if (idx >= gv.mod.currentEncounter.encounterCreatureList.Count)
                            {
                                idx = gv.mod.currentEncounter.encounterCreatureList.Count - 1;
                            }
                            endCreatureTurn(gv.mod.currentEncounter.encounterCreatureList[idx]);
                            */
                            /*
                            Creature crt = new Creature();
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    crt = c;
                                    break;
                                }
                            }
                            */
                            //endCreatureTurn(crt);

                            //}
                        }
                    }
                }
                if ((gv.mod.useManualCombatCam) && (animationSeqStack.Count == 0) && (spriteList.Count == 0))
                {
                    gv.touchEnabled = true;
                }
            }//animationsonend


            //firsttry
            /*
            if (!animationsOn && !stepAnimationsOn)
            {
                if (!isPlayerTurn)
                {
                    animationState = AnimationState.None;

                    Creature crt = new Creature();
                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            crt = c;
                            break;
                        }
                    }
                    
                    if ((crt.moveDistance - creatureMoves) < 1)
                    {
                        endCreatureTurn(crt);
                    }
                }
            }
            */
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            #endregion

            #region FLOATY TEXT
            if (floatyTextOn || floatyTextEnlargerOn)
            {
                //move up 50pxl per second (50px/1000ms)*elapsed
                float multiplier = 100.0f / gv.mod.attackAnimationSpeed;
                int shiftUp = (int)(0.05f * elapsed * multiplier);
                if (shiftUp < 1)
                {
                    shiftUp = 1;
                }
                foreach (FloatyText ft in gv.cc.floatyTextList)
                {
                    ft.location.Y -= shiftUp;
                    ft.timeToLive -= (int)(elapsed * multiplier);
                }
                //remove sprite if hit end of life
                for (int x = gv.cc.floatyTextList.Count - 1; x >= 0; x--)
                {
                    if (gv.cc.floatyTextList[x].timeToLive <= 0)
                    {
                        try
                        {
                            gv.cc.floatyTextList.RemoveAt(x);
                        }
                        catch (Exception ex)
                        {
                            gv.errorLog(ex.ToString());
                        }
                    }
                }
                if (gv.cc.floatyTextList.Count == 0)
                {
                    if (floatyTextOn)
                    {
                        floatyTextOn = false;
                    }
                    if (floatyTextEnlargerOn)
                    {
                        floatyTextEnlargerOn = false;
                    }
                }
            }
            #endregion
        }



        //we will need player covered squares, too
        public void refreshCreatureCoveredSquares()
        {
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                crt.tokenCoveredSquares.Clear();
                //add normal creature size square location first...add other sizes as needed  
                crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX, crt.combatLocY));

                int width = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Width;
                int height = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Height;
                //1=normal, 2=wide, 3=tall, 4=large  
                int crtSize = crt.creatureSize;

                //wide  
                if (crtSize == 2)
                {
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX + 1, crt.combatLocY));
                }
                //tall  
                else if (crtSize == 3)
                {
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX, crt.combatLocY + 1));
                }
                //large  
                else if (crtSize == 4)
                {
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX + 1, crt.combatLocY));
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX, crt.combatLocY + 1));
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX + 1, crt.combatLocY + 1));
                }
            }
        }

        //not used yet
        //will not be easy, think eg attacking by bump - with which part?
        public void refreshPlayerCoveredSquares()
        {
            foreach (Player crt in gv.mod.playerList)
            {
                crt.tokenCoveredSquares.Clear();
                //add normal creature size square location first...add other sizes as needed  
                crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX, crt.combatLocY));

                int width = gv.cc.GetFromBitmapList(crt.tokenFilename).PixelSize.Width;
                int height = gv.cc.GetFromBitmapList(crt.tokenFilename).PixelSize.Height;
                //1=normal, 2=wide, 3=tall, 4=large  
                int crtSize = crt.playerSize;

                //wide  
                if (crtSize == 2)
                {
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX + 1, crt.combatLocY));
                }
                //tall  
                else if (crtSize == 3)
                {
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX, crt.combatLocY + 1));
                }
                //large  
                else if (crtSize == 4)
                {
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX + 1, crt.combatLocY));
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX, crt.combatLocY + 1));
                    crt.tokenCoveredSquares.Add(new Coordinate(crt.combatLocX + 1, crt.combatLocY + 1));
                }
            }
        }

        public void scrollOnCreatureMove(float elapsed)
        {
            if (!isPlayerTurn)
            {
                //float glideSpeed = 4.75f * (100f / gv.mod.combatAnimationSpeed) * elapsed / 30f;
                float glideSpeed = 7.5f * (100f / gv.mod.combatAnimationSpeed) * elapsed / 30f;
                Creature cr = new Creature();
                int highestLivingCrtMoveOrderfound = 0;
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (currentMoveOrderIndex == 0)
                    {
                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                        {
                            highestLivingCrtMoveOrderfound = c.moveOrder;
                            cr = c;
                        }
                    }
                    else
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            cr = c;
                            break;
                        }
                    }
                }

                if (gv.mod.useCombatSmoothMovement)
                {
                    if ((cr.combatLocX != cr.newCoor.X) || (cr.combatLocY != cr.newCoor.Y))
                    {
                        if ((cr.newCoor.X != -1) && (cr.newCoor.Y != -1))
                        {
                            //glide east
                            if ((cr.combatLocX < cr.newCoor.X) && (cr.combatLocY == cr.newCoor.Y))
                            {
                                cr.glideAdderX += 0.5f * glideSpeed;
                                if (getPixelLocX(cr.combatLocX) + cr.glideAdderX >= getPixelLocX(cr.newCoor.X))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide west
                            if ((cr.combatLocX > cr.newCoor.X) && (cr.combatLocY == cr.newCoor.Y))
                            {
                                cr.glideAdderX -= 0.5f * glideSpeed;
                                if (getPixelLocX(cr.combatLocX) + cr.glideAdderX <= getPixelLocX(cr.newCoor.X))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide north
                            if ((cr.combatLocX == cr.newCoor.X) && (cr.combatLocY > cr.newCoor.Y))
                            {
                                cr.glideAdderY -= 0.5f * glideSpeed;
                                if (getPixelLocY(cr.combatLocY) + cr.glideAdderY <= getPixelLocY(cr.newCoor.Y))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide south
                            if ((cr.combatLocX == cr.newCoor.X) && (cr.combatLocY < cr.newCoor.Y))
                            {
                                cr.glideAdderY += 0.5f * glideSpeed;
                                if (getPixelLocY(cr.combatLocY) + cr.glideAdderY >= getPixelLocY(cr.newCoor.Y))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide southeast
                            if ((cr.combatLocX < cr.newCoor.X) && (cr.combatLocY < cr.newCoor.Y))
                            {
                                cr.glideAdderX += 0.5f * glideSpeed;
                                cr.glideAdderY += 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX >= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY >= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide southwest
                            if ((cr.combatLocX > cr.newCoor.X) && (cr.combatLocY < cr.newCoor.Y))
                            {
                                cr.glideAdderX -= 0.5f * glideSpeed;
                                cr.glideAdderY += 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX <= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY >= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide northwest
                            if ((cr.combatLocX > cr.newCoor.X) && (cr.combatLocY > cr.newCoor.Y))
                            {
                                cr.glideAdderX -= 0.5f * glideSpeed;
                                cr.glideAdderY -= 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX <= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY <= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide northeast
                            if ((cr.combatLocX < cr.newCoor.X) && (cr.combatLocY > cr.newCoor.Y))
                            {
                                cr.glideAdderX += 0.5f * glideSpeed;
                                cr.glideAdderY -= 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX >= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY <= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                        }
                    }
                }
            }
        }
        #region Combat Draw
        public void redrawCombat(float elapsed)
        {
            drawCombatMap();
            drawProps(elapsed);
            drawEffectSquares();
            drawCombatPlayers();

            if (gv.mod.useCombatSmoothMovement == false)
            {
                drawCombatCreatures();
            }
            else
            {
                drawMovingCombatCreatures(elapsed);
            }

            drawSprites();
            drawHeightShadows();

            if (gv.mod.currentEncounter.UseDayNightCycle)
            {
                drawOverlayTints();
            }
            if (!animationsOn)
            {
                drawTargetHighlight();
                drawLosTrail();
            }
            
            drawHPText();
            drawSPText();
            drawFloatyText();
            drawFloatyTextList(elapsed);
            drawActorFloatyOnMouseOver();

            scrollOnCreatureMove(elapsed);

            //draw hotkey text
            if (gv.showHotKeys)
            {
                drawCombatHotKeys();
            }

            //started work on iniative bar for creatures and pc
            if (showIniBar)
            {
                for (int j = 0; j < combatUiLayout.panelList.Count; j++)
                {
                    if (combatUiLayout.panelList[j].tag.Equals("InitiativePanel"))
                    {
                        if ((combatUiLayout.panelList[j].currentLocX) > (combatUiLayout.panelList[j].hiddenLocX))
                        {
                            if (ListOfCreaturesDisplayedInCurrentBar.Count > 0)
                            {
                                drawInitiativeBar();
                            }
                        }
                    }
                }
            }
            drawUiLayout();
        }

        public void drawHeightShadows()
        {
            for (int y = 0; y < gv.mod.currentEncounter.MapSizeY; y++)
            {
                for (int x = 0; x < gv.mod.currentEncounter.MapSizeX; x++)
                {

                    TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                    SharpDX.RectangleF src = new SharpDX.RectangleF(0, 0, gv.cc.GetFromBitmapList("longShadow").PixelSize.Width, gv.cc.GetFromBitmapList("longShadow").PixelSize.Height);
                    //SharpDX.RectangleF dst = new SharpDX.RectangleF(getPixelLocX(x), getPixelLocY(y) + (float)(gv.squareSize * 0.5f), (gv.squareSize), (gv.squareSize));
                    SharpDX.RectangleF dst = new SharpDX.RectangleF(getPixelLocX(x), getPixelLocY(y) + gv.oYshift, (gv.squareSize), (gv.squareSize));
                    if (!isPlayerTurn)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        //tlX = (x - UpperLeftSquare.X) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                        //tlY = (y - UpperLeftSquare.Y) * gv.squareSize - (int)cr.glideAdderY;
                        dst = new SharpDX.RectangleF(getPixelLocX(x) - cr.glideAdderX, getPixelLocY(y) + gv.oYshift - cr.glideAdderY, (gv.squareSize), (gv.squareSize));

                    }


                    //gv.oYshift
                    if (tile.isInShortShadeN)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadow"), src, dst, 180, false);
                    }

                    if (tile.isInShortShadeE)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadow"), src, dst, 270, false);
                    }

                    if (tile.isInShortShadeS)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadow"), src, dst, 0, false);
                    }

                    if (tile.isInShortShadeW)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadow"), src, dst, 90, false);
                    }

                    if (tile.isInShortShadeNW && !tile.isInShortShadeN && !tile.isInShortShadeW)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadowCorner"), src, dst, 180, false);
                    }

                    if (tile.isInShortShadeNE && !tile.isInShortShadeN && !tile.isInShortShadeE)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadowCorner"), src, dst, 270, false);
                    }

                    if (tile.isInShortShadeSW && !tile.isInShortShadeS && !tile.isInShortShadeW)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadowCorner"), src, dst, 90, false);
                    }

                    if (tile.isInShortShadeSE && !tile.isInShortShadeS && !tile.isInShortShadeE)
                    {
                        gv.DrawD2DBitmap(gv.cc.GetFromBitmapList("shortShadowCorner"), src, dst, 0, false);
                    }
                }
            }
        }
        public void drawCombatHotKeys()
        {
            int txtH = (int)gv.drawFontRegHeight;
            int lineCounter = 1;
            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Show/Hide Hotkeys: H", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Show/Hide Hotkeys: H", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Show/Hide Interface: X", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Show/Hide Interface: X", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            //lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Scroll log up: R / mouse wheel up", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Scroll log up: R / mouse wheel up", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Scroll log down: F / mouse wheel down", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Scroll log down: F / mouse wheel down", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Attack mode: K", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Attack mode: K", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move mode: M", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move mode: M", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move up: Keypad8 / (W or arrow up)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move up: Keypad8 / (W or arrow up)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move down: Keypad2 / (S or arrow down)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move down: Keypad2 / (S or arrow down)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move right: Keypad6 / (D or arrow right)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move right: Keypad6 / (D or arrow right)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move left: Keypad4 / (A or arrow left)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move left: Keypad4 / (A or arrow left)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move diagonal up-left: Keypad7 / (Q)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move diagonal up-left: Keypad7 / (Q)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move diagonal up-right: Keypad9 / (E)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move diagonal up-right: Keypad9 / (E)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move diagonal bottom-left: Keypad1 / (Y,Z)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move diagonal bottom-left: Keypad1 / (Y,Z)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move diagonal bottom-right: Keypad3 / (C)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Move diagonal bottom-right: Keypad3 / (C)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Camera up: (W or arrow up)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Camera up: (W or arrow up)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Camera down: (S or arrow down)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Camera down: (S or arrow down)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Camera right: (D or arrow right)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Camera right: (D or arrow right)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Camera left: (A or arrow left)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            */
            gv.DrawTextOutlinedRect("Camera left: (A or arrow left)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;
        }

        public void drawProps(float elapsed)
        {

            Creature cr = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        cr = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        cr = c;
                        break;
                    }
                }
            }


            //code for drawing conquer and hold locations
            if (gv.mod.currentEncounter.conquerVictory)
            {
                if (gv.mod.currentEncounter.conquerTarget1X != -1 && gv.mod.currentEncounter.conquerTarget1Y != -1)
                {
                    IbRect src = new IbRect(0, 0, gv.cc.GetFromBitmapList("conquerLocation").PixelSize.Width, gv.cc.GetFromBitmapList("conquerLocation").PixelSize.Width);
                    IbRect dst = new IbRect(getPixelLocX(gv.mod.currentEncounter.conquerTarget1X), getPixelLocY(gv.mod.currentEncounter.conquerTarget1Y), gv.squareSize, gv.squareSize);
                    if (!isPlayerTurn)
                    {
                        dst = new IbRect(getPixelLocX(gv.mod.currentEncounter.conquerTarget1X) - (int)cr.glideAdderX, getPixelLocY(gv.mod.currentEncounter.conquerTarget1Y) - (int)cr.glideAdderY, gv.squareSize, gv.squareSize);
                    }
                    gv.DrawBitmap(gv.cc.GetFromBitmapList("conquerLocation"), src, dst);
                }
            }

            if (gv.mod.currentEncounter.holdDefeat)
            {
                if (gv.mod.currentEncounter.holdTarget1X != -1 && gv.mod.currentEncounter.holdTarget1Y != -1)
                {
                    IbRect src = new IbRect(0, 0, gv.cc.GetFromBitmapList("holdLocation").PixelSize.Width, gv.cc.GetFromBitmapList("holdLocation").PixelSize.Width);
                    IbRect dst = new IbRect(getPixelLocX(gv.mod.currentEncounter.holdTarget1X), getPixelLocY(gv.mod.currentEncounter.holdTarget1Y), gv.squareSize, gv.squareSize);
                    if (!isPlayerTurn)
                    {
                        dst = new IbRect(getPixelLocX(gv.mod.currentEncounter.holdTarget1X) - (int)cr.glideAdderX, getPixelLocY(gv.mod.currentEncounter.holdTarget1Y) - (int)cr.glideAdderY, gv.squareSize, gv.squareSize);
                    }

                    gv.DrawBitmap(gv.cc.GetFromBitmapList("holdLocation"), src, dst);

                }
            }

            foreach (Prop prp in gv.mod.currentEncounter.propsList)
            {

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if (prp.maxNumberOfFrames > 1)
                {
                    if (prp.animationIsActive)
                    {
                        float fadeAmount = 0;
                        if (prp.framesNeededForFullFadeInOut > 0)
                        {
                            fadeAmount = 1f / prp.framesNeededForFullFadeInOut;
                            if (prp.totalFramesInWholeLoopCounter <= prp.framesNeededForFullFadeInOut)
                            {
                                prp.opacity = fadeAmount * prp.totalFramesInWholeLoopCounter;
                                if (prp.opacity > 1)
                                {
                                    prp.opacity = 1;
                                }
                            }

                            else if (prp.totalFramesInWholeLoopCounter >= ((prp.maxNumberOfFrames * prp.numberOfCyclesNeededForCompletion) - prp.framesNeededForFullFadeInOut))
                            {
                                int framesLeft = (prp.maxNumberOfFrames * prp.numberOfCyclesNeededForCompletion) - prp.totalFramesInWholeLoopCounter;
                                prp.opacity = framesLeft * fadeAmount;
                            }
                            else
                            {
                                prp.opacity = 1;
                            }
                        }

                        //prp.drawAnimatedProp = true;
                        if ((prp.maxNumberOfFrames > 1) && (!prp.animationComplete))
                        {
                            //prp.animationDelayCounter += (300f / elapsed);
                            prp.animationDelayCounter += (elapsed / 2f);

                            if (prp.animationDelayCounter >= prp.updateTicksNeededTillNextFrame)
                            {

                                #region forwardDirection
                                //if (!prp.inverseAnimationDirection)
                                //{
                                prp.currentFrameNumber++;
                                prp.totalFramesInWholeLoopCounter++;
                                prp.animationDelayCounter = 0;
                                if (prp.currentFrameNumber > (prp.maxNumberOfFrames - 1))
                                {
                                    prp.currentFrameNumber = 0;

                                    //enter new conditional for multiple cylces required before compleetion here
                                    if (prp.numberOfCyclesNeededForCompletion <= 1)
                                    {
                                        if (prp.randomAnimationDirectionEachCall)
                                        {
                                            int decider = gv.sf.RandInt(0, 100);
                                            if (decider >= 50)
                                            {
                                                prp.inverseAnimationDirection = true;
                                            }
                                            else
                                            {
                                                prp.inverseAnimationDirection = false;
                                            }
                                        }

                                        prp.animationComplete = true;
                                        prp.totalFramesInWholeLoopCounter = 0;
                                        if (prp.hiddenWhenComplete)
                                        {
                                            prp.drawAnimatedProp = false;
                                        }
                                    }
                                    else
                                    {
                                        prp.cycleCounter++;
                                        if (prp.cycleCounter == prp.numberOfCyclesNeededForCompletion)
                                        {
                                            if (prp.randomAnimationDirectionEachCall)
                                            {
                                                int decider = gv.sf.RandInt(0, 100);
                                                if (decider >= 50)
                                                {
                                                    prp.inverseAnimationDirection = true;
                                                }
                                                else
                                                {
                                                    prp.inverseAnimationDirection = false;
                                                }
                                            }

                                            prp.animationComplete = true;
                                            prp.cycleCounter = 0;
                                            prp.totalFramesInWholeLoopCounter = 0;
                                            if (prp.hiddenWhenComplete)
                                            {
                                                prp.drawAnimatedProp = false;
                                            }
                                        }
                                    }
                                }
                                //}
                                #endregion
                                /*
                                #region backwardsDirection
                                else
                                {
                                    prp.currentFrameNumber--;
                                    prp.totalFramesInWholeLoopCounter--;
                                    prp.animationDelayCounter = 0;
                                    if (prp.currentFrameNumber > (prp.maxNumberOfFrames - 1))
                                    {
                                        prp.currentFrameNumber = 0;

                                    //enter new conditional for multiple cylces required before compleetion here
                                    if (prp.numberOfCyclesNeededForCompletion <= 1)
                                    {
                                        prp.animationComplete = true;
                                        prp.totalFramesInWholeLoopCounter = 0;
                                        if (prp.hiddenWhenComplete)
                                        {
                                            prp.drawAnimatedProp = false;
                                        }
                                    }
                                    else
                                    {
                                        prp.cycleCounter++;
                                        if (prp.cycleCounter == prp.numberOfCyclesNeededForCompletion)
                                        {
                                            if (prp.randomAnimationDirectionEachCall)
                                            {
                                                int decider = gv.sf.RandInt(0, 100);
                                                if (decider >= 50)
                                                {
                                                    prp.inverseAnimationDirection = true;
                                                }
                                                else
                                                {
                                                    prp.inverseAnimationDirection = false;
                                                }
                                            }

                                            prp.animationComplete = true;
                                            prp.cycleCounter = 0;
                                            prp.totalFramesInWholeLoopCounter = 0;
                                            if (prp.hiddenWhenComplete)
                                            {
                                                prp.drawAnimatedProp = false;
                                            }
                                        }
                                    }
                                }
                            } 

                                #endregion
                                */
                            }
                        }

                        if (prp.animationComplete)
                        {
                            if (prp.doOnce)
                            {
                                prp.animationIsActive = false;
                            }

                            if (prp.animationIsActive)
                            {
                                if (prp.chanceToTriggerAnimationCycle >= 100)
                                {
                                    prp.animationComplete = false;
                                    prp.drawAnimatedProp = true;
                                }
                                else
                                {
                                    prp.normalizedTime += (1 / elapsed);
                                    if (prp.normalizedTime >= 1)
                                    {
                                        prp.normalizedTime = 0;
                                        float rollRandom = gv.sf.RandInt(100);
                                        if (rollRandom <= prp.chanceToTriggerAnimationCycle)
                                        {
                                            prp.animationComplete = false;
                                            prp.drawAnimatedProp = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //animation is not active
                    else
                    {
                        if (prp.hiddenWhenNotActive)
                        {
                            prp.drawAnimatedProp = false;
                        }
                    }
                }


                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                int framePosition = prp.currentFrameNumber;
                if (prp.inverseAnimationDirection)
                {
                    framePosition = (prp.maxNumberOfFrames - 1) - prp.currentFrameNumber;
                }
                //IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                //IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);


                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                //IbRect src = new IbRect(0, 0, gv.cc.GetFromBitmapList(prp.ImageFileName).PixelSize.Width, gv.cc.GetFromBitmapList(prp.ImageFileName).PixelSize.Width);
                IbRect src = new IbRect(0, framePosition * prp.propFrameHeight, gv.cc.GetFromBitmapList(prp.ImageFileName).PixelSize.Width, gv.cc.GetFromBitmapList(prp.ImageFileName).PixelSize.Width);
                IbRect dst = new IbRect(getPixelLocX(prp.LocationX), getPixelLocY(prp.LocationY), gv.squareSize, gv.squareSize);
                if (!isPlayerTurn)
                {
                    dst = new IbRect(getPixelLocX(prp.LocationX) - (int)cr.glideAdderX, getPixelLocY(prp.LocationY) - (int)cr.glideAdderY, gv.squareSize, gv.squareSize);
                }

                bool skipDraw = false;
                foreach (Trigger t in gv.mod.currentEncounter.Triggers)
                {
                    foreach (Coordinate coord in t.TriggerSquaresList)
                    {
                        if (coord.X == prp.LocationX && coord.Y == prp.LocationY)
                        {
                            if (t.chkTrigHidden)
                            {
                                skipDraw = true;
                            }
                        }
                    }
                }
                if (!skipDraw)
                {
                    gv.DrawBitmap(gv.cc.GetFromBitmapList(prp.ImageFileName), src, dst);
                }
            }
        }

        public void drawEffectSquares()
        {

            Creature cr = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        cr = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        cr = c;
                        break;
                    }
                }
            }
            foreach (Effect ef in gv.mod.currentEncounter.effectsList)
            {
                IbRect src = new IbRect(0, 0, gv.cc.GetFromBitmapList(ef.squareIndicatorFilename).PixelSize.Width, gv.cc.GetFromBitmapList(ef.squareIndicatorFilename).PixelSize.Width);
                IbRect dst = new IbRect(getPixelLocX(ef.combatLocX), getPixelLocY(ef.combatLocY), gv.squareSize, gv.squareSize);
                if (!isPlayerTurn)
                {
                    dst = new IbRect(getPixelLocX(ef.combatLocX) - (int)cr.glideAdderX, getPixelLocY(ef.combatLocY) - (int)cr.glideAdderY, gv.squareSize, gv.squareSize);
                }
                gv.DrawBitmap(gv.cc.GetFromBitmapList(ef.squareIndicatorFilename), src, dst);
            }
        }

        public void recalculateCreaturesShownInInitiativeBar()
        {
            numberOfCurrentlyShownBar = 1;

            ListOfCreaturesDisplayedInCurrentBar.Clear();
            ListOfSizesOfCreaturesInCurrentBar.Clear();

            ListOfCreaturesDisplayedInBar1.Clear();
            ListOfCreaturesDisplayedInBar2.Clear();
            ListOfCreaturesDisplayedInBar3.Clear();
            ListOfCreaturesDisplayedInBar4.Clear();
            ListOfCreaturesDisplayedInBar5.Clear();
            ListOfCreaturesDisplayedInBar6.Clear();

            ListOfSizesOfCreaturesInBar1.Clear();
            ListOfSizesOfCreaturesInBar2.Clear();
            ListOfSizesOfCreaturesInBar3.Clear();
            ListOfSizesOfCreaturesInBar4.Clear();
            ListOfSizesOfCreaturesInBar5.Clear();
            ListOfSizesOfCreaturesInBar6.Clear();

            NumberOfButtonsDisplayedInBar1 = 0;
            NumberOfButtonsDisplayedInBar2 = 0;
            NumberOfButtonsDisplayedInBar3 = 0;
            NumberOfButtonsDisplayedInBar4 = 0;
            NumberOfButtonsDisplayedInBar5 = 0;
            NumberOfButtonsDisplayedInBar6 = 0;

            NumberOfBackgroundTilesDisplayedInBar1 = 0;
            NumberOfBackgroundTilesDisplayedInBar2 = 0;
            NumberOfBackgroundTilesDisplayedInBar3 = 0;
            NumberOfBackgroundTilesDisplayedInBar4 = 0;
            NumberOfBackgroundTilesDisplayedInBar5 = 0;
            NumberOfBackgroundTilesDisplayedInBar6 = 0;

            moverOrdersOfAllLivingCreatures.Clear();
            moverOrdersOfAllFallenCreatures.Clear();
            moverOrdersOfLargeLivingCreatures.Clear();
            moverOrdersOfLargeFallenCreatures.Clear();
            moverOrdersOfNormalLivingCreatures.Clear();
            moverOrdersOfNormalFallenCreatures.Clear();

            foreach (MoveOrder m in moveOrderList)
            {
                if (m.PcOrCreature is Player)
                {
                    Player crt = (Player)m.PcOrCreature;
                    if (crt.hp <= 0)
                    {
                        //if (crt.token.PixelSize.Width > 100)
                        //{
                        //moverOrdersOfLargeFallenCreatures.Add(crt.moveOrder);
                        //}
                        //else
                        //{
                        moverOrdersOfNormalFallenCreatures.Add(crt.moveOrder);
                        //}
                    }
                    else
                    {
                        moverOrdersOfAllLivingCreatures.Add(crt.moveOrder);
                        //if (crt.token.PixelSize.Width > 100)
                        //if (crt.creatureSize == 4 || crt.creatureSize == 2)
                        //{
                        //moverOrdersOfLargeLivingCreatures.Add(crt.moveOrder);
                        //}
                        //else
                        //{
                        moverOrdersOfNormalLivingCreatures.Add(crt.moveOrder);
                        //}
                    }
                }
                else
                {
                    Creature crt = (Creature)m.PcOrCreature;
                    if (crt.hp <= 0)
                    {
                        if (crt.creatureSize == 4 || crt.creatureSize == 2)
                        {
                            moverOrdersOfLargeFallenCreatures.Add(crt.moveOrder);
                        }
                        else
                        {
                            moverOrdersOfNormalFallenCreatures.Add(crt.moveOrder);
                        }
                    }
                    else
                    {
                        moverOrdersOfAllLivingCreatures.Add(crt.moveOrder);
                        //if (crt.token.PixelSize.Width > 100)
                        if (crt.creatureSize == 4 || crt.creatureSize == 2)
                        {
                            moverOrdersOfLargeLivingCreatures.Add(crt.moveOrder);
                        }
                        else
                        {
                            moverOrdersOfNormalLivingCreatures.Add(crt.moveOrder);
                        }
                    }
                }
            }




            //calculate buttons/i needed
            int buttonsNeededOverall = 0;

            buttonsNeededOverall = (moverOrdersOfLargeLivingCreatures.Count) * 2;
            buttonsNeededOverall += moverOrdersOfNormalLivingCreatures.Count;
            //buttonsNeededOverall += moverOrdersOfTallLivingCreatures.Count;
            //buttonsNeededOverall += (moverOrdersOfWideLivingCreatures.Count) * 2;

            //determine number of inibars needed
            int numberOfIniBarsNeeded = 1;

            //not certain of rounding rules, too lazy to look up ;-)
            for (int i = 1; i <= buttonsNeededOverall; i++)
            {
                if (i == 35)
                {
                    numberOfIniBarsNeeded++;
                }

                if (i == 69)
                {
                    numberOfIniBarsNeeded++;
                }

                if (i == 103)
                {
                    numberOfIniBarsNeeded++;
                }

                if (i == 137)
                {
                    numberOfIniBarsNeeded++;
                }

                if (i == 171)
                {
                    numberOfIniBarsNeeded++;
                }
            }

            int indexIAdderForDrawnLargeCreatures = 0;
            for (int barNumber = 1; barNumber <= numberOfIniBarsNeeded; barNumber++)
            {
                int nextBarMoveOrderAdder = (barNumber - 1) * 34;

                for (int i = 0 + nextBarMoveOrderAdder; i < 34 + nextBarMoveOrderAdder; i++)
                {
                    if (barNumber == 1)
                    {
                        if ((i - indexIAdderForDrawnLargeCreatures) <= moverOrdersOfAllLivingCreatures.Count - 1)
                        {
                            ListOfCreaturesDisplayedInBar1.Add(moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures]);
                            bool foundLargeCreature = false;
                            foreach (int moveOrder in moverOrdersOfLargeLivingCreatures)
                            {
                                if (moveOrder == moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures])
                                {
                                    foundLargeCreature = true;
                                    ListOfSizesOfCreaturesInBar1.Add(2);
                                    indexIAdderForDrawnLargeCreatures++;
                                    i++;
                                    break;
                                }
                            }

                            if (!foundLargeCreature)
                            {
                                ListOfSizesOfCreaturesInBar1.Add(1);
                            }
                        }
                    }

                    if (barNumber == 2)
                    {
                        if ((i - indexIAdderForDrawnLargeCreatures) <= moverOrdersOfAllLivingCreatures.Count - 1)
                        {
                            ListOfCreaturesDisplayedInBar2.Add(moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures]);
                            bool foundLargeCreature = false;
                            foreach (int moveOrder in moverOrdersOfLargeLivingCreatures)
                            {
                                if (moveOrder == moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures])
                                {
                                    foundLargeCreature = true;
                                    ListOfSizesOfCreaturesInBar2.Add(2);
                                    indexIAdderForDrawnLargeCreatures++;
                                    i++;
                                    break;
                                }
                            }

                            if (!foundLargeCreature)
                            {
                                ListOfSizesOfCreaturesInBar2.Add(1);
                            }
                        }
                    }

                    if (barNumber == 3)
                    {
                        if ((i - indexIAdderForDrawnLargeCreatures) <= moverOrdersOfAllLivingCreatures.Count - 1)
                        {
                            ListOfCreaturesDisplayedInBar3.Add(moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures]);
                            bool foundLargeCreature = false;
                            foreach (int moveOrder in moverOrdersOfLargeLivingCreatures)
                            {
                                if (moveOrder == moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures])
                                {
                                    foundLargeCreature = true;
                                    ListOfSizesOfCreaturesInBar3.Add(2);
                                    indexIAdderForDrawnLargeCreatures++;
                                    i++;
                                    break;
                                }
                            }

                            if (!foundLargeCreature)
                            {
                                ListOfSizesOfCreaturesInBar3.Add(1);
                            }
                        }
                    }

                    if (barNumber == 4)
                    {
                        if ((i - indexIAdderForDrawnLargeCreatures) <= moverOrdersOfAllLivingCreatures.Count - 1)
                        {
                            ListOfCreaturesDisplayedInBar4.Add(moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures]);
                            bool foundLargeCreature = false;
                            foreach (int moveOrder in moverOrdersOfLargeLivingCreatures)
                            {
                                if (moveOrder == moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures])
                                {
                                    foundLargeCreature = true;
                                    ListOfSizesOfCreaturesInBar4.Add(2);
                                    indexIAdderForDrawnLargeCreatures++;
                                    i++;
                                    break;
                                }
                            }

                            if (!foundLargeCreature)
                            {
                                ListOfSizesOfCreaturesInBar4.Add(1);
                            }
                        }
                    }

                    if (barNumber == 5)
                    {
                        if ((i - indexIAdderForDrawnLargeCreatures) <= moverOrdersOfAllLivingCreatures.Count - 1)
                        {
                            ListOfCreaturesDisplayedInBar5.Add(moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures]);
                            bool foundLargeCreature = false;
                            foreach (int moveOrder in moverOrdersOfLargeLivingCreatures)
                            {
                                if (moveOrder == moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures])
                                {
                                    foundLargeCreature = true;
                                    ListOfSizesOfCreaturesInBar5.Add(2);
                                    indexIAdderForDrawnLargeCreatures++;
                                    i++;
                                    break;
                                }
                            }

                            if (!foundLargeCreature)
                            {
                                ListOfSizesOfCreaturesInBar5.Add(1);
                            }
                        }
                    }

                    if (barNumber == 6)
                    {
                        if ((i - indexIAdderForDrawnLargeCreatures) <= moverOrdersOfAllLivingCreatures.Count - 1)
                        {
                            ListOfCreaturesDisplayedInBar6.Add(moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures]);
                            bool foundLargeCreature = false;
                            foreach (int moveOrder in moverOrdersOfLargeLivingCreatures)
                            {
                                if (moveOrder == moverOrdersOfAllLivingCreatures[i - indexIAdderForDrawnLargeCreatures])
                                {
                                    foundLargeCreature = true;
                                    ListOfSizesOfCreaturesInBar6.Add(2);
                                    indexIAdderForDrawnLargeCreatures++;
                                    i++;
                                    break;
                                }
                            }

                            if (!foundLargeCreature)
                            {
                                ListOfSizesOfCreaturesInBar6.Add(1);
                            }

                        }

                    }
                }
            }

            //determine current bar
            bool foundCurrentBar = false;

            foreach (int moveOrder in ListOfCreaturesDisplayedInBar1)
            {
                if (moveOrder == (currentMoveOrderIndex))
                {
                    ListOfCreaturesDisplayedInCurrentBar = ListOfCreaturesDisplayedInBar1;
                    ListOfSizesOfCreaturesInCurrentBar = ListOfSizesOfCreaturesInBar1;
                    foundCurrentBar = true;
                    gv.mod.creatureCounterSubstractor = 0;
                }
            }

            if (!foundCurrentBar)
            {
                foreach (int moveOrder in ListOfCreaturesDisplayedInBar2)
                {
                    if (moveOrder == (currentMoveOrderIndex))
                    {
                        ListOfCreaturesDisplayedInCurrentBar = ListOfCreaturesDisplayedInBar2;
                        ListOfSizesOfCreaturesInCurrentBar = ListOfSizesOfCreaturesInBar2;
                        foundCurrentBar = true;
                        gv.mod.creatureCounterSubstractor = -34;
                    }
                }
            }

            if (!foundCurrentBar)
            {
                foreach (int moveOrder in ListOfCreaturesDisplayedInBar3)
                {
                    if (moveOrder == (currentMoveOrderIndex))
                    {
                        ListOfCreaturesDisplayedInCurrentBar = ListOfCreaturesDisplayedInBar3;
                        ListOfSizesOfCreaturesInCurrentBar = ListOfSizesOfCreaturesInBar3;
                        foundCurrentBar = true;
                        gv.mod.creatureCounterSubstractor = -68;
                    }
                }
            }

            if (!foundCurrentBar)
            {
                foreach (int moveOrder in ListOfCreaturesDisplayedInBar4)
                {
                    if (moveOrder == (currentMoveOrderIndex))
                    {
                        ListOfCreaturesDisplayedInCurrentBar = ListOfCreaturesDisplayedInBar4;
                        ListOfSizesOfCreaturesInCurrentBar = ListOfSizesOfCreaturesInBar4;
                        foundCurrentBar = true;
                        gv.mod.creatureCounterSubstractor = -102;
                    }
                }
            }

            if (!foundCurrentBar)
            {
                foreach (int moveOrder in ListOfCreaturesDisplayedInBar5)
                {
                    if (moveOrder == (currentMoveOrderIndex))
                    {
                        ListOfCreaturesDisplayedInCurrentBar = ListOfCreaturesDisplayedInBar5;
                        ListOfSizesOfCreaturesInCurrentBar = ListOfSizesOfCreaturesInBar5;
                        foundCurrentBar = true;
                        gv.mod.creatureCounterSubstractor = -136;
                    }
                }
            }

            if (!foundCurrentBar)
            {
                foreach (int moveOrder in ListOfCreaturesDisplayedInBar6)
                {
                    if (moveOrder == (currentMoveOrderIndex - 1))
                    {
                        ListOfCreaturesDisplayedInCurrentBar = ListOfCreaturesDisplayedInBar6;
                        ListOfSizesOfCreaturesInCurrentBar = ListOfSizesOfCreaturesInBar6;
                        foundCurrentBar = true;
                        gv.mod.creatureCounterSubstractor = -170;
                    }
                }
            }

            //actiavte the right number of buttons
            int numberOfIniButtonsToActivate = 0;
            foreach (int creatureSize in ListOfSizesOfCreaturesInCurrentBar)
            {
                numberOfIniButtonsToActivate += creatureSize;
            }

            for (int i = 0; i < numberOfIniButtonsToActivate; i++)
            {
                for (int j = 0; j < combatUiLayout.panelList.Count; j++)
                {
                    if (combatUiLayout.panelList[j].tag.Equals("InitiativePanel"))
                    {
                        if (!combatUiLayout.panelList[j].hiding)
                        {
                            combatUiLayout.panelList[j].buttonList[i].show = true;
                        }
                    }
                }
            }

            for (int i = 35; i > numberOfIniButtonsToActivate; i--)
            {
                for (int j = 0; j < combatUiLayout.panelList.Count; j++)
                {
                    if (combatUiLayout.panelList[j].tag.Equals("InitiativePanel"))
                    {
                        if (!combatUiLayout.panelList[j].hiding)
                        {
                            combatUiLayout.panelList[j].buttonList[i].show = false;
                        }
                    }
                }
            }
        }

        public void drawInitiativeBar()
        {

            //draw background as tiles needed
            int numberOfBackgroundTilesToDraw = 0;
            int creatureSpacesUsed = 0;
            foreach (int creatureSize in ListOfSizesOfCreaturesInCurrentBar)
            {
                numberOfBackgroundTilesToDraw += creatureSize;
            }

            if (ListOfSizesOfCreaturesInCurrentBar[ListOfSizesOfCreaturesInCurrentBar.Count - 1] == 2)
            {
                if (numberOfBackgroundTilesToDraw % 2 != 0)
                {
                    numberOfBackgroundTilesToDraw += 1;
                }
            }

            if (numberOfBackgroundTilesToDraw % 2 != 0)
            {
                numberOfBackgroundTilesToDraw += 1;
            }

            numberOfBackgroundTilesToDraw = numberOfBackgroundTilesToDraw / 2;

            for (int i = 0; i < numberOfBackgroundTilesToDraw; i++)
            {
                int startBarX = (0 * gv.squareSize) + gv.oXshift + mapStartLocXinPixels + 2 * gv.pS;
                int startBarY = 0 * gv.squareSize + 2 * gv.pS;
                int targetSizeX = gv.squareSize;
                int targetSizeY = gv.squareSize;
                IbRect src = new IbRect(0, 0, 100, 100);
                IbRect dst = new IbRect(startBarX + i * gv.squareSize - (int)(targetSizeX * 0.1), startBarY - (int)(targetSizeY * 0.1), (int)(targetSizeX * 1.2f), (int)(targetSizeY * 1.2f));
                gv.DrawBitmap(gv.cc.offScreen, src, dst, false, true);
            }

            //draw creature in current bar
            foreach (MoveOrder m in moveOrderList)
            {
                int moveOrderNumberOfCheckedCreatureFromAllCreatures = 0;
                bool isCreature = true;
                Player ply = new Player();
                Creature crt = new Creature();

                if (m.PcOrCreature is Player)
                {
                    isCreature = false;
                    ply = (Player)m.PcOrCreature;
                    moveOrderNumberOfCheckedCreatureFromAllCreatures = ply.moveOrder;
                }
                if (m.PcOrCreature is Creature)
                {
                    isCreature = true;
                    crt = (Creature)m.PcOrCreature;
                    moveOrderNumberOfCheckedCreatureFromAllCreatures = crt.moveOrder;
                }

                foreach (int m2 in ListOfCreaturesDisplayedInCurrentBar)
                {
                    if (m2 == moveOrderNumberOfCheckedCreatureFromAllCreatures)
                    {
                        //rdr4: added positive hp requirement
                        if (isCreature)
                        {
                            //rdr4: added positive hp requirement
                            if (crt.hp > 0)
                            {
                                IbRect src = new IbRect(0, 0, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                                bool isNormal = false;
                                bool isWide = false;
                                bool isTall = false;
                                bool isLarge = false;

                                //IbRect src = new IbRect(0, 0, ply.token.PixelSize.Width, ply.token.PixelSize.Width);
                                //2-frame
                                //normal
                                if (crt.token.PixelSize.Width == 100 && crt.token.PixelSize.Height == 200)
                                {
                                    src = new IbRect(0, 0, 100, 100);
                                    isNormal = true;
                                }
                                //wide
                                if (crt.token.PixelSize.Width == 200 && crt.token.PixelSize.Height == 200)
                                {
                                    src = new IbRect(0, 0, 200, 100);
                                    isWide = true;
                                }
                                //tall
                                if (crt.token.PixelSize.Width == 100 && crt.token.PixelSize.Height == 400)
                                {
                                    src = new IbRect(0, 0, 100, 200);
                                    isTall = true;
                                }
                                //large
                                if (crt.token.PixelSize.Width == 200 && crt.token.PixelSize.Height == 400)
                                {
                                    src = new IbRect(0, 0, 200, 200);
                                    isLarge = true;
                                }

                                //5-frame
                                //normal
                                if (crt.token.PixelSize.Width == 100 && crt.token.PixelSize.Height == 500)
                                {
                                    src = new IbRect(0, 0, 100, 100);
                                    isNormal = true;
                                }
                                //wide
                                if (crt.token.PixelSize.Width == 200 && crt.token.PixelSize.Height == 500)
                                {
                                    src = new IbRect(0, 0, 200, 100);
                                    isWide = true;
                                }
                                //tall
                                if (crt.token.PixelSize.Width == 100 && crt.token.PixelSize.Height == 1000)
                                {
                                    src = new IbRect(0, 0, 100, 200);
                                    isTall = true;
                                }
                                //large
                                if (crt.token.PixelSize.Width == 200 && crt.token.PixelSize.Height == 1000)
                                {
                                    src = new IbRect(0, 0, 200, 200);
                                    isLarge = true;
                                }

                                int startBarX = (0 * gv.squareSize) + gv.oXshift + mapStartLocXinPixels + 2 * gv.pS;
                                int startBarY = 0 * gv.squareSize + 2 * gv.pS;
                                int targetSizeX = gv.squareSize / 2;
                                int targetSizeY = gv.squareSize / 2;
                                int marchingLineHeight = gv.squareSize / 2;
                                if (isLarge || isWide)
                                {
                                    targetSizeX = gv.squareSize;
                                    //targetSizeY = gv.squareSize;
                                    //marchingLineHeight = 0;
                                }
                                if (isLarge || isTall)
                                {
                                    //targetSizeX = gv.squareSize;
                                    targetSizeY = gv.squareSize;
                                    marchingLineHeight = 0;
                                }
                                IbRect dst = new IbRect(startBarX + creatureSpacesUsed * gv.squareSize / 2, startBarY + marchingLineHeight, targetSizeX, targetSizeY);
                                if (crt.moveOrder + 1 == currentMoveOrderIndex)
                                {
                                    gv.DrawBitmap(gv.cc.turn_marker, src, dst, false, true);
                                }

                                gv.DrawBitmap(crt.token, src, dst, false, true);
                                int mo = crt.moveOrder + 1;
                                targetSizeX = gv.squareSize / 2;
                                targetSizeY = gv.squareSize / 2;
                                marchingLineHeight = gv.squareSize / 2;
                                dst = new IbRect(startBarX + creatureSpacesUsed * gv.squareSize / 2, startBarY + marchingLineHeight, targetSizeX, targetSizeY);
                                if (isTall || isNormal)
                                {
                                    creatureSpacesUsed++;
                                    //drawMiniText(dst.Left, dst.Top + 1 * gv.pS, mo.ToString(), Color.White);
                                    //drawMiniText(dst.Left + gv.pS, dst.Top - 5 * gv.pS, crt.hp.ToString(), Color.Red);
                                }
                                else
                                {
                                    creatureSpacesUsed++;
                                    creatureSpacesUsed++;
                                    //drawMiniText(dst.Left, dst.Top + gv.squareSize / 2 + 1 * gv.pS, mo.ToString(), Color.White);
                                    //drawMiniText(dst.Left + 3 * gv.pS, dst.Top - 3 * gv.pS, crt.hp.ToString(), Color.Red);
                                }
                                drawMiniText(dst.Left, dst.Top + 1 * gv.pS, mo.ToString(), Color.White);
                                drawMiniText(dst.Left + gv.pS, dst.Top - 5 * gv.pS, crt.hp.ToString(), Color.Red);
                            }
                        }
                        else
                        {
                            //determien which kind of token is used to get the correct frame
                            //only for old two-framers an dfull fledged-five-framers

                            bool isNormal = false;
                            bool isWide = false;
                            bool isTall = false;
                            bool isLarge = false;

                            IbRect src = new IbRect(0, 0, ply.token.PixelSize.Width, ply.token.PixelSize.Width);
                            //2-frame
                            //normal
                            if (ply.token.PixelSize.Width == 100 && ply.token.PixelSize.Height == 200)
                            {
                                src = new IbRect(0, 0, 100, 100);
                                isNormal = true;
                            }
                            //wide
                            if (ply.token.PixelSize.Width == 200 && ply.token.PixelSize.Height == 200)
                            {
                                src = new IbRect(0, 0, 200, 100);
                                isWide = true;
                            }
                            //tall
                            if (ply.token.PixelSize.Width == 100 && ply.token.PixelSize.Height == 400)
                            {
                                src = new IbRect(0, 0, 100, 200);
                                isTall = true;
                            }
                            //large
                            if (ply.token.PixelSize.Width == 200 && ply.token.PixelSize.Height == 400)
                            {
                                src = new IbRect(0, 0, 200, 200);
                                isLarge = true;
                            }

                            //5-frame
                            //normal
                            if (ply.token.PixelSize.Width == 100 && ply.token.PixelSize.Height == 500)
                            {
                                src = new IbRect(0, 0, 100, 100);
                                isNormal = true;
                            }
                            //wide
                            if (ply.token.PixelSize.Width == 200 && ply.token.PixelSize.Height == 500)
                            {
                                src = new IbRect(0, 0, 200, 100);
                                isWide = true;
                            }
                            //tall
                            if (ply.token.PixelSize.Width == 100 && ply.token.PixelSize.Height == 1000)
                            {
                                src = new IbRect(0, 0, 100, 200);
                                isTall = true;
                            }
                            //large
                            if (ply.token.PixelSize.Width == 200 && ply.token.PixelSize.Height == 1000)
                            {
                                src = new IbRect(0, 0, 200, 200);
                                isLarge = true;
                            }
                            int startBarX = (0 * gv.squareSize) + gv.oXshift + mapStartLocXinPixels + 2 * gv.pS;
                            int startBarY = 0 * gv.squareSize + 2 * gv.pS;
                            int targetSizeX = gv.squareSize / 2;
                            int targetSizeY = gv.squareSize / 2;
                            int marchingLineHeight = gv.squareSize / 2;
                            /*
                            if (ply.token.PixelSize.Width > 100)
                            {
                                targetSizeX = gv.squareSize;
                                targetSizeY = gv.squareSize;
                                marchingLineHeight = 0;
                            }
                            */
                            IbRect dst = new IbRect(startBarX + creatureSpacesUsed * gv.squareSize / 2, startBarY + marchingLineHeight, targetSizeX, targetSizeY);
                            if (ply.moveOrder + 1 == currentMoveOrderIndex)
                            {
                                gv.DrawBitmap(gv.cc.turn_marker, src, dst, false, true);
                            }

                            gv.DrawBitmap(ply.token, src, dst, false, true);
                            int mo = ply.moveOrder + 1;
                            //if (ply.token.PixelSize.Width <= 100)
                            //{
                            creatureSpacesUsed++;
                            drawMiniText(dst.Left, dst.Top + 1 * gv.pS, mo.ToString(), Color.White);
                            drawMiniText(dst.Left + gv.pS, dst.Top - 5 * gv.pS, ply.hp.ToString(), Color.Lime);
                            //}
                            //else
                            //{
                            //creatureSpacesUsed++;
                            //creatureSpacesUsed++;
                            //drawMiniText(dst.Left, dst.Top + gv.squareSize / 2 + 1 * gv.pS, mo.ToString(), Color.White);
                            //drawMiniText(dst.Left + 3 * gv.pS, dst.Top - 3 * gv.pS, ply.hp.ToString(), Color.Lime);
                            //}
                        }

                    }
                }
            }
            /*
         //draw turn marker
         //if (crt.moveOrder + 1 == currentMoveOrderIndex)
         //{
         //gv.DrawBitmap(gv.cc.turn_marker, src, dst, false);
         //}


         //XXXXXXXXXXXXXXXXXXXXXXXXXX

         if ((gv.mod.creatureCounterSubstractor / 2f == -16) && (!gv.mod.enteredFirstTime))
     {
         gv.mod.enteredFirstTime = true;
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = currentMoveOrderIndex;
     }

     if ((gv.mod.creatureCounterSubstractor / 2f == -32) && (!gv.mod.enteredFirstTime))
     {
         gv.mod.enteredFirstTime = true;
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = currentMoveOrderIndex;
     }

     if ((gv.mod.creatureCounterSubstractor / 2f == -48) && (!gv.mod.enteredFirstTime))
     {
         gv.mod.enteredFirstTime = true;
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = currentMoveOrderIndex;
     }

     if ((gv.mod.creatureCounterSubstractor / 2f == -64) && (!gv.mod.enteredFirstTime))
     {
         gv.mod.enteredFirstTime = true;
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = currentMoveOrderIndex;
     }

     if ((gv.mod.creatureCounterSubstractor / 2f == -80) && (!gv.mod.enteredFirstTime))
     {
         gv.mod.enteredFirstTime = true;
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = currentMoveOrderIndex;
     }

     if ((gv.mod.creatureCounterSubstractor / 2f == -96) && (!gv.mod.enteredFirstTime))
     {
         gv.mod.enteredFirstTime = true;
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = currentMoveOrderIndex;
     }
     //if (currentMoveOrderIndex > gv.mod.moveOrderOfCreatureThatIsBeforeBandChange)
     //{
     float numberOfBackgroundTiles = 0;
     if ((currentMoveOrderIndex > gv.mod.moveOrderOfCreatureThatIsBeforeBandChange) || (currentMoveOrderIndex == 0))
     {
         numberOfBackgroundTiles = (gv.mod.creatureCounterSubstractor / 2f);
         gv.mod.moveOrderOfCreatureThatIsBeforeBandChange = 0;
     }

     //}
     foreach (MoveOrder m in moveOrderList)
     {
         if (m.PcOrCreature is Player)
         {
             Player crt = (Player)m.PcOrCreature;
             if (crt.hp <= 0)
             {
                 continue;
             }
             if (crt.token.PixelSize.Width > 100)
             {
                 numberOfBackgroundTiles++;
             }
             else
             {
                 numberOfBackgroundTiles += 0.5f;
             }
         }

         if (m.PcOrCreature is Creature)
         {
             Creature crt = (Creature)m.PcOrCreature;
             if (crt.hp <= 0)
             {
                 continue;
             }
             if (crt.token.PixelSize.Width > 100)
             {
                 numberOfBackgroundTiles++;
             }
             else
             {
                 numberOfBackgroundTiles += 0.5f;
             }
         }

     }

     if (numberOfBackgroundTiles > 16)
     {
         numberOfBackgroundTiles = 16;
     }

     int numberOfIniButtonsToActivate = (int)(numberOfBackgroundTiles * 2);

     for (int i = 0; i < numberOfIniButtonsToActivate; i++)
     {
         for (int j = 0; j < combatUiLayout.panelList.Count; j++)
         {
             if (combatUiLayout.panelList[j].tag.Equals("InitiativePanel"))
             {
                 if (!combatUiLayout.panelList[j].hiding)
                 {
                     combatUiLayout.panelList[j].buttonList[i].show = true;
                 }
             }
        }
     }

     for (int i = 35; i > numberOfIniButtonsToActivate; i--)
     {
         for (int j = 0; j < combatUiLayout.panelList.Count; j++)
         {
             if (combatUiLayout.panelList[j].tag.Equals("InitiativePanel"))
             {
                 if (!combatUiLayout.panelList[j].hiding)
                 {
                     combatUiLayout.panelList[j].buttonList[i].show = false;
                 }
             }
         }
     }


     for (int i = 0; i < numberOfBackgroundTiles; i++)
         {
             int startBarX = (0 * gv.squareSize) + gv.oXshift + mapStartLocXinPixels + 2*gv.pS;
             int startBarY = 0 * gv.squareSize + 2*gv.pS;
             int targetSizeX = gv.squareSize;
             int targetSizeY = gv.squareSize;
             IbRect src = new IbRect(0, 0, 100, 100);
             IbRect dst = new IbRect(startBarX + i * gv.squareSize - (int)(targetSizeX * 0.1), startBarY - (int)(targetSizeY * 0.1), (int)(targetSizeX * 1.2f), (int)(targetSizeY * 1.2f));
             gv.DrawBitmap(gv.cc.offScreen, src, dst, false);
         }

     int creatureCounter = 0;
     int creatureCounter2 = 0;
     int adderForTheFallen = 0;
     int largeCreaturesInBand = 0;
     bool enteredBand2ForFirstTime = true;
     bool enteredBand3ForFirstTime = true;
     bool enteredBand4ForFirstTime = true;
     bool enteredBand5ForFirstTime = true;
     bool enteredBand6ForFirstTime = true;
     int largeCreaturesInBandBeforeThisOne = 0;

     foreach (MoveOrder m in moveOrderList)
     {
         if (m.PcOrCreature is Player)
         {
             Player crt = (Player)m.PcOrCreature;

             if (crt.hp <= 0)
             {
                 adderForTheFallen++;
                 if (crt.token.PixelSize.Width > 100)
                 {
                     adderForTheFallen++;
                 }
             }
         }

         if (m.PcOrCreature is Creature)
         {
             Creature crt = (Creature)m.PcOrCreature;

             if (crt.hp <= 0)
             {
                 adderForTheFallen++;
                 if (crt.token.PixelSize.Width > 100)
                 {
                     adderForTheFallen++;
                 }
             }
         }

     }


         foreach (MoveOrder m in moveOrderList)
     {
         if (creatureCounter2 < 32)
         {
             if ((currentMoveOrderIndex - adderForTheFallen) < 32)
             {
                 gv.mod.creatureCounterSubstractor = 0;
             }
         }
         else if ((creatureCounter2 >= 32) && (creatureCounter2 <= 64))
         {
             if ((currentMoveOrderIndex - adderForTheFallen) <= 64)
             {
                 if (enteredBand2ForFirstTime)
                 {
                     enteredBand2ForFirstTime = false;
                     largeCreaturesInBandBeforeThisOne = largeCreaturesInBand;
                     largeCreaturesInBand = 0;
                 }
                 gv.mod.creatureCounterSubstractor = -32;
             }
         }
         else if ((creatureCounter2 >= 64) && (creatureCounter2 <= 96))
         {
             if ((currentMoveOrderIndex - adderForTheFallen) <= 96)
             {
                 if (enteredBand3ForFirstTime)
                 {
                     enteredBand3ForFirstTime = false;
                     largeCreaturesInBandBeforeThisOne = largeCreaturesInBand;
                     largeCreaturesInBand = 0;
                 }
                 gv.mod.creatureCounterSubstractor = -64;
             }
         }
         else if ((creatureCounter2 >= 96) && (creatureCounter2 <= 128))
         {
             if ((currentMoveOrderIndex - adderForTheFallen) <= 128)
             {
                 if (enteredBand4ForFirstTime)
                 {
                     enteredBand4ForFirstTime = false;
                     largeCreaturesInBandBeforeThisOne = largeCreaturesInBand;
                     largeCreaturesInBand = 0;
                 }
                 gv.mod.creatureCounterSubstractor = -96;
             }
         }
         else if ((creatureCounter2 >= 128) && (creatureCounter2 <= 160))
         {
             if ((currentMoveOrderIndex - adderForTheFallen) <= 160)
             {
                 if (enteredBand5ForFirstTime)
                 {
                     enteredBand5ForFirstTime = false;
                     largeCreaturesInBandBeforeThisOne = largeCreaturesInBand;
                     largeCreaturesInBand = 0;
                 }
                 gv.mod.creatureCounterSubstractor = -128;
             }
         }
         else if ((creatureCounter2 >= 160) && (creatureCounter2 <= 192))
         {
             if ((currentMoveOrderIndex - adderForTheFallen) <= 192)
             {
                 if (enteredBand6ForFirstTime)
                 {
                     enteredBand6ForFirstTime = false;
                     largeCreaturesInBandBeforeThisOne = largeCreaturesInBand;
                     largeCreaturesInBand = 0;
                 }
                 gv.mod.creatureCounterSubstractor = -160;
             }
         }

         if (m.PcOrCreature is Player)
         {
             Player crt = (Player)m.PcOrCreature;

             if (crt.hp <= 0)
             {
                 continue;
             }
             IbRect src = new IbRect(0, 0, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
             int startBarX = (0 * gv.squareSize) + gv.oXshift + mapStartLocXinPixels + 2*gv.pS;
             int startBarY = 0 * gv.squareSize + 2*gv.pS;
             int targetSizeX = gv.squareSize / 2;
             int targetSizeY = gv.squareSize / 2;
             int marchingLineHeight = gv.squareSize / 2;
             if (crt.token.PixelSize.Width > 100)
             {
                 targetSizeX = gv.squareSize;
                 targetSizeY = gv.squareSize;
                 marchingLineHeight = 0;
             }
             IbRect dst = new IbRect(startBarX + (creatureCounter + gv.mod.creatureCounterSubstractor) * gv.squareSize / 2, startBarY + marchingLineHeight, targetSizeX, targetSizeY);
             if (crt.moveOrder+1 == currentMoveOrderIndex)
             {
                 gv.DrawBitmap(gv.cc.turn_marker, src, dst, false);
             }

             if ((crt.moveOrder + 1 + largeCreaturesInBandBeforeThisOne + adderForTheFallen > -gv.mod.creatureCounterSubstractor) && (crt.moveOrder + largeCreaturesInBand - adderForTheFallen < (-gv.mod.creatureCounterSubstractor + 32)))
             {
                 gv.DrawBitmap(crt.token, src, dst, false);
                 int mo = crt.moveOrder + 1;
                 if (crt.token.PixelSize.Width <= 100)
                 {
                     drawMiniText(dst.Left, dst.Top + 1 * gv.pS, mo.ToString(), Color.White);
                     drawMiniText(dst.Left + gv.pS, dst.Top - 5 * gv.pS, crt.hp.ToString(), Color.Lime);
                 }
                 else
                 {
                     drawMiniText(dst.Left, dst.Top + gv.squareSize / 2 + 1 * gv.pS, mo.ToString(), Color.White);
                     drawMiniText(dst.Left + 3 * gv.pS, dst.Top - 3 * gv.pS, crt.hp.ToString(), Color.Lime);
                 }
             }

             creatureCounter++;
             if (crt.moveOrder + 1 <= currentMoveOrderIndex)
             {
                 creatureCounter2++;
             }
                 if (crt.token.PixelSize.Width > 100)
             {
                 creatureCounter++;
                 if (crt.moveOrder + 1 <= currentMoveOrderIndex)
                 {
                     largeCreaturesInBand++;
                     creatureCounter2++;
                 }
             }
         }

         else
         {
             Creature crt = (Creature)m.PcOrCreature;
             if (crt.hp <= 0)
             {
                 continue;
             }
             IbRect src = new IbRect(0, 0, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
             int startBarX = (0 * gv.squareSize) + gv.oXshift + mapStartLocXinPixels + 2*gv.pS;
             int startBarY = 0 * gv.squareSize + 2*gv.pS;
             int targetSizeX = gv.squareSize / 2;
             int targetSizeY = gv.squareSize / 2;
             int marchingLineHeight = gv.squareSize / 2; ;
             if (crt.token.PixelSize.Width > 100)
             {
                 targetSizeX = gv.squareSize;
                 targetSizeY = gv.squareSize;
                 marchingLineHeight = 0;
             }
             IbRect dst = new IbRect(startBarX + (creatureCounter + gv.mod.creatureCounterSubstractor) * gv.squareSize / 2, startBarY + marchingLineHeight, targetSizeX, targetSizeY);
             if (crt.moveOrder+1 == currentMoveOrderIndex)
             {
                 gv.DrawBitmap(gv.cc.turn_marker, src, dst, false);
             }

             if ((crt.moveOrder + 1 + largeCreaturesInBandBeforeThisOne + adderForTheFallen > -gv.mod.creatureCounterSubstractor) && (crt.moveOrder + largeCreaturesInBand - adderForTheFallen < (-gv.mod.creatureCounterSubstractor + 32)))
             {
                 gv.DrawBitmap(crt.token, src, dst, false);
                 int mo = crt.moveOrder + 1;
                 if (crt.token.PixelSize.Width <= 100)
                 {
                     drawMiniText(dst.Left, dst.Top + 1 * gv.pS, mo.ToString(), Color.White);
                     drawMiniText(dst.Left + gv.pS, dst.Top - 5 * gv.pS, crt.hp.ToString(), Color.Red);
                 }
                 else
                 {
                     drawMiniText(dst.Left, dst.Top + gv.squareSize / 2 + 1 * gv.pS, mo.ToString(), Color.White);
                     drawMiniText(dst.Left + 3 * gv.pS, dst.Top - 3 * gv.pS, crt.hp.ToString(), Color.Red);
                 }
             }
             creatureCounter++;
             if (crt.moveOrder + 1 <= currentMoveOrderIndex)
             {
                 creatureCounter2++;
             }
             if (crt.token.PixelSize.Width > 100)
             {
                 largeCreaturesInBand++;
                 creatureCounter++;
                 if (crt.moveOrder + 1 <= currentMoveOrderIndex)
                 {
                     creatureCounter2++;
                 }
             }
         }  
     }
    */
        }
        public void drawUiLayout()
        {
            //SET PORTRAITS
            foreach (IB2Panel pnl in combatUiLayout.panelList)
            {
                if (pnl.tag.Equals("portraitPanel"))
                {
                    foreach (IB2Portrait ptr in pnl.portraitList)
                    {
                        ptr.show = false;
                    }
                    int index = 0;
                    foreach (Player pc1 in gv.mod.playerList)
                    {
                        if (!pc1.isTemporaryAllyForThisEncounterOnly)
                        {
                            pnl.portraitList[index].playerNumber = index;
                            pnl.portraitList[index].show = true;
                            pnl.portraitList[index].ImgFilename = pc1.portraitFilename;
                            pnl.portraitList[index].TextHP = pc1.hp + "/" + pc1.hpMax;
                            pnl.portraitList[index].TextSP = pc1.sp + "/" + pc1.spMax;

                            if (index == 0 && gv.cc.ptrPc0.glowOn)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else if (index == 1 && gv.cc.ptrPc1.glowOn)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else if (index == 2 && gv.cc.ptrPc2.glowOn)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else if (index == 3 && gv.cc.ptrPc3.glowOn)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else if (index == 4 && gv.cc.ptrPc4.glowOn)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else if (index == 5 && gv.cc.ptrPc5.glowOn)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else
                            {
                                pnl.portraitList[index].glowOn = false;
                            }
                        }


                        //gv.cc.ptrPc0.glowOn
                        if (!pc1.isTemporaryAllyForThisEncounterOnly)
                        {
                            index++;
                        }
                    }
                    break;
                }
            }

            //SET MOVES LEFT TEXT
            IB2Button btn = combatUiLayout.GetButtonByTag("btnMoveCounter");
            if (currentPlayerIndex < gv.mod.playerList.Count)
            {
                Player pc = gv.mod.playerList[currentPlayerIndex];
                float movesLeft = pc.moveDistance - currentMoves;
                if (movesLeft < 0) { movesLeft = 0; }
                //IB2Button btn = combatUiLayout.GetButtonByTag("btnMoveCounter");
                if (btn != null)
                {
                    btn.Text = movesLeft.ToString();
                }
            }
            else
            {
                //IB2Button btn = combatUiLayout.GetButtonByTag("btnMoveCounter");
                if (btn != null)
                {
                    btn.Text = "0";
                }
            }


            //SET KILL BUTTON
            if (gv.mod.debugMode)
            {
                IB2ToggleButton tgl = combatUiLayout.GetToggleByTag("tglKill");
                if (tgl != null)
                {
                    tgl.show = true;
                }
            }
            else
            {
                IB2ToggleButton tgl = combatUiLayout.GetToggleByTag("tglKill");
                if (tgl != null)
                {
                    tgl.show = false;
                }
            }

            //SET BUTTON STATES
            //select button
            if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
            {
                btn = combatUiLayout.GetButtonByTag("btnSelect");
                if (btn != null)
                {
                    btn.Text = "TARGET";
                }
            }
            else
            {
                btn = combatUiLayout.GetButtonByTag("btnSelect");
                if (btn != null)
                {
                    btn.Text = "SELECT";
                }
            }
            //move button
            if (canMove)
            {
                if (currentCombatMode.Equals("move"))
                {
                    btn = combatUiLayout.GetButtonByTag("btnMove");
                    if (btn != null)
                    {
                        btn.btnState = buttonState.On;
                    }
                }
                else
                {
                    btn = combatUiLayout.GetButtonByTag("btnMove");
                    if (btn != null)
                    {
                        btn.btnState = buttonState.Normal;
                    }
                }
            }
            else
            {
                btn = combatUiLayout.GetButtonByTag("btnMove");
                if (btn != null)
                {
                    btn.btnState = buttonState.Off;
                }
            }
            //attack button
            if (currentCombatMode.Equals("attack"))
            {
                btn = combatUiLayout.GetButtonByTag("btnAttack");
                if (btn != null)
                {
                    btn.btnState = buttonState.On;
                }
            }
            else
            {
                btn = combatUiLayout.GetButtonByTag("btnAttack");
                if (btn != null)
                {
                    btn.btnState = buttonState.Normal;
                }
            }
            //cast button
            if (currentCombatMode.Equals("cast"))
            {
                btn = combatUiLayout.GetButtonByTag("btnCast");
                if (btn != null)
                {
                    btn.btnState = buttonState.On;
                }
            }
            else
            {
                btn = combatUiLayout.GetButtonByTag("btnCast");
                if (btn != null)
                {
                    btn.btnState = buttonState.Normal;
                }
            }
            //use trait button
            if (currentCombatMode.Equals("useTrait"))
            {
                btn = combatUiLayout.GetButtonByTag("btnUseTrait");
                if (btn != null)
                {
                    btn.btnState = buttonState.On;
                }
            }
            else
            {
                btn = combatUiLayout.GetButtonByTag("btnUseTrait");
                if (btn != null)
                {
                    btn.btnState = buttonState.Normal;
                }
            }

            combatUiLayout.Draw();
        }
        public void drawCombatMap()
        {
            if (gv.mod.useAllTileSystem)
            {
                //row = y
                //col = x
                if (gv.mod.currentEncounter.UseMapImage)
                {
                    /*
                    int sqrsizeW = mapBitmap.PixelSize.Width / gv.mod.currentEncounter.MapSizeX;
                    int sqrsizeH = mapBitmap.PixelSize.Height / gv.mod.currentEncounter.MapSizeY;
                    IbRect src = new IbRect(UpperLeftSquare.X * sqrsizeW, UpperLeftSquare.Y * sqrsizeH, sqrsizeW * 9, sqrsizeH * 9);
                    IbRect dst = new IbRect(0 + gv.oXshift + mapStartLocXinPixels, 0, gv.squareSize * 9, gv.squareSize * 9);
                    gv.DrawBitmap(mapBitmap, src, dst);
                    */
                    int bmpWidth = mapBitmap.PixelSize.Width;
                    int bmpHeight = mapBitmap.PixelSize.Height;
                    int sqrsizeW = mapBitmap.PixelSize.Width / gv.mod.currentEncounter.MapSizeX;
                    int sqrsizeH = mapBitmap.PixelSize.Height / gv.mod.currentEncounter.MapSizeY;
                    int dstX = -(UpperLeftSquare.X * gv.squareSize);
                    int dstY = -(UpperLeftSquare.Y * gv.squareSize);
                    float singleImageTileSizeProxy = 100f / ((float)mapBitmap.PixelSize.Width / (float)gv.mod.currentEncounter.MapSizeX);
                    if (!gv.mod.encounterSingleImageAutoScale)
                    {
                        singleImageTileSizeProxy = 2;
                    }
                    int dstWidth = (int)(bmpWidth * singleImageTileSizeProxy * gv.screenDensity); //assumes squares are 50x50 in this image, for 100x100 use *4
                    int dstHeight = (int)(bmpHeight * singleImageTileSizeProxy * gv.screenDensity); //assumes squares are 50x50 in this image, for 100x100 use *4

                    IbRect src = new IbRect(0, 0, bmpWidth, bmpHeight);
                    //IbRect dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels, dstY, dstWidth, dstHeight);
                    IbRect dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels, dstY, dstWidth, dstHeight);
                    if (!isPlayerTurn)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels - (int)cr.glideAdderX, dstY - (int)cr.glideAdderY, dstWidth, dstHeight);
                    }
                    gv.DrawBitmap(mapBitmap, src, dst);

                    /*
                    //draw grid
                    if (gv.mod.com_showGrid)
                    {
                        src = new IbRect(0, 0, gv.squareSizeInPixels / 2, gv.squareSizeInPixels / 2);
                        dst = new IbRect(0 + mapStartLocXinPixels, 0, gv.squareSize, gv.squareSize);
                        for (int x = UpperLeftSquare.X; x < gv.mod.currentEncounter.MapSizeX; x++)
                        {
                            for (int y = UpperLeftSquare.Y; y < gv.mod.currentEncounter.MapSizeY; y++)
                            {
                                if (!IsInVisibleCombatWindow(x, y))
                                {
                                    continue;
                                }

                                int index = y * gv.mod.currentEncounter.MapSizeX + x;
                                if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                                {
                                    continue;
                                }

                                int tlX = ((x - UpperLeftSquare.X) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                int tlY = (y - UpperLeftSquare.Y) * gv.squareSize;
                                int brX = gv.squareSize;
                                int brY = gv.squareSize;

                                dst = new IbRect(tlX, tlY, brX, brY);
                                if (gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].LoSBlocked)
                                {
                                    gv.DrawBitmap(gv.cc.losBlocked, src, dst);
                                }
                                if (gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].Walkable != true)
                                {
                                    gv.DrawBitmap(gv.cc.walkBlocked, src, dst);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.walkPass, src, dst);
                                }
                                if ((pf.values != null) && (gv.mod.debugMode))
                                {
                                    //gv.DrawText(pf.values[x, y].ToString(), (x - UpperLeftSquare.X) * gv.squareSize + gv.oXshift + mapStartLocXinPixels, (y - UpperLeftSquare.Y) * gv.squareSize);
                                    //gv.DrawText(pf.values[x, y].ToString(), x * gv.squareSize + mapStartLocXinPixels, y * gv.squareSize, "wh");

                                }
                            }
                        }
                    }
                    */
                }

                //else //using tiles
                {
                    //covid19
                    //added the last -1/+1
                    int minX = UpperLeftSquare.X - 5 - 2;
                    if (minX < 0) { minX = 0; }
                    int minY = UpperLeftSquare.Y - 5 - 2;
                    if (minY < 0) { minY = 0; }
                    int maxX = UpperLeftSquare.X + gv.playerOffsetX + gv.playerOffsetX + 1 + 2;
                    if (maxX > gv.mod.currentEncounter.MapSizeX) { maxX = gv.mod.currentEncounter.MapSizeX; }
                    int maxY = UpperLeftSquare.Y + gv.playerOffsetY + gv.playerOffsetY + 1 + 2;
                    if (maxY > gv.mod.currentEncounter.MapSizeY) { maxY = gv.mod.currentEncounter.MapSizeY; }

                    #region Draw Layer1
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            int index = y * gv.mod.currentEncounter.MapSizeX + x;
                            if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                            {
                                continue;
                            }
                            TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                            try
                            {
                                //insert1                        
                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer1Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //insert2
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer1Filename);
                                    tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);
                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap1);

                                    IbRect srcLyr = getSourceIbRect(
                                    x,
                                    y,
                                    UpperLeftSquare.X,
                                    UpperLeftSquare.Y,
                                    tile.tileBitmap1.PixelSize.Width,
                                    tile.tileBitmap1.PixelSize.Height);

                                    if (srcLyr != null)
                                    {
                                        int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                                        int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                                        int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                        int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;

                                        if (!isPlayerTurn)
                                        {
                                            Creature cr = new Creature();
                                            int highestLivingCrtMoveOrderfound = 0;
                                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                            {
                                                if (currentMoveOrderIndex == 0)
                                                {
                                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                                    {
                                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                                        cr = c;
                                                    }
                                                }
                                                else
                                                {
                                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                                    {
                                                        cr = c;
                                                        break;
                                                    }
                                                }
                                            }
                                            tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                            tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                                        }

                                        float scalerX = srcLyr.Width / 100;
                                        float scalerY = srcLyr.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);




                                        gv.DrawBitmap(tile.tileBitmap1, srcLyr, dstLyr, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                                        //gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), srcLyr, dstLyr, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                                    }
                                    else
                                    {
                                        int dfdsf = 0;
                                    }
                                }
                                else
                                {
                                    IbRect srcLyr = getSourceIbRect(
                                    x,
                                    y,
                                    UpperLeftSquare.X,
                                    UpperLeftSquare.Y,
                                    gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width,
                                    gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    if (srcLyr != null)
                                    {
                                        int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                                        int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                                        int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                        int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                                        if (!isPlayerTurn)
                                        {
                                            Creature cr = new Creature();
                                            int highestLivingCrtMoveOrderfound = 0;
                                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                            {
                                                if (currentMoveOrderIndex == 0)
                                                {
                                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                                    {
                                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                                        cr = c;
                                                    }
                                                }
                                                else
                                                {
                                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                                    {
                                                        cr = c;
                                                        break;
                                                    }
                                                }
                                            }
                                            tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                            tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                                        }
                                        float scalerX = srcLyr.Width / 100;
                                        float scalerY = srcLyr.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], srcLyr, dstLyr, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                                        //gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), srcLyr, dstLyr, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);

                                    }
                                    else
                                    {
                                        int dfdsf = 0;
                                    }

                                }
                            }
                            catch
                            { }
                        }
                    }
                    #endregion

                    #region Draw Layer2
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            int index = y * gv.mod.currentEncounter.MapSizeX + x;
                            if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                            {
                                continue;
                            }
                            TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                            try
                            {
                                //insert1                        
                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer2Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //insert2
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer2Filename);
                                    tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);
                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap2);

                                    IbRect srcLyr = getSourceIbRect(
                                    x,
                                    y,
                                    UpperLeftSquare.X,
                                    UpperLeftSquare.Y,
                                    tile.tileBitmap2.PixelSize.Width,
                                    tile.tileBitmap2.PixelSize.Height);
                                    if (srcLyr != null)
                                    {
                                        int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                                        int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                                        int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                        int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                                        if (!isPlayerTurn)
                                        {
                                            Creature cr = new Creature();
                                            int highestLivingCrtMoveOrderfound = 0;
                                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                            {
                                                if (currentMoveOrderIndex == 0)
                                                {
                                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                                    {
                                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                                        cr = c;
                                                    }
                                                }
                                                else
                                                {
                                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                                    {
                                                        cr = c;
                                                        break;
                                                    }
                                                }
                                            }
                                            tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                            tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                                        }
                                        float scalerX = srcLyr.Width / 100;
                                        float scalerY = srcLyr.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                                        //gv.DrawBitmap(tile.tileBitmap2, srcLyr, dstLyr);
                                        gv.DrawBitmap(tile.tileBitmap2, srcLyr, dstLyr, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);

                                    }
                                }
                                else
                                {
                                    IbRect srcLyr = getSourceIbRect(
                                    x,
                                    y,
                                    UpperLeftSquare.X,
                                    UpperLeftSquare.Y,
                                    gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width,
                                    gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    if (srcLyr != null)
                                    {
                                        int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                                        int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                                        int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                        int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                                        if (!isPlayerTurn)
                                        {
                                            Creature cr = new Creature();
                                            int highestLivingCrtMoveOrderfound = 0;
                                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                            {
                                                if (currentMoveOrderIndex == 0)
                                                {
                                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                                    {
                                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                                        cr = c;
                                                    }
                                                }
                                                else
                                                {
                                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                                    {
                                                        cr = c;
                                                        break;
                                                    }
                                                }
                                            }
                                            tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                            tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                                        }
                                        float scalerX = srcLyr.Width / 100;
                                        float scalerY = srcLyr.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], srcLyr, dstLyr);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], srcLyr, dstLyr, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);

                                    }

                                }
                            }
                            catch
                            { }
                        }
                    }
                    #endregion

                    #region Draw Layer3
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            int index = y * gv.mod.currentEncounter.MapSizeX + x;
                            if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                            {
                                continue;
                            }
                            TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];

                            try
                            {
                                //insert1                        
                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer3Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //insert2
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer3Filename);
                                    tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);
                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap3);

                                    IbRect srcLyr = getSourceIbRect(
                                    x,
                                    y,
                                    UpperLeftSquare.X,
                                    UpperLeftSquare.Y,
                                    tile.tileBitmap3.PixelSize.Width,
                                    tile.tileBitmap3.PixelSize.Height);
                                    if (srcLyr != null)
                                    {
                                        int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                                        int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                                        int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                        int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                                        if (!isPlayerTurn)
                                        {
                                            Creature cr = new Creature();
                                            int highestLivingCrtMoveOrderfound = 0;
                                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                            {
                                                if (currentMoveOrderIndex == 0)
                                                {
                                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                                    {
                                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                                        cr = c;
                                                    }
                                                }
                                                else
                                                {
                                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                                    {
                                                        cr = c;
                                                        break;
                                                    }
                                                }
                                            }
                                            tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                            tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                                        }
                                        float scalerX = srcLyr.Width / 100;
                                        float scalerY = srcLyr.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                                        //gv.DrawBitmap(tile.tileBitmap3, srcLyr, dstLyr);
                                        gv.DrawBitmap(tile.tileBitmap3, srcLyr, dstLyr, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);

                                    }
                                }
                                else
                                {
                                    IbRect srcLyr = getSourceIbRect(
                                    x,
                                    y,
                                    UpperLeftSquare.X,
                                    UpperLeftSquare.Y,
                                    gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width,
                                    gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    if (srcLyr != null)
                                    {
                                        int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                                        int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                                        int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                        int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                                        if (!isPlayerTurn)
                                        {
                                            Creature cr = new Creature();
                                            int highestLivingCrtMoveOrderfound = 0;
                                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                            {
                                                if (currentMoveOrderIndex == 0)
                                                {
                                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                                    {
                                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                                        cr = c;
                                                    }
                                                }
                                                else
                                                {
                                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                                    {
                                                        cr = c;
                                                        break;
                                                    }
                                                }
                                            }
                                            tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                            tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                                        }
                                        float scalerX = srcLyr.Width / 100;
                                        float scalerY = srcLyr.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], srcLyr, dstLyr);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], srcLyr, dstLyr, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);

                                    }

                                }
                            }
                            catch
                            { }
                            /*
                            //code for drawing conquer and hold locations
                            if (gv.mod.currentEncounter.conquerVictory)
                            {
                                if (x == gv.mod.currentEncounter.conquerTarget1X && y == gv.mod.currentEncounter.conquerTarget1Y)
                                {
                                    //trainieren
                                }

                                if (x == gv.mod.currentEncounter.conquerTarget2X && y == gv.mod.currentEncounter.conquerTarget2Y)
                                {

                                }

                                if (x == gv.mod.currentEncounter.conquerTarget3X && y == gv.mod.currentEncounter.conquerTarget3Y)
                                {

                                }
                            }
                            */
                        }
                    }
                    #endregion

                    #region Draw Grid
                    //I brought the pix width and height of source back to normal
                    if (gv.mod.com_showGrid)
                    {
                        for (int x = UpperLeftSquare.X-2; x < gv.mod.currentEncounter.MapSizeX+2; x++)
                        {
                            for (int y = UpperLeftSquare.Y-2; y < gv.mod.currentEncounter.MapSizeY+2; y++)
                            {
                                if (!IsInVisibleCombatWindow(x, y))
                                {
                                    //continue;
                                }

                                if (x > gv.mod.currentEncounter.MapSizeX - 1)
                                {
                                    continue;
                                }

                                if (y > gv.mod.currentEncounter.MapSizeY - 1)
                                {
                                    continue;
                                }

                                if (x < 0)
                                {
                                    continue;
                                }

                                if (y < 0)
                                {
                                    continue;
                                }

                                TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                                //covid20
                                int tlX = ((x - UpperLeftSquare.X) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                                int tlY = (y - UpperLeftSquare.Y) * gv.squareSize;
                                if (!isPlayerTurn)
                                {
                                    Creature cr = new Creature();
                                    int highestLivingCrtMoveOrderfound = 0;
                                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (currentMoveOrderIndex == 0)
                                        {
                                            if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                            {
                                                highestLivingCrtMoveOrderfound = c.moveOrder;
                                                cr = c;
                                            }
                                        }
                                        else
                                        {
                                            if (c.moveOrder == currentMoveOrderIndex - 1)
                                            {
                                                cr = c;
                                                break;
                                            }
                                        }
                                    }
                                    tlX = (x - UpperLeftSquare.X) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                    tlY = (y - UpperLeftSquare.Y) * gv.squareSize - (int)cr.glideAdderY;
                                }
                                int brX = gv.squareSize;
                                int brY = gv.squareSize;

                                IbRect srcGrid = new IbRect(0, 0, gv.squareSizeInPixels, gv.squareSizeInPixels);
                                IbRect dstGrid = new IbRect(tlX, tlY, brX, brY);
                                if (gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].LoSBlocked)
                                {
                                    gv.DrawBitmap(gv.cc.losBlocked, srcGrid, dstGrid);
                                }
                                if (gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].Walkable != true)
                                {
                                    gv.DrawBitmap(gv.cc.walkBlocked, srcGrid, dstGrid);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.walkPass, srcGrid, dstGrid);
                                }
                            }
                        }
                    }
                    #endregion
                    #region Draw Pathfinding Numbers
                    for (int x = UpperLeftSquare.X; x < gv.mod.currentEncounter.MapSizeX; x++)
                    {
                        for (int y = UpperLeftSquare.Y; y < gv.mod.currentEncounter.MapSizeY; y++)
                        {
                            if (!IsInVisibleCombatWindow(x, y))
                            {
                                continue;
                            }
                            int index = y * gv.mod.currentEncounter.MapSizeX + x;
                            if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                            {
                                continue;
                            }
                            //if ((pf.values != null) && (gv.mod.debugMode))
                            //{
                            //gv.DrawText(pf.values[x, y].ToString(), (x - UpperLeftSquare.X) * gv.squareSize + gv.oXshift + mapStartLocXinPixels, (y - UpperLeftSquare.Y) * gv.squareSize);
                            //}
                        }
                    }
                    #endregion
                }

                if (gv.mod.useManualCombatCam)
                {
                    drawColumnOfBlack();
                    drawRowOfBlack();
                }
            }
            else //old system using single image background and no load tile images on demand
            {
                //row = y
                //col = x
                if (gv.mod.currentEncounter.UseMapImage)
                {
                    #region background image
                    int bmpWidth = mapBitmap.PixelSize.Width;
                    int bmpHeight = mapBitmap.PixelSize.Height;
                    int sqrsizeW = mapBitmap.PixelSize.Width / gv.mod.currentEncounter.MapSizeX;
                    int sqrsizeH = mapBitmap.PixelSize.Height / gv.mod.currentEncounter.MapSizeY;
                    int dstX = -(UpperLeftSquare.X * gv.squareSize);
                    int dstY = -(UpperLeftSquare.Y * gv.squareSize);
                    int dstWidth = (int)(bmpWidth * 2 * gv.screenDensity); //assumes squares are 50x50 in this image
                    int dstHeight = (int)(bmpHeight * 2 * gv.screenDensity); //assumes squares are 50x50 in this image

                    IbRect src = new IbRect(0, 0, bmpWidth, bmpHeight);
                    IbRect dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels, dstY, dstWidth, dstHeight);
                    if (!isPlayerTurn)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels - (int)cr.glideAdderX, dstY - (int)cr.glideAdderY, dstWidth, dstHeight);
                    }

                    gv.DrawBitmap(mapBitmap, src, dst);

                    //int sqrsizeW = mapBitmap.PixelSize.Width / gv.mod.currentEncounter.MapSizeX;
                    //int sqrsizeH = mapBitmap.PixelSize.Height / gv.mod.currentEncounter.MapSizeY;
                    //IbRect src = new IbRect(UpperLeftSquare.X * sqrsizeW, UpperLeftSquare.Y * sqrsizeH, sqrsizeW * (gv.playerOffsetX + gv.playerOffsetX + 1), sqrsizeH * (gv.playerOffsetY + gv.playerOffsetY + 1));
                    //IbRect dst = new IbRect(0 + gv.oXshift + mapStartLocXinPixels, 0, gv.squareSize * (gv.playerOffsetX + gv.playerOffsetX + 1), gv.squareSize * (gv.playerOffsetY + gv.playerOffsetY + 1));
                    //gv.DrawBitmap(mapBitmap, src, dst);                    
                    #endregion
                }

                int minX = UpperLeftSquare.X - (gv.playerOffsetX + 1);
                if (minX < 0) { minX = 0; }
                int minY = UpperLeftSquare.Y - (gv.playerOffsetY + 1);
                if (minY < 0) { minY = 0; }
                int maxX = UpperLeftSquare.X + gv.playerOffsetX + gv.playerOffsetX + 1;
                if (maxX > gv.mod.currentEncounter.MapSizeX) { maxX = gv.mod.currentEncounter.MapSizeX; }
                int maxY = UpperLeftSquare.Y + gv.playerOffsetY + gv.playerOffsetY + 2;
                if (maxY > gv.mod.currentEncounter.MapSizeY) { maxY = gv.mod.currentEncounter.MapSizeY; }

                #region Draw Layer1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int index = y * gv.mod.currentEncounter.MapSizeX + x;
                        if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                        {
                            continue;
                        }
                        TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                        IbRect srcLyr = getSourceIbRect(
                            x,
                            y,
                            UpperLeftSquare.X,
                            UpperLeftSquare.Y,
                            gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width,
                            gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);

                        if (srcLyr != null)
                        {
                            int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                            int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                            int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                            int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                            if (!isPlayerTurn)
                            {
                                Creature cr = new Creature();
                                int highestLivingCrtMoveOrderfound = 0;
                                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                {
                                    if (currentMoveOrderIndex == 0)
                                    {
                                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                        {
                                            highestLivingCrtMoveOrderfound = c.moveOrder;
                                            cr = c;
                                        }
                                    }
                                    else
                                    {
                                        if (c.moveOrder == currentMoveOrderIndex - 1)
                                        {
                                            cr = c;
                                            break;
                                        }
                                    }
                                }
                                tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                            }
                            float scalerX = srcLyr.Width / 100;
                            float scalerY = srcLyr.Height / 100;
                            int brX = (int)(gv.squareSize * scalerX);
                            int brY = (int)(gv.squareSize * scalerY);
                            IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), srcLyr, dstLyr, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                        }
                    }
                }
                #endregion
                #region Draw Layer2
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int index = y * gv.mod.currentEncounter.MapSizeX + x;
                        if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                        {
                            continue;
                        }
                        TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                        IbRect srcLyr = getSourceIbRect(
                            x,
                            y,
                            UpperLeftSquare.X,
                            UpperLeftSquare.Y,
                            gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width,
                            gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);

                        if (srcLyr != null)
                        {
                            int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                            int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                            int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                            int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                            if (!isPlayerTurn)
                            {
                                Creature cr = new Creature();
                                int highestLivingCrtMoveOrderfound = 0;
                                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                {
                                    if (currentMoveOrderIndex == 0)
                                    {
                                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                        {
                                            highestLivingCrtMoveOrderfound = c.moveOrder;
                                            cr = c;
                                        }
                                    }
                                    else
                                    {
                                        if (c.moveOrder == currentMoveOrderIndex - 1)
                                        {
                                            cr = c;
                                            break;
                                        }
                                    }
                                }
                                tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                            }
                            float scalerX = srcLyr.Width / 100;
                            float scalerY = srcLyr.Height / 100;
                            int brX = (int)(gv.squareSize * scalerX);
                            int brY = (int)(gv.squareSize * scalerY);
                            IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer2Filename), srcLyr, dstLyr, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);
                        }
                    }
                }
                #endregion
                #region Draw Layer3
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int index = y * gv.mod.currentEncounter.MapSizeX + x;
                        if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                        {
                            continue;
                        }
                        TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];
                        IbRect srcLyr = getSourceIbRect(
                            x,
                            y,
                            UpperLeftSquare.X,
                            UpperLeftSquare.Y,
                            gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width,
                            gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);

                        if (srcLyr != null)
                        {
                            int shiftY = srcLyr.Top / gv.squareSizeInPixels;
                            int shiftX = srcLyr.Left / gv.squareSizeInPixels;
                            int tlX = ((x - UpperLeftSquare.X + shiftX) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                            int tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize;
                            if (!isPlayerTurn)
                            {
                                Creature cr = new Creature();
                                int highestLivingCrtMoveOrderfound = 0;
                                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                {
                                    if (currentMoveOrderIndex == 0)
                                    {
                                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                        {
                                            highestLivingCrtMoveOrderfound = c.moveOrder;
                                            cr = c;
                                        }
                                    }
                                    else
                                    {
                                        if (c.moveOrder == currentMoveOrderIndex - 1)
                                        {
                                            cr = c;
                                            break;
                                        }
                                    }
                                }
                                tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                                tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                            }
                            float scalerX = srcLyr.Width / 100;
                            float scalerY = srcLyr.Height / 100;
                            int brX = (int)(gv.squareSize * scalerX);
                            int brY = (int)(gv.squareSize * scalerY);
                            IbRect dstLyr = new IbRect(tlX, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer3Filename), srcLyr, dstLyr, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);
                        }
                    }
                }
                #endregion
                #region Draw Grid
                //I brought the pix width and height of source back to normal
                if (gv.mod.com_showGrid)
                {
                    for (int x = UpperLeftSquare.X; x < gv.mod.currentEncounter.MapSizeX; x++)
                    {
                        for (int y = UpperLeftSquare.Y; y < gv.mod.currentEncounter.MapSizeY; y++)
                        {
                            if (!IsInVisibleCombatWindow(x, y))
                            {
                                continue;
                            }

                            if ((x < 0) || (y < 0))
                            {
                                continue;
                            }

                            if ((x >= gv.mod.currentEncounter.MapSizeX)
               || (y >= gv.mod.currentEncounter.MapSizeY))
                            {
                                continue;
                            }

                            TileEnc tile = gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x];

                            int tlX = ((x - UpperLeftSquare.X) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
                            int tlY = (y - UpperLeftSquare.Y) * gv.squareSize;
                            int brX = gv.squareSize;
                            int brY = gv.squareSize;

                            IbRect srcGrid = new IbRect(0, 0, gv.squareSizeInPixels, gv.squareSizeInPixels);
                            IbRect dstGrid = new IbRect(tlX, tlY, brX, brY);
                            if (gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].LoSBlocked)
                            {
                                gv.DrawBitmap(gv.cc.losBlocked, srcGrid, dstGrid);
                            }
                            if (gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].Walkable != true)
                            {
                                gv.DrawBitmap(gv.cc.walkBlocked, srcGrid, dstGrid);
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.walkPass, srcGrid, dstGrid);
                            }
                        }
                    }
                }
                #endregion
                #region Draw Pathfinding Numbers
                for (int x = UpperLeftSquare.X; x < gv.mod.currentEncounter.MapSizeX; x++)
                {
                    for (int y = UpperLeftSquare.Y; y < gv.mod.currentEncounter.MapSizeY; y++)
                    {
                        if (!IsInVisibleCombatWindow(x, y))
                        {
                            continue;
                        }
                        int index = y * gv.mod.currentEncounter.MapSizeX + x;
                        if ((index >= gv.mod.currentEncounter.encounterTiles.Count))
                        {
                            continue;
                        }
                        if ((pf.values != null) && (gv.mod.debugMode))
                        {
                            //gv.DrawText(pf.values[x, y].ToString(), (x - UpperLeftSquare.X) * gv.squareSize + gv.oXshift + mapStartLocXinPixels, (y - UpperLeftSquare.Y) * gv.squareSize);
                        }
                    }
                }
                #endregion

                if (gv.mod.useManualCombatCam)
                {
                    drawColumnOfBlack();
                    drawRowOfBlack();
                }
            }
        }

        //XXXX
        public void drawColumnOfBlack()
        {

            if ((UpperLeftSquare.X <= 0) || (UpperLeftSquare.X >= (gv.mod.currentEncounter.MapSizeX - 1 - (gv.playerOffsetX * 2 + 1))))
            {
                int offset = 0;
                if (UpperLeftSquare.X <= 0)
                {
                    offset = UpperLeftSquare.X + 1;
                    for (int y = -2; y < gv.playerOffsetY * 2 + 3; y++)
                    {
                        int tlX = -offset * gv.squareSize;
                        int tlY = y * gv.squareSize;
                        if (!isPlayerTurn)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            tlX = -offset * gv.squareSize - (int)(cr.glideAdderX);
                            tlY = y * gv.squareSize - (int)cr.glideAdderY;

                        }
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.4f), (int)(brY * 1.3f));
                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                    }
                }

                if (UpperLeftSquare.X >= (gv.mod.currentEncounter.MapSizeX - 1 - (gv.playerOffsetX * 2 + 1)))
                {
                    offset = ((gv.mod.currentEncounter.MapSizeX - 1) - UpperLeftSquare.X + 1) * -1;
                    //offset = gv.playerOffsetX * 2 + 1 + offset -1;
                    for (int y = -2; y < gv.playerOffsetY * 2 + 3; y++)
                    {
                        int tlX = -offset * gv.squareSize;
                        int tlY = y * gv.squareSize;
                        if (!isPlayerTurn)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            tlX = -offset * gv.squareSize - (int)(cr.glideAdderX);
                            tlY = y * gv.squareSize - (int)cr.glideAdderY;

                        }
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.4f), (int)(brY * 1.3f));
                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                    }
                }
            }

        }

        public void drawRowOfBlack()
        {
            if ((UpperLeftSquare.Y <= 1) || (UpperLeftSquare.Y + 1 >= (gv.mod.currentEncounter.MapSizeY - 1 - (gv.playerOffsetY * 2 + 1))))
            {
                int offset = 0;
                if (UpperLeftSquare.Y <= 1)
                {
                    offset = UpperLeftSquare.Y + 1;
                    for (int x = -2; x < gv.playerOffsetX * 2 + 3; x++)
                    {
                        int tlX = x * gv.squareSize;
                        int tlY = -offset * gv.squareSize;
                        if (!isPlayerTurn)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            tlX = x * gv.squareSize - (int)(cr.glideAdderX);
                            tlY = -offset * gv.squareSize - (int)cr.glideAdderY;

                        }
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.4f), (int)(brY * 1.3f));

                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                    }
                }

                if (UpperLeftSquare.Y + 1 >= (gv.mod.currentEncounter.MapSizeY - 1 - (gv.playerOffsetY * 2 + 1)))
                {
                    offset = ((gv.mod.currentEncounter.MapSizeY - 1) - UpperLeftSquare.Y + 1) * -1;
                    //offset = gv.playerOffsetY * 2 + 1 + offset - 1;
                    for (int x = -2; x < gv.playerOffsetX * 2 + 3; x++)
                    {
                        int tlX = x * gv.squareSize;
                        int tlY = -offset * gv.squareSize;
                        if (!isPlayerTurn)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            tlX = x * gv.squareSize - (int)(cr.glideAdderX);
                            tlY = -offset * gv.squareSize - (int)cr.glideAdderY;

                        }
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.4f), (int)(brY * 1.3f));

                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                    }
                }
            }
        }


        //XXXX
        public IbRect getSourceIbRect(int xSqr, int ySqr, int UpperLeftXsqr, int UpperLeftYsqr, int tileWinPixels, int tileHinPixels)
        {
            /*
            IbRect src = new IbRect(0, 0, tileWinPixels, tileHinPixels);

            int tileWsqrs = tileWinPixels / gv.squareSizeInPixels;
            int tileHsqrs = tileHinPixels / gv.squareSizeInPixels;
            int BottomRightX = UpperLeftXsqr + gv.playerOffsetX + gv.playerOffsetX + 1;
            int BottomRightY = UpperLeftYsqr + gv.playerOffsetY + gv.playerOffsetY + 2;

            //left side
            int startX = UpperLeftXsqr - xSqr;
            if (startX < 0) { startX = 0; }
            //if startX >= tileW then it is off the map
            if (startX >= tileWsqrs) { return null; }

            //top side
            int startY = UpperLeftYsqr - ySqr;
            if (startY < 0) { startY = 0; }
            //if startY >= tileY then it is off the map
            if (startY >= tileHsqrs) { return null; }

            //right side
            int endX = BottomRightX - xSqr;
            if (endX > tileWsqrs) { endX = tileWsqrs; }
            //if endX <=0 then it is off the map
            if (endX <= 0) { return null; }

            //bottom side
            int endY = BottomRightY - ySqr;
            if (endY > tileHsqrs) { endY = tileHsqrs; }
            //if endY <=0 then it is off the map
            if (endY <= 0) { return null; }

            //return new IbRect(startX * gv.squareSizeInPixels, startY * gv.squareSizeInPixels, (endX - startX) * gv.squareSizeInPixels, (endY - startY) * gv.squareSizeInPixels);
            */
            IbRect srcLyr = new IbRect();
            srcLyr.Left = 0;
            srcLyr.Top = 0;
            srcLyr.Width = tileWinPixels;
            srcLyr.Height = tileHinPixels;
            return srcLyr;

        }
        public void drawCombatPlayers()
        {
            if (currentPlayerIndex < gv.mod.playerList.Count)
            {
                Player p = gv.mod.playerList[currentPlayerIndex];
                if (IsInVisibleCombatWindow(p.combatLocX, p.combatLocY))
                {
                    IbRect src = new IbRect(0, 0, gv.cc.turn_marker.PixelSize.Width, gv.cc.turn_marker.PixelSize.Width);
                    IbRect dst = new IbRect(getPixelLocX(p.combatLocX), getPixelLocY(p.combatLocY), gv.squareSize, gv.squareSize);
                    if (!isPlayerTurn)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        //tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                        //tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                        //if (cr.moveOrder != crt.moveOrder)
                        {
                            dst.Left -= (int)(cr.glideAdderX);
                            dst.Top -= (int)(cr.glideAdderY);
                        }

                    }


                    if (isPlayerTurn)
                    {
                        gv.DrawBitmap(gv.cc.turn_marker, src, dst);
                    }
                }
            }
            //too: te livin on topthe unconciou
            foreach (Player pc in gv.mod.playerList)
            {
                if (pc.hp <= 0)
                {
                    if (IsInVisibleCombatWindow(pc.combatLocX, pc.combatLocY))
                    {
                        IbRect src = new IbRect(0, 0, pc.token.PixelSize.Width, pc.token.PixelSize.Width);
                        //check if drawing animation of player
                        if ((playerToAnimate != null) && (playerToAnimate == pc))
                        {
                            attackAnimationDelayCounter++;
                            if (attackAnimationDelayCounter >= (int)(pc.token.PixelSize.Height / 100f - 1))
                            {
                                attackAnimationFrameCounter++;
                                attackAnimationDelayCounter = 0;
                            }
                            //maxUsableCounterValue = (int)(pc.token.PixelSize.Height / 100f - 1);
                            maxUsableCounterValue = 1;
                            if (attackAnimationFrameCounter >= maxUsableCounterValue)
                            {
                                attackAnimationFrameCounter = maxUsableCounterValue;
                                blockAnimationBridge = false;
                            }
                            src = new IbRect(0, pc.token.PixelSize.Width * attackAnimationFrameCounter, pc.token.PixelSize.Width, pc.token.PixelSize.Width);
                        }
                        IbRect dst = new IbRect(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY), gv.squareSize, gv.squareSize);
                        if (!isPlayerTurn)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            //tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                            //tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                            //if (cr.moveOrder != crt.moveOrder)
                            {
                                dst.Left -= (int)(cr.glideAdderX);
                                dst.Top -= (int)(cr.glideAdderY);
                            }

                        }
                        gv.DrawBitmap(pc.token, src, dst, !pc.combatFacingLeft, false);
                        src = new IbRect(0, 0, pc.token.PixelSize.Width, pc.token.PixelSize.Width);

                        //PLAYER FACING
                        src = new IbRect(0, 0, gv.cc.facing1.PixelSize.Width, gv.cc.facing1.PixelSize.Height);
                        if (pc.hp > 0)
                        {
                            /*
                            //gv.DrawBitmap(gv.cc.facing8, src, dst, 0, false, 0, 0, 50, 50);
                            if (pc.combatFacing == 8) { gv.DrawBitmap(gv.cc.facing8, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 9) { gv.DrawBitmap(gv.cc.facing9, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 6) { gv.DrawBitmap(gv.cc.facing6, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 3) { gv.DrawBitmap(gv.cc.facing3, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 2) { gv.DrawBitmap(gv.cc.facing2, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 1) { gv.DrawBitmap(gv.cc.facing1, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 4) { gv.DrawBitmap(gv.cc.facing4, src, dst, 0, false, 0, 0, 50, 50); }
                            else if (pc.combatFacing == 7) { gv.DrawBitmap(gv.cc.facing7, src, dst, 0, false, 0, 0, 50, 50); }
                            else { } //didn't find one
                            */

                            if (pc.combatFacing == 8) { gv.DrawBitmap(gv.cc.facing8, src, dst); }
                            else if (pc.combatFacing == 9) { gv.DrawBitmap(gv.cc.facing9, src, dst); }
                            else if (pc.combatFacing == 6) { gv.DrawBitmap(gv.cc.facing6, src, dst); }
                            else if (pc.combatFacing == 3) { gv.DrawBitmap(gv.cc.facing3, src, dst); }
                            else if (pc.combatFacing == 2) { gv.DrawBitmap(gv.cc.facing2, src, dst); }
                            else if (pc.combatFacing == 1) { gv.DrawBitmap(gv.cc.facing1, src, dst); }
                            else if (pc.combatFacing == 4) { gv.DrawBitmap(gv.cc.facing4, src, dst); }
                            else if (pc.combatFacing == 7) { gv.DrawBitmap(gv.cc.facing7, src, dst); }
                            else { } //didn't find one

                        }
                        //always show effects
                        //if (!animationsOn)
                        {
                            int effectCounter = 0;
                            foreach (Effect ef in pc.effectsList)
                            {
                                if ((!ef.isPermanent) && (ef.spriteFilename != "none") && (ef.spriteFilename != "") && (ef.spriteFilename != "None"))
                                {
                                    Bitmap fx = gv.cc.LoadBitmap(ef.spriteFilename);
                                    src = new IbRect(0, 0, fx.PixelSize.Width, fx.PixelSize.Width);
                                    IbRect dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                    if (!gv.mod.allEffectsUseFullSizeIcons && !ef.thisEffectUsesFullSizeIcon)
                                    {
                                        effectCounter++;
                                        if (effectCounter == 2)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 3)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 4)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 5)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 6)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 7)
                                        {
                                            dst2 = new IbRect(dst.Left, dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 8)
                                        {
                                            dst2 = new IbRect(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 9)
                                        {
                                            dst2 = new IbRect(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                    }
                                    else
                                    {
                                        dst2 = new IbRect(dst.Left, dst.Top, (int)(gv.squareSize), (int)(gv.squareSize));
                                    }

                                    gv.DrawBitmap(fx, src, dst2);
                                    gv.cc.DisposeOfBitmap(ref fx);
                                }
                                if (ef.numberOfMirrorImagesLeft > 0)
                                {
                                    int locX = getPixelLocX(pc.combatLocX);
                                    int locX2 = getPixelLocX(pc.combatLocX) + (int)(gv.squareSize * 0.666f);
                                    int locY = getPixelLocY(pc.combatLocY);
                                    int shiftY1 = (int)(gv.squareSize * 0.333f);
                                    int shiftY2 = (int)(gv.squareSize * 0.666f);
                                    int mini = (int)(gv.squareSize / 3);
                                    IbRect dst2 = new IbRect(locX, locY, mini, mini);
                                    if (ef.numberOfMirrorImagesLeft >= 1)
                                    {
                                        dst2 = new IbRect(locX, locY, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 2)
                                    {
                                        dst2 = new IbRect(locX2, locY, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 3)
                                    {
                                        dst2 = new IbRect(locX, locY + shiftY1, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 4)
                                    {
                                        dst2 = new IbRect(locX2, locY + shiftY1, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 5)
                                    {
                                        dst2 = new IbRect(locX, locY + shiftY2, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 6)
                                    {
                                        dst2 = new IbRect(locX2, locY + shiftY2, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                }
                            }
                        }
                        if ((pc.isDead()) || (pc.isUnconcious()))
                        {
                            src = new IbRect(0, 0, gv.cc.pc_dead.PixelSize.Width, gv.cc.pc_dead.PixelSize.Width);
                            gv.DrawBitmap(gv.cc.pc_dead, src, dst);
                        }
                        if (pc.steathModeOn)
                        {
                            src = new IbRect(0, 0, gv.cc.pc_stealth.PixelSize.Width, gv.cc.pc_stealth.PixelSize.Width);
                            gv.DrawBitmap(gv.cc.pc_stealth, src, dst);
                        }



                        if (showMoveOrder)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            int mo = pc.moveOrder + 1;
                            bool noCreatureOnTop = true;
                            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (crt.combatLocX == pc.combatLocX && crt.combatLocY == pc.combatLocY)
                                {
                                    noCreatureOnTop = false;
                                }
                            }

                            if (noCreatureOnTop)
                            {
                                drawText(getPixelLocX(pc.combatLocX) - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc.combatLocY) - (int)gv.drawFontRegHeight - (int)cr.glideAdderY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                            }
                        }
                    }
                }
            }
            foreach (Player pc in gv.mod.playerList)
            {
                if (pc.hp > 0)
                {
                    if (IsInVisibleCombatWindow(pc.combatLocX, pc.combatLocY))
                    {
                        IbRect src = new IbRect(0, 0, pc.token.PixelSize.Width, pc.token.PixelSize.Width);
                        //check if drawing animation of player
                        if ((playerToAnimate != null) && (playerToAnimate == pc))
                        {
                            attackAnimationDelayCounter++;
                            if (attackAnimationDelayCounter >= (int)(pc.token.PixelSize.Height / 100f - 1))
                            {
                                attackAnimationFrameCounter++;
                                attackAnimationDelayCounter = 0;
                            }
                            //maxUsableCounterValue = (int)(pc.token.PixelSize.Height / 100f - 1);
                            maxUsableCounterValue = 1;
                            if (attackAnimationFrameCounter >= maxUsableCounterValue)
                            {
                                attackAnimationFrameCounter = maxUsableCounterValue;
                                blockAnimationBridge = false;
                            }
                            src = new IbRect(0, pc.token.PixelSize.Width * attackAnimationFrameCounter, pc.token.PixelSize.Width, pc.token.PixelSize.Width);
                        }
                        IbRect dst = new IbRect(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY), gv.squareSize, gv.squareSize);
                        if (!isPlayerTurn)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            //tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                            //tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                            //if (cr.moveOrder != crt.moveOrder)
                            {
                                dst.Left -= (int)(cr.glideAdderX);
                                dst.Top -= (int)(cr.glideAdderY);
                            }

                        }
                        gv.DrawBitmap(pc.token, src, dst, !pc.combatFacingLeft, false);

                        src = new IbRect(0, 0, pc.token.PixelSize.Width, pc.token.PixelSize.Width);
                        //PLAYER FACING
                        src = new IbRect(0, 0, gv.cc.facing1.PixelSize.Width, gv.cc.facing1.PixelSize.Height);
                        if (pc.hp > 0)
                        {
                            /*
                            if (pc.combatFacing == 8) { gv.DrawBitmap(gv.cc.facing8, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 9) { gv.DrawBitmap(gv.cc.facing9, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 6) { gv.DrawBitmap(gv.cc.facing6, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 3) { gv.DrawBitmap(gv.cc.facing3, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 2) { gv.DrawBitmap(gv.cc.facing2, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 1) { gv.DrawBitmap(gv.cc.facing1, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 4) { gv.DrawBitmap(gv.cc.facing4, src, dst, 0, false, 0, 0, 1, 1); }
                            else if (pc.combatFacing == 7) { gv.DrawBitmap(gv.cc.facing7, src, dst, 0, false, 0, 0, 1, 1); }
                            else { } //didn't find one
                            
                            
                            dst.Width = gv.squareSize / 2;
                            dst.Height = gv.squareSize / 2;
                            */

                            if (pc.combatFacing == 8) { gv.DrawBitmap(gv.cc.facing8, src, dst); }
                            else if (pc.combatFacing == 9) { gv.DrawBitmap(gv.cc.facing9, src, dst); }
                            else if (pc.combatFacing == 6) { gv.DrawBitmap(gv.cc.facing6, src, dst); }
                            else if (pc.combatFacing == 3) { gv.DrawBitmap(gv.cc.facing3, src, dst); }
                            else if (pc.combatFacing == 2) { gv.DrawBitmap(gv.cc.facing2, src, dst); }
                            else if (pc.combatFacing == 1) { gv.DrawBitmap(gv.cc.facing1, src, dst); }
                            else if (pc.combatFacing == 4) { gv.DrawBitmap(gv.cc.facing4, src, dst); }
                            else if (pc.combatFacing == 7) { gv.DrawBitmap(gv.cc.facing7, src, dst); }
                            else { } //didn't find one

                        }
                        //show effects always
                        //if (!animationsOn)
                        {
                            int effectCounter = 0;
                            foreach (Effect ef in pc.effectsList)
                            {
                                if ((!ef.isPermanent) && (ef.spriteFilename != "none") && (ef.spriteFilename != "") && (ef.spriteFilename != "None"))
                                {
                                    Bitmap fx = gv.cc.LoadBitmap(ef.spriteFilename);
                                    src = new IbRect(0, 0, fx.PixelSize.Width, fx.PixelSize.Width);
                                    IbRect dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                    if (!gv.mod.allEffectsUseFullSizeIcons && !ef.thisEffectUsesFullSizeIcon)
                                    {
                                        effectCounter++;
                                        if (effectCounter == 2)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 3)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 4)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 5)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 6)
                                        {
                                            dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 7)
                                        {
                                            dst2 = new IbRect(dst.Left, dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 8)
                                        {
                                            dst2 = new IbRect(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                        if (effectCounter == 9)
                                        {
                                            dst2 = new IbRect(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                                        }
                                    }
                                    else
                                    {
                                        dst2 = new IbRect(dst.Left, dst.Top, (int)(gv.squareSize), (int)(gv.squareSize));
                                    }
                                    gv.DrawBitmap(fx, src, dst2);
                                    gv.cc.DisposeOfBitmap(ref fx);
                                }
                                if (ef.numberOfMirrorImagesLeft > 0)
                                {
                                    int locX = getPixelLocX(pc.combatLocX);
                                    int locX2 = getPixelLocX(pc.combatLocX) + (int)(gv.squareSize * 0.666f);
                                    int locY = getPixelLocY(pc.combatLocY);
                                    int shiftY1 = (int)(gv.squareSize * 0.333f);
                                    int shiftY2 = (int)(gv.squareSize * 0.666f);
                                    int mini = (int)(gv.squareSize / 3);
                                    IbRect dst2 = new IbRect(locX, locY, mini, mini);
                                    src = new IbRect(0, 0, gv.cc.GetFromBitmapList(pc.tokenFilename).PixelSize.Width, gv.cc.GetFromBitmapList(pc.tokenFilename).PixelSize.Width);
                                    if (ef.numberOfMirrorImagesLeft >= 1)
                                    {
                                        dst2 = new IbRect(locX, locY, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 2)
                                    {
                                        dst2 = new IbRect(locX2, locY, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 3)
                                    {
                                        dst2 = new IbRect(locX, locY + shiftY1, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 4)
                                    {
                                        dst2 = new IbRect(locX2, locY + shiftY1, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 5)
                                    {
                                        dst2 = new IbRect(locX, locY + shiftY2, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                    if (ef.numberOfMirrorImagesLeft >= 6)
                                    {
                                        dst2 = new IbRect(locX2, locY + shiftY2, mini, mini);
                                        gv.DrawBitmap(gv.cc.GetFromBitmapList(pc.tokenFilename), src, dst2, !pc.combatFacingLeft);
                                    }
                                }
                            }
                        }
                        if ((pc.isDead()) || (pc.isUnconcious()))
                        {
                            src = new IbRect(0, 0, gv.cc.pc_dead.PixelSize.Width, gv.cc.pc_dead.PixelSize.Width);
                            gv.DrawBitmap(gv.cc.pc_dead, src, dst);
                        }
                        if (pc.steathModeOn)
                        {
                            src = new IbRect(0, 0, gv.cc.pc_stealth.PixelSize.Width, gv.cc.pc_stealth.PixelSize.Width);
                            gv.DrawBitmap(gv.cc.pc_stealth, src, dst);
                        }



                        if (showMoveOrder)
                        {
                            Creature cr = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        cr = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        cr = c;
                                        break;
                                    }
                                }
                            }
                            int mo = pc.moveOrder + 1;
                            bool noCreatureOnTop = true;
                            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (crt.combatLocX == pc.combatLocX && crt.combatLocY == pc.combatLocY)
                                {
                                    noCreatureOnTop = false;
                                }
                            }

                            if (noCreatureOnTop)
                            {
                                drawText(getPixelLocX(pc.combatLocX) - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc.combatLocY) - (int)gv.drawFontRegHeight - (int)cr.glideAdderY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                            }
                        }
                    }
                }
            }
        }
        public void drawLosTrail()
        {
            //Player p = gv.mod.playerList[currentPlayerIndex];
            Player p = new Player();
            if (currentPlayerIndex < gv.mod.playerList.Count)
            {
                p = gv.mod.playerList[currentPlayerIndex];
            }
            else
            {
                p = gv.mod.playerList[gv.mod.playerList.Count - 1];
            }
            if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
            {
                //Uses the Screen Pixel Locations
                int endX = getPixelLocX(targetHighlightCenterLocation.X) + (gv.squareSize / 2);
                int endY = getPixelLocY(targetHighlightCenterLocation.Y) + (gv.squareSize / 2) + gv.oYshift;
                int startX = getPixelLocX(p.combatLocX) + (gv.squareSize / 2);
                int startY = getPixelLocY(p.combatLocY) + (gv.squareSize / 2) + gv.oYshift;
                //Uses the Map Pixel Locations
                int endX2 = targetHighlightCenterLocation.X * gv.squareSize + (gv.squareSize / 2);
                int endY2 = targetHighlightCenterLocation.Y * gv.squareSize + (gv.squareSize / 2);
                int startX2 = p.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int startY2 = p.combatLocY * gv.squareSize + (gv.squareSize / 2);

                //check if target is within attack distance, use green if true, red if false
                if (isVisibleLineOfSight(new Coordinate(startX2, startY2), new Coordinate(endX2, endY2)))
                {
                    drawVisibleLineOfSightTrail(new Coordinate(endX, endY), new Coordinate(startX, startY), Color.Lime, 2);
                }
                else
                {
                    drawVisibleLineOfSightTrail(new Coordinate(endX, endY), new Coordinate(startX, startY), Color.Red, 2);
                }
            }
        }
        public void drawMovingCombatCreatures(float elapsed)
        {

            //projectmover
            //the creature gilde adders x aor y not equalling zero migth be good indictaors for displaying the walk animation (alternate frames)
            //crt.glideAdderX and  crt.glideAdderY
            //crt.inactiveTimer = 0 indicates a wiggling movement going on

            //Creatures
            //update(int elapsed) handles the animations

            //miantain two frame sprite support through all of this

            //check these conditions in update(int elapsed) of ScreenCombat  
            //breathing/idle: only animate creatures 1) whose turn it currently NOT is and 2) with hp > 0
            //walking: only animate cretaures with 1) hp > 0 and 2a) whose crt.glideAdderX/crt.glideAdderY are not 0 or 2b) whose crt.inactiveTimwe equals 0
            //I think inactiveTimer needs to be longer as otherwise not enough room is left for idle and breathe animations
            //assign and unassign(!) crt.show... values accordingly (only one can be true anytime, likely no use for the normal and attack one, as there are systems for those already)
            //might use frameNumber, like main map does, too (a bit redundant)

            //use drawMovingCombatCreatures crt.show... values in drawMovingCombatCreatures()
            //crt.show.. values determine which frame/part of the sprite to use as src here
            //factor in creature size dimensiosn for picking the correct part of the sprite
            //mainmap is using prp.currentFrameNumber, truned into framePosition, for picking correct part, maybe copy that fro crt and combat

            //PC
            //to do: plan

            //MapScrolling
            //to do: plan

            //turned inot frameposition
            //doPropAnimations used to determine the prp.currentFrameNumber there
            //setting prp.showWalkingFrame(2), prp.showIdlingFrame(3), prp.showBreathingFrame(4)
            //normal woulsd 0 then and attack 1

            //mirror tehse setting for cretaure, add prp.showAttckFrame(1)

            //all states exclude each other
            //idle has only a chnce to kick in if no other stae is currently active and should be ended by the others

            //extra considertaion needed because of the differnt creature sizes possible in combat (tall, wide, large)
            //make sure tw always support the old two-frame-sprites (nomral, attack)

            //will need to do some breathing and idle pc animations, too (walkign will not work like as pc are not gliding in combat)

            //fast mode not used right now
            if ((gv.mod.fastMode) && (!isPlayerTurn))
            {
                framesInFastForwardCounter++;
                UpperLeftSquare.X = 0;
                UpperLeftSquare.Y = gv.mod.currentEncounter.MapSizeY;
                if (framesInFastForwardCounter <= 5)
                {
                    drawText(gv.screenWidth / 2 - 2 * gv.squareSize, gv.screenHeight / 2 - gv.squareSize, "Manoeuvres in the Dark", Color.White, 1.0f);
                }
                else if (framesInFastForwardCounter <= 10)
                {
                    drawText(gv.screenWidth / 2 - 2 * gv.squareSize, gv.screenHeight / 2 - gv.squareSize, "Manoeuvres in the Dark.", Color.White, 1.0f);
                }
                else if (framesInFastForwardCounter <= 15)
                {
                    drawText(gv.screenWidth / 2 - 2 * gv.squareSize, gv.screenHeight / 2 - gv.squareSize, "Manoeuvres in the Dark..", Color.White, 1.0f);
                }
                else if (framesInFastForwardCounter <= 20)
                {
                    drawText(gv.screenWidth / 2 - 2 * gv.squareSize, gv.screenHeight / 2 - gv.squareSize, "Manoeuvres in the Dark...", Color.White, 1.0f);
                }
                else if (framesInFastForwardCounter > 20)
                {
                    framesInFastForwardCounter = 0;
                    drawText(gv.screenWidth / 2 - 2 * gv.squareSize, gv.screenHeight / 2 - gv.squareSize, "Manoeuvres in the Dark", Color.White, 1.0f);
                }
            }

            //float glideSpeed = 0.4f * 3f * (100f / gv.mod.combatAnimationSpeed) * (1f + gv.mod.currentEncounter.encounterCreatureList.Count * 0.125f);
            float glideSpeed = 4.75f * (100f / gv.mod.combatAnimationSpeed) * elapsed / 30f;

            //make extra loop for glide speed of the current creature
            /*
            if (!isPlayerTurn)
            {
                Creature cr = new Creature();
                int highestLivingCrtMoveOrderfound = 0;
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (currentMoveOrderIndex == 0)
                    {
                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                        {
                            highestLivingCrtMoveOrderfound = c.moveOrder;
                            cr = c;
                        }
                    }
                    else
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            cr = c;
                            break;
                        }
                    }
                }

                if (gv.mod.useCombatSmoothMovement)
                {
                    if ((cr.combatLocX != cr.newCoor.X) || (cr.combatLocY != cr.newCoor.Y))
                    {
                        if ((cr.newCoor.X != -1) && (cr.newCoor.Y != -1))
                        {
                            //glide east
                            if ((cr.combatLocX < cr.newCoor.X) && (cr.combatLocY == cr.newCoor.Y))
                            {
                                cr.glideAdderX += 0.5f * glideSpeed;
                                if (getPixelLocX(cr.combatLocX) + cr.glideAdderX >= getPixelLocX(cr.newCoor.X))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide west
                            if ((cr.combatLocX > cr.newCoor.X) && (cr.combatLocY == cr.newCoor.Y))
                            {
                                cr.glideAdderX -= 0.5f * glideSpeed;
                                if (getPixelLocX(cr.combatLocX) + cr.glideAdderX <= getPixelLocX(cr.newCoor.X))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide north
                            if ((cr.combatLocX == cr.newCoor.X) && (cr.combatLocY > cr.newCoor.Y))
                            {
                                cr.glideAdderY -= 0.5f * glideSpeed;
                                if (getPixelLocY(cr.combatLocY) + cr.glideAdderY <= getPixelLocY(cr.newCoor.Y))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide south
                            if ((cr.combatLocX == cr.newCoor.X) && (cr.combatLocY < cr.newCoor.Y))
                            {
                                cr.glideAdderY += 0.5f * glideSpeed;
                                if (getPixelLocY(cr.combatLocY) + cr.glideAdderY >= getPixelLocY(cr.newCoor.Y))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide southeast
                            if ((cr.combatLocX < cr.newCoor.X) && (cr.combatLocY < cr.newCoor.Y))
                            {
                                cr.glideAdderX += 0.5f * glideSpeed;
                                cr.glideAdderY += 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX >= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY >= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide southwest
                            if ((cr.combatLocX > cr.newCoor.X) && (cr.combatLocY < cr.newCoor.Y))
                            {
                                cr.glideAdderX -= 0.5f * glideSpeed;
                                cr.glideAdderY += 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX <= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY >= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide northwest
                            if ((cr.combatLocX > cr.newCoor.X) && (cr.combatLocY > cr.newCoor.Y))
                            {
                                cr.glideAdderX -= 0.5f * glideSpeed;
                                cr.glideAdderY -= 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX <= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY <= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                            //glide northeast
                            if ((cr.combatLocX < cr.newCoor.X) && (cr.combatLocY > cr.newCoor.Y))
                            {
                                cr.glideAdderX += 0.5f * glideSpeed;
                                cr.glideAdderY -= 0.5f * glideSpeed;

                                if ((getPixelLocX(cr.combatLocX) + cr.glideAdderX >= getPixelLocX(cr.newCoor.X)) && (getPixelLocY(cr.combatLocY) + cr.glideAdderY <= getPixelLocY(cr.newCoor.Y)))
                                {

                                    cr.combatLocX = cr.newCoor.X;
                                    cr.combatLocY = cr.newCoor.Y;
                                    cr.glideAdderX = 0;
                                    cr.glideAdderY = 0;

                                    //CalculateUpperLeftCreature(cr);
                                    blockAnimationBridge = false;
                                }
                            }

                        }
                    }
                }
            }
            */

            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if ((!IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY)) || (!gv.mod.useCombatSmoothMovement))
                {
                    //if (creatureIndex <= (gv.mod.currentEncounter.encounterCreatureList.Count - 1))
                    //{
                    //if (((crt == gv.mod.currentEncounter.encounterCreatureList[creatureIndex]) && (!isPlayerTurn)) || (!gv.mod.useCombatSmoothMovement))
                    if (((crt.moveOrder == currentMoveOrderIndex - 1) && (!isPlayerTurn)) || (!gv.mod.useCombatSmoothMovement))

                    {
                        if ((crt.newCoor.X != -1) && (crt.newCoor.Y != -1))
                        {
                            crt.combatLocX = crt.newCoor.X;
                            crt.combatLocY = crt.newCoor.Y;
                        }

                        blockAnimationBridge = false;
                    }
                    //}
                    continue;
                }

                //if (creatureIndex < gv.mod.currentEncounter.encounterCreatureList.Count)
                //{
                //if ((crt == gv.mod.currentEncounter.encounterCreatureList[creatureIndex]) && (!isPlayerTurn) && (gv.mod.useCombatSmoothMovement))
                if ((crt.moveOrder == currentMoveOrderIndex - 1) && (!isPlayerTurn) && (gv.mod.useCombatSmoothMovement))
                {

                    if ((crt.combatLocX != crt.newCoor.X) || (crt.combatLocY != crt.newCoor.Y))
                    {
                        if ((crt.newCoor.X != -1) && (crt.newCoor.Y != -1))
                        {
                            //CalculateUpperLeftCreature(crt);
                            /*
                            //glide east
                            if ((crt.combatLocX < crt.newCoor.X) && (crt.combatLocY == crt.newCoor.Y))
                                {
                                    crt.glideAdderX += 0.5f * glideSpeed;
                                    if (getPixelLocX(crt.combatLocX) + crt.glideAdderX >= getPixelLocX(crt.newCoor.X))
                                    {
                                   
                                        crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                        //CalculateUpperLeftCreature(crt);
                                        blockAnimationBridge = false;
                                    }
                                }

                                //glide west
                                if ((crt.combatLocX > crt.newCoor.X) && (crt.combatLocY == crt.newCoor.Y))
                                {
                                    crt.glideAdderX -= 0.5f * glideSpeed;
                                    if (getPixelLocX(crt.combatLocX) + crt.glideAdderX <= getPixelLocX(crt.newCoor.X))
                                    {
                                    
                                    crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                        //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }

                                //glide north
                                if ((crt.combatLocX == crt.newCoor.X) && (crt.combatLocY > crt.newCoor.Y))
                                {
                                    crt.glideAdderY -= 0.5f * glideSpeed;
                                    if (getPixelLocY(crt.combatLocY) + crt.glideAdderY <= getPixelLocY(crt.newCoor.Y))
                                    {
                                    
                                    crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                    //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }

                                //glide south
                                if ((crt.combatLocX == crt.newCoor.X) && (crt.combatLocY < crt.newCoor.Y))
                                {
                                    crt.glideAdderY += 0.5f * glideSpeed;
                                    if (getPixelLocY(crt.combatLocY) + crt.glideAdderY >= getPixelLocY(crt.newCoor.Y))
                                    {
                                    
                                    crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                    //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }

                                //glide southeast
                                if ((crt.combatLocX < crt.newCoor.X) && (crt.combatLocY < crt.newCoor.Y))
                                {
                                    crt.glideAdderX += 0.5f * glideSpeed;
                                    crt.glideAdderY += 0.5f * glideSpeed;

                                    if ((getPixelLocX(crt.combatLocX) + crt.glideAdderX >= getPixelLocX(crt.newCoor.X)) && (getPixelLocY(crt.combatLocY) + crt.glideAdderY >= getPixelLocY(crt.newCoor.Y)))
                                    {
                                    
                                    crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                    //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }

                                //glide southwest
                                if ((crt.combatLocX > crt.newCoor.X) && (crt.combatLocY < crt.newCoor.Y))
                                {
                                    crt.glideAdderX -= 0.5f * glideSpeed;
                                    crt.glideAdderY += 0.5f * glideSpeed;

                                    if ((getPixelLocX(crt.combatLocX) + crt.glideAdderX <= getPixelLocX(crt.newCoor.X)) && (getPixelLocY(crt.combatLocY) + crt.glideAdderY >= getPixelLocY(crt.newCoor.Y)))
                                    {
                                    
                                    crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                    //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }

                                //glide northwest
                                if ((crt.combatLocX > crt.newCoor.X) && (crt.combatLocY > crt.newCoor.Y))
                                {
                                    crt.glideAdderX -= 0.5f * glideSpeed;
                                    crt.glideAdderY -= 0.5f * glideSpeed;

                                    if ((getPixelLocX(crt.combatLocX) + crt.glideAdderX <= getPixelLocX(crt.newCoor.X)) && (getPixelLocY(crt.combatLocY) + crt.glideAdderY <= getPixelLocY(crt.newCoor.Y)))
                                    {
                                    
                                        crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                    //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }

                                //glide northeast
                                if ((crt.combatLocX < crt.newCoor.X) && (crt.combatLocY > crt.newCoor.Y))
                                {
                                    crt.glideAdderX += 0.5f * glideSpeed;
                                    crt.glideAdderY -= 0.5f * glideSpeed;

                                    if ((getPixelLocX(crt.combatLocX) + crt.glideAdderX >= getPixelLocX(crt.newCoor.X)) && (getPixelLocY(crt.combatLocY) + crt.glideAdderY <= getPixelLocY(crt.newCoor.Y) ))
                                    {
                                        
                                        crt.combatLocX = crt.newCoor.X;
                                        crt.combatLocY = crt.newCoor.Y;
                                        crt.glideAdderX = 0;
                                        crt.glideAdderY = 0;
                                        
                                    //CalculateUpperLeftCreature(crt);
                                    blockAnimationBridge = false;
                                    }
                                }
                                */
                        }
                    }
                }
                //}
                #region
                int randXInt = 0;
                int randYInt = 0;
                float randX = 0;
                float randY = 0;
                int decider = 0;
                //projectmover
                //chnace was 80, try reducing to 30
                int moveChance = 80;

                int normalizedDecider = (int)(25f / (elapsed / 30f));
                decider = gv.sf.RandInt(normalizedDecider);

                if ((decider == 1) && (crt.inactiveTimer == 0))
                {
                    //crt.inactiveTimer += gv.sf.RandInt(2);
                    crt.inactiveTimer += elapsed / 30f;
                }

                if (crt.inactiveTimer != 0)
                {
                    crt.inactiveTimer += elapsed / 30f;
                }

                //increasing threshold to give room to breathing and idle
                //projectmover
                //was 100, trying 700, looks like a good middleground
                if (crt.inactiveTimer > 450)
                {
                    crt.inactiveTimer = 0;
                }

                if ((gv.sf.RandInt(100) <= moveChance) && (crt.inactiveTimer == 0))
                {
                    randXInt = gv.sf.RandInt(100);
                    randX = (randXInt + 75) / 250f;
                    if (!crt.goRight)
                    {
                        crt.straightLineDistanceX += randX;
                        randX = -1 * randX;
                        if (crt.straightLineDistanceX >= 1.5f * gv.pS)
                        {
                            crt.goRight = true;
                            crt.straightLineDistanceX = 0;
                        }

                    }
                    else if (crt.goRight)
                    {
                        crt.straightLineDistanceX += randX;
                        randX = randX;
                        if (crt.straightLineDistanceX >= 1.5f * gv.pS)
                        {
                            crt.goRight = false;
                            crt.straightLineDistanceX = 0;
                        }
                    }

                    randYInt = gv.sf.RandInt(100);
                    randY = (randYInt + 75) / 250f;
                    if (!crt.goDown)
                    {
                        crt.straightLineDistanceY += randY;
                        randY = -1 * randY;
                        if (crt.straightLineDistanceY >= 1.5 * gv.pS)
                        {
                            crt.goDown = true;
                            crt.straightLineDistanceY = 0;
                        }

                    }
                    else if (crt.goDown)
                    {
                        crt.straightLineDistanceY += randY;
                        randY = randY;
                        if (crt.straightLineDistanceY >= 1.5 * gv.pS)
                        {
                            crt.goDown = false;
                            crt.straightLineDistanceY = 0;
                        }
                    }

                    crt.roamDistanceX += randX;
                    crt.roamDistanceY += randY;
                }

                //stopmichael

                //north on map for nomral and tall creatures
                if ((crt.creatureSize == 1 || crt.creatureSize == 3) && crt.roamDistanceY < 0)
                {
                    if ((crt.combatLocY - 1) > 0)
                    {
                        //north not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.Y - 1 >= 0)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y - 1) * gv.mod.currentEncounter.MapSizeX + coord.X].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //north occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.Y - 1 >= 0)
                                    {
                                        if (p.hp > 0 && coord.X == p.combatLocX && (coord.Y - 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.Y - 1 >= 0)
                                                {
                                                    if (coord.X == coordOther.X && (coord.Y - 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //north not on map
                    else
                    {
                        crt.roamDistanceY = 0;
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //north for wide(2) and large(4) creatures
                if ((crt.creatureSize == 2 || crt.creatureSize == 4) && crt.roamDistanceY < 0)
                {
                    if ((crt.combatLocY - 1) > 0)
                    {
                        //north not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.Y - 1 >= 0)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y - 1) * gv.mod.currentEncounter.MapSizeX + coord.X].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                            if (coord.Y - 1 >= 0 && coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y - 1) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //north occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.Y - 1 >= 0)
                                    {
                                        if (p.hp > 0 && coord.X == p.combatLocX && (coord.Y - 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                    if (coord.Y - 1 >= 0 && coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y - 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.Y - 1 >= 0)
                                                {
                                                    if (coord.X == coordOther.X && (coord.Y - 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }

                                                if (coord.Y - 1 >= 0 && coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y - 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //north not on map
                    else
                    {
                        crt.roamDistanceY = 0;
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxx

                //west on map: for normal(1) and wide creatures (2)
                if ((crt.creatureSize == 1 || crt.creatureSize == 2) && crt.roamDistanceX < 0)
                {
                    if ((crt.combatLocX - 1) > 0)
                    {
                        //north not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.X - 1 >= 0)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y) * gv.mod.currentEncounter.MapSizeX + (coord.X - 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //north occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.X - 1 >= 0)
                                    {
                                        if (p.hp > 0 && (coord.X - 1) == p.combatLocX && (coord.Y) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.X - 1 >= 0)
                                                {
                                                    if ((coord.X - 1) == coordOther.X && (coord.Y) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //west not on map
                    else
                    {
                        crt.roamDistanceX = 0;
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //west on map: for  tall (3) and large creatures (4)
                if ((crt.creatureSize == 3 || crt.creatureSize == 4) && crt.roamDistanceX < 0)
                {
                    if ((crt.combatLocX - 1) > 0)
                    {
                        //west not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.X - 1 >= 0)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y) * gv.mod.currentEncounter.MapSizeX + (coord.X - 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                            if (coord.X - 1 >= 0 && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + (coord.X - 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //west occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.X - 1 >= 0)
                                    {
                                        if (p.hp > 0 && (coord.X - 1) == p.combatLocX && (coord.Y) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }

                                    if (coord.X - 1 >= 0 && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && (coord.X - 1) == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.X - 1 >= 0)
                                                {
                                                    if ((coord.X - 1) == coordOther.X && (coord.Y) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }

                                                if (coord.X - 1 >= 0 && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if ((coord.X - 1) == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //west not on map
                    else
                    {
                        crt.roamDistanceX = 0;
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                //south and east will require four different cases each

                //south on map (for normal)
                if ((crt.creatureSize == 1) && crt.roamDistanceY > 0)
                {
                    if ((crt.combatLocY + 1 < gv.mod.currentEncounter.MapSizeY))
                    {
                        //south not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + coord.X].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //north occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && coord.X == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if (coord.X == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //south not on map
                    else
                    {
                        crt.roamDistanceY = 0;
                    }
                }
                //south on map for tall (Size 3) tall creatures - the relevant y is one higher
                else if ((crt.creatureSize == 3) && crt.roamDistanceY > 0)
                {
                    if ((crt.combatLocY + 2 < gv.mod.currentEncounter.MapSizeY))
                    {
                        //south not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + coord.X].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //south occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && coord.X == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if (coord.X == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //south not on map
                    else
                    {
                        crt.roamDistanceY = 0;
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxx
                //south on map (for wide, 2)
                else if ((crt.creatureSize == 2) && crt.roamDistanceY > 0)
                {
                    if ((crt.combatLocY + 1 < gv.mod.currentEncounter.MapSizeY))
                    {
                        //south not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + coord.X].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }

                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //north occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && coord.X == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }

                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if (coord.X == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }

                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //south not on map
                    else
                    {
                        crt.roamDistanceY = 0;
                    }
                }

                //souht for large cretaures (4)
                else if ((crt.creatureSize == 4) && crt.roamDistanceY > 0)
                {
                    if ((crt.combatLocY + 2 < gv.mod.currentEncounter.MapSizeY))
                    {
                        //south not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + coord.X].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }

                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceY = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //south occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && coord.X == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }

                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceY = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if (coord.X == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }

                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceY = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //south not on map
                    else
                    {
                        crt.roamDistanceY = 0;
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxx
                //Now finally the four east (right) cases
                //east on map (for normal)
                if ((crt.creatureSize == 1) && crt.roamDistanceX > 0)
                {
                    if ((crt.combatLocX + 1 < gv.mod.currentEncounter.MapSizeX))
                    {
                        //east not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //east occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //east not on map
                    else
                    {
                        crt.roamDistanceX = 0;
                    }
                }
                //TODO from here; think aboiut purley diagonal obstacles???
                //east on map for wide (Size 2) creatures - the relevant x is one higher
                else if ((crt.creatureSize == 2) && crt.roamDistanceX > 0)
                {
                    if ((crt.combatLocX + 2 < gv.mod.currentEncounter.MapSizeX))
                    {
                        //south not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //south occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //east not on map
                    else
                    {
                        crt.roamDistanceX = 0;
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxx
                //east on map (for tall, 3)
                else if ((crt.creatureSize == 3) && crt.roamDistanceX > 0)
                {
                    if ((crt.combatLocX + 1 < gv.mod.currentEncounter.MapSizeX))
                    {
                        //south not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //east occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }

                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }

                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //east not on map
                    else
                    {
                        crt.roamDistanceX = 0;
                    }
                }

                //east for large cretaures (4)
                else if ((crt.creatureSize == 4) && crt.roamDistanceX > 0)
                {
                    if ((crt.combatLocX + 2 < gv.mod.currentEncounter.MapSizeX))
                    {
                        //east not walkable
                        bool lookForOthers = true;
                        foreach (Coordinate coord in crt.tokenCoveredSquares)
                        {
                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }

                            if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                            {
                                if (!gv.mod.currentEncounter.encounterTiles[(coord.Y + 1) * gv.mod.currentEncounter.MapSizeX + (coord.X + 1)].Walkable)
                                {
                                    crt.roamDistanceX = 0;
                                    lookForOthers = false;
                                    break;
                                }
                            }
                        }

                        //south occupied by player or creature
                        if (lookForOthers)
                        {
                            //player
                            bool lookForCreatures = true;
                            bool foundPlayer = false;
                            foreach (Coordinate coord in crt.tokenCoveredSquares)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }

                                    if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                    {
                                        if (p.hp > 0 && (coord.X + 1) == p.combatLocX && (coord.Y + 1) == p.combatLocY)
                                        {
                                            crt.roamDistanceX = 0;
                                            lookForCreatures = false;
                                            foundPlayer = true;
                                            break;
                                        }
                                    }
                                }
                                if (foundPlayer)
                                {
                                    break;
                                }
                            }

                            //creature
                            if (lookForCreatures)
                            {
                                bool breakAllNested = false;
                                foreach (Coordinate coord in crt.tokenCoveredSquares)
                                {
                                    foreach (Creature cOther in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (cOther != crt && cOther.hp > 0)
                                        {
                                            foreach (Coordinate coordOther in cOther.tokenCoveredSquares)
                                            {
                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }

                                                if (coord.X + 1 < gv.mod.currentEncounter.MapSizeX && coord.Y + 1 < gv.mod.currentEncounter.MapSizeY)
                                                {
                                                    if ((coord.X + 1) == coordOther.X && (coord.Y + 1) == coordOther.Y)
                                                    {
                                                        crt.roamDistanceX = 0;
                                                        breakAllNested = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (breakAllNested)
                                        {
                                            break;
                                        }
                                    }
                                    if (breakAllNested)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //east not on map
                    else
                    {
                        crt.roamDistanceX = 0;
                    }
                }
                #endregion
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                //XXXXXXXXXXXXXXXXXXXXXx
                //IbRect dst = new IbRect((int)this.position.X, (int)(this.position.Y + randY), (int)((gv.squareSize * this.scaleX) + randX), (int)(gv.squareSize * this.scaleY));

                int width = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Width;
                int height = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Height;
                //1=normal, 2=wide, 3=tall, 4=large  
                int crtSize = crt.creatureSize;
                //IbRectF src = new IbRectF(0, 0, width, height / 2);
                IbRectF src = new IbRectF(0, 0, width, 100);
                if (crtSize == 3 || crtSize == 4)
                {
                    src = new IbRectF(0, 0, width, 200);
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxx
                /*
                attackAnimationDelayCounter++;
                if (attackAnimationDelayCounter >= (int)(crt.token.PixelSize.Height / 100f - 1))
                {
                    attackAnimationFrameCounter++;
                    attackAnimationDelayCounter = 0;
                }
                int maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 100f - 1);
                if ((crtSize == 3) || (crtSize == 4))
                {
                    maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 200f - 1);
                }
                if (attackAnimationFrameCounter > maxUsableCounterValue)
                {
                    attackAnimationFrameCounter = maxUsableCounterValue;
                    blockAnimationBridge = false;
                }
                */
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                //if ((creatureToAnimate != null) && (creatureToAnimate == crt))
                if ((creatureToAnimate.Count > 0) && (creatureToAnimate.Contains(crt)))
                {
                    //blockAnimationBridge = true;
                    //narr
                    attackAnimationDelayCounter++;
                    //if (attackAnimationDelayCounter >= (int)(crt.token.PixelSize.Height / 100f - 1))
                    //slowdown
                    //if (attackAnimationDelayCounter >= (int)((elapsed / 30f)*20))
                    if (attackAnimationDelayCounter >= 1)
                    {
                        attackAnimationFrameCounter++;
                        attackAnimationDelayCounter = 0;
                    }
                    int maxUsableCounterValue = 1;
                    if ((crtSize == 3) || (crtSize == 4))
                    {
                        maxUsableCounterValue = 1;
                    }
                    if (attackAnimationFrameCounter > 1)
                    {
                        attackAnimationFrameCounter = 1;
                        blockAnimationBridge = false;
                    }

                    if (crt.creatureSize == 1)
                    {
                        src = new IbRectF(0, crt.token.PixelSize.Width * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                    }
                    else if (crt.creatureSize == 2)
                    {
                        src = new IbRectF(0, crt.token.PixelSize.Width / 2 * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width / 2);
                    }
                    else if (crt.creatureSize == 3)
                    {
                        src = new IbRectF(0, crt.token.PixelSize.Width * 2 * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width * 2);
                    }
                    else if (crt.creatureSize == 4)
                    {
                        src = new IbRectF(0, crt.token.PixelSize.Width * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                    }

                    //src = new IbRect(0, height / 2, width, height / 2);
                }
                //use different parts of the source file here for walking, idling, breathing
                else
                {
                    //IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                    //walking
                    if (crt.currentFrameNumber == 2 || crt.currentFrameNumber == 3 || crt.currentFrameNumber == 4)
                    {
                        //normal
                        if (crt.creatureSize == 1)
                        {
                            src = new IbRectF(0, crt.token.PixelSize.Width * crt.currentFrameNumber, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                        }
                        //wide
                        else if (crt.creatureSize == 2)
                        {
                            src = new IbRectF(0, crt.token.PixelSize.Width / 2 * crt.currentFrameNumber, crt.token.PixelSize.Width, crt.token.PixelSize.Width / 2);
                        }
                        //tall
                        else if (crt.creatureSize == 3)
                        {
                            src = new IbRectF(0, crt.token.PixelSize.Width * 2 * crt.currentFrameNumber, crt.token.PixelSize.Width, crt.token.PixelSize.Width * 2);
                        }
                        //large
                        else if (crt.creatureSize == 4)
                        {
                            src = new IbRectF(0, crt.token.PixelSize.Width * crt.currentFrameNumber, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                        }
                    }

                }


                //normal
                IbRectF dst = new IbRectF(getPixelLocX(crt.combatLocX) + crt.roamDistanceX + crt.glideAdderX, getPixelLocY(crt.combatLocY) + crt.roamDistanceY + crt.glideAdderY, gv.squareSize, gv.squareSize);

                //wide  
                if (crtSize == 2)
                {
                    dst = new IbRectF(getPixelLocX(crt.combatLocX) + crt.roamDistanceX + crt.glideAdderX, getPixelLocY(crt.combatLocY) + crt.roamDistanceY + crt.glideAdderY, gv.squareSize * 2, gv.squareSize);
                }

                //tall  
                if (crtSize == 3)
                {
                    //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                    dst = new IbRectF(getPixelLocX(crt.combatLocX) + crt.roamDistanceX + crt.glideAdderX, getPixelLocY(crt.combatLocY) + crt.roamDistanceY + crt.glideAdderY, gv.squareSize, gv.squareSize * 2);
                }

                //large  
                if (crtSize == 4)
                {
                    dst = new IbRectF(getPixelLocX(crt.combatLocX) + crt.roamDistanceX + crt.glideAdderX, getPixelLocY(crt.combatLocY) + crt.roamDistanceY + crt.glideAdderY, gv.squareSize * 2, gv.squareSize * 2);
                }

                //if (crt.token.PixelSize.Width > 100)
                //{
                //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                //}

                bool drawCreature = true;
                foreach (Coordinate c in gv.screenCombat.deathAnimationLocations)
                {
                    if (c.X == crt.combatLocX && c.Y == crt.combatLocY)
                    {
                        drawCreature = false;
                        break;
                    }
                }
                if (drawCreature)
                {

                    if (!isPlayerTurn)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        //tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                        //tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                        if (cr.moveOrder != crt.moveOrder)
                        {
                            dst.Left -= (int)(cr.glideAdderX);
                            dst.Top -= (int)(cr.glideAdderY);
                        }
                        else
                        {
                            //dst.Left -= (int)(cr.glideAdderX);
                            //dst.Top -= (int)(cr.glideAdderY);
                            dst.Left = gv.screenWidth / 2 - gv.squareSize / 2;
                            dst.Top = gv.screenHeight / 2 - gv.squareSize / 2;

                            //CalculateUpperLeftCreature(cr); 
                            //gv.cc.addLogText("white", "X-Add:" + cr. glideAdderX);
                            //gv.cc.addLogText("white", "Y-Add:" + cr.glideAdderY);
                            //gv.cc.addLogText("white", "X-Loc:" + cr.combatLocX);
                            //gv.cc.addLogText("white", "Y-Loc:" + cr.combatLocY);
                            //gv.cc.addLogText("white", "X-NewCo:" + cr.newCoor.X);
                            //gv.cc.addLogText("white", "Y-NewCo:" + cr.newCoor.Y);
                            //gv.cc.addLogText("white", "UpperX:" + UpperLeftSquare.X);
                            //gv.cc.addLogText("white", "UpperY:" + UpperLeftSquare.Y);
                            //gv.cc.addLogText("white", "UpperX:" + getPixelLocX(cr.combatLocX));
                            //gv.cc.addLogText("white", "UpperY:" + getPixelLocX(cr.combatLocY));

                        }

                    }
                    gv.DrawBitmap(crt.token, src, dst, !crt.combatFacingLeft);
                }
                else
                {
                    //normal
                    dst = new IbRectF(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize, gv.squareSize);

                    //wide  
                    if (crtSize == 2)
                    {
                        dst = new IbRectF(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize * 2, gv.squareSize);
                    }

                    //tall  
                    if (crtSize == 3)
                    {
                        //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                        dst = new IbRectF(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize, gv.squareSize * 2);
                    }

                    //large  
                    if (crtSize == 4)
                    {
                        dst = new IbRectF(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize * 2, gv.squareSize * 2);
                    }
                    if (!isPlayerTurn)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        //tlX = (x - UpperLeftSquare.X + shiftX) * gv.squareSize - (int)(cr.glideAdderX) + gv.oXshift + mapStartLocXinPixels;
                        //tlY = (y - UpperLeftSquare.Y + shiftY) * gv.squareSize - (int)cr.glideAdderY;
                        if (cr.moveOrder != crt.moveOrder)
                        {
                            dst.Left -= (int)(cr.glideAdderX);
                            dst.Top -= (int)(cr.glideAdderY);
                        }

                        else
                        {
                            dst.Left -= (int)(cr.glideAdderX);
                            dst.Top -= (int)(cr.glideAdderY);
                        }


                    }
                    gv.DrawBitmap(crt.token, src, dst, !crt.combatFacingLeft);
                }

                /*
                //start
                IbRectF dst = new IbRectF(getPixelLocX(crt.combatLocX) + crt.roamDistanceX + crt.glideAdderX, getPixelLocY(crt.combatLocY) + crt.roamDistanceY + crt.glideAdderY, gv.squareSize, gv.squareSize);
                if (crt.token.PixelSize.Width > 100)
                {
                    dst = new IbRectF(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2) + crt.roamDistanceX + crt.glideAdderX, getPixelLocY(crt.combatLocY) - (gv.squareSize / 2) + crt.roamDistanceY + crt.glideAdderY, gv.squareSize * 2, gv.squareSize * 2);
                }

                IbRectF src = new IbRectF(0, 0, gv.cc.turn_marker.PixelSize.Width, gv.cc.turn_marker.PixelSize.Height);
                //if ((crt == gv.mod.currentEncounter.encounterCreatureList[creatureIndex]) && (!isPlayerTurn))
                //{
                //gv.DrawBitmap(gv.cc.turn_marker, src, dst);
                //}
                src = new IbRectF(0, 0, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                //for 100x100px per frame creatures
                if (crt.token.PixelSize.Width <= 100)
                {
                    if ((creatureToAnimate != null) && (creatureToAnimate == crt))
                    {
                        //blockAnimationBridge = true;
                        attackAnimationDelayCounter++;
                        if (attackAnimationDelayCounter >= (int)(crt.token.PixelSize.Height / 100f - 1))
                        {
                            attackAnimationFrameCounter++;
                            attackAnimationDelayCounter = 0;
                        }
                        maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 100f - 1);
                        if (attackAnimationFrameCounter >= maxUsableCounterValue)
                        {
                            attackAnimationFrameCounter = maxUsableCounterValue;
                            blockAnimationBridge = false;
                        }
                        src = new IbRectF(0, crt.token.PixelSize.Width * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                    }
                }
                //for 200x200 per frame creatures
                else
                {
                    if ((creatureToAnimate != null) && (creatureToAnimate == crt))
                    {
                        //blockAnimationBridge = true;
                        attackAnimationDelayCounter++;
                        if (attackAnimationDelayCounter >= (int)(crt.token.PixelSize.Height / 200f - 1))
                        {
                            attackAnimationFrameCounter++;
                            attackAnimationDelayCounter = 0;
                        }
                        maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 200f - 1);
                        if (attackAnimationFrameCounter >= maxUsableCounterValue)
                        {
                            attackAnimationFrameCounter = maxUsableCounterValue;
                            blockAnimationBridge = false;
                        }
                        src = new IbRectF(0, crt.token.PixelSize.Width * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                    }
                }
                if (attackAnimationFrameCounter > 2)
                {
                    //gv.cc.addLogText("lime", "attack animation frame counter is:" + attackAnimationFrameCounter.ToString());
                }
                gv.DrawBitmap(crt.token, src, dst, !crt.combatFacingLeft);

                //end
                */

                //if (!animationsOn && drawCreature)
                //always show efects
                //CREATURE FACING
                src = new IbRectF(0, 0, gv.cc.facing1.PixelSize.Width, gv.cc.facing1.PixelSize.Height);

                if (drawCreature)
                {
                    if (crt.combatFacing == 8) { gv.DrawBitmap(gv.cc.facing8, src, dst); }
                    else if (crt.combatFacing == 9) { gv.DrawBitmap(gv.cc.facing9, src, dst); }
                    else if (crt.combatFacing == 6) { gv.DrawBitmap(gv.cc.facing6, src, dst); }
                    else if (crt.combatFacing == 3) { gv.DrawBitmap(gv.cc.facing3, src, dst); }
                    else if (crt.combatFacing == 2) { gv.DrawBitmap(gv.cc.facing2, src, dst); }
                    else if (crt.combatFacing == 1) { gv.DrawBitmap(gv.cc.facing1, src, dst); }
                    else if (crt.combatFacing == 4) { gv.DrawBitmap(gv.cc.facing4, src, dst); }
                    else if (crt.combatFacing == 7) { gv.DrawBitmap(gv.cc.facing7, src, dst); }
                    else { } //didn't find one
                }

                if (drawCreature)
                {
                    int effectCounter = 0;
                    foreach (Effect ef in crt.cr_effectsList)
                    {

                        Bitmap fx = gv.cc.LoadBitmap(ef.spriteFilename);
                        src = new IbRectF(0, 0, fx.PixelSize.Width, fx.PixelSize.Width);
                        IbRectF dst2 = new IbRectF(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                        if (!gv.mod.allEffectsUseFullSizeIcons && !ef.thisEffectUsesFullSizeIcon)
                        {
                            effectCounter++;
                            if (effectCounter == 2)
                            {
                                dst2 = new IbRectF(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 3)
                            {
                                dst2 = new IbRectF(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 4)
                            {
                                dst2 = new IbRectF(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 5)
                            {
                                dst2 = new IbRectF(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 6)
                            {
                                dst2 = new IbRectF(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 7)
                            {
                                dst2 = new IbRectF(dst.Left, dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 8)
                            {
                                dst2 = new IbRectF(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 9)
                            {
                                dst2 = new IbRectF(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                        }
                        else
                        {
                            dst2 = new IbRectF(dst.Left, dst.Top, (int)(gv.squareSize), (int)(gv.squareSize));
                        }
                        gv.DrawBitmap(fx, src, dst2);
                        gv.cc.DisposeOfBitmap(ref fx);
                    }
                }
                //CREATURE FACING
                src = new IbRectF(0, 0, gv.cc.facing1.PixelSize.Width, gv.cc.facing1.PixelSize.Height);

                if (drawCreature)
                {


                    if (showMoveOrder)
                    {
                        Creature cr = new Creature();
                        int highestLivingCrtMoveOrderfound = 0;
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (currentMoveOrderIndex == 0)
                            {
                                if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                {
                                    highestLivingCrtMoveOrderfound = c.moveOrder;
                                    cr = c;
                                }
                            }
                            else
                            {
                                if (c.moveOrder == currentMoveOrderIndex - 1)
                                {
                                    cr = c;
                                    break;
                                }
                            }
                        }
                        int mo = crt.moveOrder + 1;
                        if (cr == crt)
                        {
                            drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) - (int)gv.drawFontRegHeight + (int)crt.roamDistanceY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                        }
                        else
                        {
                            drawText(getPixelLocX(crt.combatLocX) - (int)(cr.glideAdderX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) - (int)gv.drawFontRegHeight - (int)(cr.glideAdderY) + (int)crt.roamDistanceY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                        }
                    }
                }
            }
        }
        public void drawCombatCreatures()
        {
            if (gv.mod.currentEncounter.encounterCreatureList.Count > 0)
            {
                if (!isPlayerTurn)
                {
                    //if (creatureIndex < gv.mod.currentEncounter.encounterCreatureList.Count)
                    //{
                    Creature cr = new Creature();
                    int highestLivingCrtMoveOrderfound = 0;
                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (currentMoveOrderIndex == 0)
                        {
                            if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                            {
                                highestLivingCrtMoveOrderfound = c.moveOrder;
                                cr = c;
                            }
                        }
                        else
                        {
                            if (c.moveOrder == currentMoveOrderIndex - 1)
                            {
                                cr = c;
                                break;
                            }
                        }
                    }
                    //Creature cr = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
                    if (IsInVisibleCombatWindow(cr.combatLocX, cr.combatLocY))
                    {
                        IbRect src = new IbRect(0, 0, gv.cc.turn_marker.PixelSize.Width, gv.cc.turn_marker.PixelSize.Height);
                        //IbRect dst = new IbRect(getPixelLocX(cr.combatLocX), getPixelLocY(cr.combatLocY), gv.squareSize, gv.squareSize);
                        //gv.DrawBitmap(gv.cc.turn_marker, src, dst);
                        foreach (Coordinate coor in cr.tokenCoveredSquares)
                        {
                            IbRect dst = new IbRect(getPixelLocX(coor.X), getPixelLocY(coor.Y), gv.squareSize, gv.squareSize);
                            gv.DrawBitmap(gv.cc.turn_marker, src, dst);
                        }
                    }
                    //}
                }
            }
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                bool drawCreature = false;
                foreach (Coordinate coor in crt.tokenCoveredSquares)
                {
                    if (IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        drawCreature = true;
                    }
                }

                if (!drawCreature)
                {
                    continue;
                }

                //if (!IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                //{
                //continue;
                //}

                //IbRect src = new IbRect(0, 0, crt.token.PixelSize.Width, crt.token.PixelSize.Width);

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                /*
                int width = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Width;
                int height = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Height;
                //1=normal, 2=wide, 3=tall, 4=large  
                int crtSize = crt.creatureSize;
                IbRect src = new IbRect(0, 0, width, height / 2);

                //if ((creatureToAnimate != null) && (creatureToAnimate == crt))
                if ((creatureToAnimate.Count > 0) && (creatureToAnimate.Contains(crt)))
                {
                    //blockAnimationBridge = true;
                    attackAnimationDelayCounter++;
                    if (attackAnimationDelayCounter >= (int)(crt.token.PixelSize.Height / 100f - 1))
                    {
                        attackAnimationFrameCounter++;
                        attackAnimationDelayCounter = 0;
                    }
                    int maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 100f - 1);
                    if (attackAnimationFrameCounter > maxUsableCounterValue)
                    {
                        attackAnimationFrameCounter = maxUsableCounterValue;
                        blockAnimationBridge = false;
                    }
                    src = new IbRect(0, crt.token.PixelSize.Width * attackAnimationFrameCounter, crt.token.PixelSize.Width, crt.token.PixelSize.Width);
                    //src = new IbRect(0, height / 2, width, height / 2);
                }

                //normal
                IbRect dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize, gv.squareSize);

                //wide  
                if (crtSize == 2)
                {
                    dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize * 2, gv.squareSize);
                }

                //tall  
                if (crtSize == 3)
                {
                    //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                    dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize, gv.squareSize * 2);
                }

                //large  
                if (crtSize == 4)
                {
                    dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize * 2, gv.squareSize * 2);
                }

                //if (crt.token.PixelSize.Width > 100)
                //{
                //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                //}

                gv.DrawBitmap(crt.token, src, dst, !crt.combatFacingLeft);
                */
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                //AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                int width = gv.cc.GetFromBitmapList(crt.cr_tokenFilename).PixelSize.Width;
                int height = width; // for normal and large creatures
                
                //1=normal, 2=wide, 3=tall, 4=large  
                int crtSize = crt.creatureSize;
                
                if (crtSize == 2) //wide
                {
                    height = width / 2;
                } 
                if (crtSize == 3) //tall
                {
                    height = width * 2;
                }
                
                IbRect src = new IbRect(0, 0, width, height);

                //if ((creatureToAnimate != null) && (creatureToAnimate == crt))
                if ((creatureToAnimate.Count > 0) && (creatureToAnimate.Contains(crt)))
                {
                    //blockAnimationBridge = true;
                    attackAnimationDelayCounter++;
                    if (attackAnimationDelayCounter >= (int)(crt.token.PixelSize.Height / 100f - 1))
                    {
                        attackAnimationFrameCounter++;
                        attackAnimationDelayCounter = 0;
                    }
                    int maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 100f - 1);
                    if ((crtSize == 3) || (crtSize == 4))
                    {
                        maxUsableCounterValue = (int)(crt.token.PixelSize.Height / 200f - 1);
                    }
                    if (attackAnimationFrameCounter > maxUsableCounterValue)
                    {
                        attackAnimationFrameCounter = maxUsableCounterValue;
                        blockAnimationBridge = false;
                    }
                    src = new IbRect(0, height * attackAnimationFrameCounter, width, height);
                    //src = new IbRect(0, height / 2, width, height / 2);
                    //wide  
                    
                }

                //normal
                IbRect dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize, gv.squareSize);

                //wide  
                if (crtSize == 2)
                {
                    dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize * 2, gv.squareSize);
                }

                //tall  
                if (crtSize == 3)
                {
                    //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                    dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize, gv.squareSize * 2);
                }

                //large  
                if (crtSize == 4)
                {
                    dst = new IbRect(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY), gv.squareSize * 2, gv.squareSize * 2);
                }

                //if (crt.token.PixelSize.Width > 100)
                //{
                //dst = new IbRect(getPixelLocX(crt.combatLocX) - (gv.squareSize / 2), getPixelLocY(crt.combatLocY) - (gv.squareSize / 2), gv.squareSize * 2, gv.squareSize * 2);
                //}

                gv.DrawBitmap(crt.token, src, dst, !crt.combatFacingLeft, false);


                //CREATURE FACING
                src = new IbRect(0, 0, gv.cc.facing1.PixelSize.Width, gv.cc.facing1.PixelSize.Height);
                if (crt.combatFacing == 8) { gv.DrawBitmap(gv.cc.facing8, src, dst); }
                else if (crt.combatFacing == 9) { gv.DrawBitmap(gv.cc.facing9, src, dst); }
                else if (crt.combatFacing == 6) { gv.DrawBitmap(gv.cc.facing6, src, dst); }
                else if (crt.combatFacing == 3) { gv.DrawBitmap(gv.cc.facing3, src, dst); }
                else if (crt.combatFacing == 2) { gv.DrawBitmap(gv.cc.facing2, src, dst); }
                else if (crt.combatFacing == 1) { gv.DrawBitmap(gv.cc.facing1, src, dst); }
                else if (crt.combatFacing == 4) { gv.DrawBitmap(gv.cc.facing4, src, dst); }
                else if (crt.combatFacing == 7) { gv.DrawBitmap(gv.cc.facing7, src, dst); }
                else { } //didn't find one
                //AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                //if (!animationsOn)
                {
                    int effectCounter = 0;
                    foreach (Effect ef in crt.cr_effectsList)
                    {

                        Bitmap fx = gv.cc.LoadBitmap(ef.spriteFilename);
                        src = new IbRect(0, 0, fx.PixelSize.Width, fx.PixelSize.Width);
                        IbRect dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                        if (!gv.mod.allEffectsUseFullSizeIcons && !ef.thisEffectUsesFullSizeIcon)
                        {
                            effectCounter++;
                            if (effectCounter == 2)
                            {
                                dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 3)
                            {
                                dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 2f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 4)
                            {
                                dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 5)
                            {
                                dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 6)
                            {
                                dst2 = new IbRect(dst.Left + (int)(gv.squareSize / 3f * 1f), dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 7)
                            {
                                dst2 = new IbRect(dst.Left, dst.Top, (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 8)
                            {
                                dst2 = new IbRect(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 1f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                            if (effectCounter == 9)
                            {
                                dst2 = new IbRect(dst.Left, dst.Top + (int)(gv.squareSize / 3f * 2f), (int)(gv.squareSize / 3f), (int)(gv.squareSize / 3f));
                            }
                        }
                        else
                        {
                            dst2 = new IbRect(dst.Left, dst.Top, (int)(gv.squareSize), (int)(gv.squareSize));
                        }
                        gv.DrawBitmap(fx, src, dst2);
                        gv.cc.DisposeOfBitmap(ref fx);
                    }
                }


                if (showMoveOrder)
                {
                    Creature cr = new Creature();
                    int highestLivingCrtMoveOrderfound = 0;
                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (currentMoveOrderIndex == 0)
                        {
                            if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                            {
                                highestLivingCrtMoveOrderfound = c.moveOrder;
                                cr = c;
                            }
                        }
                        else
                        {
                            if (c.moveOrder == currentMoveOrderIndex - 1)
                            {
                                cr = c;
                                break;
                            }
                        }
                    }
                    int mo = crt.moveOrder + 1;
                    if (cr == crt)
                    {
                        drawText(getPixelLocX(crt.combatLocX) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) - (int)gv.drawFontRegHeight - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                    }
                    else
                    {
                        drawText(getPixelLocX(crt.combatLocX) - (int)(cr.glideAdderX) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) - (int)gv.drawFontRegHeight - (int)(cr.glideAdderY) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                    }
                }
            }
        }
        public void drawTargetHighlight()
        {
            //Player pc = gv.mod.playerList[currentPlayerIndex];
            Player pc = new Player();
            if (currentPlayerIndex < gv.mod.playerList.Count)
            {
                pc = gv.mod.playerList[currentPlayerIndex];
            }
            else
            {
                pc = gv.mod.playerList[gv.mod.playerList.Count - 1];
            }
            if (currentCombatMode.Equals("attack"))
            {
                Item it = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
                //if using ranged and have ammo, use ammo properties
                if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged"))
                        && (!gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
                {
                    //ranged weapon with ammo
                    it = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
                }
                if (it == null)
                {
                    it = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
                }
                //set squares list
                AreaOfEffectShape aoeShape = new AreaOfEffectShape();
                int areaOfEffect = 0;
                bool useSpellForAoEDisplay = false;

                if (it.onScoringHitCastSpellTag != "none")
                {
                    foreach (Spell sp in gv.mod.moduleSpellsList)
                    {
                        if (sp.tag == it.onScoringHitCastSpellTag)
                        {
                            aoeShape = sp.aoeShape;
                            areaOfEffect = sp.aoeRadius;
                            useSpellForAoEDisplay = true;
                            break;
                        }
                    }
                }

                if (useSpellForAoEDisplay)
                {
                    gv.sf.CreateAoeSquaresList(pc, targetHighlightCenterLocation, aoeShape, areaOfEffect);
                }
                else
                {
                    gv.sf.CreateAoeSquaresList(pc, targetHighlightCenterLocation, it.aoeShape, it.AreaOfEffect);
                }

                foreach (Coordinate coor in gv.sf.AoeSquaresList)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    bool hl_green = true;
                    int endX2 = coor.X * gv.squareSize + (gv.squareSize / 2);
                    int endY2 = coor.Y * gv.squareSize + (gv.squareSize / 2);
                    int startX2 = targetHighlightCenterLocation.X * gv.squareSize + (gv.squareSize / 2);
                    int startY2 = targetHighlightCenterLocation.Y * gv.squareSize + (gv.squareSize / 2);

                    if (isVisibleLineOfSight(new Coordinate(startX2, startY2), new Coordinate(endX2, endY2)))
                    {
                        hl_green = true;
                    }
                    else
                    {
                        hl_green = false;
                    }
                    if ((coor.X == targetHighlightCenterLocation.X) && (coor.Y == targetHighlightCenterLocation.Y))
                    {
                        int startX3 = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                        int startY3 = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                        if ((isValidAttackTarget(pc)) && (isVisibleLineOfSight(new Coordinate(startX3, startY3), new Coordinate(endX2, endY2))))
                        {
                            hl_green = true;
                        }
                        else
                        {
                            hl_green = false;
                        }
                    }

                    int x = getPixelLocX(coor.X);
                    int y = getPixelLocY(coor.Y);
                    IbRect src = new IbRect(0, 0, gv.cc.highlight_green.PixelSize.Width, gv.cc.highlight_green.PixelSize.Height);
                    IbRect dst = new IbRect(x, y, gv.squareSize, gv.squareSize);
                    if (hl_green)
                    {
                        gv.DrawBitmap(gv.cc.highlight_green, src, dst);
                    }
                    else
                    {
                        gv.DrawBitmap(gv.cc.highlight_red, src, dst);
                    }
                }
            }
            else if (currentCombatMode.Equals("cast"))
            {
                //set squares list
                gv.sf.CreateAoeSquaresList(pc, targetHighlightCenterLocation, gv.cc.currentSelectedSpell.aoeShape, gv.cc.currentSelectedSpell.aoeRadius);
                foreach (Coordinate coor in gv.sf.AoeSquaresList)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    bool hl_green = true;
                    int endX2 = coor.X * gv.squareSize + (gv.squareSize / 2);
                    int endY2 = coor.Y * gv.squareSize + (gv.squareSize / 2);
                    int startX2 = targetHighlightCenterLocation.X * gv.squareSize + (gv.squareSize / 2);
                    int startY2 = targetHighlightCenterLocation.Y * gv.squareSize + (gv.squareSize / 2);

                    if ((isValidCastTarget(pc)) && (isVisibleLineOfSight(new Coordinate(startX2, startY2), new Coordinate(endX2, endY2))))
                    {
                        hl_green = true;
                    }
                    else
                    {
                        hl_green = false;
                    }
                    if ((coor.X == targetHighlightCenterLocation.X) && (coor.Y == targetHighlightCenterLocation.Y))
                    {
                        int startX3 = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                        int startY3 = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);
                        if ((isValidCastTarget(pc)) && (isVisibleLineOfSight(new Coordinate(startX3, startY3), new Coordinate(endX2, endY2))))
                        {
                            hl_green = true;
                        }
                        else
                        {
                            hl_green = false;
                        }
                    }

                    int x = getPixelLocX(coor.X);
                    int y = getPixelLocY(coor.Y);
                    IbRect src = new IbRect(0, 0, gv.cc.highlight_green.PixelSize.Width, gv.cc.highlight_green.PixelSize.Height);
                    IbRect dst = new IbRect(x, y, gv.squareSize, gv.squareSize);
                    if (hl_green)
                    {
                        gv.DrawBitmap(gv.cc.highlight_green, src, dst);
                    }
                    else
                    {
                        gv.DrawBitmap(gv.cc.highlight_red, src, dst);
                    }
                }
            }
        }


        public void drawFloatyText()
        {
            int txtH = (int)gv.drawFontRegHeight;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    if (x != 0 || y != 0)
                    {
                        gv.DrawText(gv.cc.floatyText, gv.cc.floatyTextLoc.X + x, gv.cc.floatyTextLoc.Y + txtH + y, 1.0f, Color.Black);
                        gv.DrawText(gv.cc.floatyText2, gv.cc.floatyTextLoc.X + x, gv.cc.floatyTextLoc.Y + (txtH * 2) + y, 1.0f, Color.Black);
                        gv.DrawText(gv.cc.floatyText3, gv.cc.floatyTextLoc.X + x, gv.cc.floatyTextLoc.Y + (txtH * 3) + y, 1.0f, Color.Black);
                    }
                }
            }
            */
            bool isPlayer = false;
            foreach (Player p in gv.mod.playerList)
            {
                if (p.name == gv.cc.floatyTextActorInfoName)
                {
                    isPlayer = true;
                    break;
                }
            }

            if (isPlayer)
            {
                gv.DrawTextOutlined(gv.cc.floatyText0, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y, 0.5f, Color.Lime);
            }
            else
            {
                gv.DrawTextOutlined(gv.cc.floatyText0, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y, 0.5f, Color.Red);
            }
            gv.DrawTextOutlined(gv.cc.floatyText, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y + txtH, 0.5f, Color.White);
            if (isPlayer)
            {
                gv.DrawTextOutlined(gv.cc.floatyText2, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y + txtH * 2, 0.5f, Color.Lime);
            }
            else
            {
                gv.DrawTextOutlined(gv.cc.floatyText2, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y + txtH * 2, 0.5f, Color.Red);
            }
            gv.DrawTextOutlined(gv.cc.floatyText3, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y + txtH * 3, 0.5f, Color.Yellow);

            //gv.cc.floatyTextLocInfo.X = gv.squareSize/2;
            //gv.cc.floatyTextLocInfo.Y = gv.squareSize*1;
            //gv.DrawTextOutlined(gv.cc.floatyTextActorInfoName, gv.cc.floatyTextLocInfo.X, gv.cc.floatyTextLocInfo.Y + txtH, 1.0f, Color.White);
            if (isPlayerTurn)
            {
                if (gv.cc.floatyTextPropMouseOver != "")
                {
                    //gv.DrawTextOutlined(gv.cc.floatyTextPropMouseOver, gv.cc.floatyTextLocPropMouseOver.X, gv.cc.floatyTextLocPropMouseOver.Y, 0.5f, Color.White);
                    IbRect rect = new IbRect();
                    rect.Left = gv.cc.floatyTextLocPropMouseOver.X - (int)(0.75f * gv.squareSize) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f));
                    rect.Top = gv.cc.floatyTextLocPropMouseOver.Y - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f));
                    //   gv.cc.floatyTextLocPropMouseOver
                    rect.Width = 3 * gv.squareSize;
                    //gv.DrawTextCenterOutlined(gv.cc.floatyTextPropMouseOver, rect, FontWeight.Normal, SharpDX.DirectWrite.FontStyle.Normal, 0.5f, Color.White);
                    gv.DrawTextCenterOutlinedRect(gv.cc.floatyTextPropMouseOver, rect, 0.7f, Color.White);
                }
            }
        }

        public void drawActorFloatyOnMouseOver()
        {
            //- (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f))
            int gridx = (int)(gv.mod.mousePosX - gv.oXshift - mapStartLocXinPixels + (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f))) / gv.squareSize;
            int gridy = (int)(gv.mod.mousePosY - (gv.squareSize / 2) + (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f))) / gv.squareSize;
            //covid21
            if (gv.mod.mousePosY < gv.squareSize - (gv.squareSize / 2) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)))
            {
                gridy = -1;
            }

            /*
            if (gv.mod.mousePosX < gv.squareSize -(int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)))
            {
                gridx = -1;
            }
            */

            int txtH = (int)gv.drawFontRegHeight;
            //pistazien

            Creature cr = new Creature();
            int highestLivingCrtMoveOrderfound = 0;
            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (currentMoveOrderIndex == 0)
                {
                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                    {
                        highestLivingCrtMoveOrderfound = c.moveOrder;
                        cr = c;
                    }
                }
                else
                {
                    if (c.moveOrder == currentMoveOrderIndex - 1)
                    {
                        cr = c;
                        break;
                    }
                }
            }

            foreach (Player pc1 in gv.mod.playerList)
            {
                if ((pc1.combatLocX == gridx + UpperLeftSquare.X) && (pc1.combatLocY == gridy + UpperLeftSquare.Y))
                {
                    int mo = pc1.moveOrder + 1;
                    bool noCreatureOnTop = true;
                    foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (crt.combatLocX == pc1.combatLocX && crt.combatLocY == pc1.combatLocY)
                        {
                            noCreatureOnTop = false;
                        }
                    }

                    if (noCreatureOnTop)
                    {
                        drawText(getPixelLocX(pc1.combatLocX) - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc1.combatLocY) - (int)gv.drawFontRegHeight - (int)cr.glideAdderY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), mo.ToString(), Color.White, 0.7f);
                        drawText(getPixelLocX(pc1.combatLocX) - (int)(cr.glideAdderX) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc1.combatLocY) - (int)(cr.glideAdderY) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), pc1.hp + "/" + pc1.hpMax, Color.Lime, 0.7f);
                        drawText(getPixelLocX(pc1.combatLocX) - (int)(cr.glideAdderX) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc1.combatLocY) - (int)(cr.glideAdderY) + txtH - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), pc1.sp + "/" + pc1.spMax, Color.Yellow, 0.7f);
                    }
                }

            }

            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {

                foreach (Coordinate coord in crt.tokenCoveredSquares)
                {
                    if ((coord.X == gridx + UpperLeftSquare.X) && (coord.Y == gridy + UpperLeftSquare.Y))
                    {
                        int moCr = crt.moveOrder + 1;
                        if (crt == cr)
                        {
                            if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                            {
                                drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) - (int)gv.drawFontRegHeight + (int)crt.roamDistanceY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), moCr.ToString(), Color.White, 0.7f);
                                drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.hp + "/" + crt.hpMax, Color.Red, 0.7f);
                                drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY + txtH - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.sp + "/" + crt.spMax, Color.Yellow, 0.7f);
                            }
                        }
                        else
                        {
                            drawText(getPixelLocX(crt.combatLocX) - (int)(cr.glideAdderX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) - (int)gv.drawFontRegHeight - (int)(cr.glideAdderY) + (int)crt.roamDistanceY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), moCr.ToString(), Color.White, 0.7f);
                            drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY - (int)(cr.glideAdderY) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.hp + "/" + crt.hpMax, Color.Red, 0.7f);
                            drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY - (int)(cr.glideAdderY) + txtH - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.sp + "/" + crt.spMax, Color.Yellow, 0.7f);
                        }
                    }
                }
            }
        }




        public void drawHPText()
        {


            //if (gv.cc.floatyTextActorInfoName != "")
            //{



            if ((showHP) && (!animationsOn))
            {

                Creature cr = new Creature();
                int highestLivingCrtMoveOrderfound = 0;
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (currentMoveOrderIndex == 0)
                    {
                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                        {
                            highestLivingCrtMoveOrderfound = c.moveOrder;
                            cr = c;
                        }
                    }
                    else
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            cr = c;
                            break;
                        }
                    }
                }

                foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (crt == cr)
                    {
                        if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                        {
                            drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.hp + "/" + crt.hpMax, Color.Red, 0.7f);
                        }
                    }
                    else
                    {
                        drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY - (int)(cr.glideAdderY) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.hp + "/" + crt.hpMax, Color.Red, 0.7f);
                    }
                }
                foreach (Player pc in gv.mod.playerList)
                {
                    if (IsInVisibleCombatWindow(pc.combatLocX, pc.combatLocY))
                    {
                        bool noCreatureOnTop = true;
                        foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (crt.combatLocX == pc.combatLocX && crt.combatLocY == pc.combatLocY)
                            {
                                noCreatureOnTop = false;
                            }
                        }

                        if (noCreatureOnTop)
                        {
                            drawText(getPixelLocX(pc.combatLocX) - (int)(cr.glideAdderX) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc.combatLocY) - (int)(cr.glideAdderY) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), pc.hp + "/" + pc.hpMax, Color.Lime, 0.7f);
                        }
                    }
                }
            }
        }


        public void drawSPText()
        {
            int txtH = (int)gv.drawFontRegHeight;
            if ((showSP) && (!animationsOn))
            {

                Creature cr = new Creature();
                int highestLivingCrtMoveOrderfound = 0;
                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (currentMoveOrderIndex == 0)
                    {
                        if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                        {
                            highestLivingCrtMoveOrderfound = c.moveOrder;
                            cr = c;
                        }
                    }
                    else
                    {
                        if (c.moveOrder == currentMoveOrderIndex - 1)
                        {
                            cr = c;
                            break;
                        }
                    }
                }

                foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                {
                    if (crt == cr)
                    {
                        if (IsInVisibleCombatWindow(crt.combatLocX, crt.combatLocY))
                        {
                            drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY + txtH - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.sp + "/" + crt.spMax, Color.Yellow, 0.7f);
                        }
                    }
                    else
                    {
                        drawText(getPixelLocX(crt.combatLocX) + (int)crt.roamDistanceX - (int)cr.glideAdderX - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(crt.combatLocY) + (int)crt.roamDistanceY - (int)(cr.glideAdderY) + txtH - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), crt.sp + "/" + crt.spMax, Color.Yellow, 0.7f);
                    }
                }
                foreach (Player pc in gv.mod.playerList)
                {
                    if (IsInVisibleCombatWindow(pc.combatLocX, pc.combatLocY))
                    {
                        bool noCreatureOnTop = true;
                        foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (crt.combatLocX == pc.combatLocX && crt.combatLocY == pc.combatLocY)
                            {
                                noCreatureOnTop = false;
                            }
                        }

                        if (noCreatureOnTop)
                        {
                            drawText(getPixelLocX(pc.combatLocX) - (int)(cr.glideAdderX) - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)), getPixelLocY(pc.combatLocY) - (int)(cr.glideAdderY) + txtH - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)), pc.sp + "/" + pc.spMax, Color.Yellow, 0.7f);
                        }
                    }
                }
            }
        }
        public void drawText(int xLoc, int yLoc, string text, Color colr, float scaler)
        {
            int txtH = (int)gv.drawFontRegHeight;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    if (x != 0 || y != 0)
                    {
                        gv.DrawText(text, xLoc + x, yLoc + txtH + y, 1.0f, Color.Black);
                    }
                }
            }
            */
            gv.DrawTextOutlined(text, xLoc, yLoc + txtH, scaler, colr);
        }
        public void drawMiniText(int xLoc, int yLoc, string text, Color colr)
        {
            int txtH = (int)gv.drawFontRegHeight;

            /*
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    if (x != 0 || y != 0)
                    {
                        gv.DrawText(text, xLoc + x, yLoc + txtH + y, 0.5f, Color.Black);
                    }
                }
            }
            */
            gv.DrawTextOutlined(text, xLoc, yLoc + txtH, 0.5f, colr);
        }
        public void drawFloatyTextList(float elapsed)
        {
            //summe
            //if attack time elapsed kleienr 250, dont
            if (floatyTextOn)
            {
                int txtH = (int)gv.drawFontRegHeight;
                int rightShift = 0;
                //foreach (FloatyText ft in gv.cc.floatyTextList)
                for (int i = 0; i < gv.cc.floatyTextList.Count; i++)
                {

                    /*
                    for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            if (x != 0 || y != 0)
                            {
                                if (!ft.value.Contains("Round"))
                                {
                                    gv.DrawText(ft.value, ft.location.X - (UpperLeftSquare.X * gv.squareSize) + x + mapStartLocXinPixels, ft.location.Y - (UpperLeftSquare.Y * gv.squareSize) + y, 1.0f, Color.Black);
                                }
                            }
                        }
                    }
                    */
                    Color colr = Color.Yellow;
                    if (gv.cc.floatyTextList[i].color.Equals("yellow"))
                    {
                        colr = Color.Yellow;
                    }
                    else if (gv.cc.floatyTextList[i].color.Equals("blue"))
                    {
                        colr = Color.Blue;
                    }
                    else if (gv.cc.floatyTextList[i].color.Equals("orange"))
                    {
                        colr = Color.Orange;
                    }
                    else if (gv.cc.floatyTextList[i].color.Equals("green"))
                    {
                        colr = Color.Lime;
                    }
                    else if (gv.cc.floatyTextList[i].color.Equals("white"))
                    {
                        colr = Color.White;
                    }
                    else
                    {
                        colr = Color.Red;
                    }

                    if (i < gv.cc.floatyTextList.Count - 1)
                    {
                        if (gv.cc.floatyTextList[i].z == gv.cc.floatyTextList[i + 1].z)
                        {
                            /*
                            string text = gv.cc.floatyTextList[i].value.ToString();
                            if (!text.Contains(" /"))
                            {
                                text += " /";
                                gv.cc.floatyTextList[i].value = text;
                            }
                            */
                        }
                    }

                    if (!gv.cc.floatyTextList[i].value.Contains("Round"))
                    {
                        /*
                        if (gv.cc.floatyTextList[i].color.Equals("red"))
                        {
                            bool foundHitSymbol = false;
                            foreach (AnimationSequence seq in animationSeqStack)
                            {
                                foreach (AnimationStackGroup stackGroup in seq.AnimationSeq)
                                {
                                    foreach (Sprite spr in stackGroup.SpriteGroup)
                                    {
                                        if (spr.bitmap == "hit_symbol")
                                        {
                                            foundHitSymbol = true;
                                        }
                                    }
                                }
                            }

                            if (foundHitSymbol)
                            {
                                if (attackAnimationTimeElapsed > (10*gv.mod.attackAnimationSpeed))
                                {
                                    gv.DrawTextOutlined(gv.cc.floatyTextList[i].value, gv.cc.floatyTextList[i].location.X - (UpperLeftSquare.X * gv.squareSize) + mapStartLocXinPixels + rightShift, gv.cc.floatyTextList[i].location.Y - (UpperLeftSquare.Y * gv.squareSize), 1.0f, colr);

                                }
                                else
                                {
                                    int jghj = 0;
                                    //draw not yet
                                  
                                    //gv.cc.floatyTextList[i].timeToLive
                                }
                            }
                            else
                            */
                        //{
                        //gv.DrawTextOutlined(gv.cc.floatyTextList[i].value, gv.cc.floatyTextList[i].location.X - (UpperLeftSquare.X * gv.squareSize) + mapStartLocXinPixels + rightShift, gv.cc.floatyTextList[i].location.Y - (UpperLeftSquare.Y * gv.squareSize), 1.0f, colr);

                        //}
                        //}
                        //else
                        //{
                        gv.DrawTextOutlined(gv.cc.floatyTextList[i].value, gv.cc.floatyTextList[i].location.X - (UpperLeftSquare.X * gv.squareSize) + mapStartLocXinPixels + rightShift, gv.cc.floatyTextList[i].location.Y - (UpperLeftSquare.Y * gv.squareSize), 1.0f, colr);
                        //}
                    }

                    if (i < gv.cc.floatyTextList.Count - 1)
                    {
                        //if (gv.cc.floatyTextList[i].location.X < gv.cc.floatyTextList[i + 1].location.X - 15)
                        {
                            rightShift += (gv.squareSize / 3);
                        }
                    }
                    if (rightShift > 2f * gv.squareSize)
                    {
                        rightShift = 0;
                    }
                    if (i < gv.cc.floatyTextList.Count - 1)
                    {
                        if (gv.cc.floatyTextList[i + 1].location.X - (gv.squareSize / 2) > gv.cc.floatyTextList[i].location.X)
                        {
                            rightShift = 0;
                        }
                    }

                }
                rightShift = 0;
            }

            int txtH2 = (int)gv.drawFontRegHeight;

            foreach (FloatyText ft in gv.cc.floatyTextList)
            {

                if (floatyTextEnlargerOn && ft.value.Contains("Round"))
                {

                    Color colr = Color.Yellow;
                    if (ft.color.Equals("yellow"))
                    {
                        colr = Color.Yellow;
                    }
                    else if (ft.color.Equals("blue"))
                    {
                        colr = Color.Blue;
                    }
                    else if (ft.color.Equals("green"))
                    {
                        colr = Color.Lime;
                    }
                    else
                    {
                        colr = Color.Red;
                    }
                    if (ft.value.Contains("Round"))
                    {
                        //summe 
                        gv.DrawTextOutlined(ft.value, ft.location.X + mapStartLocXinPixels, ft.location.Y, 3.0f, colr);
                    }
                }
            }
        }
        public void drawOverlayTints()
        {
            IbRect src = new IbRect(0, 0, gv.cc.tint_sunset.PixelSize.Width, gv.cc.tint_sunset.PixelSize.Height);
            IbRect dst = new IbRect(gv.oXshift + mapStartLocXinPixels, 0, gv.squareSize * (gv.playerOffsetX + gv.playerOffsetX + 1), gv.squareSize * (gv.playerOffsetY + gv.playerOffsetY + 2));
            int dawn = 5 * 60;
            int sunrise = 6 * 60;
            int day = 7 * 60;
            int sunset = 17 * 60;
            int dusk = 18 * 60;
            int night = 20 * 60;
            int time = gv.mod.WorldTime % 1440;
            if ((time >= dawn) && (time < sunrise))
            {
                gv.DrawBitmap(gv.cc.tint_dawn, src, dst);
            }
            else if ((time >= sunrise) && (time < day))
            {
                gv.DrawBitmap(gv.cc.tint_sunrise, src, dst);
            }
            else if ((time >= day) && (time < sunset))
            {
                //no tint for day
            }
            else if ((time >= sunset) && (time < dusk))
            {
                gv.DrawBitmap(gv.cc.tint_sunset, src, dst);
            }
            else if ((time >= dusk) && (time < night))
            {
                gv.DrawBitmap(gv.cc.tint_dusk, src, dst);
            }
            else if ((time >= night) || (time < dawn))
            {
                gv.DrawBitmap(gv.cc.tint_night, src, dst, false, 0.75f);
            }

        }
        public void drawSprites()
        {
            //try freeing calculate upper left
            //hero
            foreach (Sprite spr in spriteList)
            {
                spr.Draw(gv);
            }
            if (animationsOn || stepAnimationsOn)
            {
                //todo: only delay teh combat animation themsleves, not other contained here
                //or maybe 
                if (attackAnimationTimeElapsed >= attackAnimationLengthInMilliseconds * 1.5f)
                {
                    foreach (AnimationSequence seq in animationSeqStack)
                    {
                        //foreach (Sprite spr in seq.AnimationSeq[0].SpriteGroup)
                        if (seq.AnimationSeq.Count > 0)
                        {
                            //just draw the group at the top of the stack, first in first
                            //spr.Draw(gv);
                            foreach (Sprite spr in seq.AnimationSeq[0].SpriteGroup)
                            {
                                //just draw the group at the top of the stack, first in first  
                                spr.Draw(gv);
                            }
                        }
                    }
                }
            }
        }
        #endregion

        #region Keyboard Input
        //this actually reacts ondown already
        public void onKeyUp(Keys keyData)
        {
            if (isPlayerTurn)
            {            //rdr2 added
            //recalculateCreaturesShownInInitiativeBar();
            if (keyData == Keys.M)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if (canMove)
                {
                    if (isPlayerTurn)
                    {
                        gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                        gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                        gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                        gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                        gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                        currentCombatMode = "move";
                        gv.screenType = "combat";
                    }
                }
            }
            else if (keyData == Keys.R)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                //scroll log up
                //do same for combat screen
                //wheel
                //int numberOfTextLinesToMove = e.Delta * SystemInformation.MouseWheelScrollLines / 120;
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(-numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }
            else if (keyData == Keys.F)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                //scroll log up
                //do same for combat screen
                //wheel
                //int numberOfTextLinesToMove = e.Delta * SystemInformation.MouseWheelScrollLines / 120;
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(+numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }
            else if (keyData == Keys.K)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if (isPlayerTurn)
                {
                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    currentCombatMode = "attack";
                    gv.screenType = "combat";
                    setTargetHighlightStartLocation(pc);
                }
            }
            else if (keyData == Keys.P)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if ((isPlayerTurn) && (!gv.mod.playerList[currentPlayerIndex].isTemporaryAllyForThisEncounterOnly))
                {
                    if (currentPlayerIndex > gv.mod.playerList.Count - 1)
                    {
                        return;
                    }
                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                    //if (!gv.mod.playerList[currentPlayerIndex].isTemporaryAllyForThisEncounterOnly)
                    //{
                    gv.cc.partyScreenPcIndex = currentPlayerIndex;
                    //}
                    gv.screenParty.resetPartyScreen();
                    gv.screenType = "combatParty";
                }
            }
            else if (keyData == Keys.I)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if ((isPlayerTurn) && !gv.mod.currentEncounter.noItemUseModifier)
                {
                    //(!gv.mod.playerList[currentPlayerIndex].isTemporaryAllyForThisEncounterOnly)
                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                    //gv.screenInventory.resetInventory(true);
                    gv.screenType = "combatInventory";
                    gv.screenInventory.resetInventory(true);
                }
            }
            else if (keyData == Keys.Space)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if (isPlayerTurn)
                {
                    continueTurn = false;
                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                    gv.screenType = "combat";
                    endPcTurn(false);
                }
            }
            else if (keyData == Keys.O)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if (isPlayerTurn && !gv.mod.currentEncounter.noSpellCastModifier)
                {
                    gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                    continueTurn = false;
                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    if (pc.knownSpellsTags.Count > 0)
                    {
                        currentCombatMode = "castSelector";
                        gv.screenType = "combatCast";
                        gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                        spellSelectorIndex = 0;
                        setTargetHighlightStartLocation(pc);
                    }
                    else
                    {
                        //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                    }
                }
            }
            else if (keyData == Keys.L)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if (isPlayerTurn)
                {
                    int highestMoveOrderFound = 0;

                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if (c.moveOrder > highestMoveOrderFound)
                        {
                            highestMoveOrderFound = c.moveOrder;
                        }
                    }

                    foreach (Player p in gv.mod.playerList)
                    {
                        if (p.moveOrder > highestMoveOrderFound)
                        {
                            highestMoveOrderFound = p.moveOrder;
                        }
                    }

                    if (highestMoveOrderFound != gv.mod.playerList[currentPlayerIndex].moveOrder && !gv.mod.playerList[currentPlayerIndex].hasDelayedAlready)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        gv.mod.playerList[currentPlayerIndex].moveOrder = highestMoveOrderFound + 1;
                        /*
                        foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            if (c.moveOrder == gv.mod.playerList[currentPlayerIndex].moveOrder)
                            {
                                gv.mod.playerList[currentPlayerIndex].moveOrder++;
                            }
                        }
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.moveOrder == gv.mod.playerList[currentPlayerIndex].moveOrder && p != gv.mod.playerList[currentPlayerIndex])
                            {
                                gv.mod.playerList[currentPlayerIndex].moveOrder++;
                            }
                        }
                        */

                        //add to end of move order  
                        MoveOrder newMO = new MoveOrder();
                        newMO.PcOrCreature = gv.mod.playerList[currentPlayerIndex];
                        newMO.rank = highestMoveOrderFound + 1;
                        gv.screenCombat.moveOrderList.Add(newMO);
                        for (int i = gv.screenCombat.moveOrderList.Count - 2; i >= 0; i--)
                        {
                            if (gv.screenCombat.moveOrderList[i].PcOrCreature == newMO.PcOrCreature)
                            {
                                gv.screenCombat.moveOrderList.RemoveAt(i);
                            }
                        }

                        //increment the number of initial move order objects
                        //note: check how ini bar system will interact with creatures added while battle is running  
                        gv.screenCombat.initialMoveOrderListSize++;

                        recalculateCreaturesShownInInitiativeBar();

                        endPcTurn(false);
                    }
                    else
                    {
                        gv.cc.addLogText("red", "Delaying not possible for this character this turn.");
                    }
                }
            }
            else if (keyData == Keys.U)
            {
                gv.mod.mainMapMovementRelevantKeyPressed = false;
                if (isPlayerTurn && !gv.mod.currentEncounter.noTraitUseModifier)
                {
                    gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                    continueTurn = false;
                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    if (pc.knownInCombatUsableTraitsTags.Count > 0)
                    {
                        currentCombatMode = "traitUseSelector";
                        gv.screenType = "combatTraitUse";
                        gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                        spellSelectorIndex = 0;
                        setTargetHighlightStartLocation(pc);
                    }
                    else
                    {
                        //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                    }
                }
            }
            else if (keyData == Keys.X)
            {
                if (gv.cc.drawInfoText)
                {
                    gv.cc.drawInfoText = false;
                }
                else
                {
                    gv.cc.drawInfoText = true;
                }

                gv.mod.mainMapMovementRelevantKeyPressed = false;
                foreach (IB2Panel pnl in combatUiLayout.panelList)
                {
                    //hides left
                    if (pnl.hidingXIncrement < 0)
                    {
                        if (pnl.currentLocX < pnl.shownLocX)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                    //hides right
                    else if (pnl.hidingXIncrement > 0)
                    {
                        if (pnl.currentLocX > pnl.shownLocX)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                    //hides down
                    else if (pnl.hidingYIncrement > 0)
                    {
                        if (pnl.currentLocY > pnl.shownLocY)
                        {
                            if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                            {
                                continue;
                            }
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                    //hides up
                    else if (pnl.hidingYIncrement < 0)
                    {
                        if (pnl.currentLocY < pnl.shownLocY)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                }
            }

            #region Move Map
            if (keyData == Keys.Up && !showMoveKeys)
            {
                hideActorInfo();
                if (gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.Y > -gv.playerOffsetY)
                        {
                            UpperLeftSquare.Y--;
                        }
                    }
                    */
                    gv.mod.combatScrollDirectionY = "up";
                    //gv.combatScrollTimer.Stop();
                    gv.combatScrollTimerY.Start();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.Y > 0)
                    {
                        UpperLeftSquare.Y--;
                    }
                    return;
                }
            }
            else if (keyData == Keys.Left && !showMoveKeys)
            {
                hideActorInfo();
                if (gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.X > -gv.playerOffsetX)
                        {
                            UpperLeftSquare.X--;
                        }
                    }
                    */
                    gv.mod.combatScrollDirection = "left";
                    gv.combatScrollTimer.Start();
                    //gv.combatScrollTimerY.Stop();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.X > 0)
                    {
                        UpperLeftSquare.X--;
                    }
                    return;
                }
            }
            else if (keyData == Keys.Down && !showMoveKeys)
            {
                hideActorInfo();
                if (gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.Y < gv.mod.currentEncounter.MapSizeY - gv.playerOffsetY - 1)
                        {
                            UpperLeftSquare.Y++;
                        }
                    }
                    */
                    gv.mod.combatScrollDirectionY = "down";
                    gv.combatScrollTimerY.Start();
                    //gv.combatScrollTimer.Stop();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.Y < gv.mod.currentEncounter.MapSizeY - gv.playerOffsetY - gv.playerOffsetY - 1)
                    {
                        UpperLeftSquare.Y++;
                    }
                    return;
                }
            }
            else if (keyData == Keys.Right && !showMoveKeys)
            {
                hideActorInfo();
                if (gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.X < gv.mod.currentEncounter.MapSizeX - gv.playerOffsetX - 1)
                        {
                            UpperLeftSquare.X++;
                        }
                    }
                    */
                    gv.mod.combatScrollDirection = "right";
                    gv.combatScrollTimer.Start();
                    //gv.combatScrollTimerY.Stop();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.X < gv.mod.currentEncounter.MapSizeX - gv.playerOffsetX - gv.playerOffsetX - 1)
                    {
                        UpperLeftSquare.X++;
                    }
                    return;
                }
            }

            if (keyData == Keys.W && showMoveKeys)
            {
                hideActorInfo();
                if (!gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    //do not increase by full square, but instead by eg 5 pixels (5% of gv.squaresize)
                    //needs two new avlues
                    //xScroll
                    //yScroll
                    //string combarScrollDirection will be needed, too

                    //these rnage from -gv.sqaureSize to +gv.squarezie
                    //rendering uses upp left + these values
                    //if values exceeds their limit, they are set to zero and upperleftsqure is adjusted acoordingly 

                    //or maybe only reset them, when upperleft itslef is reset by focus on creature/pc
                    //nad alway use them as render offsett
                    //yes

                    //best start a time ron key down that is stopped on key up (oh, well, we are keydown here)

                    //covid19 - take out the old liens below, manual cam does not affect the upper left square directly anymore:
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.Y > -gv.playerOffsetY)
                        {
                            UpperLeftSquare.Y--;
                        }
                    }
                    */
                    //instead:
                    gv.mod.combatScrollDirectionY = "up";
                    gv.combatScrollTimerY.Start();
                    //gv.combatScrollTimer.Stop();
                    //todo adjust rendering for the new offset x,y
                    return;
                }
                else
                {
                    if (UpperLeftSquare.Y > 0)
                    {
                        UpperLeftSquare.Y--;
                    }
                    return;
                }
            }
            else if (keyData == Keys.A && showMoveKeys)
            {
                hideActorInfo();
                if (!gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.X > -gv.playerOffsetX)
                        {
                            UpperLeftSquare.X--;
                        }
                    }
                    */
                    gv.mod.combatScrollDirection = "left";
                    gv.combatScrollTimer.Start();
                    //gv.combatScrollTimerY.Stop();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.X > 0)
                    {
                        UpperLeftSquare.X--;
                    }
                    return;
                }
            }
            else if (keyData == Keys.S && showMoveKeys)
            {
                hideActorInfo();
                if (!gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.Y < gv.mod.currentEncounter.MapSizeY - gv.playerOffsetY - 1)
                        {
                            UpperLeftSquare.Y++;
                        }
                    }
                    */
                    gv.mod.combatScrollDirectionY = "down";
                    //gv.combatScrollTimer.Stop();
                    gv.combatScrollTimerY.Start();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.Y < gv.mod.currentEncounter.MapSizeY - gv.playerOffsetY - gv.playerOffsetY - 1)
                    {
                        UpperLeftSquare.Y++;
                    }
                    return;
                }
            }
            else if (keyData == Keys.D && showMoveKeys)
            {
                hideActorInfo();
                if (!gv.screenMainMap.showMoveKeys)
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = true;
                }
                else
                {
                    gv.mod.mainMapMovementRelevantKeyPressed = false;
                }
                if (gv.mod.useManualCombatCam)
                {
                    //covid19
                    /*
                    if (gv.mod.combatScrollingTimer <= 0)
                    {
                        gv.mod.combatScrollingTimer = 100;
                        if (UpperLeftSquare.X < gv.mod.currentEncounter.MapSizeX - gv.playerOffsetX - 1)
                        {
                            UpperLeftSquare.X++;
                        }
                    }
                    */
                    gv.mod.combatScrollDirection = "right";
                    gv.combatScrollTimer.Start();
                    //gv.combatScrollTimerY.Stop();
                    return;
                }
                else
                {
                    if (UpperLeftSquare.X < gv.mod.currentEncounter.MapSizeX - gv.playerOffsetX - gv.playerOffsetX - 1)
                    {
                        UpperLeftSquare.X++;
                    }
                    return;
                }
            }
            #endregion
            #region Move PC gv.mode
            if (currentCombatMode.Equals("move"))
            {
                Player pc = gv.mod.playerList[currentPlayerIndex];
                if ((keyData == Keys.NumPad7) || (keyData == Keys.Q && !showMoveKeys))
                {
                    continueTurn = false;
                    MoveUpLeft(pc);
                }
                else if ((keyData == Keys.NumPad8) || (keyData == Keys.Up && showMoveKeys) || (keyData == Keys.W && !showMoveKeys))
                {

                    if (keyData == Keys.NumPad8)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }

                    if (keyData == Keys.Up)
                    {
                        if (gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }

                    if (keyData == Keys.W)
                    {
                        if (!gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }

                    continueTurn = false;
                    MoveUp(pc);
                }
                else if ((keyData == Keys.NumPad9) || (keyData == Keys.E && !showMoveKeys))
                {
                    continueTurn = false;
                    MoveUpRight(pc);
                }
                else if ((keyData == Keys.NumPad4) || (keyData == Keys.Left && showMoveKeys) || (keyData == Keys.A && !showMoveKeys))
                {
                    if (keyData == Keys.NumPad4)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }

                    if (keyData == Keys.Left)
                    {
                        if (gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }

                    if (keyData == Keys.A)
                    {
                        if (!gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }
                    continueTurn = false;
                    MoveLeft(pc);
                }
                else if (keyData == Keys.NumPad5)
                {
                    CenterScreenOnPC();
                }
                else if ((keyData == Keys.NumPad6) || (keyData == Keys.Right && showMoveKeys) || (keyData == Keys.D && !showMoveKeys))
                {
                    if (keyData == Keys.NumPad6)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }

                    if (keyData == Keys.Right)
                    {
                        if (gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }

                    if (keyData == Keys.D)
                    {
                        if (!gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }
                    continueTurn = false;
                    MoveRight(pc);
                }
                else if ((keyData == Keys.NumPad1) || (keyData == Keys.Y && !showMoveKeys) || (keyData == Keys.Z && !showMoveKeys))
                {
                    continueTurn = false;
                    MoveDownLeft(pc);
                }
                else if ((keyData == Keys.NumPad2) || (keyData == Keys.Down && showMoveKeys) || (keyData == Keys.S && !showMoveKeys))
                {
                    if (keyData == Keys.NumPad2)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }

                    if (keyData == Keys.Down)
                    {
                        if (gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }

                    if (keyData == Keys.S)
                    {
                        if (!gv.screenMainMap.showMoveKeys)
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = true;
                        }
                        else
                        {
                            gv.mod.mainMapMovementRelevantKeyPressed = false;
                        }
                    }
                    continueTurn = false;
                    MoveDown(pc);
                }
                else if ((keyData == Keys.NumPad3) || (keyData == Keys.C && !showMoveKeys))
                {
                    continueTurn = false;
                    MoveDownRight(pc);
                }
                return;
            }
            #endregion
            #region Move Targeting gv.mode
            if (currentCombatMode.Equals("attack"))
            {
                Player pc = gv.mod.playerList[currentPlayerIndex];
                if (keyData == Keys.NumPad5)
                {
                    continueTurn = false;
                    TargetAttackPressed(pc);
                    return;
                }
            }
            if (currentCombatMode.Equals("cast"))
            {
                Player pc = gv.mod.playerList[currentPlayerIndex];
                if (keyData == Keys.NumPad5)
                {
                    continueTurn = false;
                    if (gv.mod.isCastFromUsedItem)
                    {
                        gv.mod.isCastFromUsedItem = false;
                        Item it = gv.mod.getItemByTag(gv.mod.tagOfItemUsedForCast);
                        TargetCastPressed(pc, it);
                    }
                    else
                    {
                        TargetCastPressed(pc);
                    }
                    return;
                }
            }
            if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
            {
                if (keyData == Keys.NumPad7)
                {
                    continueTurn = false;
                    MoveTargetHighlight(7);
                }
                else if (keyData == Keys.NumPad8)
                {
                    if (keyData == Keys.NumPad8)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }

                    continueTurn = false;
                    MoveTargetHighlight(8);
                }
                else if (keyData == Keys.NumPad9)
                {
                    continueTurn = false;
                    MoveTargetHighlight(9);
                }
                else if (keyData == Keys.NumPad4)
                {
                    if (keyData == Keys.NumPad4)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }

                    continueTurn = false;
                    MoveTargetHighlight(4);
                }
                else if (keyData == Keys.NumPad6)
                {
                    continueTurn = false;
                    MoveTargetHighlight(6);
                }
                else if (keyData == Keys.NumPad1)
                {
                    continueTurn = false;
                    MoveTargetHighlight(1);
                }
                else if (keyData == Keys.NumPad2)
                {
                    if (keyData == Keys.NumPad2)
                    {
                        gv.mod.mainMapMovementRelevantKeyPressed = true;
                    }


                    continueTurn = false;
                    MoveTargetHighlight(2);
                }
                else if (keyData == Keys.NumPad3)
                {
                    continueTurn = false;
                    MoveTargetHighlight(3);
                }
                return;
            }
            #endregion
        }
    }
#endregion

#region Mouse Input
        /*public void onTouchCombatOld(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                    int x = (int)e.X;
                    int y = (int)e.Y;

                    int gridx = (int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize;
                    int gridy = (int)(e.Y - (gv.squareSize / 2)) / gv.squareSize;

#region FloatyText
                    gv.cc.floatyText = "";
                    gv.cc.floatyText2 = "";
                    gv.cc.floatyText3 = "";
                    foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        if ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y))
                        {
                            gv.cc.floatyText = crt.cr_name;
                            gv.cc.floatyText2 = "HP:" + crt.hp + " SP:" + crt.sp;
                            gv.cc.floatyText3 = "AC:" + crt.getAc() + " " + crt.cr_status;
                            gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY));
                        }
                    }
                    foreach (Player pc in gv.mod.playerList)
                    {
                        if ((pc.combatLocX == gridx + UpperLeftSquare.X) && (pc.combatLocY == gridy + UpperLeftSquare.Y))
                        {
                            string am = "";
                            ItemRefs itr = gv.mod.getItemRefsInInventoryByResRef(pc.AmmoRefs.resref);
                            if (itr != null)
                            {
                                am = itr.quantity + "";
                            }
                            else
                            {
                                am = "";
                            }

                            gv.cc.floatyText = pc.name;
                            int actext = 0;
                            if (gv.mod.ArmorClassAscending) { actext = pc.AC; }
                            else { actext = 20 - pc.AC; }
                            gv.cc.floatyText2 = "AC:" + actext + " " + pc.charStatus;
                            gv.cc.floatyText3 = "Ammo: " + am;
                            gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));

                        }
                    }
#endregion
#region Toggles
                    if (tglHP.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglHP.toggleOn)
                        {
                            tglHP.toggleOn = false;
                        }
                        else
                        {
                            tglHP.toggleOn = true;
                        }
                    }
                    if (tglSP.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglSP.toggleOn)
                        {
                            tglSP.toggleOn = false;
                        }
                        else
                        {
                            tglSP.toggleOn = true;
                        }
                    }
                    if (tglMoveOrder.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglMoveOrder.toggleOn)
                        {
                            tglMoveOrder.toggleOn = false;
                        }
                        else
                        {
                            tglMoveOrder.toggleOn = true;
                        }
                    }
                    if (tglSpeed.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        
                        if (gv.mod.combatAnimationSpeed == 100)
                        {
                            gv.mod.combatAnimationSpeed = 50;
                            gv.cc.addLogText("lime", "combat speed: 2x");
                            gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                            tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_2");
                        }
                        else if (gv.mod.combatAnimationSpeed == 50)
                        {
                            gv.mod.combatAnimationSpeed = 25;
                            gv.cc.addLogText("lime", "combat speed: 4x");
                            gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                            tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_4");
                        }
                        else if (gv.mod.combatAnimationSpeed == 25)
                        {
                            gv.mod.combatAnimationSpeed = 10;
                            gv.cc.addLogText("lime", "combat speed: 10x");
                            gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                            tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_10");
                        }
                        else if (gv.mod.combatAnimationSpeed == 10)
                        {
                            gv.mod.combatAnimationSpeed = 100;
                            gv.cc.addLogText("lime", "combat speed: 1x");
                            gv.cc.DisposeOfBitmap(ref tglSpeed.ImgOff);
                            tglSpeed.ImgOff = gv.cc.LoadBitmap("tgl_speed_1");
                        }
                    }
                    if (gv.cc.tglSound.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (gv.cc.tglSound.toggleOn)
                        {
                            gv.cc.tglSound.toggleOn = false;
                            gv.mod.playMusic = false;
                            gv.stopCombatMusic();
                            //addLogText("lime","Music Off");
                        }
                        else
                        {
                            gv.cc.tglSound.toggleOn = true;
                            gv.mod.playMusic = true;
                            gv.startCombatMusic();
                            //addLogText("lime","Music On");
                        }
                    }
                    if (tglSoundFx.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglSoundFx.toggleOn)
                        {
                            tglSoundFx.toggleOn = false;
                            gv.mod.playSoundFx = false;
                            //gv.stopCombatMusic();
                            //addLogText("lime","Music Off");
                        }
                        else
                        {
                            tglSoundFx.toggleOn = true;
                            gv.mod.playSoundFx = true;
                            //gv.startCombatMusic();
                            //addLogText("lime","Music On");
                        }
                    }
                    if (tglGrid.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglGrid.toggleOn)
                        {
                            tglGrid.toggleOn = false;
                            gv.mod.com_showGrid = false;
                        }
                        else
                        {
                            tglGrid.toggleOn = true;
                            gv.mod.com_showGrid = true;
                        }
                    }
                    if (tglHelp.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        tutorialMessageCombat(true);
                    }
                    if ((tglKill.getImpact(x, y)) && (gv.mod.debugMode))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.mod.currentEncounter.encounterCreatureList.Clear();
                        gv.mod.currentEncounter.encounterCreatureRefsList.Clear();
                        checkEndEncounter();
                    }
#endregion

                    if (btnSwitchWeapon.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}

                        if (currentPlayerIndex > gv.mod.playerList.Count - 1)
                        {
                            return;
                        }
                        gv.cc.partyScreenPcIndex = currentPlayerIndex;
                        gv.screenParty.resetPartyScreen();
                        gv.screenType = "combatParty";
                    }
                    break;
            }
            //if MoveMode(move), AttackMode(attack), CastMode(cast), or InfoMode(info)
            if (currentCombatMode.Equals("info"))
            {
                onTouchCombatInfo(e, eventType);
            }
            else if (currentCombatMode.Equals("move"))
            {
                onTouchCombatMove(e, eventType);
            }
            else if (currentCombatMode.Equals("attack"))
            {
                onTouchCombatAttack(e, eventType);
            }
            else if (currentCombatMode.Equals("castSelector"))
            {
                //onTouchCombatCastSelector(event);
            }
            else if (currentCombatMode.Equals("cast"))
            {
                onTouchCombatCast(e, eventType);
            }
            else
            {
                //info gv.mode
            }
        }*/
        /*public void onTouchCombatInfo(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            //TODOgv.cc.onTouchLog();
            Player pc = gv.mod.playerList[currentPlayerIndex];

            btnMove.glowOn = false;
            gv.cc.btnInventory.glowOn = false;
            btnAttack.glowOn = false;
            btnCast.glowOn = false;
            btnSkipTurn.glowOn = false;
            //btnKill.glowOn = false;
            //btnCombatHelp.glowOn = false;

            //int eventAction = event.getAction();
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;
                    if (btnMove.getImpact(x, y))
                    {
                        btnMove.glowOn = true;
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        gv.cc.btnInventory.glowOn = true;
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        btnAttack.glowOn = true;
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        btnCast.glowOn = true;
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        btnSkipTurn.glowOn = true;
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;

                    btnMove.glowOn = false;
                    gv.cc.btnInventory.glowOn = false;
                    btnAttack.glowOn = false;
                    btnCast.glowOn = false;
                    btnSkipTurn.glowOn = false;

                    //BUTTONS			
                    if (btnMove.getImpact(x, y))
                    {
                        if (canMove)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "move";
                            gv.screenType = "combat";
                        }
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.screenType = "combatInventory";
                        gv.screenInventory.resetInventory();
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        currentCombatMode = "attack";
                        gv.screenType = "combat";
                        setTargetHighlightStartLocation(pc);
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        if (pc.knownSpellsTags.Count > 0)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "castSelector";
                            gv.screenType = "combatCast";
                            gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                            spellSelectorIndex = 0;
                            setTargetHighlightStartLocation(pc);
                        }
                        else
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.screenType = "combat";
                        endPcTurn(false);
                    }
                    break;
            }
        }*/
        /*public void onTouchCombatMove(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            //gv.cc.onTouchLog();
            Player pc = gv.mod.playerList[currentPlayerIndex];

            gv.cc.ctrlUpArrow.glowOn = false;
            gv.cc.ctrlDownArrow.glowOn = false;
            gv.cc.ctrlLeftArrow.glowOn = false;
            gv.cc.ctrlRightArrow.glowOn = false;
            gv.cc.ctrlUpRightArrow.glowOn = false;
            gv.cc.ctrlDownRightArrow.glowOn = false;
            gv.cc.ctrlUpLeftArrow.glowOn = false;
            gv.cc.ctrlDownLeftArrow.glowOn = false;
            btnMove.glowOn = false;
            gv.cc.btnInventory.glowOn = false;
            btnAttack.glowOn = false;
            btnCast.glowOn = false;
            btnSkipTurn.glowOn = false;

            //int eventAction = event.getAction();
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;
                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlUpRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlUpLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownLeftArrow.glowOn = true;
                    }
                    else if (btnMove.getImpact(x, y))
                    {
                        btnMove.glowOn = true;
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        gv.cc.btnInventory.glowOn = true;
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        btnAttack.glowOn = true;
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        btnCast.glowOn = true;
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        btnSkipTurn.glowOn = true;
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;

                    gv.cc.ctrlUpArrow.glowOn = false;
                    gv.cc.ctrlDownArrow.glowOn = false;
                    gv.cc.ctrlLeftArrow.glowOn = false;
                    gv.cc.ctrlRightArrow.glowOn = false;
                    gv.cc.ctrlUpRightArrow.glowOn = false;
                    gv.cc.ctrlDownRightArrow.glowOn = false;
                    gv.cc.ctrlUpLeftArrow.glowOn = false;
                    gv.cc.ctrlDownLeftArrow.glowOn = false;
                    btnMove.glowOn = false;
                    gv.cc.btnInventory.glowOn = false;
                    btnAttack.glowOn = false;
                    btnCast.glowOn = false;
                    btnSkipTurn.glowOn = false;

                    //TOUCH ON MAP AREA
                    int gridx = (int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize;
                    int gridy = (int)(e.Y - (gv.squareSize / 2)) / gv.squareSize;
                    //int gridx = (int)e.X / gv.squareSize - 4;
                    //int gridy = (int)(e.Y - (gv.squareSize / 2)) / gv.squareSize;

                    if (gridy < gv.mod.currentEncounter.MapSizeY)
                    {
                        gv.cc.floatyText = "";
                        gv.cc.floatyText2 = "";
                        gv.cc.floatyText3 = "";
                        //Check for second tap so TARGET
                    }

                    //BUTTONS
                    if ((gv.cc.ctrlUpArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX) && (gridy + UpperLeftSquare.Y == pc.combatLocY - 1)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveUp(pc);
                    }
                    else if ((gv.cc.ctrlDownArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX) && (gridy + UpperLeftSquare.Y == pc.combatLocY + 1)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveDown(pc);
                    }
                    else if ((gv.cc.ctrlLeftArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX - 1) && (gridy + UpperLeftSquare.Y == pc.combatLocY)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveLeft(pc);
                    }
                    else if ((gv.cc.ctrlRightArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX + 1) && (gridy + UpperLeftSquare.Y == pc.combatLocY)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveRight(pc);
                    }
                    else if ((gv.cc.ctrlUpRightArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX + 1) && (gridy + UpperLeftSquare.Y == pc.combatLocY - 1)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveUpRight(pc);
                    }
                    else if ((gv.cc.ctrlDownRightArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX + 1) && (gridy + UpperLeftSquare.Y == pc.combatLocY + 1)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveDownRight(pc);
                    }
                    else if ((gv.cc.ctrlUpLeftArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX - 1) && (gridy + UpperLeftSquare.Y == pc.combatLocY - 1)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveUpLeft(pc);
                    }
                    else if ((gv.cc.ctrlDownLeftArrow.getImpact(x, y)) || ((gridx + UpperLeftSquare.X == pc.combatLocX - 1) && (gridy + UpperLeftSquare.Y == pc.combatLocY + 1)))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveDownLeft(pc);
                    }
                    else if (btnMove.getImpact(x, y))
                    {
                        if (canMove)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "info";
                            gv.screenType = "combat";
                            //Toast.makeText(gameContext, "Move gv.mode", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.screenType = "combatInventory";
                        gv.screenInventory.resetInventory();
                        //Toast.makeText(gameContext, "Inventory Button", Toast.LENGTH_SHORT).show();
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        currentCombatMode = "attack";
                        gv.screenType = "combat";
                        setTargetHighlightStartLocation(pc);
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        if (pc.knownSpellsTags.Count > 0)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "castSelector";
                            gv.screenType = "combatCast";
                            gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                            spellSelectorIndex = 0;
                            setTargetHighlightStartLocation(pc);
                        }
                        else
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.screenType = "combat";
                        endPcTurn(false);
                    }
                    break;
            }
        }*/
        /*public void onTouchCombatAttack(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            Player pc = gv.mod.playerList[currentPlayerIndex];

            gv.cc.ctrlUpArrow.glowOn = false;
            gv.cc.ctrlDownArrow.glowOn = false;
            gv.cc.ctrlLeftArrow.glowOn = false;
            gv.cc.ctrlRightArrow.glowOn = false;
            gv.cc.ctrlUpRightArrow.glowOn = false;
            gv.cc.ctrlDownRightArrow.glowOn = false;
            gv.cc.ctrlUpLeftArrow.glowOn = false;
            gv.cc.ctrlDownLeftArrow.glowOn = false;
            btnSelect.glowOn = false;
            btnMove.glowOn = false;
            gv.cc.btnInventory.glowOn = false;
            btnAttack.glowOn = false;
            btnCast.glowOn = false;
            btnSkipTurn.glowOn = false;

            //int eventAction = event.getAction();
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;
                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlUpRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlUpLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownLeftArrow.glowOn = true;
                    }
                    else if (btnSelect.getImpact(x, y))
                    {
                        btnSelect.glowOn = true;
                    }
                    else if (btnMove.getImpact(x, y))
                    {
                        btnMove.glowOn = true;
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        gv.cc.btnInventory.glowOn = true;
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        btnAttack.glowOn = true;
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        btnCast.glowOn = true;
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        btnSkipTurn.glowOn = true;
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;

                    gv.cc.ctrlUpArrow.glowOn = false;
                    gv.cc.ctrlDownArrow.glowOn = false;
                    gv.cc.ctrlLeftArrow.glowOn = false;
                    gv.cc.ctrlRightArrow.glowOn = false;
                    gv.cc.ctrlUpRightArrow.glowOn = false;
                    gv.cc.ctrlDownRightArrow.glowOn = false;
                    gv.cc.ctrlUpLeftArrow.glowOn = false;
                    gv.cc.ctrlDownLeftArrow.glowOn = false;
                    btnSelect.glowOn = false;
                    btnMove.glowOn = false;
                    gv.cc.btnInventory.glowOn = false;
                    btnAttack.glowOn = false;
                    btnCast.glowOn = false;
                    btnSkipTurn.glowOn = false;

                    //TOUCH ON MAP AREA
                    int gridx = ((int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize) + UpperLeftSquare.X;
                    int gridy = ((int)(e.Y - (gv.squareSize / 2)) / gv.squareSize) + UpperLeftSquare.Y;

                    if (IsInVisibleCombatWindow(gridx, gridy))
                    {
                        gv.cc.floatyText = "";
                        gv.cc.floatyText2 = "";
                        gv.cc.floatyText3 = "";
                        //Check for second tap so TARGET
                        if ((gridx == targetHighlightCenterLocation.X) && (gridy == targetHighlightCenterLocation.Y))
                        {
                            TargetAttackPressed(pc);                            
                        }
                        //targetHighlightCenterLocation.Y = gridy + UpperLeftSquare.Y;
                        //targetHighlightCenterLocation.X = gridx + UpperLeftSquare.X;
                        targetHighlightCenterLocation.Y = gridy;
                        targetHighlightCenterLocation.X = gridx;
                    }

                    //BUTTONS
                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(8);
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(2);
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(4);
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(6);
                    }
                    else if (gv.cc.ctrlUpRightArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(9);
                    }
                    else if (gv.cc.ctrlDownRightArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(3);
                    }
                    else if (gv.cc.ctrlUpLeftArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(7);
                    }
                    else if (gv.cc.ctrlDownLeftArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(1);
                    }
                    else if (btnSelect.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        TargetAttackPressed(pc);                        
                    }
                    else if (btnMove.getImpact(x, y))
                    {
                        if (canMove)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "move";
                            gv.screenType = "combat";
                        }
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.screenType = "combatInventory";
                        gv.screenInventory.resetInventory();
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        currentCombatMode = "info";
                        gv.screenType = "combat";
                        setTargetHighlightStartLocation(pc);
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        if (pc.knownSpellsTags.Count > 0)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "castSelector";
                            gv.screenType = "combatCast";
                            gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                            spellSelectorIndex = 0;
                            setTargetHighlightStartLocation(pc);
                        }
                        else
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        endPcTurn(false);
                    }
                    break;
            }
        }*/
        /*public void onTouchCombatCast(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            //gv.cc.onTouchLog();
            Player pc = gv.mod.playerList[currentPlayerIndex];

            gv.cc.ctrlUpArrow.glowOn = false;
            gv.cc.ctrlDownArrow.glowOn = false;
            gv.cc.ctrlLeftArrow.glowOn = false;
            gv.cc.ctrlRightArrow.glowOn = false;
            gv.cc.ctrlUpRightArrow.glowOn = false;
            gv.cc.ctrlDownRightArrow.glowOn = false;
            gv.cc.ctrlUpLeftArrow.glowOn = false;
            gv.cc.ctrlDownLeftArrow.glowOn = false;
            btnSelect.glowOn = false;
            btnMove.glowOn = false;
            gv.cc.btnInventory.glowOn = false;
            btnAttack.glowOn = false;
            btnCast.glowOn = false;
            btnSkipTurn.glowOn = false;

            //int eventAction = event.getAction();
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;
                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlUpRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownRightArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlUpLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownLeftArrow.glowOn = true;
                    }
                    else if (btnSelect.getImpact(x, y))
                    {
                        btnSelect.glowOn = true;
                    }
                    else if (btnMove.getImpact(x, y))
                    {
                        btnMove.glowOn = true;
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        gv.cc.btnInventory.glowOn = true;
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        btnAttack.glowOn = true;
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        btnCast.glowOn = true;
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        btnSkipTurn.glowOn = true;
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;

                    gv.cc.ctrlUpArrow.glowOn = false;
                    gv.cc.ctrlDownArrow.glowOn = false;
                    gv.cc.ctrlLeftArrow.glowOn = false;
                    gv.cc.ctrlRightArrow.glowOn = false;
                    gv.cc.ctrlUpRightArrow.glowOn = false;
                    gv.cc.ctrlDownRightArrow.glowOn = false;
                    gv.cc.ctrlUpLeftArrow.glowOn = false;
                    gv.cc.ctrlDownLeftArrow.glowOn = false;
                    btnSelect.glowOn = false;
                    btnMove.glowOn = false;
                    gv.cc.btnInventory.glowOn = false;
                    btnAttack.glowOn = false;
                    btnCast.glowOn = false;
                    btnSkipTurn.glowOn = false;

                    //TOUCH ON MAP AREA
                    int gridx = ((int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize) + UpperLeftSquare.X;
                    int gridy = ((int)(e.Y - (gv.squareSize / 2)) / gv.squareSize) + UpperLeftSquare.Y;

                    if (IsInVisibleCombatWindow(gridx, gridy))
                    //if (gridy < gv.mod.currentEncounter.MapSizeY)
                    {
                        gv.cc.floatyText = "";
                        gv.cc.floatyText2 = "";
                        gv.cc.floatyText3 = "";
                        //Check for second tap so TARGET
                        if ((gridx == targetHighlightCenterLocation.X) && (gridy == targetHighlightCenterLocation.Y))
                        {
                            TargetCastPressed(pc);
                        }
                        targetHighlightCenterLocation.Y = gridy;
                        targetHighlightCenterLocation.X = gridx;
                    }

                    //BUTTONS
                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(8);
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(2);
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(4);
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(6);
                    }
                    else if (gv.cc.ctrlUpRightArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(9);
                    }
                    else if (gv.cc.ctrlDownRightArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(3);
                    }
                    else if (gv.cc.ctrlUpLeftArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(7);
                    }
                    else if (gv.cc.ctrlDownLeftArrow.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        MoveTargetHighlight(1);
                    }
                    else if (btnSelect.getImpact(x, y))
                    {
                        TargetCastPressed(pc);
                        //Toast.makeText(gameContext, "Selected", Toast.LENGTH_SHORT).show();
                    }
                    else if (btnMove.getImpact(x, y))
                    {
                        if (canMove)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "move";
                            gv.screenType = "combat";
                            //Toast.makeText(gameContext, "Move gv.mode", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        gv.screenType = "combatInventory";
                        gv.screenInventory.resetInventory();
                        //Toast.makeText(gameContext, "Inventory Button", Toast.LENGTH_SHORT).show();
                    }
                    else if (btnAttack.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        currentCombatMode = "attack";
                        gv.screenType = "combat";
                        setTargetHighlightStartLocation(pc);
                        //Toast.makeText(gameContext, "Attack gv.mode", Toast.LENGTH_SHORT).show();
                    }
                    else if (btnCast.getImpact(x, y))
                    {
                        if (pc.knownSpellsTags.Count > 0)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            currentCombatMode = "castSelector";
                            gv.screenType = "combatCast";
                            gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                            spellSelectorIndex = 0;
                            setTargetHighlightStartLocation(pc);
                        }
                        else
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (btnSkipTurn.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        endPcTurn(false);
                    }
                    break;
            }
        }*/

        public void onTouchCombat(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:

                    //hundi
                    if (e.Button == MouseButtons.Left)
                    {

                    }
                 break;
                //MouseButtons.

                //int x = (int)e.X;
                //int y = (int)e.Y;
                //int t = 0;
                //break;

                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;
                    gv.mod.mousePosX = x;
                    gv.mod.mousePosY = y;

                    //NEW SYSTEM
                    combatUiLayout.setHover(x, y);

                    //rdr2 added
                    //recalculateCreaturesShownInInitiativeBar();

                    //covid19
                            //target.Y = target.Y - (int)(squareSize * (mod.combatScrollingTimerY / 100f));
                    //int gridx = (int)(e.X - gv.oXshift - mapStartLocXinPixels + (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f))) / gv.squareSize;
                    //int gridy = (int)(e.Y - (gv.squareSize / 2) + (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f))) / gv.squareSize;

                    int gridx = (e.X - gv.oXshift - mapStartLocXinPixels + (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f))) / gv.squareSize;
                    int gridy = (e.Y - (gv.squareSize / 2) + (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f))) / gv.squareSize;

                    //covid21
                    if (gv.mod.mousePosY < gv.squareSize - (gv.squareSize / 2) - (int)(gv.squareSize * (gv.mod.combatScrollingTimerY / 100f)))
                    {
                        gridy = -1;
                    }

                    /*
                    if (gv.mod.mousePosX < gv.squareSize - (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)))
                    {
                        gridx = -1;
                    }
                    */
                    /*
                     * 
                     
                    if (gridy == 0)
                    {
                        if (e.Y > gv.squareSize + (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)))
                        {
                            gridy = 1;
                        }
                    }

                    if (e.X - gv.oXshift - mapStartLocXinPixels + (int)(gv.squareSize * (gv.mod.combatScrollingTimer / 100f)) < gv.squareSize)
                    {
                        gridx = -1;
                    }
                    */
                    #region Floaty info on props, triggers and effect squares
                    gv.cc.floatyTextPropMouseOver = "";
                    bool propFound = false;
                    bool triggerFound = false;
                    foreach (Prop p in gv.mod.currentEncounter.propsList)
                    {
                        if ((p.LocationX == gridx + UpperLeftSquare.X) && (p.LocationY == gridy + UpperLeftSquare.Y))
                        {
                            if (!p.MouseOverText.Equals("none") && (isPlayerTurn))
                            {
                                propFound = true;
                                gv.cc.floatyTextPropMouseOver = p.MouseOverText;
                                float floatyPushUp = 0;

                                if (gv.cc.floatyTextPropMouseOver.Length <= 20)
                                {
                                    floatyPushUp = 0.0f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 35)
                                {
                                    floatyPushUp = 0.0f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 52)
                                {
                                    floatyPushUp = 0.12f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 70)
                                {
                                    floatyPushUp = 0.3f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 87)
                                {
                                    floatyPushUp = 0.7f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 105)
                                {
                                    floatyPushUp = 1.0f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 122)
                                {
                                    floatyPushUp = 1.35f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 140)
                                {
                                    floatyPushUp = 1.5f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 157)
                                {
                                    floatyPushUp = 1.62f;
                                }
                                else if (gv.cc.floatyTextPropMouseOver.Length <= 175)
                                {
                                    floatyPushUp = 1.75f;
                                }
                                else
                                {
                                    floatyPushUp = 2.0f;
                                }
                                gv.cc.floatyPushUp = floatyPushUp;
                                //aggroman
                                gv.cc.floatyTextLocPropMouseOver = new Coordinate(gridx * gv.squareSize, (gridy) * gv.squareSize - (int)(floatyPushUp * 2 * gv.squareSize));
                                //gv.DrawTextOutlined(p.MouseOverText, gv.cc.floatyTextLoc.X, gv.cc.floatyTextLoc.Y, 1.0f, Color.White);
                            }
                        }
                    }

                    if (!propFound)
                    {
                        foreach (Trigger t in gv.mod.currentEncounter.Triggers)
                        {
                            foreach (Coordinate c in t.TriggerSquaresList)
                            {
                                if ((c.X == gridx + UpperLeftSquare.X) && (c.Y == gridy + UpperLeftSquare.Y))
                                {
                                    if (!t.mouseOverText.Equals("none") && (isPlayerTurn))
                                    {
                                        triggerFound = true;
                                        gv.cc.floatyTextPropMouseOver = t.mouseOverText;
                                        float floatyPushUp = 0;

                                        if (gv.cc.floatyTextPropMouseOver.Length <= 20)
                                        {
                                            floatyPushUp = 0.0f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 35)
                                        {
                                            floatyPushUp = 0.0f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 52)
                                        {
                                            floatyPushUp = 0.12f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 70)
                                        {
                                            floatyPushUp = 0.3f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 87)
                                        {
                                            floatyPushUp = 0.7f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 105)
                                        {
                                            floatyPushUp = 1.0f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 122)
                                        {
                                            floatyPushUp = 1.35f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 140)
                                        {
                                            floatyPushUp = 1.5f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 157)
                                        {
                                            floatyPushUp = 1.62f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 175)
                                        {
                                            floatyPushUp = 1.75f;
                                        }
                                        else
                                        {
                                            floatyPushUp = 2.0f;
                                        }
                                        gv.cc.floatyPushUp = floatyPushUp;
                                        //aggroman
                                        gv.cc.floatyTextLocPropMouseOver = new Coordinate(gridx * gv.squareSize, (gridy) * gv.squareSize - (int)(floatyPushUp * 2 * gv.squareSize));

                                    }
                                }
                            }
                        }
                    }

                    if (!propFound && !triggerFound)
                    {
                        foreach (Effect ef in gv.mod.currentEncounter.effectsList)
                        {
                            if ((ef.combatLocX == gridx + UpperLeftSquare.X) && (ef.combatLocY == gridy + UpperLeftSquare.Y))
                            {
                                /*
                                if (!ef.description.Equals("none") && (isPlayerTurn))
                                {
                                    bool isBlocked = false;
                                    foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                    {
                                        if (c.combatLocX == ef.combatLocX && c.combatLocY == ef.combatLocY)
                                        {
                                            isBlocked = true;
                                        }
                                    }

                                    foreach (Player p in gv.mod.playerList)
                                    {
                                        if (p.combatLocX == ef.combatLocX && p.combatLocY == ef.combatLocY)
                                        {
                                            isBlocked = true;
                                        }
                                    }

                                    foreach (Trigger t in gv.mod.currentEncounter.Triggers)
                                    {
                                        foreach (Coordinate Coord in t.TriggerSquaresList)
                                        {
                                            if (Coord.X == ef.combatLocX && Coord.Y == ef.combatLocY)
                                            {
                                                if (t.mouseOverText != "" && t.mouseOverText != null && t.mouseOverText != "None" && t.mouseOverText != "none")
                                                {
                                                    isBlocked = true;
                                                }
                                            }
                                        }
                                    }

                                    if (!isBlocked)
                                    {
                                        gv.cc.floatyTextPropMouseOver = ef.description;

                                        float floatyPushUp = 0;

                                        if (gv.cc.floatyTextPropMouseOver.Length <= 20)
                                        {
                                            floatyPushUp = 0.0f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 35)
                                        {
                                            floatyPushUp = 0.0f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 52)
                                        {
                                            floatyPushUp = 0.12f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 70)
                                        {
                                            floatyPushUp = 0.3f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 87)
                                        {
                                            floatyPushUp = 0.7f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 105)
                                        {
                                            floatyPushUp = 1.0f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 122)
                                        {
                                            floatyPushUp = 1.35f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 140)
                                        {
                                            floatyPushUp = 1.5f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 157)
                                        {
                                            floatyPushUp = 1.62f;
                                        }
                                        else if (gv.cc.floatyTextPropMouseOver.Length <= 175)
                                        {
                                            floatyPushUp = 1.75f;
                                        }
                                        else
                                        {
                                            floatyPushUp = 2.0f;
                                        }
                                        gv.cc.floatyPushUp = floatyPushUp;
                                        //aggroman
                                        gv.cc.floatyTextLocPropMouseOver = new Coordinate(gridx * gv.squareSize, (gridy) * gv.squareSize - (int)(floatyPushUp * 2 * gv.squareSize));
                                    }

                                }
                                */
                            }
                        }
                    }




                    #endregion

                    #region FloatyText Creatures and pc
                    if (e.Button != MouseButtons.Right)
                    {
                        bool hide = true;
                        bool foundActor = false;

                        foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            //if ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y))
                            //1=normal, 2=wide, 3=tall, 4=large  
                            int crtSize = crt.creatureSize;

                            //normal  
                            if (crtSize == 1)
                            {
                                if ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y))
                                {
                                    /*
                                    gv.cc.floatyText = crt.cr_name;
                                    gv.cc.floatyText2 = "HP:" + crt.hp + " SP:" + crt.sp;
                                    gv.cc.floatyText3 = "AC:" + crt.getAc() + " " + crt.cr_status;
                                    gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY));

                                    gv.cc.floatyTextActorInfoName = crt.cr_name;
                                    */
                                    hide = false;
                                    if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                    {
                                        foundActor = true;
                                        showActorInfo(crt);
                                    }

                                }
                            }

                            //wide  
                            else if (crtSize == 2)
                            {
                                if (((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) || ((crt.combatLocX + 1 == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)))
                                {
                                    /*
                                    gv.cc.floatyText = crt.cr_name;
                                    gv.cc.floatyText2 = "HP:" + crt.hp + " SP:" + crt.sp;
                                    gv.cc.floatyText3 = "AC:" + crt.getAc() + " " + crt.cr_status;
                                    gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY));

                                    gv.cc.floatyTextActorInfoName = crt.cr_name;
                                    */
                                    hide = false;
                                    if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                    {
                                        foundActor = true;
                                        showActorInfo(crt);
                                    }
                                }
                            }

                            //tall  
                            else if (crtSize == 3)
                            {
                                if (((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) || ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY + 1 == gridy + UpperLeftSquare.Y)))
                                {
                                    /*
                                    gv.cc.floatyText = crt.cr_name;
                                    gv.cc.floatyText2 = "HP:" + crt.hp + " SP:" + crt.sp;
                                    gv.cc.floatyText3 = "AC:" + crt.getAc() + " " + crt.cr_status;
                                    gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY));

                                    gv.cc.floatyTextActorInfoName = crt.cr_name;
                                    */
                                    hide = false;
                                    if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                    {
                                        foundActor = true;
                                        showActorInfo(crt);
                                    }
                                }
                            }

                            //large  
                            else if (crtSize == 4)
                            {
                                if (((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) || ((crt.combatLocX + 1 == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) ||
                                ((crt.combatLocX == gridx + +UpperLeftSquare.X) && (crt.combatLocY + 1 == gridy + UpperLeftSquare.Y)) ||
                                ((crt.combatLocX + 1 == gridx + UpperLeftSquare.X) && (crt.combatLocY + 1 == gridy + UpperLeftSquare.Y)))
                                {
                                    /*
                                    gv.cc.floatyText = crt.cr_name;
                                    gv.cc.floatyText2 = "HP:" + crt.hp + " SP:" + crt.sp;
                                    gv.cc.floatyText3 = "AC:" + crt.getAc() + " " + crt.cr_status;
                                    gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY));

                                    gv.cc.floatyTextActorInfoName = crt.cr_name;
                                    */
                                    hide = false;
                                    if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                    {
                                        foundActor = true;
                                        showActorInfo(crt);
                                    }
                                }
                            }
                        }
                        foreach (Player pc1 in gv.mod.playerList)
                        {
                            if ((pc1.combatLocX == gridx + UpperLeftSquare.X) && (pc1.combatLocY == gridy + UpperLeftSquare.Y))
                            {
                               
                                hide = false;
                                if (!foundActor)
                                {
                                    if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                    {
                                        foundActor = true;
                                        showActorInfo(pc1);
                                    }
                                }
                            }
                        }

                        foreach (Trigger t in gv.mod.currentEncounter.Triggers)
                        {
                            foreach (Coordinate coord in t.TriggerSquaresList)
                            {
                                if ((coord.X == gridx + UpperLeftSquare.X) && (coord.Y == gridy + UpperLeftSquare.Y))
                                {
                                    hide = false;
                                    if (!foundActor)
                                    {
                                        if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                        {
                                            foundActor = true;
                                            showActorInfo(t);
                                        }
                                    }
                                }
                            }
                        }


                        foreach (Prop p in gv.mod.currentEncounter.propsList)
                        {
                                if ((p.LocationX == gridx + UpperLeftSquare.X) && (p.LocationY == gridy + UpperLeftSquare.Y))
                                {
                                    if (p.canBeTriggeredByCreature || p.canBeTriggeredByPc)
                                    {
                                        hide = false;
                                        if (!foundActor)
                                        {
                                            if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                            {
                                                foundActor = true;
                                                showActorInfo(p);
                                            }
                                        }
                                    }
                                }
                        }

                        foreach (Effect ef in gv.mod.currentEncounter.effectsList)
                        {
                            if ((ef.combatLocX == gridx + UpperLeftSquare.X) && (ef.combatLocY == gridy + UpperLeftSquare.Y))
                            {
                                    hide = false;
                                    if (!foundActor)
                                    {
                                        if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                                        {
                                            foundActor = true;
                                            showActorInfo(ef);
                                        }
                                    }
                            }
                        }


                        if (hide)
                        {
                            hideActorInfo();
                        }
                    }

                    #endregion

                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;

                    Player pc = gv.mod.playerList[currentPlayerIndex];

                    //NEW SYSTEM
                    string rtn = combatUiLayout.getImpact(x, y);
                    //gv.cc.addLogText("lime", "mouse down: " + rtn);
                    if (e.Button == MouseButtons.Left)
                    {
                        gv.cc.inEffectMode = false;
                    }

                    if (e.Button == MouseButtons.Right)
                    {
                        gridx = (int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize;
                        gridy = (int)(e.Y - (gv.squareSize / 2)) / gv.squareSize;
                        foreach (Player pc1 in gv.mod.playerList)
                        {
                            if ((pc1.combatLocX == gridx + UpperLeftSquare.X) && (pc1.combatLocY == gridy + UpperLeftSquare.Y))
                            {

                                //if (!gv.cc.showingEffects)
                                //{
                                showActorInfoRightHold(pc1);
                                //}
                                //else
                                //{
                                //showActorInfo(pc1);
                                //gv.cc.showingEffects = false;
                                //}
                                break;
                            }
                        }

                        foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            //if ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y))
                            //1=normal, 2=wide, 3=tall, 4=large  
                            int crtSize = crt.creatureSize;

                            //normal  
                            if (crtSize == 1)
                            {
                                if ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y))
                                {
                                    showActorInfoRightHold(crt);
                                    break;
                                }
                            }

                            //wide  
                            else if (crtSize == 2)
                            {
                                if (((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) || ((crt.combatLocX + 1 == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)))
                                {
                                    showActorInfoRightHold(crt);
                                    break;
                                }
                            }

                            //tall  
                            else if (crtSize == 3)
                            {
                                if (((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) || ((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY + 1 == gridy + UpperLeftSquare.Y)))
                                {
                                    showActorInfoRightHold(crt);
                                    break;
                                }
                            }

                            //large  
                            else if (crtSize == 4)
                            {
                                if (((crt.combatLocX == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) || ((crt.combatLocX + 1 == gridx + UpperLeftSquare.X) && (crt.combatLocY == gridy + UpperLeftSquare.Y)) ||
                                ((crt.combatLocX == gridx + +UpperLeftSquare.X) && (crt.combatLocY + 1 == gridy + UpperLeftSquare.Y)) ||
                                ((crt.combatLocX + 1 == gridx + UpperLeftSquare.X) && (crt.combatLocY + 1 == gridy + UpperLeftSquare.Y)))
                                {
                                    showActorInfoRightHold(crt);
                                    break;
                                }
                            }
                        }
                    }


                    #region Toggles
                    if (rtn.Equals("tglHP"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showHP = !showHP;
                    }
                    if (rtn.Equals("tglSP"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showSP = !showSP;
                    }
                    if (rtn.Equals("tglMoveKeys"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showMoveKeys = !showMoveKeys;
                    }
                    if (rtn.Equals("tglMoveOrder"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showMoveOrder = !showMoveOrder;
                    }
                    if (rtn.Equals("tglIniBar"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showIniBar = !showIniBar;
                    }
                    if (rtn.Equals("tglFastMode"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        if (gv.mod.fastMode)
                        {
                            Creature crt = new Creature();
                            int highestLivingCrtMoveOrderfound = 0;
                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (currentMoveOrderIndex == 0)
                                {
                                    if (c.moveOrder >= highestLivingCrtMoveOrderfound)
                                    {
                                        highestLivingCrtMoveOrderfound = c.moveOrder;
                                        crt = c;
                                    }
                                }
                                else
                                {
                                    if (c.moveOrder == currentMoveOrderIndex - 1)
                                    {
                                        crt = c;
                                        break;
                                    }
                                }
                            }
                            UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                            UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                        }
                        gv.mod.fastMode = !gv.mod.fastMode;
                    }

                    if (rtn.Equals("tglSpeed"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }

                        if (gv.mod.combatAnimationSpeed == 100)
                        {
                            gv.mod.combatAnimationSpeed = 50;
                            tgl.ImgOffFilename = "tgl_speedNEW_2";
                            gv.cc.addLogText("lime", "move speed: 2x");
                        }
                        else if (gv.mod.combatAnimationSpeed == 50)
                        {
                            gv.mod.combatAnimationSpeed = 25;
                            tgl.ImgOffFilename = "tgl_speedNEW_4";
                            gv.cc.addLogText("lime", "move speed: 4x");
                        }
                        else if (gv.mod.combatAnimationSpeed == 25)
                        {
                            gv.mod.combatAnimationSpeed = 10;
                            tgl.ImgOffFilename = "tgl_speedNEW_10";
                            gv.cc.addLogText("lime", "move speed: 10x");
                        }
                        else if (gv.mod.combatAnimationSpeed == 10)
                        {
                            gv.mod.combatAnimationSpeed = 100;
                            tgl.ImgOffFilename = "tgl_speedNEW_1";
                            gv.cc.addLogText("lime", "move speed: 1x");
                        }
                    }
                    if (rtn.Equals("tglAttackSpeed"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }

                        if (gv.mod.attackAnimationSpeed == 100)
                        {
                            gv.mod.attackAnimationSpeed = 50;
                            tgl.ImgOffFilename = "tgl_attackSpeed_2";
                            gv.cc.addLogText("lime", "attack and cast speed: 2x");
                        }
                        else if (gv.mod.attackAnimationSpeed == 50)
                        {
                            gv.mod.attackAnimationSpeed = 25;
                            tgl.ImgOffFilename = "tgl_attackSpeed_4";
                            gv.cc.addLogText("lime", "attack and cast speed: 4x");
                        }
                        else if (gv.mod.attackAnimationSpeed == 25)
                        {
                            gv.mod.attackAnimationSpeed = 10;
                            tgl.ImgOffFilename = "tgl_attackSpeed_10";
                            gv.cc.addLogText("lime", "attack and cast speed: 10x");
                        }
                        else if (gv.mod.attackAnimationSpeed == 10)
                        {
                            gv.mod.attackAnimationSpeed = 100;
                            tgl.ImgOffFilename = "tgl_attackSpeed_1";
                            gv.cc.addLogText("lime", "attack and cast speed: 1x");
                        }
                    } 
                    if (rtn.Equals("tglSound"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.playMusic = false;
                            //TODO gv.screenCombat.tglSoundFx.toggleOn = false;
                            gv.stopCombatMusic();
                            gv.cc.addLogText("lime", "Music Off");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.playMusic = true;
                            //TODO gv.screenCombat.tglSoundFx.toggleOn = true;
                            gv.startCombatMusic();
                            gv.cc.addLogText("lime", "Music On");
                        }
                    }
                    if (rtn.Equals("tglSoundFx"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.playSoundFx = false;
                            gv.cc.addLogText("lime", "SoundFX Off");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.playSoundFx = true;
                            gv.cc.addLogText("lime", "SoundFX On");
                        }
                    }
                    if (rtn.Equals("tglGrid"))
                    {
                        IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.com_showGrid = false;
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.com_showGrid = true;
                        }
                    }
                    if (rtn.Equals("tglHelp"))
                    {
                        tutorialMessageCombat(true);
                    }
                    if ((rtn.Equals("tglKill")) && (gv.mod.debugMode))
                    {
                        gv.mod.currentEncounter.encounterCreatureList.Clear();
                        //gv.mod.currentEncounter.encounterCreatureRefsList.Clear();
                        checkEndEncounter();
                    }
                    #endregion

                    #region TOUCH ON MAP AREA
                    gridx = ((int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize) + UpperLeftSquare.X;
                    gridy = ((int)(e.Y - (gv.squareSize / 2)) / gv.squareSize) + UpperLeftSquare.Y;
                    int tappedSqrX = ((int)(e.X - gv.oXshift - mapStartLocXinPixels) / gv.squareSize);
                    int tappedSqrY = ((int)(e.Y - (gv.squareSize / 2)) / gv.squareSize);

                    if (IsInVisibleCombatWindow(gridx, gridy))
                    {
                        if (e.Button != MouseButtons.Right)
                        {
                            //hideActorInfo();
                        }
                        if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                        {

                            if (e.Button == MouseButtons.Left)
                            {
                                //Check for second tap so TARGET
                                if ((gridx == targetHighlightCenterLocation.X) && (gridy == targetHighlightCenterLocation.Y))
                                {
                                    if (currentCombatMode.Equals("attack"))
                                    {
                                        continueTurn = false;
                                        TargetAttackPressed(pc);
                                    }
                                    else if (currentCombatMode.Equals("cast"))
                                    {
                                        continueTurn = false;
                                        if (gv.mod.isCastFromUsedItem)
                                        {
                                            gv.mod.isCastFromUsedItem = false;
                                            Item it = gv.mod.getItemByTag(gv.mod.tagOfItemUsedForCast);
                                            TargetCastPressed(pc, it);
                                        }
                                        else
                                        {
                                            TargetCastPressed(pc);
                                        }
                                    }
                                }
                                targetHighlightCenterLocation.Y = gridy;
                                targetHighlightCenterLocation.X = gridx;
                            }
                        }
                    }
                    #endregion

                    #region BUTTONS
                    if (e.Button == MouseButtons.Left)
                    {
                        if ((rtn.Equals("ctrlUpArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY - 1)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveUp(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlUpArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(8);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlDownArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY + 1)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveDown(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlDownArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(2);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlLeftArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX - 1) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveLeft(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlLeftArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(4);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlRightArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX + 1) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveRight(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlRightArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(6);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlUpRightArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX + 1) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY - 1)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveUpRight(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlUpRightArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(9);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlDownRightArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX + 1) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY + 1)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveDownRight(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlDownRightArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(3);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlUpLeftArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX - 1) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY - 1)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveUpLeft(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlUpLeftArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(7);
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlDownLeftArrow")) || ((tappedSqrX + UpperLeftSquare.X == pc.combatLocX - 1) && (tappedSqrY + UpperLeftSquare.Y == pc.combatLocY + 1)))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                continueTurn = false;
                                MoveDownLeft(pc);
                            }
                            else if ((currentCombatMode.Equals("attack")) || (currentCombatMode.Equals("cast")))
                            {
                                if (rtn.Equals("ctrlDownLeftArrow")) //if clicked on square, don't move the highlight...only move for arrow button
                                {
                                    continueTurn = false;
                                    MoveTargetHighlight(1);
                                }
                            }
                        }
                    }
                    else if (rtn.Equals("btnSwitchWeapon"))
                    {
                        if (isPlayerTurn)
                        {
                            continueTurn = false;
                            if (currentPlayerIndex > gv.mod.playerList.Count - 1)
                            {
                                return;
                            }
                            gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                            gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                            gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                            gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                            gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                            gv.cc.partyScreenPcIndex = currentPlayerIndex;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "combatParty";
                        }
                    }
                    else if (rtn.Equals("btnMove"))
                    {

                        if (canMove)
                        {
                            if (currentCombatMode.Equals("move"))
                            {
                                currentCombatMode = "info";
                            }
                            else
                            {
                                if (isPlayerTurn)
                                {
                                    gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                                    gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                                    gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                                    gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                    gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                                    currentCombatMode = "move";
                                }
                            }
                            gv.screenType = "combat";
                        }
                    }
                    else if (rtn.Equals("btnInventory"))
                    {
                        if (isPlayerTurn && !gv.mod.currentEncounter.noItemUseModifier)
                        {
                            gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                            gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                            gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                            gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                            gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                            //gv.screenInventory.resetInventory(true);
                            gv.screenType = "combatInventory";
                            gv.screenInventory.resetInventory(true);
                        }
                    }

                    else if (rtn.Equals("btnIni1"))
                    {
                        int buttonThreshold = 1 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnIni2"))
                    {
                        int buttonThreshold = 2 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnIni3"))
                    {
                        int buttonThreshold = 3 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnIni4"))
                    {
                        int buttonThreshold = 4 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnIni5"))
                    {
                        int buttonThreshold = 5 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnIni6"))
                    {
                        int buttonThreshold = 6 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnIni7"))
                    {
                        int buttonThreshold = 7 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni8"))
                    {
                        int buttonThreshold = 8 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni9"))
                    {
                        int buttonThreshold = 9 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni10"))
                    {
                        int buttonThreshold = 10 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni11"))
                    {
                        int buttonThreshold = 11 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni12"))
                    {
                        int buttonThreshold = 12 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni13"))
                    {
                        int buttonThreshold = 13 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni14"))
                    {
                        int buttonThreshold = 14 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni15"))
                    {
                        int buttonThreshold = 15 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni16"))
                    {
                        int buttonThreshold = 16 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni17"))
                    {
                        int buttonThreshold = 17 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni18"))
                    {
                        int buttonThreshold = 18 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni19"))
                    {
                        int buttonThreshold = 19 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni20"))
                    {
                        int buttonThreshold = 20 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni21"))
                    {
                        int buttonThreshold = 21 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni22"))
                    {
                        int buttonThreshold = 22 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni23"))
                    {
                        int buttonThreshold = 23 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni24"))
                    {
                        int buttonThreshold = 24 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni25"))
                    {
                        int buttonThreshold = 25 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni26"))
                    {
                        int buttonThreshold = 26 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni27"))
                    {
                        int buttonThreshold = 27 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni28"))
                    {
                        int buttonThreshold = 28 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni29"))
                    {
                        int buttonThreshold = 29 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni30"))
                    {
                        int buttonThreshold = 30 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni31"))
                    {
                        int buttonThreshold = 31 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni32"))
                    {
                        int buttonThreshold = 32 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni33"))
                    {
                        int buttonThreshold = 33 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni34"))
                    {
                        int buttonThreshold = 34 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni35"))
                    {
                        int buttonThreshold = 35 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }


                    else if (rtn.Equals("btnIni36"))
                    {
                        int buttonThreshold = 36 - gv.mod.creatureCounterSubstractor;
                        int buttonCounter = 0;
                        int index1 = 0;

                        for (int i = 0; i < moveOrderList.Count; i++)
                        {
                            if (moveOrderList[i].PcOrCreature is Player)
                            {
                                Player crt = (Player)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        //buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                            if (moveOrderList[i].PcOrCreature is Creature)
                            {
                                Creature crt = (Creature)moveOrderList[i].PcOrCreature;
                                if (crt.hp > 0)
                                {
                                    buttonCounter++;
                                    if (crt.token.PixelSize.Width > 100)
                                    {
                                        buttonCounter++;
                                    }
                                    if (buttonCounter >= buttonThreshold)
                                    {
                                        index1 = i;
                                        break;
                                    }
                                }
                            }
                        }

                        MoveOrder m = moveOrderList[index1];
                        if (m.PcOrCreature is Player)
                        {
                            Player crt = (Player)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                        if (m.PcOrCreature is Creature)
                        {
                            Creature crt = (Creature)m.PcOrCreature;
                            if (crt.hp > 0)
                            {
                                UpperLeftSquare.X = crt.combatLocX - gv.playerOffsetX;
                                UpperLeftSquare.Y = crt.combatLocY - gv.playerOffsetY;
                            }
                        }
                    }

                    else if (rtn.Equals("btnAttack"))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("attack"))
                            {
                                currentCombatMode = "info";
                            }
                            else
                            {
                                gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                                gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                                gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                                gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                                gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                                gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                                currentCombatMode = "attack";
                            }
                            gv.screenType = "combat";
                            setTargetHighlightStartLocation(pc);
                        }
                    }
                    else if (rtn.Equals("btnCast"))
                    {
                        if (isPlayerTurn && !gv.mod.currentEncounter.noSpellCastModifier)
                        {
                            gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                            continueTurn = false;
                            gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                            gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                            gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                            gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                            gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                            if (pc.knownSpellsTags.Count > 0)
                            {
                                currentCombatMode = "castSelector";
                                gv.screenType = "combatCast";
                                gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                                spellSelectorIndex = 0;
                                setTargetHighlightStartLocation(pc);
                            }
                        }
                        else
                        {
                            //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (rtn.Equals("btnTraitUse"))
                    {
                        if (isPlayerTurn && !gv.mod.currentEncounter.noTraitUseModifier)
                        {
                            gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                            continueTurn = false;
                            gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                            gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                            gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                            gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                            gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                            //potential reason
                            if (pc.knownInCombatUsableTraitsTags.Count > 0)
                            {
                                currentCombatMode = "traitUseSelector";
                                gv.screenType = "combatTraitUse";
                                gv.screenCastSelector.castingPlayerIndex = currentPlayerIndex;
                                spellSelectorIndex = 0;
                                setTargetHighlightStartLocation(pc);
                            }
                        }
                        else
                        {
                            //TODO Toast.makeText(gv.gameContext, "PC has no Spells", Toast.LENGTH_SHORT).show();
                        }
                    }
                    else if (rtn.Equals("btnSkipTurn"))
                    {
                        if (isPlayerTurn)
                        {
                            continueTurn = false;
                            gv.mod.playerList[currentPlayerIndex].thisCastIsFreeOfCost = false;
                            gv.mod.playerList[currentPlayerIndex].isPreparingSpell = false;
                            gv.mod.playerList[currentPlayerIndex].doCastActionInXFullTurns = 0;
                            gv.mod.playerList[currentPlayerIndex].tagOfSpellToBeCastAfterCastTimeIsDone = "none";
                            gv.mod.playerList[currentPlayerIndex].thisCasterCanBeInterrupted = true;
                            gv.screenType = "combat";
                            endPcTurn(false);
                        }
                    }
                    else if (rtn.Equals("btnDelay"))
                    {
                        if (isPlayerTurn)
                        {
                            int highestMoveOrderFound = 0;

                            foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                            {
                                if (c.moveOrder > highestMoveOrderFound)
                                {
                                    highestMoveOrderFound = c.moveOrder;
                                }
                            }

                            foreach (Player p in gv.mod.playerList)
                            {
                                if (p.moveOrder > highestMoveOrderFound)
                                {
                                    highestMoveOrderFound = p.moveOrder;
                                }
                            }

                            if (highestMoveOrderFound != gv.mod.playerList[currentPlayerIndex].moveOrder && !gv.mod.playerList[currentPlayerIndex].hasDelayedAlready)
                            {
                                gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                                gv.mod.playerList[currentPlayerIndex].moveOrder = highestMoveOrderFound + 1;
                                /*
                                foreach (Creature c in gv.mod.currentEncounter.encounterCreatureList)
                                {
                                    if (c.moveOrder == gv.mod.playerList[currentPlayerIndex].moveOrder)
                                    {
                                        gv.mod.playerList[currentPlayerIndex].moveOrder++;
                                    }
                                }
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (p.moveOrder == gv.mod.playerList[currentPlayerIndex].moveOrder && p != gv.mod.playerList[currentPlayerIndex])
                                    {
                                        gv.mod.playerList[currentPlayerIndex].moveOrder++;
                                    }
                                }
                                */

                                //add to end of move order  
                                MoveOrder newMO = new MoveOrder();
                                newMO.PcOrCreature = gv.mod.playerList[currentPlayerIndex];
                                newMO.rank = highestMoveOrderFound + 1;
                                gv.screenCombat.moveOrderList.Add(newMO);
                                for (int i = gv.screenCombat.moveOrderList.Count - 2; i >= 0; i--)
                                {
                                    if (gv.screenCombat.moveOrderList[i].PcOrCreature == newMO.PcOrCreature)
                                    {
                                        gv.screenCombat.moveOrderList.RemoveAt(i);
                                    }
                                }

                                //increment the number of initial move order objects
                                //note: check how ini bar system will interact with creatures added while battle is running  
                                gv.screenCombat.initialMoveOrderListSize++;

                                recalculateCreaturesShownInInitiativeBar();

                                endPcTurn(false);
                            }
                            else
                            {
                                gv.cc.addLogText("red", "Delaying not possible for this character this turn.");
                            }
                        }
                    }
                    else if (rtn.Equals("btnExit"))
                    {
                        gv.Close();
                    }
                    else if (rtn.Equals("btnSelect"))
                    {
                        if (isPlayerTurn)
                        {
                            if (currentCombatMode.Equals("attack"))
                            {
                                continueTurn = false;
                                TargetAttackPressed(pc);
                            }
                            else if (currentCombatMode.Equals("cast"))
                            {
                                continueTurn = false;
                                if (gv.mod.isCastFromUsedItem)
                                {
                                    gv.mod.isCastFromUsedItem = false;
                                    Item it = gv.mod.getItemByTag(gv.mod.tagOfItemUsedForCast);
                                    TargetCastPressed(pc, it);
                                }
                                else
                                {
                                    TargetCastPressed(pc);
                                }
                            }
                        }
                    }
                    else if (rtn.Equals("btnToggleArrows"))
                    {
                        foreach (IB2Panel pnl in combatUiLayout.panelList)
                        {
                            if (pnl.tag.Equals("arrowPanel"))
                            {
                                //hides down
                                showArrows = !showArrows;
                                if (pnl.currentLocY > pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                        }
                    }
            }
                    break;
#endregion
            }
        }

#endregion

        public void doUpdate(Player pc)
        {
            //beckhelling
            CalculateUpperLeft();

            //checkEndEncounter();
            if (moveCost == gv.mod.diagonalMoveCost)
            {
                currentMoves += gv.mod.diagonalMoveCost;
                moveCost = 1.0f;
            }
            else
            {
                currentMoves++;
            }
            float moveleft = pc.moveDistance - currentMoves;
            if (moveleft < 1) { moveleft = 0; }
            //do triggers and anything else needed after each creature or PC move
            afterEachMoveCalls();
            floatyTextOn = true;
            checkEndEncounter();
            if ((pc.hp <= 0) || (pc.isHeld()))
            {
                endPcTurn(true);
            } 
        }
        public void MoveTargetHighlight(int numPadDirection)
        {
            switch (numPadDirection)
            {
                case 8: //up
                    if (targetHighlightCenterLocation.Y > 0)
                    {
                        targetHighlightCenterLocation.Y--;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.Y++;
                        }
                    }
                    break;
                case 2: //down
                    if (targetHighlightCenterLocation.Y < gv.mod.currentEncounter.MapSizeY - 1)
                    {
                        targetHighlightCenterLocation.Y++;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.Y--;
                        }
                    }
                    break;
                case 4: //left
                    if (targetHighlightCenterLocation.X > 0)
                    {
                        targetHighlightCenterLocation.X--;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.X++;
                        }
                    }
                    break;
                case 6: //right
                    if (targetHighlightCenterLocation.X < gv.mod.currentEncounter.MapSizeX - 1)
                    {
                        targetHighlightCenterLocation.X++;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.X--;
                        }
                    }
                    break;
                case 9: //upright
                    if ((targetHighlightCenterLocation.X < gv.mod.currentEncounter.MapSizeX - 1) && (targetHighlightCenterLocation.Y > 0))
                    {
                        targetHighlightCenterLocation.X++;
                        targetHighlightCenterLocation.Y--;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.X--;
                            targetHighlightCenterLocation.Y++;
                        }
                    }
                    break;
                case 3: //downright
                    if ((targetHighlightCenterLocation.X < gv.mod.currentEncounter.MapSizeX - 1) && (targetHighlightCenterLocation.Y < gv.mod.currentEncounter.MapSizeY - 1))
                    {
                        targetHighlightCenterLocation.X++;
                        targetHighlightCenterLocation.Y++;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.X--;
                            targetHighlightCenterLocation.Y--;
                        }
                    }
                    break;
                case 7: //upleft
                    if ((targetHighlightCenterLocation.X > 0) && (targetHighlightCenterLocation.Y > 0))
                    {
                        targetHighlightCenterLocation.X--;
                        targetHighlightCenterLocation.Y--;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.X++;
                            targetHighlightCenterLocation.Y++;
                        }
                    }
                    break;
                case 1: //downleft
                    if ((targetHighlightCenterLocation.X > 0) && (targetHighlightCenterLocation.Y < gv.mod.currentEncounter.MapSizeY - 1))
                    {
                        targetHighlightCenterLocation.X--;
                        targetHighlightCenterLocation.Y++;
                        if (!IsInVisibleCombatWindow(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y))
                        {
                            targetHighlightCenterLocation.X++;
                            targetHighlightCenterLocation.Y--;
                        }
                    }
                    break;
            }

        }
        public void MoveUp(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if (pc.combatLocY > 0)
            {
                //check is walkable (blocked square or PC)
                if (isWalkable(pc.combatLocX, pc.combatLocY - 1))
                {
                    //check if creature -> do attack
                    Creature c = isBumpIntoCreature(pc.combatLocX, pc.combatLocY - 1);
                    if (c != null)
                    {
                        //attack creature
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX;
                        targetHighlightCenterLocation.Y = pc.combatLocY - 1;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= 1.0f)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX, pc.combatLocY - 1);
                        doPlayerCombatFacing(pc, pc.combatLocX, pc.combatLocY - 1);
                        pc.combatLocY--;
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveUpRight(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if ((pc.combatLocX < gv.mod.currentEncounter.MapSizeX - 1) && (pc.combatLocY > 0))
            {
                if (isWalkable(pc.combatLocX + 1, pc.combatLocY - 1))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX + 1, pc.combatLocY - 1);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX + 1;
                        targetHighlightCenterLocation.Y = pc.combatLocY - 1;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= gv.mod.diagonalMoveCost)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX + 1, pc.combatLocY - 1);
                        doPlayerCombatFacing(pc, pc.combatLocX + 1, pc.combatLocY - 1);
                        pc.combatLocX++;
                        pc.combatLocY--;
                        if (pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = false;
                        }
                        moveCost = gv.mod.diagonalMoveCost;
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveUpLeft(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if ((pc.combatLocX > 0) && (pc.combatLocY > 0))
            {
                if (isWalkable(pc.combatLocX - 1, pc.combatLocY - 1))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX - 1, pc.combatLocY - 1);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX - 1;
                        targetHighlightCenterLocation.Y = pc.combatLocY - 1;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= gv.mod.diagonalMoveCost)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX - 1, pc.combatLocY - 1);
                        doPlayerCombatFacing(pc, pc.combatLocX - 1, pc.combatLocY - 1);
                        pc.combatLocX--;
                        pc.combatLocY--;
                        if (!pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = true;
                        }
                        moveCost = gv.mod.diagonalMoveCost;
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveDown(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if (pc.combatLocY < gv.mod.currentEncounter.MapSizeY - 1)
            {
                if (isWalkable(pc.combatLocX, pc.combatLocY + 1))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX, pc.combatLocY + 1);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX;
                        targetHighlightCenterLocation.Y = pc.combatLocY + 1;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= 1.0f)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX, pc.combatLocY + 1);
                        doPlayerCombatFacing(pc, pc.combatLocX, pc.combatLocY + 1);
                        pc.combatLocY++;
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveDownRight(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if ((pc.combatLocX < gv.mod.currentEncounter.MapSizeX - 1) && (pc.combatLocY < gv.mod.currentEncounter.MapSizeY - 1))
            {
                if (isWalkable(pc.combatLocX + 1, pc.combatLocY + 1))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX + 1, pc.combatLocY + 1);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX + 1;
                        targetHighlightCenterLocation.Y = pc.combatLocY + 1;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= gv.mod.diagonalMoveCost)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX + 1, pc.combatLocY + 1);
                        doPlayerCombatFacing(pc, pc.combatLocX + 1, pc.combatLocY + 1);
                        pc.combatLocX++;
                        pc.combatLocY++;
                        if (pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = false;
                        }
                        moveCost = gv.mod.diagonalMoveCost;
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveDownLeft(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if ((pc.combatLocX > 0) && (pc.combatLocY < gv.mod.currentEncounter.MapSizeY - 1))
            {
                if (isWalkable(pc.combatLocX - 1, pc.combatLocY + 1))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX - 1, pc.combatLocY + 1);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX - 1;
                        targetHighlightCenterLocation.Y = pc.combatLocY + 1;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= gv.mod.diagonalMoveCost)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX - 1, pc.combatLocY + 1);
                        doPlayerCombatFacing(pc, pc.combatLocX - 1, pc.combatLocY + 1);
                        pc.combatLocX--;
                        pc.combatLocY++;
                        if (!pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = true;
                        }
                        moveCost = gv.mod.diagonalMoveCost;
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveRight(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if (pc.combatLocX < gv.mod.currentEncounter.MapSizeX - 1)
            {
                if (isWalkable(pc.combatLocX + 1, pc.combatLocY))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX + 1, pc.combatLocY);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX + 1;
                        targetHighlightCenterLocation.Y = pc.combatLocY;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= 1.0f)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX + 1, pc.combatLocY);
                        doPlayerCombatFacing(pc, pc.combatLocX + 1, pc.combatLocY);
                        pc.combatLocX++;
                        if (pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = false;
                        }
                        doUpdate(pc);
                    }
                }
            }
        }
        public void MoveLeft(Player pc)
        {
            if (isPlayerTurn)
            {
                CenterScreenOnPC();
            }

            if (pc.combatLocX > 0)
            {
                if (isWalkable(pc.combatLocX - 1, pc.combatLocY))
                {
                    Creature c = isBumpIntoCreature(pc.combatLocX - 1, pc.combatLocY);
                    if (c != null)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        dontEndTurn = false;
                        targetHighlightCenterLocation.X = pc.combatLocX - 1;
                        targetHighlightCenterLocation.Y = pc.combatLocY;
                        currentCombatMode = "attack";
                        TargetAttackPressed(pc);
                    }
                    else if ((pc.moveDistance - currentMoves) >= 1.0f)
                    {
                        gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
                        LeaveThreatenedCheck(pc, pc.combatLocX - 1, pc.combatLocY);
                        doPlayerCombatFacing(pc, pc.combatLocX - 1, pc.combatLocY);
                        pc.combatLocX--;
                        if (!pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = true;
                        }
                        doUpdate(pc);
                    }
                }
            }
        }
        public void TargetAttackPressed(Player pc)
        {
            //if (isPlayerTurn)
            //{
            //CenterScreenOnPC();
            //}
            gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
            if (isValidAttackTarget(pc))
            {
                if ((targetHighlightCenterLocation.X < pc.combatLocX) && (!pc.combatFacingLeft)) //attack left
                {
                    pc.combatFacingLeft = true;
                }
                else if ((targetHighlightCenterLocation.X > pc.combatLocX) && (pc.combatFacingLeft)) //attack right
                {
                    pc.combatFacingLeft = false;
                }
                doPlayerCombatFacing(pc, targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y);
                gv.touchEnabled = false;
                creatureToAnimate.Clear();
                playerToAnimate = pc;
                //set attack animation and do a delay
                attackAnimationTimeElapsed = 0;
                attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) * (-1 + (int)pc.token.PixelSize.Height / 100f));
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)pc.token.PixelSize.Height / 100f) * 100);
                if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee"))
                        || (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).name.Equals("none"))
                        || (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
                {
                    //do melee attack stuff and animations  
                    AnimationSequence newSeq = new AnimationSequence();
                    animationSeqStack.Add(newSeq);
                    doCombatAttack(pc);
                    //add hit or miss animation
                    //add floaty text
                    //add death animations
                    AnimationStackGroup newGroup = new AnimationStackGroup();
                    animationSeqStack[0].AnimationSeq.Add(newGroup);
                    foreach (Coordinate coor in deathAnimationLocations)
                    {
                        if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                        {
                            continue;
                        }
                        addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                    }
                    animationsOn = true;
                }
                else //Ranged Attack
                {
                    //play attack sound for ranged
                    gv.PlaySound(gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).itemOnUseSound);
                    //do ranged attack stuff and animations
                    //add projectile animation
                    int startX = getPixelLocX(pc.combatLocX);
                    int startY = getPixelLocY(pc.combatLocY);
                    int endX = getPixelLocX(targetHighlightCenterLocation.X);
                    int endY = getPixelLocY(targetHighlightCenterLocation.Y);
                    string filename = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).projectileSpriteFilename;
                    AnimationSequence newSeq = new AnimationSequence();
                    animationSeqStack.Add(newSeq);
                    AnimationStackGroup newGroup = new AnimationStackGroup();
                    newSeq.AnimationSeq.Add(newGroup);
                    launchProjectile(filename, startX, startY, endX, endY, newGroup);
                    //add ending projectile animation  
                    doCombatAttack(pc);
                    //add hit or miss animation
                    //add floaty text
                    //add death animations
                    newGroup = new AnimationStackGroup();
                    animationSeqStack[0].AnimationSeq.Add(newGroup);
                    foreach (Coordinate coor in deathAnimationLocations)
                    {
                        if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                        {
                            continue;
                        }
                        addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                    }
                    animationsOn = true;
                }
            }
        }
        public void TargetCastPressed(Player pc)
        {
            //if (isPlayerTurn)
            //{
            //CenterScreenOnPC();
            //}
            gv.mod.playerList[currentPlayerIndex].hasDelayedAlready = true;
            //Uses Map Pixel Locations
            int endX = targetHighlightCenterLocation.X * gv.squareSize + (gv.squareSize / 2);
            int endY = targetHighlightCenterLocation.Y * gv.squareSize + (gv.squareSize / 2);
            int startX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
            int startY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);

            if ((isValidCastTarget(pc)) && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
            {
                if ((targetHighlightCenterLocation.X < pc.combatLocX) && (!pc.combatFacingLeft)) //attack left
                {
                    pc.combatFacingLeft = true;
                }
                else if ((targetHighlightCenterLocation.X > pc.combatLocX) && (pc.combatFacingLeft)) //attack right
                {
                    pc.combatFacingLeft = false;
                }
                doPlayerCombatFacing(pc, targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y);
                gv.touchEnabled = false;
                creatureToAnimate.Clear();
                playerToAnimate = pc;
                //set attack animation and do a delay
                attackAnimationTimeElapsed = 0;
                attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)pc.token.PixelSize.Height / 100f) * 2* gv.mod.attackAnimationSpeed);
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)pc.token.PixelSize.Height / 100f) * 100);
                AnimationSequence newSeq = new AnimationSequence();
                animationSeqStack.Add(newSeq);
                //add projectile animation
                gv.PlaySound(gv.cc.currentSelectedSpell.spellStartSound);
                startX = getPixelLocX(pc.combatLocX);
                startY = getPixelLocY(pc.combatLocY);
                endX = getPixelLocX(targetHighlightCenterLocation.X);
                endY = getPixelLocY(targetHighlightCenterLocation.Y);
                string filename = gv.cc.currentSelectedSpell.spriteFilename;
                AnimationStackGroup newGroup = new AnimationStackGroup();
                newSeq.AnimationSeq.Add(newGroup);
                launchProjectile(filename, startX, startY, endX, endY, newGroup);
                //gv.PlaySound(gv.cc.currentSelectedSpell.spellEndSound);
                object target = getCastTarget(pc);
                //papagei
                if (gv.cc.currentSelectedSpell.onlyOncePerTurn)
                {
                    gv.mod.nonRepeatableFreeActionsUsedThisTurnBySpellTag.Add(gv.cc.currentSelectedSpell.tag);
                }
                if (gv.cc.currentSelectedSpell.isSwiftAction)
                {
                    gv.mod.swiftActionHasBeenUsedThisTurn = true;
                }
                if (gv.cc.currentSelectedSpell.coolDownTime > 0)
                {
                    pc.coolingSpellsByTag.Add(gv.cc.currentSelectedSpell.tag);
                    pc.coolDownTimes.Add(gv.cc.currentSelectedSpell.coolDownTime);
                }

                

                if (gv.cc.isTraitUsage)
                {
                    Trait thisTrait = null;
                    gv.cc.isTraitUsage = false;
                    string traitName = "";
                    foreach (Trait t in gv.mod.moduleTraitsList)
                    {
                        if (t.associatedSpellTag == gv.cc.currentSelectedSpell.tag)
                        {
                            thisTrait = t;
                            traitName = t.name;
                            break;
                        }
                    }
                    gv.cc.doSpellBasedOnScriptOrEffectTag(gv.cc.currentSelectedSpell, pc, target, false, true, traitName, thisTrait);
                }
                else
                {
                    gv.cc.doSpellBasedOnScriptOrEffectTag(gv.cc.currentSelectedSpell, pc, target, false, false, null);
                }
                //add ending projectile animation
                newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                filename = gv.cc.currentSelectedSpell.spriteEndingFilename;
                foreach (Coordinate coor in gv.sf.AoeSquaresList)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    addEndingAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)), filename);
                }
                //add floaty text
                //add death animations
                newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                foreach (Coordinate coor in deathAnimationLocations)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                }
                animationsOn = true;
                //if this is a trait that is meant to not consume a turn then set the flag 
                if (!gv.cc.currentSelectedSpell.usesTurnToActivate)
                {
                    continueTurn = true;
                    //currentCombatMode = "move";
                    //return;
                }
            }
            currentCombatMode = "info";
        }

        //overload for cast from item
        public void TargetCastPressed(Player pc, Item it)
        {
            //if (isPlayerTurn)
            //{
            //CenterScreenOnPC();
            //}

            //Uses Map Pixel Locations
            int endX = targetHighlightCenterLocation.X * gv.squareSize + (gv.squareSize / 2);
            int endY = targetHighlightCenterLocation.Y * gv.squareSize + (gv.squareSize / 2);
            int startX = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
            int startY = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);

            if ((isValidCastTarget(pc)) && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
            {
                if ((targetHighlightCenterLocation.X < pc.combatLocX) && (!pc.combatFacingLeft)) //attack left
                {
                    pc.combatFacingLeft = true;
                }
                else if ((targetHighlightCenterLocation.X > pc.combatLocX) && (pc.combatFacingLeft)) //attack right
                {
                    pc.combatFacingLeft = false;
                }
                doPlayerCombatFacing(pc, targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y);
                gv.touchEnabled = false;
                creatureToAnimate.Clear();
                playerToAnimate = pc;
                //set attack animation and do a delay
                attackAnimationTimeElapsed = 0;
                attackAnimationLengthInMilliseconds = (int)(5f * gv.mod.attackAnimationSpeed);
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)pc.token.PixelSize.Height / 100f) * 2* gv.mod.attackAnimationSpeed);
                //attackAnimationLengthInMilliseconds = (int)((5f * gv.mod.attackAnimationSpeed) + (-1 + (int)pc.token.PixelSize.Height / 100f) * 100);
                AnimationSequence newSeq = new AnimationSequence();
                animationSeqStack.Add(newSeq);
                //add projectile animation
                gv.PlaySound(gv.cc.currentSelectedSpell.spellStartSound);
                startX = getPixelLocX(pc.combatLocX);
                startY = getPixelLocY(pc.combatLocY);
                endX = getPixelLocX(targetHighlightCenterLocation.X);
                endY = getPixelLocY(targetHighlightCenterLocation.Y);
                string filename = gv.cc.currentSelectedSpell.spriteFilename;
                AnimationStackGroup newGroup = new AnimationStackGroup();
                newSeq.AnimationSeq.Add(newGroup);
                launchProjectile(filename, startX, startY, endX, endY, newGroup);
                //gv.PlaySound(gv.cc.currentSelectedSpell.spellEndSound);
                object target = new object();
                if (it.onScoringHitCastOnSelf)
                {
                    target = pc;
                }
                else
                {
                    target = getCastTarget(pc);
                }

                if (gv.cc.isTraitUsage)
                {
                    Trait thisTrait = null;
                    gv.cc.isTraitUsage = false;
                    string traitName = "";
                    foreach (Trait t in gv.mod.moduleTraitsList)
                    {
                        if (t.associatedSpellTag == gv.cc.currentSelectedSpell.tag)
                        {
                            thisTrait = t;
                            traitName = t.name;
                            break;
                        }
                    }
                    gv.cc.doSpellBasedOnScriptOrEffectTag(gv.cc.currentSelectedSpell, it, target, false, true, traitName, thisTrait);
                }
                else
                {
                    gv.cc.doSpellBasedOnScriptOrEffectTag(gv.cc.currentSelectedSpell, it, target, false, false, null);
                }

                //gv.cc.doSpellBasedOnScriptOrEffectTag(gv.cc.currentSelectedSpell, it, target, false, false);
                //add ending projectile animation
                newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                filename = gv.cc.currentSelectedSpell.spriteEndingFilename;
                foreach (Coordinate coor in gv.sf.AoeSquaresList)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    addEndingAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)), filename);
                }
                //add floaty text
                //add death animations
                newGroup = new AnimationStackGroup();
                animationSeqStack[0].AnimationSeq.Add(newGroup);
                foreach (Coordinate coor in deathAnimationLocations)
                {
                    if (!IsInVisibleCombatWindow(coor.X, coor.Y))
                    {
                        continue;
                    }
                    addDeathAnimation(newGroup, new Coordinate(getPixelLocX(coor.X), getPixelLocY(coor.Y)));
                }
                animationsOn = true;
                //if this is a trait that is meant to not consume a turn then set the flag 
                if (!gv.cc.currentSelectedSpell.usesTurnToActivate)
                {
                    continueTurn = true;
                    //currentCombatMode = "move";
                    //return;
                }
            }
            currentCombatMode = "info";
        }

        public void launchProjectile(string filename, int startX, int startY, int endX, int endY, AnimationStackGroup group)
        {
            //calculate angle from start to end point
            float angle = AngleRad(new Point(startX, startY), new Point(endX, endY));
            float dX = (endX - startX);
            float dY = (endY - startY);
            //calculate needed TimeToLive based on a constant speed for projectiles
            int ttl = 1000;
            float speed = 2f; //small number is faster travel speed
            if (Math.Abs(dX) > Math.Abs(dY))
            {
                ttl = (int)(Math.Abs(dX) * speed);
            }
            else
            {
                ttl = (int)(Math.Abs(dY) * speed);
            }
            SharpDX.Vector2 vel = SharpDX.Vector2.Normalize(new SharpDX.Vector2(dX, dY));
            Sprite spr = new Sprite(gv, filename, startX, startY, vel.X / speed, vel.Y / speed, angle, 0, 1.0f, ttl, false, 100);
            group.SpriteGroup.Add(spr);
        }
        public void addHitAnimation(AnimationStackGroup group)
        {
            if (gv.mod.useManualCombatCam)
            {
                gv.touchEnabled = false;
            }
            int ttl = 8 * gv.mod.attackAnimationSpeed;
            Sprite spr = new Sprite(gv, "hit_symbol", hitAnimationLocation.X, hitAnimationLocation.Y, 0, 0, 0, 0, 1.0f, ttl, false, ttl / 4);
            group.turnFloatyTextOn = true;
            group.SpriteGroup.Add(spr);
        }
        public void addMissAnimation(AnimationStackGroup group)
        {
            if (gv.mod.useManualCombatCam)
            {
                gv.touchEnabled = false;
            }
            int ttl = 8 * gv.mod.attackAnimationSpeed;
            Sprite spr = new Sprite(gv, "miss_symbol", hitAnimationLocation.X, hitAnimationLocation.Y, 0, 0, 0, 0, 1.0f, ttl, false, ttl / 4);
            group.SpriteGroup.Add(spr);
        }
        public void addDeathAnimation(AnimationStackGroup group, Coordinate Loc)
        {
            if (gv.mod.useManualCombatCam)
            {
                gv.touchEnabled = false;
            }
            int ttl = 16 * gv.mod.attackAnimationSpeed;
            Sprite spr = new Sprite(gv, "death_fx", Loc.X, Loc.Y, 0, 0, 0, 0, 1.0f, ttl, false, ttl / 4);
            group.SpriteGroup.Add(spr);
        }
        public void addEndingAnimation(AnimationStackGroup group, Coordinate Loc, string filename)
        {
            if (gv.mod.useManualCombatCam)
            {
                gv.touchEnabled = false;
            }

            int ttl = 16 * gv.mod.attackAnimationSpeed;
            if (gv.mod.useManualCombatCam)
            {
                ttl = 8 * gv.mod.attackAnimationSpeed;
            }

            Sprite spr = new Sprite(gv, filename, Loc.X, Loc.Y, 0, 0, 0, 0, 1.0f, ttl, false, ttl / 4);
            group.turnFloatyTextOn = true;
            group.SpriteGroup.Add(spr);
        }
        public float AngleRad(Point start, Point end)
        {
            return (float)(-1 * ((Math.Atan2(start.Y - end.Y, end.X - start.X)) - (Math.PI) / 2));
        }

        //Helper Methods
        //projectcombatscrollling
        public void showActorInfoRightHold(Object actor)
        {
            /*
            if (!gv.cc.showingEffects)
            {
                gv.cc.showingEffects = true;
            }
            else
            {
                gv.cc.showingEffects = false;
            }
            */
            if (actor is Player)
            {
                gv.cc.inEffectMode = true;
                //gv.cc.showingEffects = true;
                /*
                showHP = false;
                showSP = false;
                showMoveOrder = false;
                

                Player pc = (Player)(actor);
                string am = "";
                ItemRefs itr = gv.mod.getItemRefsInInventoryByResRef(pc.AmmoRefs.resref);
                if (itr != null)
                {
                    am = itr.quantity + "";
                }
                else
                {
                    am = "";
                }

                //drawText(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY) - (int)gv.drawFontRegHeight, pc.name, Color.Lime);
                int mo = pc.moveOrder + 1;

                gv.cc.floatyText0 = pc.name; 
                //gv.cc.floatyText = "Ini " + mo.ToString();
                int actext = 0;
                if (gv.mod.ArmorClassAscending) { actext = pc.AC; }
                else { actext = 20 - pc.AC; }
                gv.cc.floatyText = "AC " + actext;
                gv.cc.floatyText2 = "HP: " + pc.hp + "/" + pc.hpMax;
                gv.cc.floatyText3 = "SP: " + pc.sp + "/" + pc.spMax;
                gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(pc.combatLocX), getPixelLocY(pc.combatLocY));
                */
                //showHP = true;
                //showSP = true;
                //showMoveOrder = true;
                Player pc = (Player)(actor);
                //gv.cc.floatyTextActorInfoName = pc.name;
                string effectsText = "";
                foreach (Effect ef in pc.effectsList)
                {
                    effectsText += ef.name;
                }
                gv.cc.floatyTextActorInfoTempEffects1 = effectsText;

                if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                {
                    gv.cc.floatyTextActorInfoTempEffects1 = "No temporary effects";
                }

                gv.cc.floatyTextActorInfoText = "";
                gv.cc.floatyTextActorInfoWorksFor = "";
                gv.cc.floatyTextActorInfoEnableTrait = "";
                gv.cc.floatyTextActorInfoEnabledState = "";
                gv.cc.floatyTextActorInfoEnableDC = "";
                gv.cc.floatyTextActorInfoDisableTrait = "";
                gv.cc.floatyTextActorInfoDisableDC = "";
                gv.cc.floatyTextActorInfoCharges = "";
                gv.cc.floatyTextActorInfoEveryStep = "";

                gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
                gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
                gv.cc.floatyTextActorInfoLingeringEffectPower = "";

                gv.cc.floatyTextActorInfoVanishInXTurns = "";
                gv.cc.floatyTextActorInfoAppearInXTurns = "";
                gv.cc.floatyTextActorInfoChangeWalkableState = "";

        //hide the normal info when efects are shown
        gv.cc.floatyTextActorInfoMoveOrder = "";
                gv.cc.floatyTextActorInfoInitiative = "";
                gv.cc.floatyTextActorInfoAC = "";
                gv.cc.floatyTextActorInfoMovementRange = "";
                gv.cc.floatyTextActorInfoHP = "";
                gv.cc.floatyTextActorInfoSP = "";
                gv.cc.floatyTextActorInfoToHit = "";
                gv.cc.floatyTextActorInfoNumberOfAttacks = "";
                gv.cc.floatyTextActorInfoWeaponTags = "";
                gv.cc.floatyTextActorInfoOnScoringHitSpellName = "";
                gv.cc.floatyTextActorInfoOnScoringHitSpellNameSelf = "";
                gv.cc.floatyTextActorInfoAttackRange = "";
                gv.cc.floatyTextActorInfoAttackType = "";
                gv.cc.floatyTextActorInfoDamage = "";
                gv.cc.floatyTextActorInfoSaves = "";
                gv.cc.floatyTextActorInfoSaves2 = "";
                gv.cc.floatyTextActorInfoSaves3 = "";
                gv.cc.floatyTextActorInfoDamageType = "";
                gv.cc.floatyTextActorInfoAmmo = "";
                gv.cc.floatyTextActorInfoResistances1 = "";
                gv.cc.floatyTextActorInfoResistances2 = "";
                gv.cc.floatyTextActorInfoResistances3 = "";
                gv.cc.floatyTextActorInfoResistances4 = "";
                gv.cc.floatyTextActorInfoResistances5 = "";
                gv.cc.floatyTextActorInfoResistances6 = "";
                gv.cc.floatyTextActorInfoResistances7 = "";

                gv.cc.floatyTextActorInfoRegenerationHP = "";
                gv.cc.floatyTextActorInfoRegenerationSP = "";
                gv.cc.floatyTextActorInfoSpellsKnown1 = "";
                gv.cc.floatyTextActorInfoSpellsKnown2 = "";
                gv.cc.floatyTextActorInfoSpellsKnown3 = "";
                gv.cc.floatyTextActorInfoAIType = "";
                gv.cc.floatyTextActorInfoAIAffinityForCasting = "";//0 to 100
                gv.cc.floatyTextActorInfoInjuryThreshold = "";
                gv.cc.floatyTextActorInfoCreatureTags = "";//used for immunities, special weaknesses, eg "undead" are affected by turn spells and immunne to paralyze...
                gv.cc.floatyTextActorInfoHitBy = "";
                gv.cc.floatyTextActorInfoOnDeathScriptName = "";
                gv.cc.floatyTextActorInfoRMB1 = "";
                gv.cc.floatyTextActorInfoRMB2 = "";

                gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
                gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
                gv.cc.floatyTextActorInfoLingeringEffectPower = "";

                gv.cc.floatyTextActorInfoText = "";
                gv.cc.floatyTextActorInfoWorksFor = "";
                gv.cc.floatyTextActorInfoEnableTrait = "";
                gv.cc.floatyTextActorInfoEnabledState = "";
                gv.cc.floatyTextActorInfoEnableDC = "";
                gv.cc.floatyTextActorInfoDisableTrait = "";
                gv.cc.floatyTextActorInfoDisableDC = "";
                gv.cc.floatyTextActorInfoCharges = "";
                gv.cc.floatyTextActorInfoEveryStep = "";
                gv.cc.floatyTextActorInfoSpellName = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                gv.cc.floatyTextActorInfoSpellName2 = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare2 = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel2 = "";
                gv.cc.floatyTextActorInfoSpellName3 = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare3 = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel3 = "";

                gv.cc.floatyTextActorInfoVanishInXTurns = "";
                gv.cc.floatyTextActorInfoAppearInXTurns = "";
                gv.cc.floatyTextActorInfoChangeWalkableState = "";



                int counter = 0;
                foreach (Effect ef in pc.effectsList)
                {
                    counter++;
                    if (counter == 1)
                    {
                        gv.cc.floatyTextActorInfoTempEffects1 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects1custom = ef.description;
                    }
                    if (counter == 2)
                    {
                        gv.cc.floatyTextActorInfoTempEffects2 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects2custom = ef.description;
                    }
                    if (counter == 3)
                    {
                        gv.cc.floatyTextActorInfoTempEffects3 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects3custom = ef.description;
                    }
                    if (counter == 4)
                    {
                        gv.cc.floatyTextActorInfoTempEffects4 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects4custom = ef.description;
                    }
                    if (counter == 5)
                    {
                        gv.cc.floatyTextActorInfoTempEffects5 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects5custom = ef.description;
                    }
                    if (counter == 6)
                    {
                        gv.cc.floatyTextActorInfoTempEffects6 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects6custom = ef.description;
                    }
                    if (counter == 7)
                    {
                        gv.cc.floatyTextActorInfoTempEffects7 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects7custom = ef.description;
                    }
                    if (counter == 8)
                    {
                        gv.cc.floatyTextActorInfoTempEffects8 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects8custom = ef.description;
                    }
                    if (counter == 9)
                    {
                        gv.cc.floatyTextActorInfoTempEffects9 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects9custom = ef.description;
                    }
                    if (counter == 10)
                    {
                        gv.cc.floatyTextActorInfoTempEffects10 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects10custom = ef.description;
                    }
                }

                if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                {
                    gv.cc.floatyTextActorInfoTempEffects1 = "No temporary effects";
                }
            }

        
            else if (actor is Creature)
            {
                gv.cc.inEffectMode = true; 
                //gv.cc.showingEffects = true;
                /*
                showHP = false;
                showSP = false;
                showMoveOrder = false;
                Creature crt = (Creature)(actor);
                gv.cc.floatyText0 = crt.cr_name;
                //gv.cc.floatyText = "Ini " + mo.ToString();
                int actext = 0;
                if (gv.mod.ArmorClassAscending) { actext = crt.getAc(); }
                else { actext = 20 - crt.getAc(); }
                gv.cc.floatyText = "AC " + actext;
                int maxHP = crt.hpMax + crt.getMaxHPModifier();
                gv.cc.floatyText2 = "HP: " + crt.hp + "/" + maxHP;
                gv.cc.floatyText3 = "SP: " + crt.sp + "/" + crt.spMax;
                gv.cc.floatyTextLoc = new Coordinate(getPixelLocX(crt.combatLocX), getPixelLocY(crt.combatLocY));
                */

                //only for right clikc (effects)
                //showHP = true;
                //showSP = true;
                //showMoveOrder = true;
                Creature crt = (Creature)(actor);
                //gv.cc.floatyTextActorInfoName = crt.cr_name;


                gv.cc.floatyTextActorInfoText = "";
                gv.cc.floatyTextActorInfoWorksFor = "";
                gv.cc.floatyTextActorInfoEnableTrait = "";
                gv.cc.floatyTextActorInfoEnabledState = "";
                gv.cc.floatyTextActorInfoEnableDC = "";
                gv.cc.floatyTextActorInfoDisableTrait = "";
                gv.cc.floatyTextActorInfoDisableDC = "";
                gv.cc.floatyTextActorInfoCharges = "";
                gv.cc.floatyTextActorInfoEveryStep = "";

                gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
                gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
                gv.cc.floatyTextActorInfoLingeringEffectPower = "";

                gv.cc.floatyTextActorInfoVanishInXTurns = "";
                gv.cc.floatyTextActorInfoAppearInXTurns = "";
                gv.cc.floatyTextActorInfoChangeWalkableState = "";

                gv.cc.floatyTextActorInfoMoveOrder = "";
                gv.cc.floatyTextActorInfoInitiative = "";
                gv.cc.floatyTextActorInfoAC = "";
                gv.cc.floatyTextActorInfoMovementRange = "";
                gv.cc.floatyTextActorInfoHP = "";
                gv.cc.floatyTextActorInfoSP = "";
                gv.cc.floatyTextActorInfoToHit = "";
                gv.cc.floatyTextActorInfoWeaponTags = "";
                gv.cc.floatyTextActorInfoNumberOfAttacks = "";
                gv.cc.floatyTextActorInfoAmmo = "";
                gv.cc.floatyTextActorInfoOnScoringHitSpellName = "";
                gv.cc.floatyTextActorInfoOnScoringHitSpellNameSelf = "";
                gv.cc.floatyTextActorInfoAttackRange = "";
                gv.cc.floatyTextActorInfoAttackType = "";
                gv.cc.floatyTextActorInfoDamage = "";
                gv.cc.floatyTextActorInfoSaves = "";
                gv.cc.floatyTextActorInfoSaves2 = "";
                gv.cc.floatyTextActorInfoSaves3 = "";
                gv.cc.floatyTextActorInfoDamageType = "";
                gv.cc.floatyTextActorInfoResistances1 = "";
                gv.cc.floatyTextActorInfoResistances2 = "";
                gv.cc.floatyTextActorInfoResistances3 = "";
                gv.cc.floatyTextActorInfoResistances4 = "";
                gv.cc.floatyTextActorInfoResistances5 = "";
                gv.cc.floatyTextActorInfoResistances6 = "";
                gv.cc.floatyTextActorInfoResistances7 = "";
                gv.cc.floatyTextActorInfoRegenerationHP = "";
                gv.cc.floatyTextActorInfoRegenerationSP = "";
                gv.cc.floatyTextActorInfoSpellsKnown1 = "";
                gv.cc.floatyTextActorInfoSpellsKnown2 = "";
                gv.cc.floatyTextActorInfoSpellsKnown3 = "";
                gv.cc.floatyTextActorInfoAIType = "";
                gv.cc.floatyTextActorInfoAIAffinityForCasting = "";//0 to 100
                gv.cc.floatyTextActorInfoInjuryThreshold = "";
                gv.cc.floatyTextActorInfoCreatureTags = "";//used for immunities, special weaknesses, eg "undead" are affected by turn spells and immunne to paralyze...
                gv.cc.floatyTextActorInfoHitBy = "";
                gv.cc.floatyTextActorInfoOnDeathScriptName = "";
                gv.cc.floatyTextActorInfoRMB1 = "";
                gv.cc.floatyTextActorInfoRMB2 = "";

                gv.cc.floatyTextActorInfoText = "";
                gv.cc.floatyTextActorInfoWorksFor = "";
                gv.cc.floatyTextActorInfoEnableTrait = "";
                gv.cc.floatyTextActorInfoEnabledState = "";
                gv.cc.floatyTextActorInfoEnableDC = "";

                gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
                gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
                gv.cc.floatyTextActorInfoLingeringEffectPower = "";

                gv.cc.floatyTextActorInfoVanishInXTurns = "";
                gv.cc.floatyTextActorInfoAppearInXTurns = "";
                gv.cc.floatyTextActorInfoChangeWalkableState = "";
                gv.cc.floatyTextActorInfoDisableTrait = "";
                gv.cc.floatyTextActorInfoDisableDC = "";
                gv.cc.floatyTextActorInfoCharges = "";
                gv.cc.floatyTextActorInfoEveryStep = "";
                gv.cc.floatyTextActorInfoSpellName = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                gv.cc.floatyTextActorInfoSpellName2 = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare2 = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel2 = "";
                gv.cc.floatyTextActorInfoSpellName3 = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare3 = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel3 = "";


                //string effectsText = "";
                int counter = 0;
                foreach (Effect ef in crt.cr_effectsList)
                {
                    counter++;
                    if (counter == 1)
                    {
                        gv.cc.floatyTextActorInfoTempEffects1 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects1custom = ef.description;
                    }
                    if (counter == 2)
                    {
                        gv.cc.floatyTextActorInfoTempEffects2 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects2custom = ef.description;
                    }
                    if (counter == 3)
                    {
                        gv.cc.floatyTextActorInfoTempEffects3 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects3custom = ef.description;
                    }
                    if (counter == 4)
                    {
                        gv.cc.floatyTextActorInfoTempEffects4 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects4custom = ef.description;
                    }
                    if (counter == 5)
                    {
                        gv.cc.floatyTextActorInfoTempEffects5 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects5custom = ef.description;
                    }
                    if (counter == 6)
                    {
                        gv.cc.floatyTextActorInfoTempEffects6 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects6custom = ef.description;
                    }
                    if (counter == 7)
                    {
                        gv.cc.floatyTextActorInfoTempEffects7 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects7custom = ef.description;
                    }
                    if (counter == 8)
                    {
                        gv.cc.floatyTextActorInfoTempEffects8 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects8custom = ef.description;
                    }
                    if (counter == 9)
                    {
                        gv.cc.floatyTextActorInfoTempEffects9 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects9custom = ef.description;
                    }
                    if (counter == 10)
                    {
                        gv.cc.floatyTextActorInfoTempEffects10 = ef.name + " (" + (ef.durationInUnits / gv.mod.TimePerRound) + ")";
                        gv.cc.floatyTextActorInfoTempEffects10custom = ef.description;
                    }        
                }
         
                if (gv.cc.floatyTextActorInfoTempEffects1 == "")
                {
                    gv.cc.floatyTextActorInfoTempEffects1 = "No temporary effects";
                }
            }
           
        }


        public void showActorInfo(Object actor)
        {
            if (actor is Player)
            {
                //showHP = true;
                //showSP = true;
                //showMoveOrder = true;
                Player pc = (Player)(actor);
                gv.cc.floatyTextActorInfoName = pc.name;
                //(pc.dexterity - 10) / 2) *5
                gv.cc.floatyTextActorInfoMoveOrder = "Ord. " + (pc.moveOrder+1);
                gv.cc.floatyTextActorInfoInitiative = "Ini " + ((pc.dexterity - 10) / 2) * 5;
                gv.cc.floatyTextActorInfoAC = "AC " + pc.AC;
                gv.cc.floatyTextActorInfoMovementRange = "Moves " + pc.moveDistance;
                gv.cc.floatyTextActorInfoHP = "HP " + pc.hp + "/" + pc.hpMax;
                gv.cc.floatyTextActorInfoSP = "SP " + pc.sp + "/" + pc.spMax;

                int numAtt = 1;
                numAtt = gv.sf.CalcNumberOfAttacks(pc);
                if (numAtt < 1)
                {
                    numAtt = 1;
                }
                int attackMod = 0;
                int modifier = 0;
                
                if (gv.sf.isMeleeAttack(pc))
                { 
                    modifier = gv.sf.CalcPcMeleeAttackAttributeModifier(pc, true);
                }
                else //ranged weapon used
                {
                    modifier = (pc.dexterity - 10) / 2;

                    int preciseShotAdder = 0;
                    preciseShotAdder = gv.sf.CalcPcRangedAttackModifier(pc);
                    if (preciseShotAdder > 0)
                    {
                        modifier += preciseShotAdder;
                    }

                    if (gv.sf.hasTrait(pc, "preciseshot2"))
                    {
                        modifier += 2;
                    }
                    else if (gv.sf.hasTrait(pc, "preciseshot"))
                    {
                        modifier++;
                    }
                    
                    Item it2 = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
                    if (it2 != null)
                    {
                        modifier += gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).attackBonus;
                    }
                }
                attackMod = modifier + pc.baseAttBonus + gv.sf.CalcAttackBonusesNoAmmo(pc, true);

                bool autoHit = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).automaticallyHitsTarget;

                int numberOfDiceRolled = 0;
                int typeOfDieRolled = 0;
                int dammodifier = 0;
                string damageType = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage;

                if (gv.sf.isMeleeAttack(pc))
                {
                    /*
                    dammodifier = (pc.strength - 10) / 2;
                    //if has critical strike trait use dexterity for damage modifier in melee if greater than strength modifier
                    if (gv.sf.hasTrait(pc, "criticalstrike"))
                    {
                        int dammodifierDex = (pc.dexterity - 10) / 4;
                        if (dammodifierDex > dammodifier)
                        {
                            dammodifier = (pc.dexterity - 10) / 2;
                        }
                    }
                    */
                    dammodifier = gv.sf.CalcPcMeleeDamageAttributeModifier(pc);
                }
                else //ranged weapon used
                {
                    dammodifier = 0;
                    int preciseShotAdder = 0;
                    preciseShotAdder = gv.sf.CalcPcRangedDamageModifier(pc);
                    if (preciseShotAdder > 0)
                    {
                        //dammodifier += 2;
                        dammodifier += preciseShotAdder;
                    }
                    else
                    {
                        if (gv.sf.hasTrait(pc, "preciseshot2"))
                        {
                            dammodifier += 2;
                        }
                        else if (gv.sf.hasTrait(pc, "preciseshot"))
                        {
                            dammodifier++;
                        }

                    }
                    Item it3 = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
                    if (it3 != null)
                    {
                        dammodifier += gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).damageAdder;
                        damageType = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage;
                    }

                }

                dammodifier += gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).damageAdder;
                numberOfDiceRolled = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).damageNumDice;
                typeOfDieRolled = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).damageDie;

                string am = "";
                ItemRefs itr = gv.mod.getItemRefsInInventoryByResRef(pc.AmmoRefs.resref);
                if (itr != null)
                {
                    am = itr.quantity + "";
                }
                else
                {
                    am = "";
                }
                string weaponTags = "";
                Item it = gv.mod.getItemByResRef(pc.MainHandRefs.resref);
                if (it != null)
                {
                    foreach (LocalImmunityString tag in it.entriesForPcTags)
                    {
                        weaponTags += tag.Value + ", ";
                    }
                }
                it = gv.mod.getItemByResRef(pc.OffHandRefs.resref);
                if (it != null)
                {
                    foreach (LocalImmunityString tag in it.entriesForPcTags)
                    {
                        weaponTags += tag.Value + ", ";
                    }
                }
                it = gv.mod.getItemByResRef(pc.AmmoRefs.resref);
                if (it != null)
                {
                    foreach (LocalImmunityString tag in it.entriesForPcTags)
                    {
                        weaponTags += tag.Value + ", ";
                    }
                }

                //if (weaponTags != "")
                //{
                    //weaponTags.Remove(2);
                //}

                if (weaponTags == "")
                {
                    weaponTags = "none";
                    gv.cc.floatyTextActorInfoWeaponTags = "Perks: " + weaponTags;
                }
                else
                {
                    gv.cc.floatyTextActorInfoWeaponTags = "Perks: " + weaponTags.Remove(weaponTags.Length -2);
                }
             


                gv.cc.floatyTextActorInfoNumberOfAttacks = "#A " + numAtt;

                if (autoHit)
                {
                    gv.cc.floatyTextActorInfoToHit = "Autohit";
                }
                else
                {
                    if (attackMod > 0)
                    {
                        gv.cc.floatyTextActorInfoToHit = "To hit +" + attackMod;
                    }
                    else if (attackMod <= 0)
                    {
                        gv.cc.floatyTextActorInfoToHit = "To hit " + attackMod;
                    }
                }
                if (am != "")
                {
                    gv.cc.floatyTextActorInfoAmmo = "Ammo " + am;
                }
                else
                {
                    gv.cc.floatyTextActorInfoAmmo = "";
                }
                if (dammodifier >= 0)
                {
                    if (dammodifier == 0)
                    {
                        gv.cc.floatyTextActorInfoDamage = "Damage " + numberOfDiceRolled + "d" + typeOfDieRolled;
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoDamage = "Damage " + numberOfDiceRolled + "d" + typeOfDieRolled + "+" + dammodifier;
                    }
                }
                else
                {
                    gv.cc.floatyTextActorInfoDamage = "Damage " + numberOfDiceRolled + "d" + typeOfDieRolled + dammodifier;
                }
                gv.cc.floatyTextActorInfoDamageType = damageType;

                if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged"))
                       && (!gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
                {
                    if (!gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).onScoringHitCastOnSelf)
                    {
                        if (gv.cc.floatyTextActorInfoOnScoringHitSpellName != "none")
                        {
                            gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit: " + gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).onScoringHitCastSpellTag;
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit: " + gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).onScoringHit;
                        }
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit self: " + gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).onScoringHitCastSpellTag;
                    }
                }
                else
                {
                    if (!gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).onScoringHitCastOnSelf)
                    {
                        if (gv.cc.floatyTextActorInfoOnScoringHitSpellName != "none")
                        {
                            gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit: " + gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).onScoringHitCastSpellTag;
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit: " + gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).onScoringHit;
                        }
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit self: " + gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).onScoringHitCastSpellTag;
                    }
                }
                //gv.cc.floatyTextActorInfoOnDeathScriptName
                //gv.cc.floatyTextActorInfoAttackRange = "";

                if (pc.fortitude < 0)
                {
                    gv.cc.floatyTextActorInfoSaves = "Fort " + pc.fortitude;
                }
                else
                {
                    gv.cc.floatyTextActorInfoSaves = "Fort " + "+" + pc.fortitude;
                }
                if (pc.reflex < 0)
                {
                    gv.cc.floatyTextActorInfoSaves2 = "Ref " + pc.reflex;
                }
                else
                {
                    gv.cc.floatyTextActorInfoSaves2 = "Ref " + "+" + pc.reflex;
                }
                if (pc.will < 0)
                {
                    gv.cc.floatyTextActorInfoSaves3 = "Will " + pc.will;
                }
                else
                {
                    gv.cc.floatyTextActorInfoSaves3 = "Will " + "+" + pc.will;
                }
                gv.cc.floatyTextActorInfoResistances1 = "N% " + pc.damageTypeResistanceTotalNormal;
                gv.cc.floatyTextActorInfoResistances2 = "M% " + pc.damageTypeResistanceTotalMagic;
                gv.cc.floatyTextActorInfoResistances3 = "P% " + pc.damageTypeResistanceTotalPoison;
                gv.cc.floatyTextActorInfoResistances4 = "F% " + pc.damageTypeResistanceTotalFire;
                gv.cc.floatyTextActorInfoResistances5 = "C% " + pc.damageTypeResistanceTotalCold;
                gv.cc.floatyTextActorInfoResistances6 = "A% " + pc.damageTypeResistanceTotalAcid;
                gv.cc.floatyTextActorInfoResistances7 = "E% " + pc.damageTypeResistanceTotalElectricity;
                gv.cc.floatyTextActorInfoAttackRange = "Range " + gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).attackRange;
                if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged")))
                {
                    gv.cc.floatyTextActorInfoAttackType = "Ranged";
                }
                else
                {
                    gv.cc.floatyTextActorInfoAttackType = "Melee";
                }
                gv.cc.floatyTextActorInfoRMB1 = "Press RMB to show current";
                gv.cc.floatyTextActorInfoRMB2 = "temporary effects";

                //To do: must set all creature exclusive innfo to "" here
                //public string floatyTextActorInfoFaction = "";
        gv.cc.floatyTextActorInfoRegenerationHP = "";
        gv.cc.floatyTextActorInfoRegenerationSP = "";
        gv.cc.floatyTextActorInfoSpellsKnown1 = "";
        gv.cc.floatyTextActorInfoSpellsKnown2 = "";
        gv.cc.floatyTextActorInfoSpellsKnown3 = "";
        gv.cc.floatyTextActorInfoAIType = "";
        gv.cc.floatyTextActorInfoAIAffinityForCasting = "";//0 to 100
                gv.cc.floatyTextActorInfoInjuryThreshold = "";
                gv.cc.floatyTextActorInfoCreatureTags = "";//used for immunities, special weaknesses, eg "undead" are affected by turn spells and immunne to paralyze...
                gv.cc.floatyTextActorInfoHitBy = "";
                gv.cc.floatyTextActorInfoOnDeathScriptName = "";

                gv.cc.floatyTextActorInfoText = "";
                gv.cc.floatyTextActorInfoWorksFor = "";
                gv.cc.floatyTextActorInfoEnableTrait = "";
                gv.cc.floatyTextActorInfoEnabledState = "";
                gv.cc.floatyTextActorInfoEnableDC = "";

                gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
                gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
                gv.cc.floatyTextActorInfoLingeringEffectPower = "";

                gv.cc.floatyTextActorInfoVanishInXTurns = "";
                gv.cc.floatyTextActorInfoAppearInXTurns = "";
                gv.cc.floatyTextActorInfoChangeWalkableState = "";
                gv.cc.floatyTextActorInfoDisableTrait = "";
                gv.cc.floatyTextActorInfoDisableDC = "";
                gv.cc.floatyTextActorInfoCharges = "";
                gv.cc.floatyTextActorInfoEveryStep = "";
                gv.cc.floatyTextActorInfoSpellName = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                gv.cc.floatyTextActorInfoSpellName2 = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare2 = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel2 = "";
                gv.cc.floatyTextActorInfoSpellName3 = "";//get via tag
                gv.cc.floatyTextActorInfoOnlyWhileOnSquare3 = "";
                gv.cc.floatyTextActorInfoOnlyCasterLevel3 = "";

            }
            else if (actor is Creature)
            {
                gv.cc.floatyTextActorInfoWeaponTags = "";
                //showHP = true;
                //showSP = true;
                //showMoveOrder = true;
                Creature crt = (Creature)(actor);
                gv.cc.floatyTextActorInfoName = crt.cr_name;
                gv.cc.floatyTextActorInfoAC = "AC " +crt.getAc();
                gv.cc.floatyTextActorInfoInitiative = "Ini " + crt.initiativeBonus;
                gv.cc.floatyTextActorInfoMoveOrder = "Ord. " + (crt.moveOrder+1);
                gv.cc.floatyTextActorInfoNumberOfAttacks = "#A " + crt.getNumberOfAttacks();
                if (crt.getAttackBonus() > 0)
                {
                    gv.cc.floatyTextActorInfoToHit = "To hit +" + crt.getAttackBonus();
                }
                else if (crt.getAttackBonus() <= 0)
                {
                    gv.cc.floatyTextActorInfoToHit = "To hit " + crt.getAttackBonus();
                }

                gv.cc.floatyTextActorInfoHP = "HP " + crt.hp + "/" + crt.hpMax;

                int spMax = 0;
                foreach (Creature crt2 in gv.mod.currentEncounter.encounterCreatureList)
                {
                    foreach (Creature crtOrg in gv.mod.moduleCreaturesList)
                    {
                        if (crt2.cr_resref == crtOrg.cr_resref)
                        {
                            spMax = crtOrg.sp;
                        }
                    }

                }
                gv.cc.floatyTextActorInfoSP = "SP " + crt.sp + "/" + spMax;
                gv.cc.floatyTextActorInfoAttackType = crt.cr_category;
                gv.cc.floatyTextActorInfoAttackRange = "Range " + crt.cr_attRange;
                if (crt.cr_damageAdder >= 0)
                {
                    if (crt.cr_damageAdder == 0)
                    {
                        gv.cc.floatyTextActorInfoDamage = "Damage " + crt.cr_damageNumDice + "d" + crt.cr_damageDie;
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoDamage = "Damage " + crt.cr_damageNumDice + "d" + crt.cr_damageDie + "+" + crt.cr_damageAdder;
                    }
                }
                else
                {
                    gv.cc.floatyTextActorInfoDamage = "Damage " + crt.cr_damageNumDice + "d" + crt.cr_damageDie + crt.cr_damageAdder;
                }
                gv.cc.floatyTextActorInfoDamageType = crt.cr_typeOfDamage;
                if (crt.onScoringHitCastSpellTag != "none" && crt.onScoringHitCastSpellTag != "")
                {
                    gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit: " + crt.onScoringHitCastSpellTag;
                }
                else
                {
                    gv.cc.floatyTextActorInfoOnScoringHitSpellName = "On hit: " + crt.onScoringHit;
                }


                if (crt.getFortitude() < 0)
                {
                    gv.cc.floatyTextActorInfoSaves = "Fort " + crt.getFortitude();
                }
                else
                {
                    gv.cc.floatyTextActorInfoSaves = "Fort " + "+" + crt.getFortitude();
                }
                if (crt.getReflex() < 0)
                {
                    gv.cc.floatyTextActorInfoSaves2 = "Ref " + crt.getReflex();
                }
                else
                {
                    gv.cc.floatyTextActorInfoSaves2 = "Ref " + "+" + crt.getReflex();
                }
                if (crt.getWill() < 0)
                {
                    gv.cc.floatyTextActorInfoSaves3 = "Will " + crt.getWill();
                }
                else
                {
                    gv.cc.floatyTextActorInfoSaves3 = "Will " + "+" + crt.getWill();
                }
                gv.cc.floatyTextActorInfoResistances1 = "N% " + crt.getDamageTypeResistanceValueNormal();
                gv.cc.floatyTextActorInfoResistances2 = "M% " + crt.getDamageTypeResistanceValueMagic();
                gv.cc.floatyTextActorInfoResistances3 = "P% " + crt.getDamageTypeResistanceValuePoison();
                gv.cc.floatyTextActorInfoResistances4 = "F% " + crt.getDamageTypeResistanceValueFire();
                gv.cc.floatyTextActorInfoResistances5 = "C% " + crt.getDamageTypeResistanceValueCold();
                gv.cc.floatyTextActorInfoResistances6 = "A% " + crt.getDamageTypeResistanceValueAcid();
                gv.cc.floatyTextActorInfoResistances7 = "E% " + crt.getDamageTypeResistanceValueElectricity();

                //CreatureTypeTags: Undead, Lycan, Animal, etc. (efefcts use these),alreday i via local ints
                //CreatureREquiredWeaponTypes: Silver, lesserMagic, greaterMagic, dragonGlass/Obsidian, Holy, Unholy, to do on cretaures and items

                gv.cc.floatyTextActorInfoRegenerationHP = "HPReg " + crt.hpRegenerationPerRound;
                gv.cc.floatyTextActorInfoRegenerationSP = "SPReg " + crt.spRegenerationPerRound;
                gv.cc.floatyTextActorInfoSpellsKnown1 = "";
                gv.cc.floatyTextActorInfoSpellsKnown2 = "";
                gv.cc.floatyTextActorInfoSpellsKnown3 = "";
                int counter = 0;
                foreach (String spell in crt.knownSpellsTags)
                {
                    counter++;
                    string spellName = "";
                    foreach (Spell sp in gv.mod.moduleSpellsList)
                    {
                        if (sp.tag == spell)
                        {
                            spellName = sp.name;
                            break;
                        }
                    }
                    if (counter == 1)
                    {
                        gv.cc.floatyTextActorInfoSpellsKnown1 += spellName + ", ";
                    }
                    if (counter == 2)
                    {
                        gv.cc.floatyTextActorInfoSpellsKnown1 += spellName;
                    }
                    if (counter == 3)
                    {
                        gv.cc.floatyTextActorInfoSpellsKnown2 += spellName + ", ";
                    }
                    if (counter == 4)
                    {
                        gv.cc.floatyTextActorInfoSpellsKnown2 += spellName;
                    }
                    if (counter == 5)
                    {
                        gv.cc.floatyTextActorInfoSpellsKnown3 += spellName + ", ";
                    }
                    if (counter == 6)
                    {
                        gv.cc.floatyTextActorInfoSpellsKnown3 += spellName;
                    }
                    if (counter >= 7)
                    {
                        break;
                    }
                }

                if (crt.cr_ai == "BasicAttacker")
                {
                    gv.cc.floatyTextActorInfoAIType = "AI Type: " + "Straight forward";
                }
                if (crt.cr_ai == "GeneralCaster")
                {
                    gv.cc.floatyTextActorInfoAIType = "AI Type: " + "Caster";
                }
                if (crt.cr_ai == "bloodHunter")
                {
                    gv.cc.floatyTextActorInfoAIType = "AI Type: " + "Preys on the weak";
                }
                if (crt.cr_ai == "mindHunter")
                {
                    gv.cc.floatyTextActorInfoAIType = "AI Type: " + "Attracted by energy";
                }
                if (crt.cr_ai == "softTargetHunter")
                {
                    gv.cc.floatyTextActorInfoAIType = "AI Type: " + "Goes for soft targets";
                }

                if (crt.cr_ai == "GeneralCaster")
                {
                    gv.cc.floatyTextActorInfoAIAffinityForCasting = "Cast% " + crt.percentChanceToCastSpell; //0 to 100
                }
                else
                {
                    gv.cc.floatyTextActorInfoAIAffinityForCasting = "Cast% " + 0;
                }

                if (crt.cr_ai == "GeneralCaster")
                {
                    gv.cc.floatyTextActorInfoInjuryThreshold = "Loss threshold " + crt.percentRequirementOfTargetInjuryForHealSpells + "%";
                }
                else
                {
                    gv.cc.floatyTextActorInfoInjuryThreshold = "";
                }

                counter = 0;
                gv.cc.floatyTextActorInfoHitBy = "Hit by: ";
                foreach (LocalString lis in crt.requiredWeaponTypesToHarmCreature)
                {
                    counter++;
                    if (counter == 1)
                    {
                        if (crt.requiredWeaponTypesToHarmCreature.Count() == 1)
                        {
                            gv.cc.floatyTextActorInfoHitBy += lis.Value;
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoHitBy += lis.Value + ", ";
                        }
                    }
                    if (counter == 2)
                    {
                        if (crt.requiredWeaponTypesToHarmCreature.Count() == 2)
                        {
                            gv.cc.floatyTextActorInfoHitBy += lis.Value;
                        }
                        else  
                        {
                            gv.cc.floatyTextActorInfoHitBy += lis.Value + ", ";
                        }
                    }
                    if (counter == 3)
                    {
                        gv.cc.floatyTextActorInfoHitBy += lis.Value;
                    }
                    if (counter >= 4)
                    {
                        break;
                    }
                }
                if (crt.requiredWeaponTypesToHarmCreature.Count() == 0)
                {
                    gv.cc.floatyTextActorInfoHitBy = "Hit by: all";
                }
                /*
                if (crt.requiredWeaponTypesToHarmCreature.Count() == 1 || crt.requiredWeaponTypesToHarmCreature.Count() == 2)
                {
                    //gv.cc.floatyTextActorInfoHitBy.Remove(gv.cc.floatyTextActorInfoHitBy.Length-10, 3);
                }
                */

                counter = 0;
                gv.cc.floatyTextActorInfoCreatureTags = "Type: ";
                foreach (LocalString tag in crt.CreatureLocalStrings)
                {
                    counter++;
                    if (counter == 1)
                    {
                        if (crt.CreatureLocalStrings.Count() == 1)
                        {
                            gv.cc.floatyTextActorInfoCreatureTags += tag.Value;
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoCreatureTags += tag.Value + ", ";
                        }
                    }
                    if (counter == 2)
                    {
                        if (crt.CreatureLocalStrings.Count() == 2)
                        {
                            gv.cc.floatyTextActorInfoCreatureTags += tag.Value;
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoCreatureTags += tag.Value + ", ";
                        }
                    }
                    if (counter == 3)
                    {
                        gv.cc.floatyTextActorInfoCreatureTags += tag.Value;
                    }
                    if (counter >= 4)
                    {
                        break;
                    }
                }
                if (crt.CreatureLocalStrings.Count == 0)
                {
                    gv.cc.floatyTextActorInfoCreatureTags += "Standard";
                }
                //gv.cc.floatyTextActorInfoCreatureTags = "";//used for immunities, special weaknesses, eg "undead" are affected by turn spells and immunne to paralyze...

                gv.cc.floatyTextActorInfoOnDeathScriptName = "On death: " + crt.onDeathIBScript;

                gv.cc.floatyTextActorInfoRMB1 = "Press RMB to show current";
                gv.cc.floatyTextActorInfoRMB2 = "temporary effects";
            }
            else if (actor is Trigger)
            {
                Trigger trg = (Trigger)(actor);
                if (!trg.chkTrigHidden)
                {
                    gv.cc.floatyTextActorInfoName = "Trigger Square";

                    if (trg.mouseOverText == "none")
                    {
                        gv.cc.floatyTextActorInfoText = "Triggers event(s) described below";
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoText = trg.mouseOverText;
                    }
                    if (trg.Enabled)
                    {
                        gv.cc.floatyTextActorInfoEnabledState = "Enabled";
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoEnabledState = "Disabled";
                    }
                    
                    if (trg.txtTrigEnablingTraitTag != "" && trg.txtTrigEnablingTraitTag != "none" && trg.txtTrigEnablingTraitTag != "None" && trg.txtTrigEnablingTraitTag != null)
                    {
                        //enable info
                        string traitName = "";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(trg.txtTrigEnablingTraitTag))
                            {
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        if (trg.Enabled == false)
                        {
                            gv.cc.floatyTextActorInfoEnableTrait = "Use " + traitName + " to enable";
                            gv.cc.floatyTextActorInfoEnableDC = "Roll for DC " + trg.txtTrigEnablingDC;
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoDisableTrait = "No trait/spell usage needed";
                            gv.cc.floatyTextActorInfoDisableDC = "Has been enabled";
                        }
                    }
                    else
                    {
                        if (trg.txtTrigDisablingTraitTag != "" && trg.txtTrigDisablingTraitTag != "none" && trg.txtTrigDisablingTraitTag != "None" && trg.txtTrigDisablingTraitTag != null)
                        {
                            //disable info
                            string traitName = "";
                            foreach (Trait t in gv.mod.moduleTraitsList)
                            {
                                if (t.tag.Contains(trg.txtTrigDisablingTraitTag))
                                {
                                    traitName = t.nameOfTraitGroup;
                                }
                            }
                            if (trg.Enabled == true)
                            {
                                gv.cc.floatyTextActorInfoDisableTrait = "Use " + traitName + " to disable";
                                gv.cc.floatyTextActorInfoDisableDC = "Roll for DC " + trg.txtTrigDisablingDC;
                            }
                            else
                            {
                                gv.cc.floatyTextActorInfoDisableTrait = "No trait/spell usage needed";
                                gv.cc.floatyTextActorInfoDisableDC = "Has been disabled";
                            }
                        }
                        else
                        {
                            //neutral info
                            gv.cc.floatyTextActorInfoDisableTrait = "No trait/spell usage needed";
                            gv.cc.floatyTextActorInfoDisableDC = "Cannot be disabled";
                        }
                    }

                    if (trg.canBeTriggeredByPc && trg.canBeTriggeredByCreature)
                    {
                        if (trg.Event1Type == "container")
                        {
                            gv.cc.floatyTextActorInfoWorksFor = "Applies to: players";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoWorksFor = "Applies to: players and creatures";
                        }
                    }
                    if (!trg.canBeTriggeredByPc && trg.canBeTriggeredByCreature)
                    {
                        if (trg.Event1Type == "container")
                        {
                            gv.cc.floatyTextActorInfoWorksFor = "Applies to: players";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoWorksFor = "Applies to: creatures";
                        }
                    }
                    if (trg.canBeTriggeredByPc && !trg.canBeTriggeredByCreature)
                    {
                        gv.cc.floatyTextActorInfoWorksFor = "Applies to: players";
                    }
                    if ((trg.numberOfScriptCallsRemaining == -1 || trg.numberOfScriptCallsRemaining > 100) && gv.cc.floatyTextActorInfoCharges != "Charges: depleted")
                    {
                        gv.cc.floatyTextActorInfoCharges = "Charges: unlimited";
                    }
                    else if (trg.numberOfScriptCallsRemaining <= 0)
                    {
                        gv.cc.floatyTextActorInfoCharges = "Charges: depleted";
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoCharges = "Charges: " + trg.numberOfScriptCallsRemaining.ToString();
                    }

                    if (trg.encounterTriggerOnEveryStep)
                    {
                        if (trg.Event1Type == "container")
                        {
                            gv.cc.floatyTextActorInfoEveryStep = "Multiple times a turn each actor";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoEveryStep = "Only once a turn each actor";
                        }
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoEveryStep = "Multiple times a turn each actor";
                    }

                    if (trg.vanishInXTurns != null && trg.vanishInXTurns != "" && trg.vanishInXTurns != "none" && trg.vanishInXTurns != "None")
                    {
                        if (Convert.ToInt32(trg.vanishInXTurns) - trg.vanishCounter < 0)
                        {
                            gv.cc.floatyTextActorInfoVanishInXTurns = "Has vanished";
                        }
                        else if (Convert.ToInt32(trg.vanishInXTurns) - trg.vanishCounter == 0)
                        {
                            gv.cc.floatyTextActorInfoVanishInXTurns = "Vanishes on start of next round";
                        }          
                        else
                        {
                            gv.cc.floatyTextActorInfoVanishInXTurns = "Vanishes in " + (Convert.ToInt32(trg.vanishInXTurns) - trg.vanishCounter + 1).ToString() + " rounds";
                        }
                        //has vanished todo
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoVanishInXTurns = "";
                    }

                    if (trg.appearInXTurns != null && trg.appearInXTurns != "" && trg.appearInXTurns != "none" && trg.appearInXTurns != "None")
                    {
                        if (Convert.ToInt32(trg.appearInXTurns) - trg.appearCounter < 0)
                        {
                            gv.cc.floatyTextActorInfoAppearInXTurns = "Has appeared/been activated";
                        }
                        else if (Convert.ToInt32(trg.vanishInXTurns) - trg.vanishCounter == 0)
                        {
                            gv.cc.floatyTextActorInfoVanishInXTurns = "Activated on start of next round";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoAppearInXTurns = "Activated in " + (Convert.ToInt32(trg.appearInXTurns) - trg.appearCounter + 1).ToString() + " rounds";
                            //has appeared todo
                        }
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoAppearInXTurns = "";
                    }

                    if (gv.cc.floatyTextActorInfoVanishInXTurns == "" && gv.cc.floatyTextActorInfoAppearInXTurns == "")
                    {
                        gv.cc.floatyTextActorInfoVanishInXTurns = "No timer for this event square";
                    }
                    //gv.cc.floatyTextActorInfoVanishInXTurns
                    //appear/vanish

                    if (trg.changeWalkableStateOnEnabledStateChange)
                    {
                        gv.cc.floatyTextActorInfoChangeWalkableState = "Affects walkable state on change";
                    }
                    else
                    {
                        gv.cc.floatyTextActorInfoChangeWalkableState = "Does not change walkable state";
                    }
                    //Affects walkable state



                    if (trg.Event1FilenameOrTag == "gaCastSpellEncounterTrigger.cs")
                    {
                        foreach (Spell sp in gv.mod.moduleSpellsList)
                        {
                            if (sp.tag == trg.Event1Parm1)
                            {
                                gv.cc.floatyTextActorInfoSpellName = "Event: " + sp.name;
                                break;
                            }
                        }
                        if (trg.Event1Parm2 == "true" || trg.Event1Parm2 == "True")
                        {
                            gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "Only works while on this square";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "No presence on square required";
                        }
                        gv.cc.floatyTextActorInfoOnlyCasterLevel = "Power: " + trg.Event1Parm3;
                    }

                    if (trg.changeWalkableStateOnEnabledStateChange)
                    {
                        gv.cc.floatyTextActorInfoSpellName = "Barrier";
                        gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                        gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                    }

                    if (trg.Event1Type == "container")
                    {
                        gv.cc.floatyTextActorInfoSpellName = "Treasure";
                        gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                        gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                    }

                    if (trg.Event2FilenameOrTag == "gaCastSpellEncounterTrigger.cs")
                    {
                        foreach (Spell sp in gv.mod.moduleSpellsList)
                        {
                            if (sp.tag == trg.Event2Parm1)
                            {
                                gv.cc.floatyTextActorInfoSpellName2 = "Event: " + sp.name;
                                break;
                            }
                        }
                        if (trg.Event2Parm2 == "true" || trg.Event2Parm2 == "True")
                        {
                            gv.cc.floatyTextActorInfoOnlyWhileOnSquare2 = "Only works while on this square";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoOnlyWhileOnSquare2 = "No presence on square required";
                        }
                        gv.cc.floatyTextActorInfoOnlyCasterLevel2 = "Power: " + trg.Event2Parm3;
                    }

                    if (trg.Event2Type == "container")
                    {
                        gv.cc.floatyTextActorInfoSpellName = "Treasure";
                        gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                        gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                    }

                    if (trg.Event3FilenameOrTag == "gaCastSpellEncounterTrigger.cs")
                    {
                        foreach (Spell sp in gv.mod.moduleSpellsList)
                        {
                            if (sp.tag == trg.Event3Parm1)
                            {
                                gv.cc.floatyTextActorInfoSpellName3 = "Event: " + sp.name;
                                break;
                            }
                        }
                        if (trg.Event3Parm2 == "true" || trg.Event3Parm2 == "True")
                        {
                            gv.cc.floatyTextActorInfoOnlyWhileOnSquare3 = "Only works while on this square";
                        }
                        else
                        {
                            gv.cc.floatyTextActorInfoOnlyWhileOnSquare3 = "No presence on square required";
                        }
                        gv.cc.floatyTextActorInfoOnlyCasterLevel3 = "Power: " + trg.Event3Parm3;
                    }
                    if (trg.Event3Type == "container")
                    {
                        gv.cc.floatyTextActorInfoSpellName = "Treasure";
                        gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
                        gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
                    }

                    //hide the normal info when efects are shown
                    gv.cc.floatyTextActorInfoMoveOrder = "";
                    gv.cc.floatyTextActorInfoInitiative = "";
                    gv.cc.floatyTextActorInfoAC = "";
                    gv.cc.floatyTextActorInfoMovementRange = "";
                    gv.cc.floatyTextActorInfoHP = "";
                    gv.cc.floatyTextActorInfoSP = "";
                    gv.cc.floatyTextActorInfoToHit = "";
                    gv.cc.floatyTextActorInfoNumberOfAttacks = "";
                    gv.cc.floatyTextActorInfoWeaponTags = "";
                    gv.cc.floatyTextActorInfoOnScoringHitSpellName = "";
                    gv.cc.floatyTextActorInfoOnScoringHitSpellNameSelf = "";
                    gv.cc.floatyTextActorInfoAttackRange = "";
                    gv.cc.floatyTextActorInfoAttackType = "";
                    gv.cc.floatyTextActorInfoDamage = "";
                    gv.cc.floatyTextActorInfoSaves = "";
                    gv.cc.floatyTextActorInfoSaves2 = "";
                    gv.cc.floatyTextActorInfoSaves3 = "";
                    gv.cc.floatyTextActorInfoDamageType = "";
                    gv.cc.floatyTextActorInfoAmmo = "";
                    gv.cc.floatyTextActorInfoResistances1 = "";
                    gv.cc.floatyTextActorInfoResistances2 = "";
                    gv.cc.floatyTextActorInfoResistances3 = "";
                    gv.cc.floatyTextActorInfoResistances4 = "";
                    gv.cc.floatyTextActorInfoResistances5 = "";
                    gv.cc.floatyTextActorInfoResistances6 = "";
                    gv.cc.floatyTextActorInfoResistances7 = "";


                    //To do: must set all creature exclusive innfo to "" here
                    //public string floatyTextActorInfoFaction = "";
                    gv.cc.floatyTextActorInfoRegenerationHP = "";
                    gv.cc.floatyTextActorInfoRegenerationSP = "";
                    gv.cc.floatyTextActorInfoSpellsKnown1 = "";
                    gv.cc.floatyTextActorInfoSpellsKnown2 = "";
                    gv.cc.floatyTextActorInfoSpellsKnown3 = "";
                    gv.cc.floatyTextActorInfoAIType = "";
                    gv.cc.floatyTextActorInfoAIAffinityForCasting = "";//0 to 100
                    gv.cc.floatyTextActorInfoInjuryThreshold = "";
                    gv.cc.floatyTextActorInfoCreatureTags = "";//used for immunities, special weaknesses, eg "undead" are affected by turn spells and immunne to paralyze...
                    gv.cc.floatyTextActorInfoHitBy = "";
                    gv.cc.floatyTextActorInfoOnDeathScriptName = "";

                    gv.cc.floatyTextActorInfoRMB1 = "";
                    gv.cc.floatyTextActorInfoRMB2 = "";

                    //more draw routines missing
                    //nedd to celar all not needed infos


                    //mouseOverText on top (one liner, count chars)
                    //works for pc/creature/all
                    //charges
                    //every step (With multi square triggers)

                    //for all 3 events
                    //do the following only for scripts that call "gaCastSpellEncounterTrigger.cs" (ie no ibscripts), in case of event1.filenameortag
                    //get more info from the parms
                    //in case of event1.filenameortag
                    //filename.Equals("gaCastSpellEncounterTrigger.cs"
                    //string parm1 tag of spell
                    //bool parm2 remove effect immediately when leaving trigger square (true/false); this is handy for triggers that give positional buffs for position, simualting eg height advantage 
                    //add effect tag for with duration > 0 (or buff/debuff) to tagsOfEffectsToRemoveOnMove list of cretaure/pc
                    //string parm3 caster level
                    //string parm4 custom log text override (this will not be needed)  
                    //might finally do a efects contained

                    //eventually add trait related info to this for eg traps (disarm on step on mechnaism or trait use on the trap?), useability trait requiremnts (to have effect when stepping on it), spawn requiremnets (at start of battle), spawn prevention requirements (at start of battle),
                    //unveiling requirements for hidden triggers (successful triatc ehck of nearby character, might cerate nice gameplay where a thief scous a path)
                }
                else
                {
                    //corona
                    hideActorInfo();
                }
            }
            else if (actor is Effect)
            {
                Effect ef = (Effect)(actor);
                gv.cc.floatyTextActorInfoName = "Lingering Effect";

                if (ef.description == "none")
                {
                    gv.cc.floatyTextActorInfoText = "Details are unknown";
                }
                else
                {
                    gv.cc.floatyTextActorInfoText = ef.description;
                }


                gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "Duration: " + (ef.durationOnSquareInUnits/gv.mod.TimePerRound) + " round(s)";
                gv.cc.floatyTextActorInfoLingeringEffectPersistence = "Persistence: " + ef.onSquarePersistenceBonus;
                gv.cc.floatyTextActorInfoLingeringEffectPower = "Power: " + ef.classLevelOfSender;
                
                //duration remaining (dutration on square in units)
                //power (claasslevelofsender)
                //persistence

            }
        }

        public void hideActorInfo()
        {
            gv.cc.inEffectMode = false;
            
            //gv.cc.showingEffects = false;
            /*
            if (rtn.Equals("tglHP"))
            {
                IB2ToggleButton tgl = combatUiLayout.GetToggleByTag(rtn);
                if (tgl == null) { return; }
                tgl.toggleOn = !tgl.toggleOn;
                showHP = !showHP;
            }
            */
            try
            {
                IB2ToggleButton tgl = combatUiLayout.GetToggleByTag("tglHP");
                if (tgl.toggleOn)
                {
                    showHP = true;
                }
                else
                {
                    showHP = false;
                }

                tgl = combatUiLayout.GetToggleByTag("tglSP");
                if (tgl.toggleOn)
                {
                    showSP = true;
                }
                else
                {
                    showSP = false;
                }


                tgl = combatUiLayout.GetToggleByTag("tglMoveOrder");
                if (tgl.toggleOn)
                {
                    showMoveOrder = true;
                }
                else
                {
                    showMoveOrder = false;
                }
            }
            catch
            { }


            gv.cc.floatyText = "";
            gv.cc.floatyText2 = "";
            gv.cc.floatyText3 = "";
            gv.cc.floatyText4 = "";
            gv.cc.floatyText0 = "";
            gv.cc.floatyTextA = "";
            gv.cc.floatyTextB = "";

            //this will hide second page with effects on mouse move and left click
            //if (gv.cc.floatyTextActorInfoName == "")
            //{
            gv.cc.floatyTextActorInfoTempEffects1 = "";
            gv.cc.floatyTextActorInfoTempEffects2 = "";
            gv.cc.floatyTextActorInfoTempEffects3 = "";
            gv.cc.floatyTextActorInfoTempEffects4 = "";
            gv.cc.floatyTextActorInfoTempEffects5 = "";
            gv.cc.floatyTextActorInfoTempEffects6 = "";
            gv.cc.floatyTextActorInfoTempEffects7 = "";
            gv.cc.floatyTextActorInfoTempEffects8 = "";
            gv.cc.floatyTextActorInfoTempEffects9 = "";
            gv.cc.floatyTextActorInfoTempEffects10 = "";
            gv.cc.floatyTextActorInfoTempEffects1custom = "";
            gv.cc.floatyTextActorInfoTempEffects2custom = "";
            gv.cc.floatyTextActorInfoTempEffects3custom = "";
            gv.cc.floatyTextActorInfoTempEffects4custom = "";
            gv.cc.floatyTextActorInfoTempEffects5custom = "";
            gv.cc.floatyTextActorInfoTempEffects6custom = "";
            gv.cc.floatyTextActorInfoTempEffects7custom = "";
            gv.cc.floatyTextActorInfoTempEffects8custom = "";
            gv.cc.floatyTextActorInfoTempEffects9custom = "";
            gv.cc.floatyTextActorInfoTempEffects10custom = "";
            //}


            gv.cc.floatyTextActorInfoText = "";
            gv.cc.floatyTextActorInfoWorksFor = "";
            gv.cc.floatyTextActorInfoEnableTrait = "";
            gv.cc.floatyTextActorInfoEnabledState = "";
            gv.cc.floatyTextActorInfoEnableDC = "";

            gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
            gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
            gv.cc.floatyTextActorInfoLingeringEffectPower = "";

            gv.cc.floatyTextActorInfoVanishInXTurns = "";
            gv.cc.floatyTextActorInfoAppearInXTurns = "";
            gv.cc.floatyTextActorInfoChangeWalkableState = "";
            gv.cc.floatyTextActorInfoDisableTrait = "";
            gv.cc.floatyTextActorInfoDisableDC = "";
            gv.cc.floatyTextActorInfoCharges = "";
            gv.cc.floatyTextActorInfoEveryStep = "";

            gv.cc.floatyTextActorInfoName = "";
            gv.cc.floatyTextActorInfoMoveOrder = "";
            gv.cc.floatyTextActorInfoInitiative = "";
            gv.cc.floatyTextActorInfoAC = "";
            gv.cc.floatyTextActorInfoMovementRange = "";
            gv.cc.floatyTextActorInfoHP = "";
            gv.cc.floatyTextActorInfoSP = "";
            gv.cc.floatyTextActorInfoToHit = "";
            gv.cc.floatyTextActorInfoWeaponTags = "";
            gv.cc.floatyTextActorInfoNumberOfAttacks = "";
            gv.cc.floatyTextActorInfoOnScoringHitSpellName = "";
            gv.cc.floatyTextActorInfoOnScoringHitSpellNameSelf = "";
            gv.cc.floatyTextActorInfoAttackRange = "";
            gv.cc.floatyTextActorInfoAttackType = "";
            gv.cc.floatyTextActorInfoDamage = "";
            gv.cc.floatyTextActorInfoSaves = "";
            gv.cc.floatyTextActorInfoSaves2 = "";
            gv.cc.floatyTextActorInfoSaves3 = "";
            gv.cc.floatyTextActorInfoDamageType = "";
            gv.cc.floatyTextActorInfoAmmo = "";
            gv.cc.floatyTextActorInfoResistances1 = "";
            gv.cc.floatyTextActorInfoResistances2 = "";
            gv.cc.floatyTextActorInfoResistances3 = "";
            gv.cc.floatyTextActorInfoResistances4 = "";
            gv.cc.floatyTextActorInfoResistances5 = "";
            gv.cc.floatyTextActorInfoResistances6 = "";
            gv.cc.floatyTextActorInfoResistances7 = "";
            gv.cc.floatyTextActorInfoRegenerationHP = "";
            gv.cc.floatyTextActorInfoRegenerationSP = "";
            gv.cc.floatyTextActorInfoSpellsKnown1 = "";
            gv.cc.floatyTextActorInfoSpellsKnown2 = "";
            gv.cc.floatyTextActorInfoSpellsKnown3 = "";
            gv.cc.floatyTextActorInfoAIType = "";
            gv.cc.floatyTextActorInfoAIAffinityForCasting = "";//0 to 100
            gv.cc.floatyTextActorInfoInjuryThreshold = "";
            gv.cc.floatyTextActorInfoCreatureTags = "";//used for immunities, special weaknesses, eg "undead" are affected by turn spells and immunne to paralyze...
            gv.cc.floatyTextActorInfoHitBy = "";
            gv.cc.floatyTextActorInfoOnDeathScriptName = "";
            gv.cc.floatyTextActorInfoRMB1 = "";
            gv.cc.floatyTextActorInfoRMB2 = "";
            //gv.cc.showingEffects = false;

            gv.cc.floatyTextActorInfoText = "";
            gv.cc.floatyTextActorInfoWorksFor = "";
            gv.cc.floatyTextActorInfoEnableTrait = "";
            gv.cc.floatyTextActorInfoEnabledState = "";
            gv.cc.floatyTextActorInfoEnableDC = "";

            gv.cc.floatyTextActorInfoLingeringEffectRemainingDuration = "";
            gv.cc.floatyTextActorInfoLingeringEffectPersistence = "";
            gv.cc.floatyTextActorInfoLingeringEffectPower = "";

            gv.cc.floatyTextActorInfoVanishInXTurns = "";
            gv.cc.floatyTextActorInfoAppearInXTurns = "";
            gv.cc.floatyTextActorInfoChangeWalkableState = "";
            gv.cc.floatyTextActorInfoDisableTrait = "";
            gv.cc.floatyTextActorInfoDisableDC = "";
            gv.cc.floatyTextActorInfoCharges = "";
            gv.cc.floatyTextActorInfoEveryStep = "";
            gv.cc.floatyTextActorInfoSpellName = "";//get via tag
            gv.cc.floatyTextActorInfoOnlyWhileOnSquare = "";
            gv.cc.floatyTextActorInfoOnlyCasterLevel = "";
            gv.cc.floatyTextActorInfoSpellName2 = "";//get via tag
            gv.cc.floatyTextActorInfoOnlyWhileOnSquare2 = "";
            gv.cc.floatyTextActorInfoOnlyCasterLevel2 = "";
            gv.cc.floatyTextActorInfoSpellName3 = "";//get via tag
            gv.cc.floatyTextActorInfoOnlyWhileOnSquare3 = "";
            gv.cc.floatyTextActorInfoOnlyCasterLevel3 = "";
    }

        public void CalculateUpperLeft()
        {

            hideActorInfo();

            Player pc2 = gv.mod.playerList[currentPlayerIndex];
            if (pc2.hp > 0)
            { 
                //if (animationSeqStack.Count == 0)
            //{
                if (gv.mod.useManualCombatCam)
                {
                FormerUpperLeftSquare.X = UpperLeftSquare.X;
                FormerUpperLeftSquare.Y = UpperLeftSquare.Y;
                CenterScreenOnPC();
                }

                else
                {
                    Player pc = gv.mod.playerList[currentPlayerIndex];
                    int minX = pc.combatLocX - gv.playerOffsetX;
                    if (minX < 0) { minX = 0; }
                    int minY = pc.combatLocY - gv.playerOffsetY;
                    if (minY < 0) { minY = 0; }

                    if ((pc.combatLocX <= (UpperLeftSquare.X + 7)) && (pc.combatLocX >= UpperLeftSquare.X + 2) && (pc.combatLocY <= (UpperLeftSquare.Y + 7)) && (pc.combatLocY >= UpperLeftSquare.Y + 2))
                    {
                        return;
                    }
                    else
                    {
                        UpperLeftSquare.X = minX;
                        UpperLeftSquare.Y = minY;
                    int deltaX = UpperLeftSquare.X - FormerUpperLeftSquare.X;
                    int deltaY = UpperLeftSquare.Y - FormerUpperLeftSquare.Y;
                    deltaX = 0;
                    deltaY = 0;
                    foreach (Sprite spr in spriteList)
                    {
                        spr.position.X = spr.position.X + (deltaX * gv.squareSize);
                        spr.position.Y = spr.position.Y + (deltaY * gv.squareSize);
                    }
                        foreach (AnimationSequence aS in animationSeqStack)
                        {
                            for (int i = 0; i < aS.AnimationSeq.Count; i++)
                            {
                                for (int j = 0; j < aS.AnimationSeq[i].SpriteGroup.Count; j++)
                                {
                                    aS.AnimationSeq[i].SpriteGroup[j].position.X = aS.AnimationSeq[i].SpriteGroup[j].position.X + (deltaX * gv.squareSize);
                                    aS.AnimationSeq[i].SpriteGroup[j].position.Y = aS.AnimationSeq[i].SpriteGroup[j].position.Y + (deltaY * gv.squareSize);
                                }
                            }
                        }
                    }
                }
            }
           
        }

        public void CalculateUpperLeftCreature(Creature crt)
        {
            hideActorInfo();

            FormerUpperLeftSquare.X = UpperLeftSquare.X;
            FormerUpperLeftSquare.Y = UpperLeftSquare.Y;

            //if (animationSeqStack.Count == 0)
            //{
            //Creature crt = gv.mod.currentEncounter.encounterCreatureList[creatureIndex];
            //Player pc = gv.mod.playerList[currentPlayerIndex];

            if (crt.combatLocX == 0 && crt.combatLocY == 0)
            {
                int hgjh = 0;
            }

            if (crt.cr_tag == "newTag")
            {
                return;
            }
            int minX = crt.combatLocX - gv.playerOffsetX;
                if (!gv.mod.useManualCombatCam)
                {
                    if (minX < 0) { minX = 0; }
                }
                else
                {
                    if (minX < -gv.playerOffsetX) { minX = -gv.playerOffsetX; }
                }
                //if (minX < 0) { minX = 0; }
                int minY = crt.combatLocY - gv.playerOffsetY;
                if (!gv.mod.useManualCombatCam)
                {
                    if (minY < 0) { minY = 0; }
                }
                else
                {
                    if (minY < -gv.playerOffsetY) { minY = -gv.playerOffsetY; }
                }
            //if (minY < 0) { minY = 0; }

            //do not adjust view port if creature is on screen already and ends move at least one square away from border
            int oversizeMargin = 0;
            if (crt.creatureSize > 1)
            {
                oversizeMargin = 2;
            }
                if (((crt.combatLocX + 2 + oversizeMargin) <= (UpperLeftSquare.X + (gv.playerOffsetX * 2))) && ((crt.combatLocX - 2 - oversizeMargin) >= (UpperLeftSquare.X)) && ((crt.combatLocY + 2 + oversizeMargin) <= (UpperLeftSquare.Y + (gv.playerOffsetY * 2))) && ((crt.combatLocY - 2 - oversizeMargin) >= (UpperLeftSquare.Y)))
                {
                     //return;
                }

                //else
                {
                    if ((gv.mod.useManualCombatCam) && !gv.mod.fastMode)
                    {
                        //bali2
                        int relevantRange = 1;
                        if (crt.cr_category.Equals("Melee"))
                        {
                            relevantRange = crt.cr_attRange;
                        }
                    relevantRange = 100;
                        //Melee or AoO situation
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (getDistance(new Coordinate(p.combatLocX, p.combatLocY), new Coordinate(crt.combatLocX, crt.combatLocY)) <= relevantRange)
                            {
                                UpperLeftSquare.X = minX;
                                UpperLeftSquare.Y = minY;
                            int deltaX = UpperLeftSquare.X - FormerUpperLeftSquare.X;
                            int deltaY = UpperLeftSquare.Y - FormerUpperLeftSquare.Y;
                            //deltaX = 0;
                            //deltaY = 0;
                            foreach (Sprite spr in spriteList)
                            {
                                spr.position.X = spr.position.X + (deltaX * gv.squareSize);
                                spr.position.Y = spr.position.Y + (deltaY * gv.squareSize);
                            }
                            foreach (AnimationSequence aS in animationSeqStack)
                            {
                                for (int i = 0; i < aS.AnimationSeq.Count; i++)
                                {
                                    for (int j = 0; j < aS.AnimationSeq[i].SpriteGroup.Count; j++)
                                    {
                                        aS.AnimationSeq[i].SpriteGroup[j].position.X = aS.AnimationSeq[i].SpriteGroup[j].position.X - (deltaX * gv.squareSize);
                                        aS.AnimationSeq[i].SpriteGroup[j].position.Y = aS.AnimationSeq[i].SpriteGroup[j].position.Y - (deltaY * gv.squareSize);
                                    }
                                }
                            }

                            break;
                            }

                            //ranged situation
                            //bali1
                            if (adjustCamToRangedCreature)
                            {
                                UpperLeftSquare.X = minX;
                                UpperLeftSquare.Y = minY;
                            int deltaX = UpperLeftSquare.X - FormerUpperLeftSquare.X;
                            int deltaY = UpperLeftSquare.Y - FormerUpperLeftSquare.Y;
                            //deltaX = 0;
                            //deltaY = 0;
                            foreach (Sprite spr in spriteList)
                            {
                                spr.position.X = spr.position.X + (deltaX * gv.squareSize);
                                spr.position.Y = spr.position.Y + (deltaY * gv.squareSize);
                            }
                            foreach (AnimationSequence aS in animationSeqStack)
                            {
                                for (int i = 0; i < aS.AnimationSeq.Count; i++)
                                {
                                    for (int j = 0; j < aS.AnimationSeq[i].SpriteGroup.Count; j++)
                                    {
                                        aS.AnimationSeq[i].SpriteGroup[j].position.X = aS.AnimationSeq[i].SpriteGroup[j].position.X - (deltaX * gv.squareSize);
                                        aS.AnimationSeq[i].SpriteGroup[j].position.Y = aS.AnimationSeq[i].SpriteGroup[j].position.Y - (deltaY * gv.squareSize);
                                    }
                                }
                            }
                            break;
                                //cut out fo bugfixing
                                /*
                                if (getDistance(new Coordinate(p.combatLocX, p.combatLocY), new Coordinate(crt.combatLocX, crt.combatLocY)) < 9)
                                {
                                    if (p.combatLocX < crt.combatLocX)
                                    {
                                        UpperLeftSquare.X = p.combatLocX;
                                    }
                                    else
                                    {
                                        UpperLeftSquare.X = crt.combatLocX;
                                    }

                                    if (p.combatLocY < crt.combatLocY)
                                    {
                                        UpperLeftSquare.Y = p.combatLocY;
                                    }
                                    else
                                    {
                                        UpperLeftSquare.Y = crt.combatLocY;
                                    }
                                    break;
                                }
                                */
                            }
                        }

                        //return;
                    }
                    else if (!gv.mod.fastMode)
                    {
                    UpperLeftSquare.X = minX;
                    UpperLeftSquare.Y = minY;
                    int deltaX = UpperLeftSquare.X - FormerUpperLeftSquare.X;
                    int deltaY = UpperLeftSquare.Y - FormerUpperLeftSquare.Y;
                    //deltaX = 0;
                    //deltaY = 0;
                    foreach (Sprite spr in spriteList)
                    {
                        spr.position.X = spr.position.X + (deltaX * gv.squareSize);
                        spr.position.Y = spr.position.Y + (deltaY * gv.squareSize);
                    }
                    foreach (AnimationSequence aS in animationSeqStack)
                    {
                        for (int i = 0; i < aS.AnimationSeq.Count; i++)
                        {
                            for (int j = 0; j < aS.AnimationSeq[i].SpriteGroup.Count; j++)
                            {
                                aS.AnimationSeq[i].SpriteGroup[j].position.X = aS.AnimationSeq[i].SpriteGroup[j].position.X - (deltaX * gv.squareSize);
                                aS.AnimationSeq[i].SpriteGroup[j].position.Y = aS.AnimationSeq[i].SpriteGroup[j].position.Y - (deltaY * gv.squareSize);
                            }
                        }
                    }
                }
                }
            //}
        }
        public void CenterScreenOnPC()
        {


            if (currentPlayerIndex < gv.mod.playerList.Count && currentPlayerIndex > -1)
            {
                if (gv.mod.playerList[currentPlayerIndex] != null)
                {
                    Player pc = gv.mod.playerList[currentPlayerIndex];

                    foreach (Trigger t in gv.mod.currentEncounter.Triggers)
                    {
                        foreach (Coordinate coord in t.TriggerSquaresList)
                        {
                            if (pc.combatLocX <= coord.X +1 && pc.combatLocX >= coord.X -1)
                            {
                                if (pc.combatLocY <= coord.Y + 1 && pc.combatLocY >= coord.Y - 1)
                                {
                                    if (t.chkTrigHidden)
                                    {
                                        if (t.txtTrigFindingTraitTag != "" && t.txtTrigFindingTraitTag != "None" && t.txtTrigFindingTraitTag != "none" && t.txtTrigFindingTraitTag != null)
                                        {
                                        

                                            if (gv.sf.CheckPassSkill(currentPlayerIndex, t.txtTrigFindingTraitTag, Convert.ToInt32(t.txtTrigFindingDC), true, true))
                                            {

                                                //find out trait name
                                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                                /*
                                                foreach (LocalImmunityString lis in gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).entriesForPcTags)
                    {
                        string typeWeapon = lis.Value.Remove(lis.Value.Length - 1);
                        //string typeWeapon = lis.Value;
                        //typeWeapon.Remove(typeWeapon.Length - 1);

                        //string amount = ls.Value;
                        //amount.Remove(0, amount.Length - 1);
                        char c2 = lis.Value[lis.Value.Length - 1];
                        int amountNumberWeapon = 0;
                        if (Char.IsDigit(c2))
                        {
                            amountNumberWeapon = Convert.ToInt32(c2);
                        }
                        else
                        {
                            typeWeapon = lis.Value;
                        }
                                                */
                                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                                string groupName = "none";
                                                foreach (Trait trait in gv.mod.moduleTraitsList)
                                                {
                                                    if (trait.tag.Contains(t.txtTrigFindingTraitTag))
                                                    {
                                                        groupName = trait.nameOfTraitGroup;
                                                    }
                                                }
                                                if (groupName != "none")
                                                {
                                                    gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>found event square (" + groupName + ", DC " + t.txtTrigFindingDC + ")</font><BR>");
                                                }
                                                else
                                                {
                                                    gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>found event square (" + t.txtTrigFindingTraitTag + ", DC " + t.txtTrigFindingDC + ")</font><BR>");
                                                }
                                                t.chkTrigHidden = false;
                                                if (t.chkTrigEnableOnFinding)
                                                {
                                                    t.Enabled = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            /*
                            foreach (Prop p in gv.mod.currentEncounter.propsList)
                            {
                                if (p.LocationX == coord.X && p.LocationY == coord.Y)
                                {

                                }
                            }
                            */
                        }
                    }
                    //if (pc.combatLocX == 0 && pc.combatLocY == 0)
                    //{
                        //int hgjh = 0;
                    //}

                    int minX = pc.combatLocX - gv.playerOffsetX;
                    if (!gv.mod.useManualCombatCam)
                    {
                        if (minX < 0) { minX = 0; }
                    }
                    else
                    {
                        if (minX < -gv.playerOffsetX) { minX = -gv.playerOffsetX; }
                    }
                    int minY = pc.combatLocY - gv.playerOffsetY;

                    if (!gv.mod.useManualCombatCam)
                    {
                        if (minY < 0) { minY = 0; }
                    }
                    else
                    {
                        if (minY < -gv.playerOffsetY) { minY = -gv.playerOffsetY; }
                    }
                    //gv.screenCombat.animationSeqStack.Clear();
                    UpperLeftSquare.X = minX;
                    UpperLeftSquare.Y = minY;
                    //TODO: transform sprite position here, based on delta between current and older upper left, also for creatue
                    int deltaX = UpperLeftSquare.X - FormerUpperLeftSquare.X;
                    int deltaY = UpperLeftSquare.Y - FormerUpperLeftSquare.Y;
                    //deltaX = 0;
                    //deltaY = 0;
                    foreach (Sprite spr in spriteList)
                    {
                        spr.position.X = spr.position.X + (deltaX * gv.squareSize);
                        spr.position.Y = spr.position.Y + (deltaY * gv.squareSize);
                    }
                    
                    foreach (AnimationSequence aS in animationSeqStack)
                    {
                        for (int i = 0; i < aS.AnimationSeq.Count; i++)
                        {
                            for (int j = 0; j < aS.AnimationSeq[i].SpriteGroup.Count; j++)
                            {
                                aS.AnimationSeq[i].SpriteGroup[j].position.X = aS.AnimationSeq[i].SpriteGroup[j].position.X - (deltaX * gv.squareSize);
                                aS.AnimationSeq[i].SpriteGroup[j].position.Y = aS.AnimationSeq[i].SpriteGroup[j].position.Y - (deltaY * gv.squareSize);
                            }
                        }
                    }
                    
                }
            }
        }

        public void CenterScreenOnPC(Player pc)
        {
            if (pc != null)
            {
              

                if (pc.combatLocX == 0 && pc.combatLocY == 0)
                {
                    int hgjh = 0;
                }
                //Player pc = gv.mod.playerList[currentPlayerIndex];
                int minX = pc.combatLocX - gv.playerOffsetX;
                if (!gv.mod.useManualCombatCam)
                {
                    if (minX < 0) { minX = 0; }
                }
                else
                {
                    if (minX < -gv.playerOffsetX) { minX = -gv.playerOffsetX; }
                }
                int minY = pc.combatLocY - gv.playerOffsetY;

                if (!gv.mod.useManualCombatCam)
                {
                    if (minY < 0) { minY = 0; }
                }
                else
                {
                    if (minY < -gv.playerOffsetY) { minY = -gv.playerOffsetY; }
                }
                //gv.screenCombat.animationSeqStack.Clear();
                UpperLeftSquare.X = minX;
                UpperLeftSquare.Y = minY;
                //TODO: transform sprite position here, based on delta between current and older upper left, also for creatue
                int deltaX = UpperLeftSquare.X - FormerUpperLeftSquare.X;
                int deltaY = UpperLeftSquare.Y - FormerUpperLeftSquare.Y;
                //deltaX = 0;
                //deltaY = 0;
                foreach (Sprite spr in spriteList)
                {
                    spr.position.X = spr.position.X + (deltaX * gv.squareSize);
                    spr.position.Y = spr.position.Y + (deltaY * gv.squareSize);
                }
                foreach (AnimationSequence aS in animationSeqStack)
                {
                    for (int  i = 0; i < aS.AnimationSeq.Count; i++)
                    {
                        for (int j = 0; j < aS.AnimationSeq[i].SpriteGroup.Count; j++)
                        {
                            aS.AnimationSeq[i].SpriteGroup[j].position.X = aS.AnimationSeq[i].SpriteGroup[j].position.X - (deltaX * gv.squareSize);
                            aS.AnimationSeq[i].SpriteGroup[j].position.Y = aS.AnimationSeq[i].SpriteGroup[j].position.Y - (deltaY * gv.squareSize);
                        }
                    }
                }
            }
        }

        public bool IsInVisibleCombatWindow(int sqrX, int sqrY)
        {
            //all input coordinates are in Map Location, not Screen Location
            if ((sqrX < UpperLeftSquare.X-2-2) || (sqrY < UpperLeftSquare.Y-2-2))
            {
                return false;
            }

            if (!gv.mod.useManualCombatCam)
            {
                if ((sqrX < 0) || (sqrY < 0))
                {
                    return false;
                }
            }

            if ((sqrX >= UpperLeftSquare.X + gv.playerOffsetX + gv.playerOffsetX + 1 +2 +2)
                || (sqrY >= UpperLeftSquare.Y + gv.playerOffsetY + gv.playerOffsetY + 2 +2 +2))
            {
                return false;
            }

            if (!gv.mod.useManualCombatCam)
            {
                if ((sqrX >= gv.mod.currentEncounter.MapSizeX)
                || (sqrY >= gv.mod.currentEncounter.MapSizeY))
                {
                    return false;
                }
            }

            return true;
        }
        public bool IsInVisibleCombatWindow(int sqrX, int sqrY, int tileW, int tileH)
        {
            //all input coordinates are in Map Location, not Screen Location
            if ((sqrX < UpperLeftSquare.X -2) || (sqrY < UpperLeftSquare.Y -2))
            {
                return false;
            }
            if ((sqrX >= UpperLeftSquare.X + gv.playerOffsetX + gv.playerOffsetX + 1 +2)
                || (sqrY >= UpperLeftSquare.Y + gv.playerOffsetY + gv.playerOffsetY + 2 +2))
            {
                return false;
            }
            return true;
        }
        public int getPixelLocX(int sqrX)
        {
            return ((sqrX - UpperLeftSquare.X) * gv.squareSize) + gv.oXshift + mapStartLocXinPixels;
        }
        public int getPixelLocY(int sqrY) 
        {
            return (sqrY - UpperLeftSquare.Y) * gv.squareSize;
        }
        public int getViewportSquareLocX(int sqrX)
        {
            return sqrX - UpperLeftSquare.X;
        }
        public int getViewportSquareLocY(int sqrY)
        {
            return sqrY - UpperLeftSquare.Y;
        }
        public void setTargetHighlightStartLocation(Player pc)
        {
            targetHighlightCenterLocation.X = pc.combatLocX;
            targetHighlightCenterLocation.Y = pc.combatLocY;
        }
        public bool isValidAttackTarget(Player pc)
        {
            if (isInRange(pc))
            {
                Item it = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
                //if using ranged and have ammo, use ammo properties
                if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged"))
                        && (!gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
                {
                    //ranged weapon with ammo
                    it = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
                }
                if (it == null)
                {
                    it = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref);
                }

                //check to see if is AoE or Point Target else needs a target PC or Creature
                /*
                bool isAoEType = false;
                if (it.onScoringHitCastSpellTag != "none")
                {
                    foreach (Spell sp in gv.mod.moduleSpellsList)
                    {
                        if (sp.tag == it.onUseItemCastSpellTag)
                        {
                            isAoEType = true;
                            break;
                        }
                    }
                }
                if (it.AreaOfEffect > 0 || isAoEType)
                {
                    return true;
                }
                */
                if (it.AreaOfEffect > 0)
                {
                    return true;
                }
                //Uses the Map Pixel Locations
                int endX2 = targetHighlightCenterLocation.X * gv.squareSize + (gv.squareSize / 2);
                int endY2 = targetHighlightCenterLocation.Y * gv.squareSize + (gv.squareSize / 2);
                int startX2 = pc.combatLocX * gv.squareSize + (gv.squareSize / 2);
                int startY2 = pc.combatLocY * gv.squareSize + (gv.squareSize / 2);

                if ((isVisibleLineOfSight(new Coordinate(startX2, startY2), new Coordinate(endX2, endY2)))
                    || (getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), targetHighlightCenterLocation) == 1))
                {
                    foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                    {
                        //if ((crt.combatLocX == targetHighlightCenterLocation.X) && (crt.combatLocY == targetHighlightCenterLocation.Y))
                        //{
                        //return true;
                        //}
                        foreach (Coordinate coor in crt.tokenCoveredSquares)
                        {
                            if ((coor.X == targetHighlightCenterLocation.X) && (coor.Y == targetHighlightCenterLocation.Y))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        public bool isValidCastTarget(Player pc)
        {
            if (isInRange(pc))
            {
                //check to see if is AoE or Point Target else needs a target PC or Creature
                if ((gv.cc.currentSelectedSpell.aoeRadius > 0) || (gv.cc.currentSelectedSpell.spellTargetType.Equals("PointLocation")))
                {
                    return true;
                }
                //is not an AoE ranged attack, is a PC or Creature
                else
                {
                    //check to see if target is a friend or self
                    if ((gv.cc.currentSelectedSpell.spellTargetType.Equals("Friend")) || (gv.cc.currentSelectedSpell.spellTargetType.Equals("Self")))
                    {
                        foreach (Player p in gv.mod.playerList)
                        {
                            if ((p.combatLocX == targetHighlightCenterLocation.X) && (p.combatLocY == targetHighlightCenterLocation.Y))
                            {
                                return true;
                            }
                        }
                    }
                    else //target is a creature
                    {
                        foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            //if ((crt.combatLocX == targetHighlightCenterLocation.X) && (crt.combatLocY == targetHighlightCenterLocation.Y))
                            //{
                            //return true;
                            //}
                            foreach (Coordinate coor in crt.tokenCoveredSquares)
                            {
                                if ((coor.X == targetHighlightCenterLocation.X) && (coor.Y == targetHighlightCenterLocation.Y))
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
        public object getCastTarget(Player pc)
        {
            if (isInRange(pc))
            {
                //check to see if is AoE or Point Target else needs a target PC or Creature
                if ((gv.cc.currentSelectedSpell.aoeRadius > 0) || (gv.cc.currentSelectedSpell.spellTargetType.Equals("PointLocation")))
                {
                    return new Coordinate(targetHighlightCenterLocation.X, targetHighlightCenterLocation.Y);
                }
                //is not an AoE ranged attack, is a PC or Creature
                else
                {
                    //check to see if target is a friend or self
                    if ((gv.cc.currentSelectedSpell.spellTargetType.Equals("Friend")) || (gv.cc.currentSelectedSpell.spellTargetType.Equals("Self")))
                    {
                        foreach (Player p in gv.mod.playerList)
                        {
                            if ((p.combatLocX == targetHighlightCenterLocation.X) && (p.combatLocY == targetHighlightCenterLocation.Y))
                            {
                                return p;
                            }
                        }
                    }
                    else //target is a creature
                    {
                        foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
                        {
                            //if ((crt.combatLocX == targetHighlightCenterLocation.X) && (crt.combatLocY == targetHighlightCenterLocation.Y))
                            //{
                            //return crt;
                            //}
                            foreach (Coordinate coor in crt.tokenCoveredSquares)
                            {
                                if ((coor.X == targetHighlightCenterLocation.X) && (coor.Y == targetHighlightCenterLocation.Y))
                                {
                                    return crt;
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }
        public bool isInRange(Player pc)
        {
            if (currentCombatMode.Equals("attack"))
            {
                int range = 1;
                if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Ranged"))
                        && (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
                {
                    //ranged weapon with no ammo
                    range = 1;
                }
                else
                {
                    range = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).attackRange;
                }

                if (getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), targetHighlightCenterLocation) <= range)
                {
                    return true;
                }
            }
            else if (currentCombatMode.Equals("cast"))
            {
                if (getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), targetHighlightCenterLocation) <= gv.cc.currentSelectedSpell.range)
                {
                    return true;
                }
            }
            return false;
        }
        public bool isAdjacentEnemy(Player pc)
        {
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                //if (getDistance(new Coordinate(pc.combatLocX,pc.combatLocY), new Coordinate(crt.combatLocX,crt.combatLocY)) == 1)
                foreach (Coordinate coor in crt.tokenCoveredSquares)
                {
                    //if (!crt.isHeld())
                    if (getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), new Coordinate(coor.X, coor.Y)) == 1)
                    {
                        //if (crt.hp > 0)
                        if (!crt.isHeld())
                        {
                            //return true;
                            if (crt.hp > 0)
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        public bool isAdjacentPc(Creature crt)
        {
            foreach (Player pc in gv.mod.playerList)
            {
                if (getDistance(new Coordinate(pc.combatLocX, pc.combatLocY), new Coordinate(crt.combatLocX, crt.combatLocY)) == 1)
                {
                    if ((pc.hp > 0) && (!pc.isHeld()))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        public int getGridX(Coordinate nextPoint)
        {
            int gridx = ((nextPoint.X - mapStartLocXinPixels - gv.oXshift) / gv.squareSize) + UpperLeftSquare.X;
            if (gridx > gv.mod.currentEncounter.MapSizeX - 1) { gridx = gv.mod.currentEncounter.MapSizeX - 1; }
            if (gridx < 0) { gridx = 0; }
            return gridx;
        }
        public int getGridY(Coordinate nextPoint)
        {
            int gridy = ((nextPoint.Y - gv.oYshift) / gv.squareSize) + UpperLeftSquare.Y;
            if (gridy > gv.mod.currentEncounter.MapSizeY - 1) { gridy = gv.mod.currentEncounter.MapSizeY - 1; }
            if (gridy < 0) { gridy = 0; }
            return gridy;
        }
        public int getMapSquareX(Coordinate nextPoint)
        {
            int gridx = (nextPoint.X / gv.squareSize);
            if (gridx > gv.mod.currentEncounter.MapSizeX - 1) { gridx = gv.mod.currentEncounter.MapSizeX - 1; }
            if (gridx < 0) { gridx = 0; }
            return gridx;
        }
        public int getMapSquareY(Coordinate nextPoint)
        {
            int gridy = (nextPoint.Y / gv.squareSize);
            if (gridy > gv.mod.currentEncounter.MapSizeY - 1) { gridy = gv.mod.currentEncounter.MapSizeY - 1; }
            if (gridy < 0) { gridy = 0; }
            return gridy;
        }
        public bool isVisibleLineOfSight(Coordinate start, Coordinate end)
        {
            //This Method Uses Map Pixel Locations Only

            int deltax = Math.Abs(end.X - start.X);
            int deltay = Math.Abs(end.Y - start.Y);
            int ystep = gv.squareSize / 50;
            int xstep = gv.squareSize / 50;
            if (ystep < 1) { ystep = 1; }
            if (xstep < 1) { xstep = 1; }

            if (deltax > deltay) //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltax / 2;

                if (end.Y < start.Y) { ystep = -1 * ystep; } //down and right or left

                if (end.X > start.X) //down and right
                {
                    for (int x = start.X; x <= end.X; x += xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getMapSquareX(nextPoint);
                        int gridy = getMapSquareY(nextPoint);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                    }
                }
                else //down and left
                {
                    for (int x = start.X; x >= end.X; x -= xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getMapSquareX(nextPoint);
                        int gridy = getMapSquareY(nextPoint);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                    }
                }
            }

            else //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltay / 2;

                if (end.X < start.X) { xstep = -1 * xstep; } //up and right or left

                if (end.Y > start.Y) //up and right
                {
                    for (int y = start.Y; y <= end.Y; y += ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getMapSquareX(nextPoint);
                        int gridy = getMapSquareY(nextPoint);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                    }
                }
                else //up and right
                {
                    for (int y = start.Y; y >= end.Y; y -= ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getMapSquareX(nextPoint);
                        int gridy = getMapSquareY(nextPoint);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                    }
                }
            }

            return true;
        }
        public bool drawVisibleLineOfSightTrail(Coordinate end, Coordinate start, Color penColor, int penWidth)
        {
            // Bresenham Line algorithm
            // Creates a line from Begin to End starting at (x0,y0) and ending at (x1,y1)
            // where x0 less than x1 and y0 less than y1
            // AND line is less steep than it is wide (dx less than dy)    

            int deltax = Math.Abs(end.X - start.X);
            int deltay = Math.Abs(end.Y - start.Y);
            int ystep = gv.squareSize / 50;
            int xstep = gv.squareSize / 50;
            if (ystep < 1) { ystep = 1; }
            if (xstep < 1) { xstep = 1; }

            if (deltax > deltay) //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltax / 2;

                if (end.Y < start.Y) { ystep = -1 * ystep; } //down and right or left

                if (end.X > start.X) //down and right
                {
                    int lastX = start.X;
                    int lastY = start.Y;
                    for (int x = start.X; x <= end.X; x += xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getGridX(nextPoint);
                        int gridy = getGridY(nextPoint);
                        gv.DrawLine(lastX + gv.oXshift, lastY, nextPoint.X + gv.oXshift, nextPoint.Y, penColor, penWidth);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                        lastX = nextPoint.X;
                        lastY = nextPoint.Y;
                    }
                }
                else //down and left
                {
                    int lastX = start.X;
                    int lastY = start.Y;
                    for (int x = start.X; x >= end.X; x -= xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getGridX(nextPoint);
                        int gridy = getGridY(nextPoint);
                        gv.DrawLine(lastX + gv.oXshift, lastY, nextPoint.X + gv.oXshift, nextPoint.Y, penColor, penWidth);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                        lastX = nextPoint.X;
                        lastY = nextPoint.Y;
                    }
                }
            }

            else //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltay / 2;

                if (end.X < start.X) { xstep = -1 * xstep; } //up and right or left

                if (end.Y > start.Y) //up and right
                {
                    int lastX = start.X;
                    int lastY = start.Y;
                    for (int y = start.Y; y <= end.Y; y += ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getGridX(nextPoint);
                        int gridy = getGridY(nextPoint);
                        gv.DrawLine(lastX + gv.oXshift, lastY, nextPoint.X + gv.oXshift, nextPoint.Y, penColor, penWidth);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                        lastX = nextPoint.X;
                        lastY = nextPoint.Y;
                    }
                }
                else //up and right
                {
                    int lastX = start.X;
                    int lastY = start.Y;
                    for (int y = start.Y; y >= end.Y; y -= ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        int gridx = getGridX(nextPoint);
                        int gridy = getGridY(nextPoint);
                        gv.DrawLine(lastX + gv.oXshift, lastY, nextPoint.X + gv.oXshift, nextPoint.Y, penColor, penWidth);
                        if (gv.mod.currentEncounter.encounterTiles[gridy * gv.mod.currentEncounter.MapSizeX + gridx].LoSBlocked)
                        {
                            return false;
                        }
                        lastX = nextPoint.X;
                        lastY = nextPoint.Y;
                    }
                }
            }

            return true;
        }
        public bool IsAttackFromBehind(Player pc, Creature crt)
        {
            if ((pc.combatLocX > crt.combatLocX) && (pc.combatLocY > crt.combatLocY) && (crt.combatFacing == 7)) { return true; }
            if ((pc.combatLocX == crt.combatLocX) && (pc.combatLocY > crt.combatLocY) && (crt.combatFacing == 8)) { return true; }
            if ((pc.combatLocX < crt.combatLocX) && (pc.combatLocY > crt.combatLocY) && (crt.combatFacing == 9)) { return true; }
            if ((pc.combatLocX > crt.combatLocX) && (pc.combatLocY == crt.combatLocY) && (crt.combatFacing == 4)) { return true; }
            if ((pc.combatLocX < crt.combatLocX) && (pc.combatLocY == crt.combatLocY) && (crt.combatFacing == 6)) { return true; }
            if ((pc.combatLocX > crt.combatLocX) && (pc.combatLocY < crt.combatLocY) && (crt.combatFacing == 1)) { return true; }
            if ((pc.combatLocX == crt.combatLocX) && (pc.combatLocY < crt.combatLocY) && (crt.combatFacing == 2)) { return true; }
            if ((pc.combatLocX < crt.combatLocX) && (pc.combatLocY < crt.combatLocY) && (crt.combatFacing == 3)) { return true; }
            return false;
        }
        public bool IsCreatureAttackFromBehind(Player pc, Creature crt)
        {
            if ((crt.combatLocX > pc.combatLocX) && (crt.combatLocY > pc.combatLocY) && (pc.combatFacing == 7)) { return true; }
            if ((crt.combatLocX == pc.combatLocX) && (crt.combatLocY > pc.combatLocY) && (pc.combatFacing == 8)) { return true; }
            if ((crt.combatLocX < pc.combatLocX) && (crt.combatLocY > pc.combatLocY) && (pc.combatFacing == 9)) { return true; }
            if ((crt.combatLocX > pc.combatLocX) && (crt.combatLocY == pc.combatLocY) && (pc.combatFacing == 4)) { return true; }
            if ((crt.combatLocX < pc.combatLocX) && (crt.combatLocY == pc.combatLocY) && (pc.combatFacing == 6)) { return true; }
            if ((crt.combatLocX > pc.combatLocX) && (crt.combatLocY < pc.combatLocY) && (pc.combatFacing == 1)) { return true; }
            if ((crt.combatLocX == pc.combatLocX) && (crt.combatLocY < pc.combatLocY) && (pc.combatFacing == 2)) { return true; }
            if ((crt.combatLocX < pc.combatLocX) && (crt.combatLocY < pc.combatLocY) && (pc.combatFacing == 3)) { return true; }
            return false;
        }
        public int getDistance(Coordinate start, Coordinate end)
        {
            int dist = 0;
            int deltaX = (int)Math.Abs((start.X - end.X));
            int deltaY = (int)Math.Abs((start.Y - end.Y));
            if (deltaX > deltaY)
                dist = deltaX;
            else
                dist = deltaY;
            return dist;
        }
        public bool isWalkable(int x, int y)
        {
            if (!gv.mod.currentEncounter.encounterTiles[y * gv.mod.currentEncounter.MapSizeX + x].Walkable)
            {
                return false;
            }
            foreach (Player p in gv.mod.playerList)
            {
                if ((p.combatLocX == x) && (p.combatLocY == y))
                {
                    if ((!p.isDead()) && (p.hp > 0))
                    {
                        return false;
                    }
                }
            }
            return true;
        }
        public Creature isBumpIntoCreature(int x, int y)
        {
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                //if ((crt.combatLocX == x) && (crt.combatLocY == y))
                foreach (Coordinate coor in crt.tokenCoveredSquares)
                {
                    //return crt;
                    if ((coor.X == x) && (coor.Y == y))
                    {
                        return crt;
                    }
                }
            }
            return null;
        }
        public bool hasWeaponInOffHand(Player pc)
        {
            if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).category.Equals("Melee"))
            {
                return true;
            }
            return false;
        }
        public void LeaveThreatenedCheck(Player pc, int futurePlayerLocationX, int futurePlayerLocationY)
        {

            int passX = pc.combatLocX;
            int passY = pc.combatLocY;

            if (pc.combatLocX > futurePlayerLocationX)
            {
                passX = pc.combatLocX + 1;
            }
            else if (pc.combatLocX < futurePlayerLocationX)
            {
                passX = pc.combatLocX - 1;
            }

            if (pc.combatLocY > futurePlayerLocationY)
            {
                passY = pc.combatLocY + 1;
            }
            else if (pc.combatLocY < futurePlayerLocationY)
            {
                passY = pc.combatLocY - 1;
            }

            foreach (string eTag in pc.tagsOfEffectsToRemoveOnMove)
            {
                for (int i = pc.effectsList.Count-1; i >= 0; i--)
                {
                    if (pc.effectsList[i].tag == eTag)
                    {
                        pc.effectsList.RemoveAt(i);
                    }
                }
            }
            //burning man
            gv.sf.UpdateStats(pc);
            //update stats
            pc.tagsOfEffectsToRemoveOnMove.Clear();

            //testing...
            if (currentCombatMode == "move")
            {
                dontEndTurn = true;
            }


            



            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if ((crt.hp > 0) && (!crt.isHeld()))
                {
                    //if started in distance = 1 and now distance = 2 then do attackOfOpportunity
                    //also do attackOfOpportunity if moving within controlled area around a creature, i.e. when distance to cerature after move is still one square
                    //the later makes it harder to circle around a cretaure or break through lines, fighters get more area control this way, allwoing them to protect other charcters with more ease
                    /*if ( ( (CalcDistance(crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) == 1)
                        && (CalcDistance(crt.combatLocX, crt.combatLocY, futurePlayerLocationX, futurePlayerLocationY) == 2) ) 
                        || ( (currentMoves > 0) && (CalcDistance(crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) == 1)
                        && (CalcDistance(crt.combatLocX, crt.combatLocY, futurePlayerLocationX, futurePlayerLocationY) == 1) ) )*/

                    if (((CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) == 1)
                     && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, futurePlayerLocationX, futurePlayerLocationY) == 2))
                     || ((currentMoves > 0) && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, pc.combatLocX, pc.combatLocY) == 1)
                     && (CalcDistance(crt, crt.combatLocX, crt.combatLocY, futurePlayerLocationX, futurePlayerLocationY) == 1)))
                    {
                        if (pc.steathModeOn)
                        {
                            gv.cc.addLogText("<font color='white'>Avoids Attack of Opportunity due to Stealth</font><BR>");
                        }
                        else
                        {

                            //gv.mod.numberOfAoOAttackers++;
                            gv.touchEnabled = false;
                            gv.cc.addLogText("<font color='white'>Attack of Opportunity by: <font color='white'>" + crt.cr_name + "</font><BR>");
                            
                                CreatureDoesAttack(crt, false, pc, passX, passY);
                            
                           
                            //doActualCreatureAttack(pc, crt, 1);
                            if (pc.hp <= 0)
                            {
                                currentMoves = 99;
                                dontEndTurn = false;
                                //checkEndEncounter();
                            }
                        }
                    }
                }
            }
            //gv.mod.AoOHitSymbolHasBeenDrawn = false;
            //gv.mod.numberOfAoOAttackers = 0;
    }

        public int CalcPcAttackModifier(Player pc, Creature crt, bool isMainHand)
        {
            int modifier = 0;
            int situationalModifier = 0;

            if (gv.sf.isMeleeAttack(pc))
            {
                modifier = gv.sf.CalcPcMeleeAttackAttributeModifier(pc, isMainHand);
                //if has critical strike trait use dexterity for attack modifier in melee if greater than strength modifier
                /*
                if (pc.knownTraitsTags.Contains("criticalstrike"))
			    {
            	    int modifierDex = (pc.dexterity - 10) / 2;
            	    if (modifierDex > modifier)
            	    {
            		    modifier = (pc.dexterity - 10) / 2;
            	    }
			    }
                */
                //if doing sneak attack, bonus to hit roll
                if (pc.steathModeOn)
                {
                    if (pc.knownTraitsTags.Contains("sneakattack"))
                    {
                        //+1 for every 2 levels after level 1
                        int adding = ((pc.classLevel - 1) / 2) + 1;
                        modifier += adding;
                        situationalModifier += adding;
                        gv.cc.addLogText("<font color='lime'> sneak attack: +" + adding + " to hit</font><BR>");
                    }
                }
                //all attacks of the PC from behind get a +2 bonus to hit            
                if (IsAttackFromBehind(pc, crt))
                {
                    modifier += gv.mod.attackFromBehindToHitModifier;
                    situationalModifier += gv.mod.attackFromBehindToHitModifier;
                    if (gv.mod.attackFromBehindToHitModifier > 0)
                    {
                        gv.cc.addLogText("<font color='white'>Attack from behind: +" + gv.mod.attackFromBehindToHitModifier.ToString() + " to hit." + "</font><BR>");
                    }
                }
                //attacks on truely held creatures get +4 bonus to hit
                if (crt.isHeld())
                {
                    modifier += 4;
                    situationalModifier += 4;
                    gv.cc.addLogText("<font color='lime'>" + pc.name + " <font color='white'>attacks held creature: +4 att</font><BR>");
                }
            }
            else //ranged weapon used
            {
                modifier = (pc.dexterity - 10) / 2;
                situationalModifier = 0;
                //factor in penalty for adjacent enemies when using ranged weapon
                if (isAdjacentEnemy(pc))
                {
                    //if (gv.sf.hasTrait(pc, "pointblankshot"))
                    if (gv.sf.canNegateAdjacentAttackPenalty(pc))
                    {
                        //can ignore attack penalty due to PC having a pointblankshot type of trait or effect 
                    }
                    else
                    {
                        modifier -= 4;
                        situationalModifier -= 4;
                        gv.cc.addLogText("<font color='white'>" + "-4 ranged attack penalty" + "</font><BR>");
                        gv.cc.addLogText("<font color='white'>" + "with enemies in melee range" + "</font><BR>");
                        //gv.cc.addFloatyText(new Coordinate(pc.combatLocX, pc.combatLocY), "-4 att", "yellow");
                    }
                }
                //if (gv.sf.hasTrait(pc, "preciseshot2"))
                int preciseShotAdder = 0;
                preciseShotAdder = gv.sf.CalcPcRangedAttackModifier(pc);
                if (preciseShotAdder > 0)
                {
                    modifier += preciseShotAdder;
                    gv.cc.addLogText("<font color='lime'> Bonus: +" + preciseShotAdder + "to hit</font><BR>");
                }
                //else
                //{
                    if (gv.sf.hasTrait(pc, "preciseshot2"))
                    {
                        modifier += 2;
                        gv.cc.addLogText("<font color='lime'> PreciseShotL2: +2 to hit</font><BR>");
                    }
                    else if (gv.sf.hasTrait(pc, "preciseshot"))
                    {
                        modifier++;
                        gv.cc.addLogText("<font color='lime'> PreciseShotL1: +1 to hit</font><BR>");
                    }
                //}
            }

            if (gv.sf.hasTrait(pc, "hardtokill"))
            {
                modifier -= 2;
                gv.cc.addLogText("<font color='white'>" + "blinded by rage" + "</font><BR>");
                gv.cc.addLogText("<font color='white'>" + "-2 attack penalty" + "</font><BR>");
            }

            if (situationalModifier != 0)
            {
                gv.cc.addFloatyText(new Coordinate(pc.combatLocX, pc.combatLocY), "+" + situationalModifier + " att", "white");
            }

            int attackBonus = 0;
            if (hasWeaponInOffHand(pc)) 
            {
                if (isMainHand)
                {
                    attackBonus += gv.sf.CalcPcMeleeTwoWeaponModifier(pc, true);
                }
                else
                {
                    attackBonus += gv.sf.CalcPcMeleeTwoWeaponModifier(pc, false);

                }
            }

            int attackMod = modifier + pc.baseAttBonus + attackBonus + gv.sf.CalcAttackBonusesNoAmmo(pc, true);
            if (!isMainHand) 
            {
                attackMod = modifier + pc.baseAttBonus + attackBonus + gv.sf.CalcAttackBonusesNoAmmo(pc, false);
            }
            Item it = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
            if (it != null)
            {
                attackMod += gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).attackBonus;
            }
            return attackMod + gv.mod.poorVisionModifier;
        }
        public int CalcCreatureDefense(Player pc, Creature crt)
        {
            int defense = crt.getAc();

            /*
            if (crt.isHeld())
            {
        	    defense -= 4;
        	    gv.cc.addFloatyText(new Coordinate(crt.combatLocX, crt.combatLocY), "+4 att", "green");
            } 
            */

            return defense;
        }
        public int CalcPcDamageToCreature(Player pc, Creature crt, bool isMainHand)
        {
            int damModifier = 0;
            int adder = 0;
            bool melee = false;
            /*
            if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee")) 
        		    || (pc.MainHandRefs.name.Equals("none"))
        		    || (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
             */
            if (gv.sf.isMeleeAttack(pc))
            {
                melee = true;
                /*
                damModifier = (pc.strength - 10) / 2;
                //if has critical strike trait use dexterity for damage modifier in melee if greater than strength modifier
                if (gv.sf.hasTrait(pc, "criticalstrike"))
                {
                    int damModifierDex = (pc.dexterity - 10) / 4;
                    if (damModifierDex > damModifier)
                    {
                        damModifier = (pc.dexterity - 10) / 2;
                    }
                }
                */

                //we need to take ffect for melee damage into account here
                damModifier += gv.sf.CalcPcMeleeDamageAttributeModifier(pc);

                if (IsAttackFromBehind(pc, crt))
                {
                    damModifier += gv.mod.attackFromBehindDamageModifier;
                    if (gv.mod.attackFromBehindDamageModifier > 0)
                    {
                        gv.cc.addLogText("<font color='white'>Attack from behind: +" + gv.mod.attackFromBehindDamageModifier.ToString() + " damage." + "</font><BR>");
                    }
                }

            }
            else //ranged weapon used
            {
                damModifier = 0;
                if (gv.sf.hasTrait(pc, "preciseshot2"))
                {
                    damModifier += 2;
                    gv.cc.addLogText("<font color='lime'> PreciseShotL2: +2 damage</font><BR>");
                }
                else if (gv.sf.hasTrait(pc, "preciseshot"))
                {
                    damModifier++;
                    gv.cc.addLogText("<font color='lime'> PreciseShotL1: +1 damage</font><BR>");
                }

                //we need to take effect for ranged damage into account here
                damModifier += gv.sf.CalcPcRangedDamageModifier(pc);
            }

            int dDam = gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).damageDie;
            float damage = (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).damageNumDice * gv.sf.RandInt(dDam)) + damModifier + adder + gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).damageAdder;
            if (!isMainHand)
            {
                dDam = gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).damageDie;
                damage = (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).damageNumDice * gv.sf.RandInt(dDam)) + damModifier + adder + gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).damageAdder;
            }
            if (damage < 0)
            {
                damage = 0;
            }
            Item it = gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref);
            if (it != null)
            {
                damage += gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).damageAdder;
            }

            float resist = 0;

            if ((gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).category.Equals("Melee"))
                     || (pc.MainHandRefs.name.Equals("none"))
                     || (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).name.Equals("none")))
            {

                //hit by immunity code and messging (floaty, log) here
                //loop hrough cretaure ahremd by list
                //forahc entry, compare wtherer pc perks are matched
                //if case, do damage
                //if liszt = 0, do dmaage
                if (isMainHand)
                { 
                    if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Acid"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueAcid() / 100f));
                        //gv.cc.addLogText("<font color='white'>Acid resistance: +" + adding + "%</font><BR>");
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Normal"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueNormal() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Cold"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueCold() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Electricity"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueElectricity() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Fire"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueFire() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Magic"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueMagic() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).typeOfDamage.Equals("Poison"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValuePoison() / 100f));
                    }
                }
                else //OFF-HAND
                {
                    if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Acid"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueAcid() / 100f));
                        //gv.cc.addLogText("<font color='white'>Acid resistance: +" + adding + "%</font><BR>");
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Normal"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueNormal() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Cold"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueCold() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Electricity"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueElectricity() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Fire"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueFire() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Magic"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueMagic() / 100f));
                    }
                    else if (gv.mod.getItemByResRefForInfo(pc.OffHandRefs.resref).typeOfDamage.Equals("Poison"))
                    {
                        resist = (float)(1f - ((float)crt.getDamageTypeResistanceValuePoison() / 100f));
                    }
                }
            }
            else //ranged weapon so use ammo gv.mods  
            {
                if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Acid"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueAcid() / 100f));
                }
                else if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Normal"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueNormal() / 100f));
                }
                else if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Cold"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueCold() / 100f));
                }
                else if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Electricity"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueElectricity() / 100f));
                }
                else if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Fire"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueFire() / 100f));
                }
                else if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Magic"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValueMagic() / 100f));
                }
                else if (gv.mod.getItemByResRefForInfo(pc.AmmoRefs.resref).typeOfDamage.Equals("Poison"))
                {
                    resist = (float)(1f - ((float)crt.getDamageTypeResistanceValuePoison() / 100f));
                }
            }

            int totalDam = (int)(damage * resist);
            if (totalDam < 0)
            {
                totalDam = 0;
            }

            bool immune = true;
            if (crt.requiredWeaponTypesToHarmCreature.Count == 0)
            {
                immune = false;
            }
            else
            {
                foreach (LocalString ls in crt.requiredWeaponTypesToHarmCreature)
                {
                    string typeCreature = ls.Value.Remove(ls.Value.Length-1);
                    //typeCreature.Remove(typeCreature.Length-1);

                    //string amount = ls.Value;
                    //amount.Remove(0, amount.Length - 1);
                    char c = ls.Value[ls.Value.Length-1];
                    int amountNumberCreature = 0;
                    if (Char.IsDigit(c))
                    {
                        amountNumberCreature = Convert.ToInt32(c);
                    }
                    else
                    {
                        typeCreature = ls.Value;
                    }

                  
                    //grotzo
                    //public List<LocalImmunityString> entriesForPcTags = new List<LocalImmunityString>();
                    foreach (LocalImmunityString lis in gv.mod.getItemByResRefForInfo(pc.MainHandRefs.resref).entriesForPcTags)
                    {
                        string typeWeapon = lis.Value.Remove(lis.Value.Length - 1);
                        //string typeWeapon = lis.Value;
                        //typeWeapon.Remove(typeWeapon.Length - 1);

                        //string amount = ls.Value;
                        //amount.Remove(0, amount.Length - 1);
                        char c2 = lis.Value[lis.Value.Length - 1];
                        int amountNumberWeapon = 0;
                        if (Char.IsDigit(c2))
                        {
                            amountNumberWeapon = Convert.ToInt32(c2);
                        }
                        else
                        {
                            typeWeapon = lis.Value;
                        }

                        if (typeWeapon == typeCreature)
                        {
                            if (amountNumberCreature != 0)
                            {
                                if (amountNumberWeapon >= amountNumberCreature)
                                {
                                    immune = false;
                                }
                            }
                            else
                            {
                                immune = false;
                            }
                        }
                    }
                }
            }

            if (immune)
            {
                damage = 0;
                totalDam = 0;
                gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>is not harmed by this weapon.</font><BR>");

            }

            if (totalDam < damage)
            {
                gv.cc.addLogText("<font color='red'>" + crt.cr_name + "<font color='white'>mitigation: " + (damage - totalDam) + " hp" + "</font><BR>");
            }
            else if (totalDam > damage)
            {
                gv.cc.addLogText("<font color='red'>" + crt.cr_name + "<font color='white'>extra damage: " + (damage - totalDam) + " hp" + "</font><BR>");
            }
            //if doing sneak attack, does extra damage
            //if ((pc.steathModeOn) && (melee) && (IsAttackFromBehind(pc,crt)))
            if ((pc.steathModeOn) && (gv.sf.isMeleeAttack(pc)) && (IsAttackFromBehind(pc, crt)))
            {
                if (pc.knownTraitsTags.Contains("sneakattack"))
                {
                    //+1d6 for every 2 levels after level 1
                    int multiplier = ((pc.classLevel - 1) / 2) + 1;
                    int adding = 0;
                    for (int i = 0; i < multiplier; i++)
                    {
                        adding += gv.sf.RandInt(6);
                    }
                    totalDam += adding;
                    gv.cc.addLogText("<font color='white'> sneak attack: +" + adding + " damage</font><BR>");
                }
            }

            if (melee)
            {
                if (gv.mod.currentEncounter.reducedDamageofPcMeleeAttack)
                {
                    totalDam /= 3;
                    return totalDam;
                }
                else
                {
                    return totalDam;
                }
            }
            else
            {
                if (gv.mod.currentEncounter.reducedDamageofPcRangedAttack)
                {
                    totalDam /= 3;
                    return totalDam;
                }
                else
                {
                    return totalDam;
                }
            }
        }
        public int CalcCreatureAttackModifier(Creature crt, Player pc)
        {
            int modifier = 0;
            int situationalModifier = 0;

            //ranged weapon
            if (crt.cr_category.Equals("Ranged"))
            {
                if (isAdjacentPc(crt))
                {
                    gv.cc.addLogText("<font color='white'> -4 ranged attack penalty </font><BR>");
                    gv.cc.addLogText("<font color='white'>with enemies in melee range</font><BR>");
                    gv.cc.addFloatyText(new Coordinate(crt.combatLocX, crt.combatLocY), "-4 att", "white");
                    return crt.getAttackBonus() - 4;
                }
                else
                {
                    return crt.getAttackBonus();
                }
            }
            else //melee weapon used
            {
                //modifier = 0;
                //all attacks of the Creature from behind get a +2 bonus to hit            
                if (IsCreatureAttackFromBehind(pc, crt))
                {
                    modifier += gv.mod.attackFromBehindToHitModifier;
                    situationalModifier += gv.mod.attackFromBehindToHitModifier;
                    gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>attacks from behind: +" + gv.mod.attackFromBehindToHitModifier + " att</font><BR>");
                }
                if (pc.isHeld())
                {
                    modifier += 4;
                    situationalModifier += 4;
                    gv.cc.addLogText("<font color='red'>" + crt.cr_name + " <font color='white'>attacks held player character: +4 att</font><BR>");
                }
                if (situationalModifier != 0)
                {
                    gv.cc.addFloatyText(new Coordinate(crt.combatLocX, crt.combatLocY), "+" + situationalModifier + " att", "white");
                }
                return crt.getAttackBonus() + modifier;
            }
        }
        public int CalcPcDefense(Player pc, Creature crt)
        {
            int defense = pc.AC;
            return defense;
        }
        public int CalcCreatureDamageToPc(Player pc, Creature crt)
        {
            int dDam = crt.cr_damageDie;
            float damage = (crt.cr_damageNumDice * gv.sf.RandInt(dDam)) + crt.cr_damageAdder;
            if (damage < 0)
            {
                damage = 0;
            }

            float resist = 0;

            if (crt.cr_typeOfDamage.Equals("Acid"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalAcid / 100f));
            }
            else if (crt.cr_typeOfDamage.Equals("Normal"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalNormal / 100f));
            }
            else if (crt.cr_typeOfDamage.Equals("Cold"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalCold / 100f));
            }
            else if (crt.cr_typeOfDamage.Equals("Electricity"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalElectricity / 100f));
            }
            else if (crt.cr_typeOfDamage.Equals("Fire"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalFire / 100f));
            }
            else if (crt.cr_typeOfDamage.Equals("Magic"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalMagic / 100f));
            }
            else if (crt.cr_typeOfDamage.Equals("Poison"))
            {
                resist = (float)(1f - ((float)pc.damageTypeResistanceTotalPoison / 100f));
            }

            int totalDam = (int)(damage * resist);
            if (totalDam < 0)
            {
                totalDam = 0;
            }

            return totalDam;
        }

        public Player targetClosestPC(Creature crt)
        {
            Player pc = null;
            int farDist = 99;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }

            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);
                   
                    if (dist < farDist)
                    {
                        farDist = dist;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='lime'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }
            return pc;
        }

        public Player targetPCWithLeastHPInAttackRange(Creature crt)
        {
            Player pc = null;
            int farDist = 99;
            int lowestHP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }

            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((crt.cr_attRange >= dist) && (p.hp < lowestHP))
                    {
                        lowestHP = p.hp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='lime'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p  in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }
                        
                }
            }
                return pc;
        }

        public Player targetPCWithLeastHPInCombinedRange(Creature crt)
        {
            Player pc = null;
            crt.targetPcTag = "none";
            //float combinedRange = crt.cr_attRange + crt.getMoveDistance() - creatureMoves;
            //int lowestHP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }


            bool attackPossible = false;
            float range = crt.moveDistance - creatureMoves;
            int lowestHPFound = 1000000;
            float interimPathCountAdjustForDiagonalMovesFirst = 999;
            float interimPathCountAdjustForDiagonalMoves = 999;
            List<Coordinate> InterimPath = new List<Coordinate>();
            List<Coordinate> InterimPath2 = new List<Coordinate>();

            //check players in range (facor in attack range)
            foreach (Player p in gv.mod.playerList)
            {
                //only still conscious targets
                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                {
                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                    //{
                    attackPossible = false;
                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                    //run pathFinder to get new location
                    pf.resetGrid(crt);
                    InterimPath.Clear();
                    InterimPath2.Clear();
                    //check findNEwPoint favouring diagonal ath too much
                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                    foreach (Coordinate cord in InterimPath2)
                    {
                        InterimPath.Add(cord);
                    }
                    if (InterimPath != null)
                    {
                        //interimPathCountAdjustForDiagonalMoves = 0;
                        if (InterimPath.Count > 2)
                        {
                            interimPathCountAdjustForDiagonalMovesFirst = 0;
                            for (int i = 1; i < InterimPath.Count - 1; i++)
                            {
                                //it a horizontal/vertical move
                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                {
                                    interimPathCountAdjustForDiagonalMovesFirst++;
                                }
                                //it is a diagonal move
                                else
                                {
                                    interimPathCountAdjustForDiagonalMovesFirst = interimPathCountAdjustForDiagonalMovesFirst + gv.mod.diagonalMoveCost;
                                }
                            }
                        }
                        else if (InterimPath.Count > 0)
                        {
                            interimPathCountAdjustForDiagonalMovesFirst = 0;
                        }


                        //bool attackPossible = false;
                        
                            for (int j = InterimPath.Count -1; j >= 0; j--)
                            {
                                int endX = coordinatesOfPcTheCreatureMovesTowards.X * gv.squareSize + (gv.squareSize / 2);
                                int endY = coordinatesOfPcTheCreatureMovesTowards.Y * gv.squareSize + (gv.squareSize / 2);
                                int startX = InterimPath[j].X * gv.squareSize + (gv.squareSize / 2);
                                int startY = InterimPath[j].Y * gv.squareSize + (gv.squareSize / 2);

                                if (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY)))
                                {
                                    if (CalcDistance(crt, coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y, InterimPath[j].X, InterimPath[j].Y) <= crt.cr_attRange)
                                    {

                                    interimPathCountAdjustForDiagonalMoves = 0;
                                    for (int i = InterimPath.Count - 1; i > j; i--)
                                    {
                                        //it a horizontal/vertical move
                                        if ((InterimPath[i].X == InterimPath[i - 1].X) || (InterimPath[i].Y == InterimPath[i - 1].Y))
                                        {
                                            interimPathCountAdjustForDiagonalMoves++;
                                        }
                                        //it is a diagonal move
                                        else
                                        {
                                            interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                        }
                                    }

                                    if (interimPathCountAdjustForDiagonalMoves <= range)
                                    {
                                        attackPossible = true;
                                        break;
                                    }
                                 }
                              }
                          }

                        /*
                        if ((crt.cr_attRange > 1) && (crt.cr_attRange > (InterimPath.Count-2)))
                        {

                        }
                        */

                        if ((InterimPath.Count >= 2) && (p.hp < lowestHPFound) && (attackPossible) && p.hp > 0 && !p.steathModeOn)
                        {
                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                            lowestHPFound = p.hp;
                            pc = p;
                            crt.targetPcTag = pc.tag;
                        }//if inner
                    }//if outer
                     //}//if
                }//if
            }

            return pc;

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            /*
            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((combinedRange >= dist) && (p.hp < lowestHP))
                    {
                        lowestHP = p.hp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }
            return pc;
            */
        }

        public Player targetPCWithHighestSPInCombinedRange(Creature crt)
        {
            Player pc = null;
            crt.targetPcTag = "none";
            //float combinedRange = crt.cr_attRange + crt.getMoveDistance() - creatureMoves;
            //int lowestHP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }


            bool attackPossible = false;
            float range = crt.moveDistance - creatureMoves;
            int highestSPFound = 0;
            float interimPathCountAdjustForDiagonalMovesFirst = 999;
            float interimPathCountAdjustForDiagonalMoves = 999;
            List<Coordinate> InterimPath = new List<Coordinate>();
            List<Coordinate> InterimPath2 = new List<Coordinate>();

            //check players in range (facor in attack range)
            foreach (Player p in gv.mod.playerList)
            {
                //only still conscious targets
                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                {
                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                    //{
                    attackPossible = false;
                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                    //run pathFinder to get new location
                    pf.resetGrid(crt);
                    InterimPath.Clear();
                    InterimPath2.Clear();
                    //check findNEwPoint favouring diagonal ath too much
                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                    foreach (Coordinate cord in InterimPath2)
                    {
                        InterimPath.Add(cord);
                    }
                    if (InterimPath != null)
                    {
                        //interimPathCountAdjustForDiagonalMoves = 0;
                        if (InterimPath.Count > 2)
                        {
                            interimPathCountAdjustForDiagonalMovesFirst = 0;
                            for (int i = 1; i < InterimPath.Count - 1; i++)
                            {
                                //it a horizontal/vertical move
                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                {
                                    interimPathCountAdjustForDiagonalMovesFirst++;
                                }
                                //it is a diagonal move
                                else
                                {
                                    interimPathCountAdjustForDiagonalMovesFirst = interimPathCountAdjustForDiagonalMovesFirst + gv.mod.diagonalMoveCost;
                                }
                            }
                        }
                        else if (InterimPath.Count > 0)
                        {
                            interimPathCountAdjustForDiagonalMovesFirst = 0;
                        }


                        //bool attackPossible = false;

                        for (int j = InterimPath.Count - 1; j >= 0; j--)
                        {
                            int endX = coordinatesOfPcTheCreatureMovesTowards.X * gv.squareSize + (gv.squareSize / 2);
                            int endY = coordinatesOfPcTheCreatureMovesTowards.Y * gv.squareSize + (gv.squareSize / 2);
                            int startX = InterimPath[j].X * gv.squareSize + (gv.squareSize / 2);
                            int startY = InterimPath[j].Y * gv.squareSize + (gv.squareSize / 2);

                            if (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY)))
                            {
                                if (CalcDistance(crt, coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y, InterimPath[j].X, InterimPath[j].Y) <= crt.cr_attRange)
                                {

                                    interimPathCountAdjustForDiagonalMoves = 0;
                                    for (int i = InterimPath.Count - 1; i > j; i--)
                                    {
                                        //it a horizontal/vertical move
                                        if ((InterimPath[i].X == InterimPath[i - 1].X) || (InterimPath[i].Y == InterimPath[i - 1].Y))
                                        {
                                            interimPathCountAdjustForDiagonalMoves++;
                                        }
                                        //it is a diagonal move
                                        else
                                        {
                                            interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                        }
                                    }

                                    if (interimPathCountAdjustForDiagonalMoves <= range)
                                    {
                                        attackPossible = true;
                                        break;
                                    }
                                }
                            }
                        }

                        /*
                        if ((crt.cr_attRange > 1) && (crt.cr_attRange > (InterimPath.Count-2)))
                        {

                        }
                        */

                        if ((InterimPath.Count >= 2) && (p.sp > highestSPFound) && (attackPossible) && p.hp > 0 && !p.steathModeOn)
                        {
                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                            highestSPFound = p.sp;
                            pc = p;
                            crt.targetPcTag = pc.tag;
                        }//if inner
                    }//if outer
                     //}//if
                }//if
            }

            return pc;

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            /*
            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((combinedRange >= dist) && (p.hp < lowestHP))
                    {
                        lowestHP = p.hp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }
            return pc;
            */
        }

        public Player targetPCWithWorstACInCombinedRange(Creature crt)
        {
            Player pc = null;
            crt.targetPcTag = "none";
            //float combinedRange = crt.cr_attRange + crt.getMoveDistance() - creatureMoves;
            //int lowestHP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }


            bool attackPossible = false;
            float range = crt.moveDistance - creatureMoves;
            int worstACFound = 1000000;
            float interimPathCountAdjustForDiagonalMovesFirst = 999;
            float interimPathCountAdjustForDiagonalMoves = 999;
            List<Coordinate> InterimPath = new List<Coordinate>();
            List<Coordinate> InterimPath2 = new List<Coordinate>();

            //check players in range (facor in attack range)
            foreach (Player p in gv.mod.playerList)
            {
                //only still conscious targets
                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                {
                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                    //{
                    attackPossible = false;
                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                    //run pathFinder to get new location
                    pf.resetGrid(crt);
                    InterimPath.Clear();
                    InterimPath2.Clear();
                    //check findNEwPoint favouring diagonal ath too much
                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                    foreach (Coordinate cord in InterimPath2)
                    {
                        InterimPath.Add(cord);
                    }
                    if (InterimPath != null)
                    {
                        //interimPathCountAdjustForDiagonalMoves = 0;
                        if (InterimPath.Count > 2)
                        {
                            interimPathCountAdjustForDiagonalMovesFirst = 0;
                            for (int i = 1; i < InterimPath.Count - 1; i++)
                            {
                                //it a horizontal/vertical move
                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                {
                                    interimPathCountAdjustForDiagonalMovesFirst++;
                                }
                                //it is a diagonal move
                                else
                                {
                                    interimPathCountAdjustForDiagonalMovesFirst = interimPathCountAdjustForDiagonalMovesFirst + gv.mod.diagonalMoveCost;
                                }
                            }
                        }
                        else if (InterimPath.Count > 0)
                        {
                            interimPathCountAdjustForDiagonalMovesFirst = 0;
                        }


                        //bool attackPossible = false;

                        for (int j = InterimPath.Count - 1; j >= 0; j--)
                        {
                            int endX = coordinatesOfPcTheCreatureMovesTowards.X * gv.squareSize + (gv.squareSize / 2);
                            int endY = coordinatesOfPcTheCreatureMovesTowards.Y * gv.squareSize + (gv.squareSize / 2);
                            int startX = InterimPath[j].X * gv.squareSize + (gv.squareSize / 2);
                            int startY = InterimPath[j].Y * gv.squareSize + (gv.squareSize / 2);

                            if (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY)))
                            {
                                if (CalcDistance(crt, coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y, InterimPath[j].X, InterimPath[j].Y) <= crt.cr_attRange)
                                {

                                    interimPathCountAdjustForDiagonalMoves = 0;
                                    for (int i = InterimPath.Count - 1; i > j; i--)
                                    {
                                        //it a horizontal/vertical move
                                        if ((InterimPath[i].X == InterimPath[i - 1].X) || (InterimPath[i].Y == InterimPath[i - 1].Y))
                                        {
                                            interimPathCountAdjustForDiagonalMoves++;
                                        }
                                        //it is a diagonal move
                                        else
                                        {
                                            interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                        }
                                    }

                                    if (interimPathCountAdjustForDiagonalMoves <= range)
                                    {
                                        attackPossible = true;
                                        break;
                                    }
                                }
                            }
                        }

                        /*
                        if ((crt.cr_attRange > 1) && (crt.cr_attRange > (InterimPath.Count-2)))
                        {

                        }
                        */

                        if ((InterimPath.Count >= 2) && (p.AC < worstACFound) && (attackPossible) && p.hp > 0 && !p.steathModeOn)
                        {
                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                            worstACFound = p.AC;
                            pc = p;
                            crt.targetPcTag = pc.tag;
                        }//if inner
                    }//if outer
                     //}//if
                }//if
            }

            return pc;

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            /*
            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((combinedRange >= dist) && (p.hp < lowestHP))
                    {
                        lowestHP = p.hp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }
            return pc;
            */
        }

        public Player targetPCWithHighestSPInCombinedRangeOLD(Creature crt)
        {
            Player pc = null;
            //float combinedRange = crt.cr_attRange + crt.getMoveDistance() - creatureMoves;
            //int lowestHP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }


            float range = crt.moveDistance + crt.cr_attRange - creatureMoves;
            int highestSPFound = 0;
            float interimPathCountAdjustForDiagonalMoves = 999;
            List<Coordinate> InterimPath = new List<Coordinate>();
            List<Coordinate> InterimPath2 = new List<Coordinate>();

            //check players in range (facor in attack range)
            foreach (Player p in gv.mod.playerList)
            {
                //only still conscious targets
                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                {
                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                    //{
                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                    //run pathFinder to get new location
                    pf.resetGrid(crt);
                    InterimPath.Clear();
                    InterimPath2.Clear();
                    //check findNEwPoint favouring diagonal ath too much
                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                    foreach (Coordinate cord in InterimPath2)
                    {
                        InterimPath.Add(cord);
                    }
                    if (InterimPath != null)
                    {
                        //interimPathCountAdjustForDiagonalMoves = 0;
                        if (InterimPath.Count > 2)
                        {
                            interimPathCountAdjustForDiagonalMoves = 0;
                            for (int i = 1; i < InterimPath.Count - 1; i++)
                            {
                                //it a horizontal/vertical move
                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                {
                                    interimPathCountAdjustForDiagonalMoves++;
                                }
                                //it is a diagonal move
                                else
                                {
                                    interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                }
                            }
                        }
                        else if (InterimPath.Count > 0)
                        {
                            interimPathCountAdjustForDiagonalMoves = 0;
                        }


                        int rangeNegator = 0;
                        if (crt.cr_attRange > 1)
                        {
                            bool negateRange = true;

                            foreach (Coordinate c in InterimPath)
                            {
                                int endX = coordinatesOfPcTheCreatureMovesTowards.X * gv.squareSize + (gv.squareSize / 2);
                                int endY = coordinatesOfPcTheCreatureMovesTowards.Y * gv.squareSize + (gv.squareSize / 2);
                                int startX = c.X * gv.squareSize + (gv.squareSize / 2);
                                int startY = c.Y * gv.squareSize + (gv.squareSize / 2);

                                if (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY)))
                                {
                                    if (CalcDistance(crt, coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y, c.X, c.Y) <= crt.cr_attRange)
                                    {
                                        negateRange = false;
                                        break;
                                    }
                                }
                            }

                            if (negateRange)
                            {
                                rangeNegator = -crt.cr_attRange + 1;
                            }
                        }
                        /*
                        if ((crt.cr_attRange > 1) && (crt.cr_attRange > (InterimPath.Count-2)))
                        {

                        }
                        */

                        if ((InterimPath.Count >= 2) && (p.sp > highestSPFound) && ((interimPathCountAdjustForDiagonalMoves + 1) <= (range - rangeNegator)) && p.hp > 0 && !p.steathModeOn)
                        {
                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                            highestSPFound = p.sp;
                            pc = p;
                            crt.targetPcTag = pc.tag;
                        }//if inner
                    }//if outer
                     //}//if
                }//if
            }

            return pc;

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            /*
            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((combinedRange >= dist) && (p.hp < lowestHP))
                    {
                        lowestHP = p.hp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }
            return pc;
            */
        }

        public Player targetPCWithWorstACInCombinedRangeOLD(Creature crt)
        {
            Player pc = null;
            //float combinedRange = crt.cr_attRange + crt.getMoveDistance() - creatureMoves;
            //int lowestHP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }


            float range = crt.moveDistance + crt.cr_attRange - creatureMoves;
            int worstACFound = 999;
            float interimPathCountAdjustForDiagonalMoves = 999;
            List<Coordinate> InterimPath = new List<Coordinate>();
            List<Coordinate> InterimPath2 = new List<Coordinate>();

            //check players in range (facor in attack range)
            foreach (Player p in gv.mod.playerList)
            {
                //only still conscious targets
                if (p.isAlive() && !p.steathModeOn && !p.isInvisible())
                {
                    //if ((p.combatLocX != coordinatesOfPcTheCreatureMovesTowards.X) || (p.combatLocY != coordinatesOfPcTheCreatureMovesTowards.Y))
                    //{
                    coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                    coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                    //run pathFinder to get new location
                    pf.resetGrid(crt);
                    InterimPath.Clear();
                    InterimPath2.Clear();
                    //check findNEwPoint favouring diagonal ath too much
                    InterimPath2 = pf.findNewPoint(crt, new Coordinate(coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y), false);
                    foreach (Coordinate cord in InterimPath2)
                    {
                        InterimPath.Add(cord);
                    }
                    if (InterimPath != null)
                    {
                        //interimPathCountAdjustForDiagonalMoves = 0;
                        if (InterimPath.Count > 2)
                        {
                            interimPathCountAdjustForDiagonalMoves = 0;
                            for (int i = 1; i < InterimPath.Count - 1; i++)
                            {
                                //it a horizontal/vertical move
                                if ((InterimPath[i].X == InterimPath[i + 1].X) || (InterimPath[i].Y == InterimPath[i + 1].Y))
                                {
                                    interimPathCountAdjustForDiagonalMoves++;
                                }
                                //it is a diagonal move
                                else
                                {
                                    interimPathCountAdjustForDiagonalMoves = interimPathCountAdjustForDiagonalMoves + gv.mod.diagonalMoveCost;
                                }
                            }
                        }
                        else if (InterimPath.Count > 0)
                        {
                            interimPathCountAdjustForDiagonalMoves = 0;
                        }


                        int rangeNegator = 0;
                        if (crt.cr_attRange > 1)
                        {
                            bool negateRange = true;

                            foreach (Coordinate c in InterimPath)
                            {
                                int endX = coordinatesOfPcTheCreatureMovesTowards.X * gv.squareSize + (gv.squareSize / 2);
                                int endY = coordinatesOfPcTheCreatureMovesTowards.Y * gv.squareSize + (gv.squareSize / 2);
                                int startX = c.X * gv.squareSize + (gv.squareSize / 2);
                                int startY = c.Y * gv.squareSize + (gv.squareSize / 2);

                                if (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY)))
                                {
                                    if (CalcDistance(crt, coordinatesOfPcTheCreatureMovesTowards.X, coordinatesOfPcTheCreatureMovesTowards.Y, c.X, c.Y) <= crt.cr_attRange)
                                    {
                                        negateRange = false;
                                        break;
                                    }
                                }
                            }

                            if (negateRange)
                            {
                                rangeNegator = -crt.cr_attRange + 1;
                            }
                        }
                        /*
                        if ((crt.cr_attRange > 1) && (crt.cr_attRange > (InterimPath.Count-2)))
                        {

                        }
                        */

                        if ((InterimPath.Count >= 2) && (p.AC < worstACFound) && ((interimPathCountAdjustForDiagonalMoves + 1) <= (range - rangeNegator)) && p.hp > 0 && !p.steathModeOn)
                        {
                            //coordinatesOfPcTheCreatureMovesTowards.X = p.combatLocX;
                            //coordinatesOfPcTheCreatureMovesTowards.Y = p.combatLocY;
                            //shortestPath = interimPathCountAdjustForDiagonalMoves;
                            worstACFound = p.AC;
                            pc = p;
                            crt.targetPcTag = pc.tag;
                        }//if inner
                    }//if outer
                     //}//if
                }//if
            }

            return pc;

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            /*
            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((combinedRange >= dist) && (p.hp < lowestHP))
                    {
                        lowestHP = p.hp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }
            return pc;
            */
        }

        public Player targetPCWithLeastSPInRange(Creature crt)
        {
            Player pc = null;
            int farDist = 99;
            int lowestSP = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }

            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((crt.cr_attRange >= dist) && (p.sp < lowestSP))
                    {
                        lowestSP = p.sp;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }

            return pc;
        }

        public Player targetPCWithWorstACInRange(Creature crt)
        {
            Player pc = null;
            int farDist = 99;
            int worstAC = 10000000;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }

            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if ((crt.cr_attRange >= dist) && (p.sp < worstAC))
                    {
                        worstAC = p.AC;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='lime'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }

            if (crt.targetPcTag != "none")
            {
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.tag == crt.targetPcTag)
                    {
                        pc = p;
                    }

                }
            }
            return pc;
        }

        public Player targetPCWithLeastHPAnywhere(Creature crt)
        {
            Player pc = null;
            int farDist = 99;
            bool doDeStealth = true;

            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }

            foreach (Player p in gv.mod.playerList)
            {
                if ((!p.isDead()) && (p.hp > 0) && (!p.steathModeOn))
                {
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);

                    if (dist < farDist)
                    {
                        farDist = dist;
                        pc = p;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='lime'>target:" + pc.name + "</font><BR>");
                        }
                    }
                }
            }
            return pc;
        }

        public Creature targetClosestCreature(Creature crt)
        {
            Creature crtReturn = null;
            int farDist = 99;
            //bool doDeStealth = true;
            /*
            foreach (Player p in gv.mod.playerList)
            {
                if ((p.hp > 0) && (!p.steathModeOn))
                {
                    doDeStealth = false;
                    break;
                }
            }

            if (doDeStealth)
            {
                foreach (Player p in gv.mod.playerList)
                {
                    p.steathModeOn = false;
                }
                gv.cc.addLogText("<font color='red'> All stealthers are discovered </font><BR>");
            }
            */

            foreach (Creature crtByCounter in gv.mod.currentEncounter.encounterCreatureList)
            {
                if ((crtByCounter.hp > 0) && (crtByCounter.cr_tag != crt.cr_tag))
                {
                    //int dist = CalcDistance(crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);
                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, crtByCounter.combatLocX, crtByCounter.combatLocY);
                    /*
                    if (dist == farDist)
                    {
                        //since at same distance, do a random check to see if switch or stay with current PC target
                        if (gv.sf.RandInt(20) > 10)
                        {
                            //switch target
                            pc = p;
                            if (gv.mod.debugMode)
                            {
                                gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                            }
                        }
                    }
                    */
                    if (dist < farDist)
                    {
                        farDist = dist;
                        crtReturn = crtByCounter;
                        if (gv.mod.debugMode)
                        {
                            gv.cc.addLogText("<font color='red'>target:" + crtReturn.cr_name + "</font><BR>");
                        }
                    }
                }
            }
            return crtReturn;
        }

        public Creature targetClosestCreatureInRangeAndVisible(Creature crt)
        {
            Creature crtReturn = null;
            int farDist = 99;
            

            foreach (Creature crtByCounter in gv.mod.currentEncounter.encounterCreatureList)
            {
                if ((crtByCounter.hp > 0) && (crtByCounter.cr_tag != crt.cr_tag))
                {

                    int endX = crtByCounter.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int endY = crtByCounter.combatLocY * gv.squareSize + (gv.squareSize / 2);
                    int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);

                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, crtByCounter.combatLocX, crtByCounter.combatLocY);

                    if ((dist <= gv.sf.SpellToCast.range) && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                    {


                        //int dist = CalcDistance(crt.combatLocX, crt.combatLocY, p.combatLocX, p.combatLocY);
                        //int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, crtByCounter.combatLocX, crtByCounter.combatLocY);
                        /*
                        if (dist == farDist)
                        {
                            //since at same distance, do a random check to see if switch or stay with current PC target
                            if (gv.sf.RandInt(20) > 10)
                            {
                                //switch target
                                pc = p;
                                if (gv.mod.debugMode)
                                {
                                    gv.cc.addLogText("<font color='yellow'>target:" + pc.name + "</font><BR>");
                                }
                            }
                        }
                        */
                        if (dist < farDist)
                        {
                            farDist = dist;
                            crtReturn = crtByCounter;
                            if (gv.mod.debugMode)
                            {
                                gv.cc.addLogText("<font color='red'>target:" + crtReturn.cr_name + "</font><BR>");
                            }
                        }
                    }
                }
            }
            return crtReturn;
        }

        public Coordinate targetBestPointLocation(Creature crt)
        {
            Coordinate targetLoc = new Coordinate(-1, -1);
            //JamesManhattan Utility maximization function for the VERY INTELLIGENT CREATURE CASTER
            int utility = 0; //utility
            int optimalUtil = 0; //optimal utility, a storage of the highest achieved
            Coordinate selectedPoint = new Coordinate(crt.combatLocX, crt.combatLocY); //Initial Select Point is Creature itself, then loop through all squares within range!
            for (int y = gv.sf.SpellToCast.range; y > -gv.sf.SpellToCast.range; y--)  //start at far range and work backwards does a pretty good job of avoiding hitting allies.
            {
                for (int x = gv.sf.SpellToCast.range; x > -gv.sf.SpellToCast.range; x--)
                {
                    utility = 0; //reset utility for each point tested
                    selectedPoint = new Coordinate(crt.combatLocX + x, crt.combatLocY + y);

                    //check if selected point is a valid location on combat map
                    if ((selectedPoint.X < 0) || (selectedPoint.X > gv.mod.currentEncounter.MapSizeX - 1) || (selectedPoint.Y < 0) || (selectedPoint.Y > gv.mod.currentEncounter.MapSizeY - 1))
                    {
                        continue;
                    }

                    //check if selected point is in LoS, if not skip this point
                    int endX = selectedPoint.X * gv.squareSize + (gv.squareSize / 2);
                    int endY = selectedPoint.Y * gv.squareSize + (gv.squareSize / 2);
                    int startX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int startY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                    if (!isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY)))
                    {
                        continue;
                    }

                    if (selectedPoint == new Coordinate(crt.combatLocX, crt.combatLocY))
                    {
                        utility -= 4; //the creature at least attempts to avoid hurting itself, but if surrounded might fireball itself!
                        if (crt.hp <= crt.hpMax / 4) //caster is wounded, definately avoids itself.
                        {
                            utility -= 4;
                        }
                    }

                    //get the list of AFFECTED SQUARES AND SEE IF A CREATURE is on it
                    if (gv.sf.SpellToCast.aoeShape == AreaOfEffectShape.Line || (gv.sf.SpellToCast.aoeShape == AreaOfEffectShape.Cone))
                    {
                        List<Coordinate> targetSquareList = new List<Coordinate>();
                        targetSquareList = gv.sf.CreateAoeSquaresListWithReturnValue(crt, selectedPoint, gv.sf.SpellToCast.aoeShape, gv.sf.SpellToCast.aoeRadius);
                        foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList) //if its allies are in the burst subtract a point, or half depending on how evil it is.
                        {
                            Coordinate crtCoord = new Coordinate();
                            crtCoord.X = crtr.combatLocX;
                            crtCoord.Y = crtr.combatLocY;
                            foreach (Coordinate c in targetSquareList)
                            {
                                if (c.X == crtCoord.X && c.Y == crtCoord.Y)
                                {
                                    utility -= 1;
                                }
                            }
                        }
                    }
                    else
                    {
                        foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList) //if its allies are in the burst subtract a point, or half depending on how evil it is.
                        {
                            //if (this.CalcDistance(crtr.combatLocX, crtr.combatLocY, selectedPoint.X, selectedPoint.Y) <= gv.sf.SpellToCast.aoeRadius) //if friendly creatures are in the AOE burst, count how many, subtract 0.5 for each, evil is evil
                            //{
                            if (this.CalcDistance(crtr, crtr.combatLocX, crtr.combatLocY, selectedPoint.X, selectedPoint.Y) <= gv.sf.SpellToCast.aoeRadius) //if friendly creatures are in the AOE burst, count how many, subtract 0.5 for each, evil is evil  
                            {

                                utility -= 1;
                            }
                        }
                    }
                    foreach (Player tgt_pc in gv.mod.playerList)
                    {
                        //if ((this.CalcDistance(tgt_pc.combatLocX, tgt_pc.combatLocY, selectedPoint.X, selectedPoint.Y) <= gv.sf.SpellToCast.aoeRadius) && (tgt_pc.hp > 0)) //if players are in the AOE burst, count how many, total count is utility  //&& sf.GetLocalInt(tgt_pc.Tag, "StealthModeOn") != 1  <-throws an annoying message if not found!!
                        //{
                        
                            List<Coordinate> targetSquareList = new List<Coordinate>();
                            targetSquareList = gv.sf.CreateAoeSquaresListWithReturnValue(crt, selectedPoint, gv.sf.SpellToCast.aoeShape, gv.sf.SpellToCast.aoeRadius);
                            //foreach (Creature crtr in gv.mod.currentEncounter.encounterCreatureList) //if its allies are in the burst subtract a point, or half depending on how evil it is.
                            //{
                                Coordinate playerCoord = new Coordinate();
                                playerCoord.X = tgt_pc.combatLocX;
                                playerCoord.Y = tgt_pc.combatLocY;
                        if (gv.sf.SpellToCast.aoeShape == AreaOfEffectShape.Line || (gv.sf.SpellToCast.aoeShape == AreaOfEffectShape.Cone))
                        {
                            //***********************************
                            foreach (Coordinate c in targetSquareList)
                                {
                                    if (c.X == playerCoord.X && c.Y == playerCoord.Y)
                                    {
                                    if (tgt_pc.hp > 0 && tgt_pc.hp < (float)(tgt_pc.hpMax/4f))
                                    {
                                        utility += 3;
                                    }
                                    else if (tgt_pc.hp > 0)
                                    {
                                        utility += 2;
                                    }
                                   
                                        if ((utility > optimalUtil) && (utility > -4))
                                        {
                                            //optimal found, choose this point
                                            optimalUtil = utility;
                                            targetLoc = selectedPoint;
                                        }
                                    }
                                }

                                //***********************************
                                /*
                                if (targetSquareList.Contains(crtCoord))
                                {
                                    utility += 2;
                                    if (utility > optimalUtil)
                                    {
                                        //optimal found, choose this point
                                        optimalUtil = utility;
                                        targetLoc = selectedPoint;
                                    }
                                }
                                */
                            //}
                        }
                        else if ((this.CalcDistance(null, tgt_pc.combatLocX, tgt_pc.combatLocY, selectedPoint.X, selectedPoint.Y) <= gv.sf.SpellToCast.aoeRadius) && (tgt_pc.hp > 0)) //if players are in the AOE burst, count how many, total count is utility  //&& sf.GetLocalInt(tgt_pc.Tag, "StealthModeOn") != 1  <-throws an annoying message if not found!!  
                        {
                            if (tgt_pc.hp > 0 && tgt_pc.hp < (float)(tgt_pc.hpMax / 4f))
                            {
                                utility += 3;
                            }
                            else if (tgt_pc.hp > 0)
                            {
                                utility += 2;
                            }
                            
                            if ((utility > optimalUtil) && (utility > -4))
                            {
                                //optimal found, choose this point
                                optimalUtil = utility;
                                targetLoc = selectedPoint;
                            }
                        }
                    }
                    if (gv.mod.debugMode)
                    {
                        gv.cc.addLogText("<font color='white'>(" + selectedPoint.X + "," + selectedPoint.Y + "):" + utility + "</font><BR>");
                    }
                }
            }

            return targetLoc;
        }
        public int CalcDistance(Creature crt, int locCrX, int locCrY, int locPcX, int locPcY)
        {
            //KARL: transpose IBMini changes
            /*
            int dist = 0;
            int deltaX = (int)Math.Abs((locCrX - locPcX));
            int deltaY = (int)Math.Abs((locCrY - locPcY));
            if (deltaX > deltaY)
                dist = deltaX;
            else
                dist = deltaY;
                */

            int dist = 999;
            if (crt == null)
            {
                int deltaX = (int)Math.Abs((locCrX - locPcX));
                int deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY)
                    return deltaX;
                else
                    return deltaY;
            }
            //go through all squares of creature and return the lowest distance  
            int crtSize = crt.creatureSize; //1=normal, 2=wide, 3=tall, 4=large  
                                            //crt normal  
            if (crtSize == 1)
            {
                int deltaX = (int)Math.Abs((locCrX - locPcX));
                int deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY)
                    dist = deltaX;
                else
                    dist = deltaY;
            }
            //crt wide  
            else if (crtSize == 2)
            {
                int dist1 = 999;
                int dist2 = 999;
                //main square  
                int deltaX = (int)Math.Abs((locCrX - locPcX));
                int deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY) { dist1 = deltaX; }
                else { dist1 = deltaY; }
                //right square  
                deltaX = (int)Math.Abs((locCrX + 1 - locPcX));
                deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY) { dist2 = deltaX; }
                else { dist2 = deltaY; }
                //see which is lower  
                if (dist1 > dist2) { dist = dist2; }
                else { dist = dist1; }
            }
            //crt tall  
            else if (crtSize == 3)
            {
                int dist1 = 999;
                int dist2 = 999;
                //main square  
                int deltaX = (int)Math.Abs((locCrX - locPcX));
                int deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY) { dist1 = deltaX; }
                else { dist1 = deltaY; }
                //lower square  
                deltaX = (int)Math.Abs((locCrX - locPcX));
                deltaY = (int)Math.Abs((locCrY + 1 - locPcY));
                if (deltaX > deltaY) { dist2 = deltaX; }
                else { dist2 = deltaY; }
                //see which is lower  
                if (dist1 > dist2) { dist = dist2; }
                else { dist = dist1; }
            }
            //crt large  
            else if (crtSize == 4)
            {
                int dist1 = 999;
                int dist2 = 999;
                int dist3 = 999;
                int dist4 = 999;
                //main square  
                int deltaX = (int)Math.Abs((locCrX - locPcX));
                int deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY) { dist1 = deltaX; }
                else { dist1 = deltaY; }
                //right square  
                deltaX = (int)Math.Abs((locCrX + 1 - locPcX));
                deltaY = (int)Math.Abs((locCrY - locPcY));
                if (deltaX > deltaY) { dist2 = deltaX; }
                else { dist2 = deltaY; }
                //lower square  
                deltaX = (int)Math.Abs((locCrX - locPcX));
                deltaY = (int)Math.Abs((locCrY + 1 - locPcY));
                if (deltaX > deltaY) { dist3 = deltaX; }
                else { dist3 = deltaY; }
                //lower right square  
                deltaX = (int)Math.Abs((locCrX + 1 - locPcX));
                deltaY = (int)Math.Abs((locCrY + 1 - locPcY));
                if (deltaX > deltaY) { dist4 = deltaX; }
                else { dist4 = deltaY; }
                //see which is lower  
                if (dist1 < dist) { dist = dist1; }
                if (dist2 < dist) { dist = dist2; }
                if (dist3 < dist) { dist = dist3; }
                if (dist4 < dist) { dist = dist4; }
            }

            return dist;
        }
        public Creature GetCreatureWithLowestHP()
        {
            int lowHP = 999;
            Creature returnCrt = null;
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crt.hp > 0)
                {
                    if (crt.hp < lowHP)
                    {
                        lowHP = crt.hp;
                        returnCrt = crt;
                    }
                }
            }
            return returnCrt;
        }

        public Creature GetCreatureWithMostDamaged(Creature creatureCaster)
        {
            int damaged = 0;
            Creature returnCrt = null;
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crt.hp > 0)
                {
                    int endX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int endY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                    int startX = creatureCaster.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int startY = creatureCaster.combatLocY * gv.squareSize + (gv.squareSize / 2);

                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, creatureCaster.combatLocX, creatureCaster.combatLocY);

                    if ((dist <= gv.sf.SpellToCast.range) && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                    {
                        int dam = crt.hpMax - crt.hp;
                        float hpProxy = crt.hp;
                        float hpMaxProxy = crt.hpMax;
                        float injuryLevel = (1 - (float)(hpProxy/hpMaxProxy)) * 100;
                        if (injuryLevel >= crt.percentRequirementOfTargetInjuryForHealSpells)
                        {
                            if (dam > damaged)
                            {
                                damaged = dam;
                                returnCrt = crt;
                            }
                        }
                    }
                }
            }
            return returnCrt;
        }

        public Creature GetCreatureWithMostSPMissing(Creature creatureCaster)
        {
            int damaged = 0;
            Creature returnCrt = null;
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crt.hp > 0)
                {
                    int endX = crt.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int endY = crt.combatLocY * gv.squareSize + (gv.squareSize / 2);
                    int startX = creatureCaster.combatLocX * gv.squareSize + (gv.squareSize / 2);
                    int startY = creatureCaster.combatLocY * gv.squareSize + (gv.squareSize / 2);

                    int dist = CalcDistance(crt, crt.combatLocX, crt.combatLocY, creatureCaster.combatLocX, creatureCaster.combatLocY);

                    if ((dist <= gv.sf.SpellToCast.range) && (isVisibleLineOfSight(new Coordinate(startX, startY), new Coordinate(endX, endY))))
                    {
                        int dam = crt.spMax - crt.sp;
                        float spProxy = crt.sp;
                        float spMaxProxy = crt.spMax;
                        float injuryLevel = (1 - (float)(spProxy / spMaxProxy)) * 100;
                        if (injuryLevel >= crt.percentRequirementOfTargetSPLossForRestoreSPSpells)
                        {
                            if (dam > damaged)
                            {
                                damaged = dam;
                                returnCrt = crt;
                            }
                        }
                    }
                }
            }
            return returnCrt;
        }


        public Creature GetNextAdjacentCreature(Player pc)
        {
            foreach (Creature nextCrt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (alreadyTargetedCreatureTagsList.Contains(nextCrt.cr_tag))
                {
                    //already targeted this creature once so skip  
                    continue;
                }

                //if ((CalcDistance(nextCrt.combatLocX, nextCrt.combatLocY, pc.combatLocX, pc.combatLocY) < 2) && (nextCrt.hp > 0))
                if ((CalcDistance(nextCrt, nextCrt.combatLocX, nextCrt.combatLocY, pc.combatLocX, pc.combatLocY) < 2) && (nextCrt.hp > 0))
                {
                    alreadyTargetedCreatureTagsList.Add(nextCrt.cr_tag);
                    return nextCrt;
                }
            }
            return null;
        }
        public Creature GetCreatureByTag(String tag)
        {
            foreach (Creature crt in gv.mod.currentEncounter.encounterCreatureList)
            {
                if (crt.cr_tag.Equals(tag))
                {
                    return crt;
                }
            }
            return null;
        }
    }
}

