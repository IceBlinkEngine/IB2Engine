using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using Bitmap = SharpDX.Direct2D1.Bitmap;
using Color = SharpDX.Color;

namespace IceBlink2
{
    public class ScreenMainMap
    {
        //public gv.module gv.mod;
        public GameView gv;
        public IB2UILayout mainUiLayout = null;
        public bool isMoving = false;
        public bool showMiniMap = false;
        public bool showClock = false;
        public bool showFullParty = true;
        public bool showMoveKeys = false;
        public bool showArrows = true;
        public bool hideClock = false;
        public int shifter = 0;
        public int shifterY = 0;
        public float shifterDelayCounter = 0;
        public bool shifterRise = true;
        public float shifterYDelayCounter = 0;
        public bool shifterYRise = true;
        public float flicker = 0;
        public float flicker2 = 0;
        public float flickerDelayCounter = 0;
        public bool flickerRise = true;
        public bool shifterPause = false;

        /*private IbbButton btnParty = null;
        private IbbButton btnJournal = null;
        private IbbButton btnSettings = null;
        private IbbButton btnSave = null;
        private IbbButton btnCastOnMainMap = null;
        private IbbButton btnWait = null;
        public IbbToggleButton tglFullParty = null;
        public IbbToggleButton tglMiniMap = null;
        public IbbToggleButton tglGrid = null;
        public IbbToggleButton tglInteractionState = null;
        public IbbToggleButton tglAvoidConversation = null;
        public IbbToggleButton tglClock = null;*/
        public List<FloatyText> floatyTextPool = new List<FloatyText>();
        public List<FloatyTextByPixel> floatyTextByPixelPool = new List<FloatyTextByPixel>();
        public int mapStartLocXinPixels;
        public int movementDelayInMiliseconds = 100;
        private long timeStamp = 0;
        private bool finishedMove = true;
        public Bitmap minimap = null;
        public Bitmap fullScreenEffect1 = null;
        public Bitmap fullScreenEffect2 = null;
        public Bitmap fullScreenEffect3 = null;
        public Bitmap fullScreenEffect4 = null;
        public Bitmap fullScreenEffect5 = null;
        public Bitmap fullScreenEffect6 = null;
        public Bitmap fullScreenEffect7 = null;
        public Bitmap fullScreenEffect8 = null;
        public Bitmap fullScreenEffect9 = null;
        public Bitmap fullScreenEffect10 = null;
        public List<Sprite> spriteList = new List<Sprite>();

        public ScreenMainMap(Module m, GameView g)
        {
            //gv.mod = m;
            gv = g;
            mapStartLocXinPixels = 0 * gv.squareSize + gv.oXshift;
            loadMainUILayout();
            //setControlsStart();
            //setToggleButtonsStart();            
        }
        public void loadMainUILayout()
        {
            try
            {
                if (File.Exists(gv.cc.GetModulePath() + "\\data\\MainUILayout.json"))
                {
                    using (StreamReader file = File.OpenText(gv.cc.GetModulePath() + "\\data\\MainUILayout.json"))
                    {
                        JsonSerializer serializer = new JsonSerializer();
                        mainUiLayout = (IB2UILayout)serializer.Deserialize(file, typeof(IB2UILayout));
                        mainUiLayout.setupIB2UILayout(gv);
                    }
                }
                else
                {
                    using (StreamReader file = File.OpenText(gv.mainDirectory + "\\default\\NewModule\\data\\MainUILayout.json"))
                    {
                        JsonSerializer serializer = new JsonSerializer();
                        mainUiLayout = (IB2UILayout)serializer.Deserialize(file, typeof(IB2UILayout));
                        mainUiLayout.setupIB2UILayout(gv);
                    }
                }

                IB2ToggleButton tgl = mainUiLayout.GetToggleByTag("tglMiniMap");
                if (tgl != null)
                {
                    showMiniMap = tgl.toggleOn;
                }

                IB2ToggleButton tgl2 = mainUiLayout.GetToggleByTag("tglClock");
                if (tgl2 != null)
                {
                    showClock = tgl2.toggleOn;
                }
                IB2ToggleButton tgl3 = mainUiLayout.GetToggleByTag("tglFullParty");
                if (tgl3 != null)
                {
                    showFullParty = tgl3.toggleOn;
                }

                IB2ToggleButton tgl4 = mainUiLayout.GetToggleByTag("tglMoveKeys");
                if (tgl4 != null)
                {
                    showMoveKeys = tgl4.toggleOn;
                }
                foreach (IB2Panel pnl in mainUiLayout.panelList)
                {
                    if (pnl.tag.Equals("logPanel"))
                    {
                        float sqrW = (float)gv.screenWidth / (gv.squaresInWidth + 2f / 10f);
                        float sqrH = (float)gv.screenHeight / (gv.squaresInHeight + 3f / 10f);
                        gv.log = pnl.logList[0];
                        gv.cc.addLogText("red", "screenDensity: " + gv.screenDensity);
                        gv.cc.addLogText("fuchsia", "screenWidth: " + gv.screenWidth);
                        gv.cc.addLogText("lime", "screenHeight: " + gv.screenHeight);
                        gv.cc.addLogText("yellow", "squareSize: " + gv.squareSize);
                        gv.cc.addLogText("yellow", "sqrW: " + sqrW);
                        gv.cc.addLogText("yellow", "sqrH: " + sqrH);
                        gv.cc.addLogText("yellow", "");
                        gv.cc.addLogText("red", "Welcome to " + gv.mod.moduleLabelName);
                        gv.cc.addLogText("fuchsia", "You can scroll this message log box, use mouse wheel");
                        gv.cc.addLogText("yellow", "'x' will hide/show all UI panels");
                    }

                    if (gv.mod.useMinimalisticUI)
                    {
                        if (pnl.tag.Equals("arrowPanel"))
                        {
                            pnl.hiding = true;
                            pnl.showing = false;
                            showArrows = false;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error Loading MainUILayout.json: " + ex.ToString());
                gv.errorLog(ex.ToString());
            }
        }
        public void saveUILayout()
        {
            try
            {
                //string filepath = gv.mainDirectory + "\\MainUILayout.json";
                string filepath = gv.cc.GetModulePath() + "\\data\\MainUILayout.json";
                string json = JsonConvert.SerializeObject(mainUiLayout, Newtonsoft.Json.Formatting.Indented);
                using (StreamWriter sw = new StreamWriter(filepath))
                {
                    sw.Write(json.ToString());
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
            }
        }
        /*public void setControlsStart()
        {
            int pW = (int)((float)gv.screenWidth / 100.0f);
            int pH = (int)((float)gv.screenHeight / 100.0f);
            int padW = gv.squareSize / 6;
            int hotkeyShift = 0;
            if (gv.useLargeLayout)
            {
                hotkeyShift = 1;
            }


            if (btnWait == null)
            {
                btnWait = new IbbButton(gv, 0.8f);
                btnWait.Text = "WAIT";
                btnWait.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnWait.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnWait.X = 17 * gv.squareSize - 3*gv.oXshift;
                //btnWait.Y = 8 * gv.squareSize + pH * 2;
                btnWait.X = gv.cc.pnlArrows.LocX + 1 * gv.squareSize + gv.squareSize / 2;
                btnWait.Y = gv.cc.pnlArrows.LocY + 1 * gv.squareSize + gv.pS;
                btnWait.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnWait.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnParty == null)
            {
                btnParty = new IbbButton(gv, 0.8f);
                btnParty.HotKey = "P";
                btnParty.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnParty.Img2 = gv.cc.LoadBitmap("btnparty"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnparty);
                btnParty.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnParty.X = 7 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnParty.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnParty.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 0) * gv.squareSize;
                btnParty.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnParty.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnParty.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnJournal == null)
            {
                btnJournal = new IbbButton(gv, 0.8f);
                btnJournal.HotKey = "J";
                btnJournal.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnJournal.Img2 = gv.cc.LoadBitmap("btnjournal"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnjournal);
                btnJournal.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnJournal.X = 9 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnJournal.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnJournal.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 2) * gv.squareSize;
                btnJournal.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnJournal.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnJournal.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnSettings == null)
            {
                btnSettings = new IbbButton(gv, 1.0f);
                btnSettings.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnSettings.Img2 = gv.cc.LoadBitmap("btnsettings"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnsettings);
                btnSettings.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnSettings.X = 10 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnSettings.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnSettings.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 3) * gv.squareSize;
                btnSettings.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnSettings.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSettings.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnCastOnMainMap == null)
            {
                btnCastOnMainMap = new IbbButton(gv, 0.8f);
                btnCastOnMainMap.HotKey = "C";
                btnCastOnMainMap.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnCastOnMainMap.Img2 = gv.cc.LoadBitmap("btnspell"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnspell);
                btnCastOnMainMap.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnCastOnMainMap.X = 11 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnCastOnMainMap.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnCastOnMainMap.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 4) * gv.squareSize;
                btnCastOnMainMap.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnCastOnMainMap.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnCastOnMainMap.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnSave == null)
            {
                btnSave = new IbbButton(gv, 0.8f);
                btnSave.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnSave.ImgOff = gv.cc.LoadBitmap("btn_small_off");
                btnSave.Img2 = gv.cc.LoadBitmap("btndisk"); // BitmapFactory.decodeResource(getResources(), R.drawable.btndisk);
                btnSave.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnSave.X = 12 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnSave.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnSave.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 5) * gv.squareSize;
                btnSave.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnSave.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSave.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
        }*/
        /*public void setToggleButtonsStart()
        {
            int pW = (int)((float)gv.screenWidth / 100.0f);
            int pH = (int)((float)gv.screenHeight / 100.0f);
            int padW = gv.squareSize / 6;

            if (tglFullParty == null)
            {
                tglFullParty = new IbbToggleButton(gv);
                tglFullParty.ImgOn = gv.cc.LoadBitmap("tgl_fullparty_on");
                tglFullParty.ImgOff = gv.cc.LoadBitmap("tgl_fullparty_off");
                //tglFullParty.X = 0 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglFullParty.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglFullParty.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglFullParty.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglFullParty.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglFullParty.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglFullParty.toggleOn = true;
            }
            if (tglMiniMap == null)
            {
                tglMiniMap = new IbbToggleButton(gv);
                tglMiniMap.ImgOn = gv.cc.LoadBitmap("tgl_minimap_on");
                tglMiniMap.ImgOff = gv.cc.LoadBitmap("tgl_minimap_off");
                //tglMiniMap.X = 4 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglMiniMap.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglMiniMap.X = gv.cc.pnlToggles.LocX + 2 * gv.squareSize + gv.squareSize / 4;
                tglMiniMap.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglMiniMap.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglMiniMap.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglMiniMap.toggleOn = false;
            }
            if (tglGrid == null)
            {
                tglGrid = new IbbToggleButton(gv);
                tglGrid.ImgOn = gv.cc.LoadBitmap("tgl_grid_on");
                tglGrid.ImgOff = gv.cc.LoadBitmap("tgl_grid_off");
                //tglGrid.X = 1 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglGrid.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglGrid.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglGrid.Y = gv.cc.pnlToggles.LocY + 1 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglGrid.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglGrid.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglGrid.toggleOn = true;
            }
            if (tglClock == null)
            {
                tglClock = new IbbToggleButton(gv);
                tglClock.ImgOn = gv.cc.LoadBitmap("tgl_clock_on");
                tglClock.ImgOff = gv.cc.LoadBitmap("tgl_clock_off");
                //tglClock.X = 2 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglClock.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglClock.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglClock.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglClock.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglClock.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglClock.toggleOn = true;
            }
            if (tglInteractionState == null)
            {
                tglInteractionState = new IbbToggleButton(gv);
                tglInteractionState.ImgOn = gv.cc.LoadBitmap("tgl_state_on");
                tglInteractionState.ImgOff = gv.cc.LoadBitmap("tgl_state_off");
                //tglInteractionState.X = 1 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglInteractionState.Y = 8 * (gv.squareSize) + (gv.squareSize / 2);
                tglInteractionState.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglInteractionState.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglInteractionState.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglInteractionState.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglInteractionState.toggleOn = false;
            }
            if (tglAvoidConversation == null)
            {
                tglAvoidConversation = new IbbToggleButton(gv);
                tglAvoidConversation.ImgOn = gv.cc.LoadBitmap("tgl_avoidConvo_on");
                tglAvoidConversation.ImgOff = gv.cc.LoadBitmap("tgl_avoidConvo_off");
                //tglAvoidConversation.X = 0 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglAvoidConversation.Y = 8 * (gv.squareSize) + (gv.squareSize / 2);
                tglAvoidConversation.X = gv.cc.pnlToggles.LocX + 2 * gv.squareSize + gv.squareSize / 4;
                tglAvoidConversation.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglAvoidConversation.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglAvoidConversation.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglAvoidConversation.toggleOn = false;
            }
        }*/

        public void StopScrollingOnBlocked()
        {
            if (gv.mod.useScrollingSystem)
            {
                gv.mod.isScrollingNow = false;
                gv.mod.scrollingTimer = 0;
            }
        }

        //MAIN SCREEN UPDATE
        public void Update(int elapsed)
        {
            //scrollingSystem
            if (gv.mod.useScrollingSystem)
            {
                if (gv.mod.isScrollingNow)
                {
                    doScrolling(elapsed);
                }
            }
            
            //prop animation code
            doPropAnimations(elapsed);

            if (gv.moveTimerRuns)
            {
                int x = gv.mousePositionX - (int)(gv.squareSize * 15f / 100f);
                int y = gv.mousePositionY - (int)(gv.squareSize * 55f / 100f);

                int xDistanceFromCenter = x - (int)(gv.screenWidth / 2f);
                if (xDistanceFromCenter < 0)
                {
                    xDistanceFromCenter = xDistanceFromCenter * -1;
                }

                int yDistanceFromCenter = y - (int)(gv.screenHeight / 2f);
                if (yDistanceFromCenter < 0)
                {
                    yDistanceFromCenter = yDistanceFromCenter * -1;
                }

                int moveSpeed = 0;
                if (yDistanceFromCenter >= xDistanceFromCenter)
                {
                    moveSpeed = (int)(yDistanceFromCenter * 0.8f);
                }
                else
                {
                    moveSpeed = (int)(xDistanceFromCenter * 0.8f);
                }

                if (moveSpeed > 2.5f * gv.squareSize)
                {
                    moveSpeed = (int)(2.5f * gv.squareSize);
                }

                gv.moveTimerCounter += (elapsed * moveSpeed / gv.squareSize);

                if (gv.moveTimerCounter >= 150)
                {
                    isMoving = true;
                }

                if (gv.moveTimerCounter >= 300)
                {
                    gv.moveTimerCounter = 0;
                    //int x = gv.mousePositionX - (int)(gv.squareSize * 4f / 10f);
                    //int y = gv.mousePositionY - (int)(gv.squareSize * 55f / 100f);
                    int gridX = x / gv.squareSize;
                    int gridY = y / gv.squareSize;
                    int actualx = gv.mod.PlayerLocationX + (gridX - gv.playerOffsetX);
                    int actualy = gv.mod.PlayerLocationY + (gridY - gv.playerOffsetY);

                    if (gv.mod.PlayerLocationX == actualx && gv.mod.PlayerLocationY - 1 >= actualy)
                    {
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            bool bumpPropExists = false;
                            bool bumpTriggerExists = false;
                            Trigger bumpTrigger = new Trigger();
                            Prop bumpProp = new Prop();

                            if (gv.mod.PlayerLocationY > 0)
                            {
                                foreach (Trigger t in gv.mod.currentArea.Triggers)
                                {
                                    //migh add isBumpTRigger requirement here
                                    if (t.Enabled)
                                    {
                                        foreach (Coordinate p in t.TriggerSquaresList)
                                        {
                                            if ((p.X == gv.mod.PlayerLocationX) && (p.Y == gv.mod.PlayerLocationY - 1))
                                            {
                                                bumpTriggerExists = true;
                                                bumpTrigger = t;
                                                break;
                                            }
                                        }
                                    }
                                }

                                foreach (Prop p in gv.mod.currentArea.Props)
                                {
                                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                    {
                                        if ((p.LocationX == gv.mod.PlayerLocationX) && (p.LocationY == gv.mod.PlayerLocationY - 1))
                                        {
                                            bumpPropExists = true;
                                            bumpProp = p;
                                            gv.sf.ThisProp = bumpProp;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (gv.mod.PlayerLocationY > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY - 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isSecretPassage)
                                    {
                                         gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationY--;
                                        gv.mod.PlayerLocationY--;
                                        gv.mod.drawPartyDirection = "down";
                                        gv.mod.breakActiveSearch = false;
                                        gv.cc.doUpdate();
                                    }
                                    else
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationY--;
                                        gv.mod.drawPartyDirection = "down";
                                        gv.mod.breakActiveSearch = false;
                                        //gv.cc.doUpdate();
                                        //gv.cc.doUpdate();
                                        if (!gv.mod.wasSuccessfulPush)
                                        {
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.wasSuccessfulPush = false;
                                        }

                                    }
                                }
                                else if (bumpPropExists || bumpTriggerExists)
                                {
                                    StopScrollingOnBlocked();

                                    if (bumpPropExists)
                                    {
                                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                        {
                                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                        }

                                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                                        { 
                                            //called from prop add?
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                        }

                                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                                        {
                                            gv.mod.EncounterOfTurnDone = true;
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.calledEncounterFromProp = true;
                                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                        }

                                        if (bumpProp.scriptFilename != "none")
                                        {
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                            //code for floaty shown on prop upon script activation
                                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                            {
                                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                            }

                                            //code for log, to do
                                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                            {
                                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                            }

                                            if (bumpProp.onlyOnce)
                                            {
                                                bumpProp.isShown = false;
                                                bumpProp.isActive = false;
                                            }                                            
                                        }
                                    }
                                    else if (bumpTriggerExists)
                                    {
                                        gv.cc.doBumpTrigger(bumpTrigger);
                                    }
                                    gv.cc.doUpdate();
                                }
                                else
                                {
                                    StopScrollingOnBlocked();
                                }
                            }
                        }
                    }
                    else if (gv.mod.PlayerLocationX == actualx && gv.mod.PlayerLocationY + 1 <= actualy)
                    {

                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            int mapheight = gv.mod.currentArea.MapSizeY;
                            bool bumpPropExists = false;
                            bool bumpTriggerExists = false;
                            Trigger bumpTrigger = new Trigger();
                            Prop bumpProp = new Prop();

                            if (gv.mod.PlayerLocationX < (mapheight - 1))
                            {
                                foreach (Trigger t in gv.mod.currentArea.Triggers)
                                {
                                    //migh add isBumpTRigger requirement here
                                    if (t.Enabled)
                                    {
                                        foreach (Coordinate p in t.TriggerSquaresList)
                                        {
                                            if ((p.X == gv.mod.PlayerLocationX) && (p.Y == gv.mod.PlayerLocationY+1))
                                            {
                                                bumpTriggerExists = true;
                                                bumpTrigger = t;
                                                break;
                                            }
                                        }
                                    }
                                }

                                foreach (Prop p in gv.mod.currentArea.Props)
                                {
                                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                    {
                                        if ((p.LocationX == gv.mod.PlayerLocationX) && (p.LocationY == gv.mod.PlayerLocationY+1))
                                        {
                                            bumpPropExists = true;
                                            bumpProp = p;
                                            gv.sf.ThisProp = bumpProp;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (gv.mod.PlayerLocationY < (mapheight - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY + 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isSecretPassage)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationY++;
                                        gv.mod.PlayerLocationY++;
                                        gv.mod.drawPartyDirection = "up";
                                        gv.mod.breakActiveSearch = false;
                                        gv.cc.doUpdate();
                                    }
                                    else
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationY++;
                                        gv.mod.drawPartyDirection = "up";
                                        gv.mod.breakActiveSearch = false;
                                        //gv.cc.doUpdate();
                                        if (!gv.mod.wasSuccessfulPush)
                                        {
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.wasSuccessfulPush = false;
                                        }
                                    }
                                }
                                else if (bumpPropExists || bumpTriggerExists)
                                {
                                    StopScrollingOnBlocked();
                                    if (bumpPropExists)
                                    {
                                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                        {
                                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                        }

                                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                                        {
                                            //called from prop add?
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                        }

                                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                                        {
                                            gv.mod.EncounterOfTurnDone = true;
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.calledEncounterFromProp = true;
                                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                        }

                                        if (bumpProp.scriptFilename != "none")
                                        {
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                            //code for floaty shown on prop upon script activation
                                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                            {
                                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                            }

                                            //code for log, to do
                                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                            {
                                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                            }

                                            if (bumpProp.onlyOnce)
                                            {
                                                bumpProp.isShown = false;
                                                bumpProp.isActive = false;
                                            }
                                        }
                                    }
                                    else if (bumpTriggerExists)
                                    {
                                        gv.cc.doBumpTrigger(bumpTrigger);
                                    }
                                    gv.cc.doUpdate();
                                }
                                else
                                {
                                    StopScrollingOnBlocked();
                                }
                            }
                        }
                    }
                    else if (gv.mod.PlayerLocationX - 1 >= actualx && gv.mod.PlayerLocationY == actualy)
                    {
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            bool bumpPropExists = false;
                            bool bumpTriggerExists = false;
                            Trigger bumpTrigger = new Trigger();
                            Prop bumpProp = new Prop();

                            if (gv.mod.PlayerLocationX > 0)
                            {
                                foreach (Trigger t in gv.mod.currentArea.Triggers)
                                {
                                    //migh add isBumpTRigger requirement here
                                    if (t.Enabled)
                                    {
                                        foreach (Coordinate p in t.TriggerSquaresList)
                                        {
                                            if ((p.X == gv.mod.PlayerLocationX - 1) && (p.Y == gv.mod.PlayerLocationY))
                                            {
                                                bumpTriggerExists = true;
                                                bumpTrigger = t;
                                                break;
                                            }
                                        }
                                    }
                                }

                                foreach (Prop p in gv.mod.currentArea.Props)
                                {
                                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                    {
                                        if ((p.LocationX == gv.mod.PlayerLocationX - 1) && (p.LocationY == gv.mod.PlayerLocationY))
                                        {
                                            bumpPropExists = true;
                                            bumpProp = p;
                                            gv.sf.ThisProp = bumpProp;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (gv.mod.PlayerLocationX > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX - 1].isSecretPassage)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationX--;
                                        gv.mod.PlayerLocationX--;
                                        gv.mod.drawPartyDirection = "right";
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if (!pc.combatFacingLeft)
                                            {
                                                pc.combatFacingLeft = true;
                                            }
                                        }
                                        gv.mod.breakActiveSearch = false;
                                        gv.cc.doUpdate();
                                    }
                                    else
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationX--;
                                        gv.mod.drawPartyDirection = "right";
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if (!pc.combatFacingLeft)
                                            {
                                                pc.combatFacingLeft = true;
                                            }
                                        }
                                        gv.mod.breakActiveSearch = false;
                                        if (!gv.mod.wasSuccessfulPush)
                                        {
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.wasSuccessfulPush = false;
                                        }
                                    }
                                }
                                //dodo: code ok here,too?
                                else if (bumpPropExists || bumpTriggerExists)
                                {
                                    StopScrollingOnBlocked();
                                    if (bumpPropExists)
                                    {
                                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                        {
                                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                        }

                                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                                        {
                                            //called from prop add?
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                        }

                                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                                        {
                                            gv.mod.EncounterOfTurnDone = true;
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.calledEncounterFromProp = true;
                                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                        }

                                        if (bumpProp.scriptFilename != "none")
                                        {
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                            //code for floaty shown on prop upon script activation
                                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                            {
                                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                            }

                                            //code for log, to do
                                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                            {
                                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                            }

                                            if (bumpProp.onlyOnce)
                                            {
                                                bumpProp.isShown = false;
                                                bumpProp.isActive = false;
                                            }
                                        }
                                    }
                                    else if (bumpTriggerExists)
                                    {
                                        gv.cc.doBumpTrigger(bumpTrigger);
                                    }

                                    gv.cc.doUpdate();
                                }
                                else
                                {
                                    StopScrollingOnBlocked();
                                }

                            }
                        }
                    }
                    else if (gv.mod.PlayerLocationX + 1 <= actualx && gv.mod.PlayerLocationY == actualy)
                    {
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            //bumper
                            int mapwidth = gv.mod.currentArea.MapSizeX;
                            bool bumpPropExists = false;
                            bool bumpTriggerExists = false;
                            Trigger bumpTrigger = new Trigger();
                            Prop bumpProp = new Prop();

                            if (gv.mod.PlayerLocationX < (mapwidth - 1))
                            {
                                foreach (Trigger t in gv.mod.currentArea.Triggers)
                                {
                                    //migh add isBumpTRigger requirement here
                                    if (t.Enabled)
                                    {
                                        foreach (Coordinate p in t.TriggerSquaresList)
                                        {
                                            if ((p.X == gv.mod.PlayerLocationX + 1) && (p.Y == gv.mod.PlayerLocationY))
                                            {
                                                bumpTriggerExists = true;
                                                bumpTrigger = t;
                                                break;
                                            }
                                        }
                                    }
                                }

                                foreach (Prop p in gv.mod.currentArea.Props)
                                {
                                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                    {
                                        if ((p.LocationX == gv.mod.PlayerLocationX + 1) && (p.LocationY == gv.mod.PlayerLocationY))
                                        {
                                            bumpPropExists = true;
                                            bumpProp = p;
                                            gv.sf.ThisProp = bumpProp;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (gv.mod.PlayerLocationX < (mapwidth - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX + 1].isSecretPassage)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationX++;
                                        gv.mod.PlayerLocationX++;
                                        gv.mod.drawPartyDirection = "left";
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if (pc.combatFacingLeft)
                                            {
                                                pc.combatFacingLeft = false;
                                            }
                                        }
                                        gv.mod.breakActiveSearch = false;
                                        gv.cc.doUpdate();
                                    }
                                    else
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationX++;
                                        gv.mod.drawPartyDirection = "left";
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if (pc.combatFacingLeft)
                                            {
                                                pc.combatFacingLeft = false;
                                            }
                                        }
                                        gv.mod.breakActiveSearch = false;
                                        if (!gv.mod.wasSuccessfulPush)
                                        {
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.wasSuccessfulPush = false;
                                        }
                                    }
                                }
                                //dodo: code ok here,too?
                                else if (bumpPropExists || bumpTriggerExists)
                                {
                                    StopScrollingOnBlocked();
                                    if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                    {
                                        gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                    }

                                    if (bumpPropExists)
                                    {
                                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                                        {
                                            //called from prop add?
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                        }

                                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                                        {
                                            gv.mod.EncounterOfTurnDone = true;
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.calledEncounterFromProp = true;
                                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                        }

                                        if (bumpProp.scriptFilename != "none")
                                        {
                                            gv.sf.ThisProp = bumpProp;
                                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                            //code for floaty shown on prop upon script activation
                                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                            {
                                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                            }

                                            //code for log, to do
                                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                            {
                                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                            }

                                            if (bumpProp.onlyOnce)
                                            {
                                                bumpProp.isShown = false;
                                                bumpProp.isActive = false;
                                            }
                                        }
                                    }
                                    else if (bumpTriggerExists)
                                    {
                                        gv.cc.doBumpTrigger(bumpTrigger);
                                    }

                                    //update could be wrong here?
                                    gv.cc.doUpdate();
                                }
                                else
                                {
                                    StopScrollingOnBlocked();
                                }

                            }
                        }
                    }

                }
            }

            mainUiLayout.Update(elapsed);

            //handle RealTime Timer events if gv.module uses this system
            if (gv.mod.useRealTimeTimer && !gv.mod.currentArea.isOverviewMap)
            {
                if (!gv.mod.realTimeTimerStopped)
                {
                    gv.realTimeTimerMilliSecondsEllapsed += elapsed;
                }

                if (gv.realTimeTimerMilliSecondsEllapsed >= gv.mod.realTimeTimerLengthInMilliSeconds)
                {
                    gv.mod.calledByRealTimeTimer = true;
                    gv.cc.doUpdate();
                    gv.mod.calledByRealTimeTimer = false;
                    gv.realTimeTimerMilliSecondsEllapsed = 0;
                }
            }

            //weather effects
            if (gv.mod.isRaining)
            {
                gv.fullScreenEffectTimerMilliSecondsElapsedRain += elapsed;
                float rainChance2 = gv.sf.RandInt(200) + 150;
                if (gv.fullScreenEffectTimerMilliSecondsElapsedRain > rainChance2)
                {
                    gv.cc.createRain(gv.rainType);
                    gv.fullScreenEffectTimerMilliSecondsElapsedRain = 0;
                    gv.mod.isInitialParticleWave = false;
                }
            }


            if (gv.mod.isSnowing)
            {
                gv.fullScreenEffectTimerMilliSecondsElapsedSnow += elapsed;
                float snowChance2 = gv.sf.RandInt(200) + 150;
                if (gv.fullScreenEffectTimerMilliSecondsElapsedSnow > snowChance2)
                {
                    gv.cc.createSnow(gv.snowType);
                    gv.fullScreenEffectTimerMilliSecondsElapsedSnow = 0;
                    gv.mod.isInitialParticleWave = false;
                }
            }

            if (gv.mod.isSandstorm)
            {
                gv.fullScreenEffectTimerMilliSecondsElapsedSandstorm += elapsed;
                float sandstormChance2 = gv.sf.RandInt(200) + 150;
                if (gv.fullScreenEffectTimerMilliSecondsElapsedSandstorm > sandstormChance2)
                {
                    gv.cc.createSandstorm(gv.sandstormType);
                    gv.fullScreenEffectTimerMilliSecondsElapsedSandstorm = 0;
                    gv.mod.isInitialParticleWave = false;
                }
            }

            if ((gv.mod.isCloudy) && (!gv.mod.blockCloudCreation))
            {
                //gv.fullScreenEffectTimerMilliSecondsElapsedClouds += elapsed;
                //float cloudChance = gv.sf.RandInt(10000) + 7500;
                //if (gv.fullScreenEffectTimerMilliSecondsElapsedClouds > cloudChance)
                //{
                int decider2 = gv.sf.RandInt(8);
                if (decider2 == 1)
                {
                    gv.mod.windDirection = "SE";
                }
                if (decider2 == 2)
                {
                    gv.mod.windDirection = "NE";
                }
                if (decider2 == 3)
                {
                    gv.mod.windDirection = "SW";
                }
                if (decider2 == 4)
                {
                    gv.mod.windDirection = "NW";
                }
                if (decider2 == 5)
                {
                    gv.mod.windDirection = "South";
                }
                if (decider2 == 6)
                {
                    gv.mod.windDirection = "North";
                }
                if (decider2 == 7)
                {
                    gv.mod.windDirection = "West";
                }
                if (decider2 == 8)
                {
                    gv.mod.windDirection = "East";
                }

                float speedMultiplier = 0;
                float positionmodifierX = 0;
                float positionmodifierY = 0;

                for (int i = 0; i < 7; i++)
                {
                    int decider = gv.sf.RandInt(3);
                    string layerType = "";
                    if (decider == 1)
                    {
                        layerType = "LayerA";
                    }
                    if (decider == 2)
                    {
                        layerType = "LayerB";
                    }
                    if (decider == 3)
                    {
                        layerType = "LayerC";
                    }
                    //ausweichstrecken
                    string backupCloudType = gv.cloudType;
                    bool exchangeDone = false;
                    if (gv.cloudType == "lightCloud")
                    {
                        exchangeDone = true;
                        decider = gv.sf.RandInt(5);
                        if (decider == 4)
                        {
                            gv.cloudType = "cloud";
                        }
                        else if (decider == 5)
                        {
                            gv.cloudType = "heavyCloud";
                        }
                    }
                    else if (gv.cloudType == "cloud" && !exchangeDone)
                    {
                        exchangeDone = true;
                        decider = gv.sf.RandInt(5);
                        if (decider == 4)
                        {
                            gv.cloudType = "lightCloud";
                        }
                        else if (decider == 5)
                        {
                            gv.cloudType = "heavyCloud";
                        }
                    }
                    else if (gv.cloudType == "heavyCloud" && !exchangeDone)
                    {
                        exchangeDone = true;
                        decider = gv.sf.RandInt(5);
                        if (decider == 4)
                        {
                            gv.cloudType = "lightCloud";
                        }
                        else if (decider == 5)
                        {
                            gv.cloudType = "cloud";
                        }
                    }
                    decider = gv.sf.RandInt(2);
                    int mass = 0;
                    if (decider == 1)
                    {
                        mass = 1;
                    }

                    speedMultiplier = 0.39f + (i * 0.1f);
                    decider = gv.sf.RandInt(15);
                    positionmodifierX = (-7 + decider) * gv.squareSize;
                    decider = gv.sf.RandInt(9);
                    positionmodifierY = (-4 + decider) * gv.squareSize;
                    float angle = 362;
                    decider = gv.sf.RandInt(2);
                    if (decider == 2)
                    {
                        angle = 361;
                    }
                    gv.cc.createClouds(gv.cloudType + layerType, speedMultiplier, positionmodifierX, positionmodifierY, mass, angle);
                    gv.cloudType = backupCloudType;
                    gv.mod.blockCloudCreation = true;

                }
            }

            if ((gv.mod.isFoggy) && (!gv.mod.blockFogCreation))
            {

                gv.mod.blockFogCreation = true;
                float speedMultiplier = 0;
                float positionmodifierX = 0;
                float positionmodifierY = 0;
                string layerType = "";
                int decider = 0;
                int iLimit = 0;
                if (gv.fogType.Contains("lightFog") || gv.fogType.Contains("LightFog"))
                {
                    iLimit = 6;
                }
                else if (gv.fogType.Contains("heavyFog") || gv.fogType.Contains("HeavyFog"))
                {
                    iLimit = 8;
                }
                else if (gv.fogType.Contains("fog") || gv.fogType.Contains("Fog"))
                {
                    iLimit = 7;
                }

                for (int i = 0; i < iLimit; i++)
                {

                    positionmodifierX = 0;
                    positionmodifierY = 0;

                    if (i == 0)
                    {
                        layerType = "fog1";
                        decider = gv.sf.RandInt(20);
                        speedMultiplier = 0.50f + (decider / 100f);
                        positionmodifierX = (-4) * gv.squareSize;
                    }

                    if (i == 1)
                    {
                        layerType = "fog2";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (4) * gv.squareSize;
                    }

                    if (i == 2)
                    {
                        layerType = "fog3";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (2) * gv.squareSize;
                        positionmodifierY = (2) * gv.squareSize;
                    }

                    if (i == 3)
                    {
                        layerType = "fog4";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-2) * gv.squareSize;
                        positionmodifierY = (-2) * gv.squareSize;
                    }

                    if (i == 4)
                    {
                        layerType = "fog5";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-6) * gv.squareSize;

                    }

                    if (i == 5)
                    {
                        layerType = "fog6";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = 6 * gv.squareSize;

                    }
                    if (i == 6)
                    {
                        layerType = "fog7";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-1) * gv.squareSize;
                        positionmodifierY = (-1) * gv.squareSize;

                    }

                    if (i == 7)
                    {
                        layerType = "fog8";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-3) * gv.squareSize;
                        positionmodifierY = (-3) * gv.squareSize;
                    }

                    if (i == 8)
                    {
                        layerType = "fog1";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (3) * gv.squareSize;
                        positionmodifierY = (3) * gv.squareSize;
                    }

                    if (i == 9)
                    {
                        layerType = "fog2";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-5) * gv.squareSize;

                    }

                    gv.cc.createFog(layerType, speedMultiplier, positionmodifierX - 1.8f * gv.squareSize, positionmodifierY);
                }
            }

            if (gv.mod.isLightning)
            {
                string lightningType = "";
                float posX = 0;
                float posY = 0;
                float scalemod = 0;
                int lightningChance = 175;
                if (gv.sf.RandInt(lightningChance) == 1)
                {
                    gv.cc.setToBorderPixDistancesMainMap();
                    int deciderWestEast = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderWest + (int)gv.mod.pixDistanceToBorderEast);
                    int deciderNorthSouth = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderNorth + (int)gv.mod.pixDistanceToBorderSouth);

                    if (deciderWestEast <= (int)gv.mod.pixDistanceToBorderWest)
                    {
                        posX = -gv.sf.RandInt((int)gv.mod.pixDistanceToBorderWest) + gv.screenWidth / 2;
                    }
                    else
                    {
                        //the -3 gv.modifiier makes sure that at significant part of the lightning is onscreen
                        posX = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderEast) - (3 * gv.squareSize) + gv.screenWidth / 2;
                    }

                    if (deciderNorthSouth <= (int)gv.mod.pixDistanceToBorderNorth)
                    {
                        posY = -gv.sf.RandInt((int)gv.mod.pixDistanceToBorderNorth) + gv.screenHeight / 2;
                    }
                    else
                    {
                        //the -3 gv.modifiier makes sure that at significant part of the lightning is onscreen
                        posY = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderSouth) - (3 * gv.squareSize) + gv.screenHeight / 2;
                    }

                    int lightningTypeDecider = gv.sf.RandInt(2);

                    if (lightningTypeDecider == 1)
                    {
                        lightningType = "lightningLayerA";
                    }

                    else
                    {
                        lightningType = "lightningLayerB";
                    }

                    scalemod = (gv.sf.RandInt(70) + 65) / 100;
                    gv.cc.createLightning(lightningType, posX, posY, scalemod);
                }
            }

            #region PROP AMBIENT SPRITES
            foreach (Sprite spr in spriteList)
            {
                spr.Update(elapsed, gv);
            }
            for (int x = spriteList.Count - 1; x >= 0; x--)
            {
                if (spriteList[x].timeToLiveInMilliseconds <= 0)
                {
                    try
                    {
                        if (!spriteList[x].movementMethod.Contains("clouds") && !spriteList[x].movementMethod.Contains("fog") && !spriteList[x].movementMethod.Contains("lightning"))
                        {
                            spriteList.RemoveAt(x);
                            continue;
                        }
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if (!gv.mod.isCloudy && spriteList[x].movementMethod.Contains("clouds"))
                {
                    gv.mod.blockCloudCreation = false;
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if (!gv.mod.isFoggy && spriteList[x].movementMethod.Contains("fog"))
                {
                    gv.mod.blockFogCreation = false;
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if ((!gv.mod.isRaining && spriteList[x].movementMethod.Contains("rain")) || (!gv.mod.isSnowing && spriteList[x].movementMethod.Contains("snow")) || (!gv.mod.isSandstorm && spriteList[x].movementMethod.Contains("sandStorm")))
                {
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if (spriteList[x].movementMethod.Contains("lightning") && (spriteList[x].totalElapsedTime >= (spriteList[x].numberOFFramesForAnimationsMadeFromSeveralBitmaps * spriteList[x].millisecondsPerFrame)))
                {
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }
            }
            #endregion

            #region FLOATY TEXT            
            //move up 50pxl per second (50px/1000ms)*elapsed
            if (gv.mod.useSmoothMovement)
            {
                if (floatyTextByPixelPool.Count > 0)
                {
                    int shiftUp = (int)(0.05f * elapsed);
                    foreach (FloatyTextByPixel ft in floatyTextByPixelPool)
                    {
                        ft.z += shiftUp;
                        ft.timeToLive -= (int)(elapsed);
                    }
                    //remove expired floaty text
                    for (int i = floatyTextByPixelPool.Count - 1; i >= 0; i--)
                    {
                        if (floatyTextByPixelPool[i].timeToLive <= 0)
                        {
                            floatyTextByPixelPool.RemoveAt(i);
                        }
                    }

                    //remove if too many floats are in pool
                    for (int i = floatyTextByPixelPool.Count - 1; i >= 0; i--)
                    {
                        if (((floatyTextByPixelPool.Count - 1 - i) > 15))
                        {
                            floatyTextByPixelPool.RemoveAt(i);
                        }
                    }
                }
            }
            if (floatyTextPool.Count > 0)
            {
                int shiftUp = (int)(0.05f * elapsed);
                foreach (FloatyText ft in floatyTextPool)
                {
                    ft.z += shiftUp;
                    ft.timeToLive -= (int)(elapsed);
                }

                //remove expired floaty text
                for (int i = floatyTextPool.Count - 1; i >= 0; i--)
                {
                    if (floatyTextPool[i].timeToLive <= 0)
                    {
                        floatyTextPool.RemoveAt(i);
                    }
                }

                //remove if too many floats are in pool
                for (int i = floatyTextPool.Count - 1; i >= 0; i--)
                {
                    if (((floatyTextPool.Count - 1 - i) > 15))
                    {
                        floatyTextPool.RemoveAt(i);
                    }
                }

            }
            #endregion
        }

        public void doScrolling(float elapsed)
        {
            //3500
            //20ms
            //25 call consume it (half second for square)
            //decrease by 4
            gv.mod.scrollingTimer = gv.mod.scrollingTimer - (4f*(elapsed/3.5f));


            if (gv.mod.scrollingTimer <= 0)
            {
                gv.mod.isScrollingNow = false;
                gv.mod.scrollingTimer = 0;
                gv.cc.doPropTriggers();
                //gv.mod.scrollingTimer = 100;
            }
                

        }

        public void doPropAnimations(float elapsed)
        {
            
            //need to update animated props on neighbouring areas, too
            //theflameandtheflood

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
             //XXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //player near northern border
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                {
                    seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near southern  border
                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near western border
                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                {
                    seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near eastern border
                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                bool situationFound = false;
                //int relevantIndex = -1;
                List<int> relevantIndices = new List<int>();
                int northernmodifier = 0;
                int easternmodifier = 0;
                int westernmodifier = 0;
                int southernmodifier = 0;

                //northwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthWesternNeighbour);
                }
                //northeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthEasternNeighbour);
                }
                //southwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthWesternNeighbour);
                }
                //southeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthEasternNeighbour);
                }
                //north
                if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthernNeighbour);
                }
                //south
                if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthernNeighbour);
                }
                //west
                if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfWesternNeighbour);
                }
                //east
                if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfEasternNeighbour);
                }
                
                //current map
                //if (!situationFound)
                //{
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                        {
                            relevantIndices.Add(i);
                        }
                    } 
                //}
                

                //XXXXXXXXXXXXXXXXXXXXXXXX
                for (int i = 0; i < relevantIndices.Count; i++)
                {//2

                    int backupLocationX = -1;
                    int backupLocationY = -1;

                    foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                    {


                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                        //foreach (Prop p in gv.mod.currentArea.Props)
                        //{
                        if (p.animationIsActive)
                        {
                            float fadeAmount = 0;
                            if (p.framesNeededForFullFadeInOut > 0)
                            {
                                fadeAmount = 1f / p.framesNeededForFullFadeInOut;
                                if (p.totalFramesInWholeLoopCounter <= p.framesNeededForFullFadeInOut)
                                {
                                    p.opacity = fadeAmount * p.totalFramesInWholeLoopCounter;
                                    if (p.opacity > 1)
                                    {
                                        p.opacity = 1;
                                    }
                                }

                                else if (p.totalFramesInWholeLoopCounter >= ((p.maxNumberOfFrames * p.numberOfCyclesNeededForCompletion) - p.framesNeededForFullFadeInOut))
                                {
                                    int framesLeft = (p.maxNumberOfFrames * p.numberOfCyclesNeededForCompletion) - p.totalFramesInWholeLoopCounter;
                                    p.opacity = framesLeft * fadeAmount;
                                }
                                else
                                {
                                    p.opacity = 1;
                                }
                            }

                            //p.drawAnimatedProp = true;
                            if ((p.maxNumberOfFrames > 1) && (!p.animationComplete))
                            {
                                //p.animationDelayCounter += (300f / elapsed);
                                p.animationDelayCounter += (elapsed/2f);

                            if (p.animationDelayCounter >= p.updateTicksNeededTillNextFrame)
                                {

                                #region forwardDirection
                                //if (!p.inverseAnimationDirection)
                                //{
                                    p.currentFrameNumber++;
                                    p.totalFramesInWholeLoopCounter++;
                                    p.animationDelayCounter = 0;
                                    if (p.currentFrameNumber > (p.maxNumberOfFrames - 1))
                                    {
                                        p.currentFrameNumber = 0;

                                        //enter new conditional for multiple cylces required before compleetion here
                                        if (p.numberOfCyclesNeededForCompletion <= 1)
                                        {
                                            if (p.randomAnimationDirectionEachCall)
                                            {
                                                int decider = gv.sf.RandInt(0, 100);
                                                if (decider >= 50)
                                                {
                                                    p.inverseAnimationDirection = true;
                                                }
                                                else
                                                {
                                                    p.inverseAnimationDirection = false;
                                                }
                                            }

                                            p.animationComplete = true;
                                            p.totalFramesInWholeLoopCounter = 0;
                                            if (p.hiddenWhenComplete)
                                            {
                                                p.drawAnimatedProp = false;
                                            }
                                        }
                                        else
                                        {
                                            p.cycleCounter++;
                                            if (p.cycleCounter == p.numberOfCyclesNeededForCompletion)
                                            {
                                                if (p.randomAnimationDirectionEachCall)
                                                {
                                                    int decider = gv.sf.RandInt(0, 100);
                                                    if (decider >= 50)
                                                    {
                                                        p.inverseAnimationDirection = true;
                                                    }
                                                    else
                                                    {
                                                        p.inverseAnimationDirection = false;
                                                    }
                                                }

                                                p.animationComplete = true;
                                                p.cycleCounter = 0;
                                                p.totalFramesInWholeLoopCounter = 0;
                                                if (p.hiddenWhenComplete)
                                                {
                                                    p.drawAnimatedProp = false;
                                                }
                                            }
                                        }
                                    }
                                //}
                                #endregion
                                /*
                                #region backwardsDirection
                                else
                                {
                                    p.currentFrameNumber--;
                                    p.totalFramesInWholeLoopCounter--;
                                    p.animationDelayCounter = 0;
                                    if (p.currentFrameNumber > (p.maxNumberOfFrames - 1))
                                    {
                                        p.currentFrameNumber = 0;

                                    //enter new conditional for multiple cylces required before compleetion here
                                    if (p.numberOfCyclesNeededForCompletion <= 1)
                                    {
                                        p.animationComplete = true;
                                        p.totalFramesInWholeLoopCounter = 0;
                                        if (p.hiddenWhenComplete)
                                        {
                                            p.drawAnimatedProp = false;
                                        }
                                    }
                                    else
                                    {
                                        p.cycleCounter++;
                                        if (p.cycleCounter == p.numberOfCyclesNeededForCompletion)
                                        {
                                            if (p.randomAnimationDirectionEachCall)
                                            {
                                                int decider = gv.sf.RandInt(0, 100);
                                                if (decider >= 50)
                                                {
                                                    p.inverseAnimationDirection = true;
                                                }
                                                else
                                                {
                                                    p.inverseAnimationDirection = false;
                                                }
                                            }

                                            p.animationComplete = true;
                                            p.cycleCounter = 0;
                                            p.totalFramesInWholeLoopCounter = 0;
                                            if (p.hiddenWhenComplete)
                                            {
                                                p.drawAnimatedProp = false;
                                            }
                                        }
                                    }
                                }
                            } 

                                #endregion
                                */
                            }
                            }

                            if (p.animationComplete)
                            {
                                if (p.doOnce)
                                {
                                    p.animationIsActive = false;
                                }

                                if (p.animationIsActive)
                                {
                                    if (p.chanceToTriggerAnimationCycle >= 100)
                                    {
                                        p.animationComplete = false;
                                        p.drawAnimatedProp = true;
                                    }
                                    else
                                    {
                                        p.normalizedTime += (1 / elapsed);
                                        if (p.normalizedTime >= 1)
                                        {
                                            p.normalizedTime = 0;
                                            float rollRandom = gv.sf.RandInt(100);
                                            if (rollRandom <= p.chanceToTriggerAnimationCycle)
                                            {
                                                p.animationComplete = false;
                                                p.drawAnimatedProp = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        //animation is not active
                        else
                        {
                            if (p.hiddenWhenNotActive)
                            {
                                p.drawAnimatedProp = false;
                            }
                        }
                    }
                }
        }

        //MAIN SCREEN DRAW
        public void resetMiniMapBitmap()
        {
            if (gv.mod.useAllTileSystem)
            {
                minimap = gv.cc.LoadBitmap(gv.mod.currentArea.Filename + "Minimap");
            }
            else
            {
                int minimapSquareSizeInPixels = 4 * gv.squareSize / gv.mod.currentArea.MapSizeX;
                int drawW = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeX;
                int drawH = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeY;
                using (System.Drawing.Bitmap surface = new System.Drawing.Bitmap(drawW, drawH))
                {
                    using (Graphics device = Graphics.FromImage(surface))
                    {
                        //draw background image first
                        if ((!gv.mod.currentArea.ImageFileName.Equals("none")) && (gv.cc.bmpMap != null))
                        {
                            System.Drawing.Bitmap bg = gv.cc.LoadBitmapGDI(gv.mod.currentArea.ImageFileName);
                            Rectangle srcBG = new Rectangle(0, 0, bg.Width, bg.Height);
                            Rectangle dstBG = new Rectangle(gv.mod.currentArea.backgroundImageStartLocX * minimapSquareSizeInPixels,
                                                            gv.mod.currentArea.backgroundImageStartLocY * minimapSquareSizeInPixels,
                                                            minimapSquareSizeInPixels * (bg.Width / 50),
                                                            minimapSquareSizeInPixels * (bg.Height / 50));
                            device.DrawImage(bg, dstBG, srcBG, GraphicsUnit.Pixel);
                            bg.Dispose();
                            bg = null;
                        }
                        #region Draw Layer 1
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer1Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 2
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer2Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 3
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer3Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 4
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer4Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 5
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer5Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        minimap = gv.cc.ConvertGDIBitmapToD2D((System.Drawing.Bitmap)surface.Clone());
                    }
                }
            }
        }

        public void drawHeightShadows()
        {

            int tileXCoordOnItsArea = -1;
            int tileYCoordOnItsArea = -1;
            #region draw Height Shadows
            gv.mod.indexOfNorthernNeighbour = -1;
            gv.mod.indexOfSouthernNeighbour = -1;
            gv.mod.indexOfEasternNeighbour = -1;
            gv.mod.indexOfWesternNeighbour = -1;
            gv.mod.indexOfNorthEasternNeighbour = -1;
            gv.mod.indexOfNorthWesternNeighbour = -1;
            gv.mod.indexOfSouthEasternNeighbour = -1;
            gv.mod.indexOfSouthWesternNeighbour = -1;
            gv.mod.indexOfCurrentArea = -1;

            gv.mod.seamlessModififierMinX = 0;
            gv.mod.seamlessModififierMaxX = 0;
            gv.mod.seamlessModififierMinY = 0;
            gv.mod.seamlessModififierMaxY = 0;

            #region neighbours

            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
            {
                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.Filename)
                {
                    gv.mod.indexOfCurrentArea = i;
                }
            }

            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
            {
                gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        gv.mod.indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        gv.mod.indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
            {
                gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        gv.mod.indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        gv.mod.indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }
            #endregion
            //foreach (Area a in gv.mod.moduleAreasObjects)

            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

            /*
            if (gv.mod.currentArea.sourceBitmapName != "")
            {
                #region Draw Layer 0
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
            */


            //*************************************************************************
            //*************************************************************************
            //*************************************************************************
            /*
                        for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                        {
                            for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                            {
                            */

            /*
            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
            int brX = gv.squareSize;
            int brY = gv.squareSize;
            IbRect src = new IbRect(0, 0, gv.cc.walkBlocked.PixelSize.Width, gv.cc.walkBlocked.PixelSize.Height);
            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
            if (gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
            {
                gv.DrawBitmap(gv.cc.losBlocked, src, dst);
            }
            */
            //gv.DrawBitmap(gv.cc.losBlocked, src, dst);
            for (int x = minX; x < maxX; x++)
            {
                for (int y = minY; y < maxY; y++)
                {

                    bool situationFound = false;
                    bool drawTile = true;
                    int index = -1;
                    Tile tile = new Tile();

                    //nine situations where a tile can be:
                    //tile on north-western map (diagonal situation)
                    if ((x < 0) && (y < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfNorthWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                            int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfNorthWesternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on south-westernmap (diagonal situation)
                    if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfSouthWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                            int transformedY = y - gv.mod.currentArea.MapSizeY;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfSouthWesternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on south-easternmap (diagonal situation)
                    if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfSouthEasternNeighbour != -1)
                        {
                            int transformedX = x - gv.mod.currentArea.MapSizeX;
                            int transformedY = y - gv.mod.currentArea.MapSizeY;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfSouthEasternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on north-easternmap (diagonal situation)
                    if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfNorthEasternNeighbour != -1)
                        {
                            int transformedX = x - gv.mod.currentArea.MapSizeX;
                            int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfNorthEasternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on western map
                    if ((x < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                            int transformedY = y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfWesternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on southern map
                    if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfSouthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = y - gv.mod.currentArea.MapSizeY;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfSouthernNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on eastern map
                    if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfEasternNeighbour != -1)
                        {
                            int transformedX = x - gv.mod.currentArea.MapSizeX;
                            int transformedY = y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfEasternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on northern map
                    if ((y < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfNorthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfNorthernNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile is on current map
                    if (!situationFound)
                    {
                        tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        index = gv.mod.indexOfCurrentArea;
                        tileXCoordOnItsArea = x;
                        tileYCoordOnItsArea = y;
                        //lumberjack

                    }

                    if (drawTile)
                    {
                        //*********************************************************************************
                        //*********************************************************************************
                        
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.longShadow.PixelSize.Width / 100;
                        float scalerY = gv.cc.longShadow.PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);
                        //amitee
                        IbRect dstNorth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY - gv.squareSize, brX, brY);
                        IbRect dstEast = new IbRect(tlX + gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dstSouth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY + gv.squareSize, brX, brY);
                        IbRect dstWest = new IbRect(tlX - gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst2 = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst3 = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst4 = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        //IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);
                        /*
                        IbRect dst = new IbRect(x * (gv.squareSize), y * gv.squareSize, (gv.squareSize), (gv.squareSize));
                        IbRect dst2 = new IbRect(x * (gv.squareSize), y * gv.squareSize, (gv.squareSize), (gv.squareSize));
                        IbRect dst3 = new IbRect(x * (gv.squareSize), y * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dst4 = new IbRect(x * (gv.squareSize), y * (gv.squareSize), gv.squareSize, gv.squareSize);
                        IbRect dstNorth = new IbRect(x * gv.squareSize, (y - 1) * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dstEast = new IbRect((x + 1) * gv.squareSize, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dstSouth = new IbRect(x * gv.squareSize, (y + 1) * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dstWest = new IbRect((x - 1) * gv.squareSize, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        */
                        //note: fillavergaeHEightOnThisMap each turn wth the height of the square the palyer is currently on

                        //add too extreme deep and high here (paradise)
                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                        {
                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                            {
                                //tileIsTooExtreme = true;
                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0,0,0,1.0f);
                            }
                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                            {
                                //tileIsTooExtreme = true;
                                IbRect dstE = new IbRect();
                                dstE.Width = (dst.Width + 1) / 2;
                                dstE.Height = (dst.Height + 1) / 2;
                                dstE.Top = dst.Top;
                                dstE.Left = dst.Left;
                                gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0,0,0,1.0f);
                                dstE.Left += dstE.Width;
                                gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0, 0, 0, 1.0f);
                                dstE.Left -= dstE.Width;
                                dstE.Top += dstE.Height;
                                gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0, 0, 0, 1.0f);
                                dstE.Left += dstE.Width;
                                gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0, 0, 0, 1.0f);
                            }
                        }

                        if (tile.isInMaxShadeE)
                        {
                            tile.isInLongShadeE = true;
                        }
                        if (tile.isInMaxShadeW)
                        {
                            tile.isInLongShadeW = true;
                        }
                        if (tile.isInMaxShadeS)
                        {
                            tile.isInLongShadeS = true;
                        }
                        if (tile.isInMaxShadeN)
                        {
                            tile.isInLongShadeN = true;
                        }

                        if (tile.isInMaxShadeNE)
                        {
                            tile.isInLongShadeNE = true;
                        }
                        if (tile.isInMaxShadeNW)
                        {
                            tile.isInLongShadeNW = true;
                        }
                        if (tile.isInMaxShadeSE)
                        {
                            tile.isInLongShadeSE = true;
                        }
                        if (tile.isInMaxShadeSW)
                        {
                            tile.isInLongShadeSW = true;
                        }

                        tile.isInMaxShadeE = false;
                        tile.isInMaxShadeW = false;
                        tile.isInMaxShadeN = false;
                        tile.isInMaxShadeS = false;
                        tile.isInMaxShadeNE = false;
                        tile.isInMaxShadeNW = false;
                        tile.isInMaxShadeSE = false;
                        tile.isInMaxShadeSW = false;

                        float relativeTileHeight = tile.heightLevel - gv.mod.currentArea.averageHeightOnThisMap;
                        if (relativeTileHeight > 4)
                        {
                            relativeTileHeight = 4;
                        }
                        if (relativeTileHeight < -4)
                        {
                            relativeTileHeight = -4;
                        }
                        relativeTileHeight = relativeTileHeight / 10;
                        if (gv.mod.noRimLights)
                        {
                            relativeTileHeight = -0.5f;
                        }

                        //gv.DrawBitmap(gv.cc.losBlocked, src, dst);

                        int xAdder = 1;
                        int yAdder = 1;
                        int xSubstractor = 1;
                        int ySubstractor = 1;

                        if (x == 0)
                        {
                            xSubstractor = 0;
                        }
                        if (y == 0)
                        {
                            ySubstractor = 0;
                        }

                        if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            xAdder = 0;
                        }

                        if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            yAdder = 0;
                        }

                        //highlights
                        //if (gv.mod.currentArea.Tiles[(y + yAdder) * gv.mod.currentArea.MapSizeX + x].transitionToMasterDirection != "S")
                        if (tile.transitionToMasterDirection != "S")
                        {
                            if (tile.hasHighlightS)
                            {
                                if (tile.isEWBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst4, 0, false, 0, -1, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 0, false, 0, -1, 1, 1, (0.5f + relativeTileHeight)*0.15f);
                                    //gv.DrawBitmap(gv.cc.highlight90, src, dst, 0, false, 0, 0, 0, 0, (0.5f + relativeTileHeight) * 0.18f);
                                }
                                //DrawD2DBitmap
                            }
                        }

                        //if (gv.mod.currentArea.Tiles[(y - ySubstractor) * gv.mod.currentArea.MapSizeX + x].transitionToMasterDirection != "N")
                        if (tile.transitionToMasterDirection != "N")
                        {
                            if (tile.hasHighlightN)
                            {
                                if (tile.isEWBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst, 180, false, 0, 0, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 180, false, 0, 0, 1, 1, (0.5f + relativeTileHeight) * 0.15f);
                                    //gv.DrawBitmap(gv.cc.highlight90, src, dst, 180, false, 0, 0, 0, 0, (0.5f + relativeTileHeight) * 0.18f);
                                }
                            }
                        }

                        //if (gv.mod.currentArea.Tiles[(y) * gv.mod.currentArea.MapSizeX + x - xSubstractor].transitionToMasterDirection != "W")
                        if (tile.transitionToMasterDirection != "W")
                        {
                            if (tile.hasHighlightW)
                            {
                                if (tile.isNSBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst, 90, false, 0, 0, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 90, false, 0, 0, 1, 1, (0.5f + relativeTileHeight) * 0.15f);
                                    //gv.DrawBitmap(gv.cc.highlight90, src, dst, 90, false, 0, 0, 0, 0, (0.5f + relativeTileHeight) * 0.18f);
                                }
                            }
                        }

                        //if (gv.mod.currentArea.Tiles[(y) * gv.mod.currentArea.MapSizeX + x + xAdder].transitionToMasterDirection != "E")
                        if (tile.transitionToMasterDirection != "E")
                        {
                            if (tile.hasHighlightE)
                            {
                                if (tile.isNSBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst3, 270, false, -1, 0, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 270, false, -1, 0, 1, 1, (0.5f + relativeTileHeight) * 0.15f);
                                    //gv.DrawBitmap(gv.cc.highlight90, src, dst, 270, false, 0, 0, 0, 0, (0.5f + relativeTileHeight) * 0.18f);
                                }
                            }
                        }


                        if (gv.mod.currentArea.masterOfThisArea == "none")
                        {
                            //changela
                            if (tile.transitionToMasterDirection == "E")
                            {
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstEast, 90, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstEast, 90, false, 0, 1, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstEast, 90, false, 0, -1, 1, 1, 1f);
                                //allowHighLight = false;
                            }
                            if (tile.transitionToMasterDirection == "S")
                            {
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstSouth, 180, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstSouth, 180, false, 0, 1, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstSouth, 180, false, 0, -1, 1, 1, 1f);
                                //allowHighLight = false;
                            }
                            if (tile.transitionToMasterDirection == "W")
                            {
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstWest, 270, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstWest, 270, false, 0, 1, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstWest, 270, false, 0, -1, 1, 1, 1f);

                                //allowHighLight = false;0
                            }
                            if (tile.transitionToMasterDirection == "N")
                            {
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstNorth, 0, false, 0, 0, 1, 1, 1f);
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstNorth, 0, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstNorth, 0, false, 0, 0, -1, 1, 1f);
                                //allowHighLight = false;
                            }
                        }

                        //urfeld
                        //stair shadows
                        if (tile.hasDownStairShadowN)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 180, false, 0, 0);
                            if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == 0)
                                {
                                    //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr*0.5f, sqr);
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 180, false, 0, 0);
                                    //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr * 2f, sqr);
                                }
                            }
                            if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, false, 0, 0);
                                }
                            }
                            //freedom, WIP

                            if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 90, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 270, false, 0, 0);
                                }
                            }

                            /*
                            DrawD2DBitmap(GetFromBitmapList("downStairShadow"), src, dst, 180, false, 0, 0);
                        if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                        {
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == 0)
                            {
                                //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr*0.5f, sqr);
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowLeft"), src, dst2, 180, false, 0, 0);
                                //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr * 2f, sqr);
                            }
                        }
                        if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                        {
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == 0)
                            {
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowRight"), src, dst2, 180, false, 0, 0);
                            }
                        }
                        //freedom, WIP
                        
                        if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                        {
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -2)
                            {
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowLeft"), src, dst2, 90, false, 0, 0);
                            }
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -3)
                            {
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowRight"), src, dst2, 270, false, 0, 0);
                            }
                        }      


                            */
                        }
                        if (tile.hasDownStairShadowE)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 270, false, 0, 0);
                            if (!tile.isInShortShadeS && !tile.isInLongShadeS && !tile.isInMaxShadeS)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 270, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 270, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 0, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 180, false, 0, 0);
                                }
                            }

                        }
                        if (tile.hasDownStairShadowS)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 0, false, 0, 0);
                            if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 0, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 0, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeS && !tile.isInLongShadeS && !tile.isInMaxShadeS)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 90, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 270, false, 0, 0);
                                }
                            }
                        }
                        if (tile.hasDownStairShadowW)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 90, false, 0, 0);
                            if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 90, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeS && !tile.isInLongShadeS && !tile.isInMaxShadeS)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 90, false, 0, 0);
                                }
                            }

                            if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 0, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, false, 0, 0);
                                }
                            }
                        }
                        
                        if (tile.inRampShadowWest1Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 180, true, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowWest1Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 0, true, 0, 0);
                        }

                        if (tile.inRampShadowWest2Long)
                        {
                            gv.DrawBitmap(gv.cc.rightCurtain, src, dst, 0, false, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowWest2Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, false, 0, 0);
                        }

                        if (tile.inRampShadowEast3Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 180, false, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowEast3Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 0, true, 0, 0);
                        }

                        if (tile.inRampShadowEast4Long)
                        {
                            gv.DrawBitmap(gv.cc.rightCurtain, src, dst, 0, true, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowEast4Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, true, 0, 0);
                        }

                        if (tile.inRampShadowNorth5Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 270, true, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowNorth5Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 90, true, 0, 0);
                        }

                        if (tile.inRampShadowNorth6Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 90, false, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowNorth6Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 270, true, 0, 0);
                        }

                        if (tile.inRampShadowSouth7Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 270, false, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowSouth7Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 90, true, 0, 0);
                        }

                        if (tile.inRampShadowSouth8Long)
                        {
                            gv.DrawBitmap(gv.cc.rightCurtain, src, dst, 90, true, 0, 0, 0, 0, 0.8f);
                        }
                        if (tile.inRampShadowSouth8Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 270, true, 0, 0);
                        }

                        if (tile.inSmallStairNEVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 0, true, 0, 0);
                        }
                        if (tile.inSmallStairNEHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 90, true, 0, 0);
                        }
                        if (tile.inSmallStairSEVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 180, true, 0, 0);
                        }
                        if (tile.inSmallStairSEHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 90, true, 0, 0);
                        }
                        if (tile.inSmallStairSWVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 180, true, 0, 0);
                        }
                        if (tile.inSmallStairSWHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 270, true, 0, 0);
                        }
                        if (tile.inSmallStairNWVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 0, true, 0, 0);
                        }
                        if (tile.inSmallStairNWHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 270, true, 0, 0);
                        }

                        //height shadows
                        //for (int i = 0; i <= gv.mod.moduleAreasObjects[index].Tiles.Count; i++)
                        //{
                            //if (gv.mod.moduleAreasObjects[index].Tiles)
                        //}
                        
                        //gv.mod.moduleAreasObjects[index]
                        //int test = gv.mod.moduleAreasObjects.Count;

                        if (tile.isInLongShadeN)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 180, false, 0, 0);
                        }
                        else if (tile.isInShortShadeN)
                        {
                            if (tileYCoordOnItsArea - 1 >= 0)
                            {
                                //todo: alwaysNormalShadow
                                if ((!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea - 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].isEWBridge || gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea - 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].alwaysNormalShadow) && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea - 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].transitionToMasterDirection != "S")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 180, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 180, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 180, false, 0, 0);
                            }
                        }

                        if (tile.isInLongShadeE)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 270, false, 0, 0);
                        }
                        else if (tile.isInShortShadeE)
                        {
                            if (tileXCoordOnItsArea + 1 <= gv.mod.moduleAreasObjects[index].MapSizeX - 1)
                            {
                                if ((!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea + 1)].isNSBridge || gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea + 1)].alwaysNormalShadow) && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea + 1].transitionToMasterDirection != "W")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 270, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 270, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 270, false, 0, 0);
                            }

                        }

                        if (tile.isInLongShadeS)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 0, false, 0, 0);
                        }
                        else if (tile.isInShortShadeS)
                        {
                            if (tileYCoordOnItsArea + 1 <= gv.mod.moduleAreasObjects[index].MapSizeY - 1)
                            {
                                if ((!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea + 1) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea)].isEWBridge || gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea + 1) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea)].alwaysNormalShadow) && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea + 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].transitionToMasterDirection != "N")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 0, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 0, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 0, false, 0, 0);
                            }
                        }

                        if (tile.isInLongShadeW)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 90, false, 0, 0);
                        }
                        else if (tile.isInShortShadeW)
                        {
                            if (tileXCoordOnItsArea - 1 >= 0)
                            {
                                if ((!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea - 1)].isNSBridge || gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea - 1)].alwaysNormalShadow) && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea - 1].transitionToMasterDirection != "E")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 90, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 90, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 90, false, 0, 0);
                            }
                        }

                        //if (!tile.isRamp)
                        //{
                        //if (!tile.inRampShadowWest1Short && !tile.inRampShadowWest1Long && !tile.inRampShadowWest2Short && !tile.inRampShadowWest2Long && !tile.inRampShadowNorth5Long && !tile.inRampShadowNorth5Short && !tile.inRampShadowNorth6Long && !tile.inRampShadowNorth6Short)
                        //{
                        if (!tile.isInLongShadeN && !tile.isInShortShadeN && !tile.isInLongShadeW && !tile.isInShortShadeW)
                        {
                            if (tile.isInMaxShadeNW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 180, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNW)
                            {
                                if ((!tile.inRampShadowNorth5Long) && (!tile.inRampShadowWest2Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 180, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeNW) && (!tile.inRampShadowNorth5Short) && (!tile.inRampShadowWest2Short) && !tile.inRampShadowNorth6Short && !tile.inRampShadowWest1Short && (!tile.inRampShadowNorth5Long) && (!tile.inRampShadowWest2Long) && !tile.inRampShadowNorth6Long && !tile.inRampShadowWest1Long)
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 180, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeN && !tile.isInLongShadeW)
                        {

                            if (tile.isInMaxShadeNW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 180, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNW)
                            {
                                if ((!tile.inRampShadowNorth5Long) && (!tile.inRampShadowWest2Long))
                                {
                                    //gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 180, false, 0, 0);
                                    gv.DrawBitmap(gv.cc.longShadowCornerHalf, src, dst, 180, false, 0, 0);
                                }
                            }
                        }
                        //}

                        //if (!tile.inRampShadowEast3Long && !tile.inRampShadowEast3Short && !tile.inRampShadowEast4Short && !tile.inRampShadowEast4Long && !tile.inRampShadowNorth5Long && !tile.inRampShadowNorth5Short && !tile.inRampShadowNorth6Long && !tile.inRampShadowNorth6Short)
                        //{
                        if (!tile.isInLongShadeN && !tile.isInShortShadeN && !tile.isInLongShadeE && !tile.isInShortShadeE)
                        {
                            if (tile.isInMaxShadeNE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 270, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNE)
                            {
                                if ((!tile.inRampShadowNorth6Long) && (!tile.inRampShadowEast4Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 270, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeNE) && (!tile.inRampShadowEast4Short) && (!tile.inRampShadowNorth6Short) && !tile.inRampShadowEast3Short && !tile.inRampShadowNorth5Short && (!tile.inRampShadowEast4Long) && (!tile.inRampShadowNorth6Long) && !tile.inRampShadowEast3Long && !tile.inRampShadowNorth5Long)
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 270, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeN && !tile.isInLongShadeE)
                        {
                            if (tile.isInMaxShadeNE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 270, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNE)
                            {
                                if ((!tile.inRampShadowNorth6Long) && (!tile.inRampShadowEast4Long))
                                {
                                    //gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 270, false, 0, 0);
                                    //mirror before
                                    gv.DrawBitmap(gv.cc.longShadowCornerHalf, src, dst, 270, false, 0, 0);
                                }
                            }
                        }
                        //}

                        //if (!tile.inRampShadowEast3Short && !tile.inRampShadowEast3Long && !tile.inRampShadowEast4Short && !tile.inRampShadowEast4Long && !tile.inRampShadowSouth7Long && !tile.inRampShadowSouth7Short && !tile.inRampShadowSouth8Long && !tile.inRampShadowSouth8Short)
                        //{
                        if (!tile.isInLongShadeS && !tile.isInShortShadeS && !tile.isInLongShadeE && !tile.isInShortShadeE)
                        {
                            if (tile.isInMaxShadeSE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 0, false, 0, 0);
                            }
                            else
                                    if (tile.isInLongShadeSE)
                            {
                                if ((!tile.inRampShadowSouth8Long) && (!tile.inRampShadowEast3Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 0, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeSE) && (!tile.inRampShadowEast3Short) && (!tile.inRampShadowSouth8Short) && !tile.inRampShadowEast4Short && ! tile.inRampShadowSouth7Short && (!tile.inRampShadowEast3Long) && (!tile.inRampShadowSouth8Long) && !tile.inRampShadowEast4Long && !tile.inRampShadowSouth7Long)
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 0, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeS && !tile.isInLongShadeE)
                        {
                            if (tile.isInMaxShadeSE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 0, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeSE)
                            {
                                if ((!tile.inRampShadowSouth8Long) && (!tile.inRampShadowEast3Long))
                                {
                                    //gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 0, false, 0, 0);
                                    //no mirror before
                                    gv.DrawBitmap(gv.cc.longShadowCornerHalfMirror, src, dst, 0, false, 0, 0);
                                }
                            }
                        }
                        //}

                        //if (!tile.inRampShadowWest1Short && !tile.inRampShadowWest1Long && !tile.inRampShadowWest2Short && !tile.inRampShadowWest2Long && !tile.inRampShadowSouth7Long && !tile.inRampShadowSouth7Short && !tile.inRampShadowSouth8Long && !tile.inRampShadowSouth8Short)
                        //{
                        if (!tile.isInLongShadeS && !tile.isInShortShadeS && !tile.isInLongShadeW && !tile.isInShortShadeW)
                        {
                            if (tile.isInMaxShadeSW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 90, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeSW)
                            {
                                if ((!tile.inRampShadowSouth7Long) && (!tile.inRampShadowWest1Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 90, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeSW) && (!tile.inRampShadowWest1Short) && (!tile.inRampShadowSouth7Short) && !tile.inRampShadowWest2Short && !tile.inRampShadowSouth8Short && (!tile.inRampShadowSouth7Long) && (!tile.inRampShadowWest1Long) && !tile.inRampShadowSouth8Long && !tile.inRampShadowWest2Long)
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 90, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeS && !tile.isInLongShadeW)
                        {
                            if (tile.isInMaxShadeSW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 90, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeSW)
                            {
                                if ((!tile.inRampShadowSouth7Long) && (!tile.inRampShadowWest1Long))
                                {
                                    //gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 90, false, 0, 0);
                                    gv.DrawBitmap(gv.cc.longShadowCornerHalfMirror, src, dst, 90, false, 0, 0);
                                }
                            }
                        }
                        /*
                        //entführt
                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                        {
                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                            {
                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                            }
                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                            {
                                gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                            }
                        }
                        */
                        //entrance lights
                        /*
                        if (tile.hasEntranceLightNorth)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 0, false, 0, 0);
                        }
                        if (tile.hasEntranceLightEast)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 90, false, 0, 0);
                        }
                        if (tile.hasEntranceLightSouth)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 180, false, 0, 0);
                        }
                        if (tile.hasEntranceLightWest)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 270, false, 0, 0);
                        }
                        */
                        /*
                        if (tile.isEWBridge)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstNorth, 0, false, 0, 0);
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstSouth, 180, false, 0, 0);
                        }

                        if (tile.isNSBridge)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstWest, 270, false, 0, 0);
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstEast, 90, false, 0, 0);
                        }
                        */
                    }
                }
            }
            #endregion
        }

        
        public void setBridgeStateForMovingProps()
        {
            //note: player bridge state is handled by gv.mod.currentArea.PlayerIsUnderBridge
            //note: for moving props it is then p.isUnderBridge

            foreach (Prop p in gv.mod.currentArea.Props)
            {
                if ((p.isShown) && (p.isMover))
                {
                    if (((p.lastLocationY < gv.mod.currentArea.MapSizeY) && (p.lastLocationX < gv.mod.currentArea.MapSizeX) && p.lastLocationX >= 0 && p.lastLocationY >= 0) && ((p.LocationY < gv.mod.currentArea.MapSizeY) && (p.LocationX < gv.mod.currentArea.MapSizeX) && p.LocationX >= 0 && p.LocationY >= 0))
                    {
                        if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isEWBridge || gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isNSBridge)
                        {
                            if (gv.mod.currentArea.Tiles[p.lastLocationY * gv.mod.currentArea.MapSizeX + p.lastLocationX].heightLevel + 1 == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                            {
                                p.isUnderBridge = true;
                            }
                            else
                            {
                                p.isUnderBridge = false;
                            }
                        }
                        else
                        {
                            p.isUnderBridge = false;
                        }
                    }
                }
            }
        }

        public void drawPermanentTextOnProps()
        {
            foreach (Prop p in gv.mod.currentArea.Props)
            {
                if ((p.permanentText != "none" && p.permanentText != "" && p.permanentText != null) && p.isShown)
                {
                    int txtH = (int)gv.drawFontRegHeight;
                    int xPos = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                    int yPos = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);

                    for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            gv.DrawText(p.permanentText, xPos + x, yPos + txtH + y -gv.squareSize/2, 1.0f, Color.Black);
                        }
                    }
                    gv.DrawText(p.permanentText, xPos, yPos + txtH -gv.squareSize/2, 1.0f, Color.Yellow);
                }
            }
        }

        public void drawPermanentTextOnParty()
        {
            
                if (gv.mod.permanentPartyText != "none")
                {
                    int txtH = 0;
                    if (gv.mod.currentArea.useSuperTinyProps)
                    {
                        txtH = (int)(gv.drawFontRegHeight * 1.5f);
                    }
                    else if (gv.mod.currentArea.useMiniProps)
                    {
                        txtH = (int)(gv.drawFontRegHeight * 1.5f);
                    }
                    else
                    {
                        txtH = (int)(gv.drawFontRegHeight * 1.0f);
                    }
                    int xPos = ((gv.mod.PlayerLocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                    int yPos = ((gv.mod.PlayerLocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                    //frei
                    if (gv.mod.drawPartyDirection == "up" && !gv.mod.currentArea.useSuperTinyProps && !gv.mod.currentArea.useMiniProps)
                    {
                        yPos += gv.squareSize + 1 * txtH;
                    }
                    else if (gv.mod.drawPartyDirection == "up")
                    {
                        yPos += gv.squareSize;
                    }
                        for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            gv.DrawText(gv.mod.permanentPartyText, xPos + x, yPos + txtH + y - gv.squareSize / 2, 0.5f, Color.Black);
                        }
                    }
                    gv.DrawText(gv.mod.permanentPartyText, xPos, yPos + txtH - gv.squareSize / 2, 0.5f, Color.Yellow);
                }
            
        }
        public void redrawMain(float elapsed)
        {

            if (gv.mod.currentArea.areaWeatherName == "" || gv.mod.currentArea.isOverviewMap)
            {
                gv.weatherSounds1.controls.stop();
                gv.weatherSounds2.controls.stop();
                gv.weatherSounds3.controls.stop();
            }
            setBridgeStateForMovingProps();
            //setExplored();
            //setExploredForConnectedDiscoveryTriggers();
            if (!gv.mod.currentArea.areaDark)
            {
                drawBottomFullScreenEffects();
                if ((!gv.mod.currentArea.ImageFileName.Equals("none")) && (gv.cc.bmpMap != null))
                {
                    drawMap();
                }
                drawWorldMap();//ressource heavy

                //CommonCode.addLogText("red", "Failed to setup Music Player...Audio will be disabled. Most likely due to not having Windows Media Player installed or having an incompatible version.");

                //drawProps();
                if (gv.mod.map_showGrid)
                {
                    drawGrid();
                }
            }
            if (gv.mod.currentArea.areaDark)
            {
                drawProps();
                drawPlayer();
                drawHeightShadows();
                //new method for drawing shade for linked tiles on links
                drawLinkShades();
            }
            if (!gv.mod.currentArea.areaDark)
            {
                //drawMovingProps();
            }
            //drawMainMapFloatyText();
            //drawFloatyTextPool();
            //if (gv.mod.useSmoothMovement)
            //{
            //drawFloatyTextByPixelPool();
            //}

            //drawSprites();
            //drawTopFullScreenEffects();

            if (!gv.mod.currentArea.areaDark)
            {
                //drawMovingPropsUnderBridge(elapsed);
                drawProps();
                drawMovingProps(elapsed);
                drawPermanentTextOnProps();
               
                if ((!gv.mod.currentArea.useLightSystem) || (!gv.mod.partyLightOn))
                {
                    //drawProps();
                    //drawMovingProps();
                    drawPlayer();
                    drawHeightShadows();
                    drawPropsOverParty();
                    //new method for drawing shade for linked tiles on links
                    //drawLinkShades();
                    //drawBrigdePropsOverPlayer();
                }

                //if (gv.mod.useAllTileSystem)
                //{
                //drawLightAndDarkness(elapsed);
                //}
                //drawProps();
                //drawMovingProps();
                if ((gv.mod.currentArea.useLightSystem) && (gv.mod.partyLightOn))
                {
                    //drawProps();
                    //drawMovingProps();
                    //if (!gv.mod.noHaloForParty)
                    //{
                    drawPartyHalo(elapsed);
                    //}
                    drawPlayer();
                    drawHeightShadows();
                    drawPropsOverParty();
                    //new method for drawing shade for linked tiles on links
                    //drawLinkShades();
                    //drawBrigdePropsOverPlayer();
                }

                //drawPermanentTextOnParty();

                if (gv.mod.spritesUnderOverlays)
                {
                    if (!gv.mod.currentArea.isOverviewMap)
                    {
                        drawWeatherSprites();
                    }
                }

                if (gv.mod.useAllTileSystem)
                {
                    //if (gv.mod.fogOfWarOpacity == 1.0f)
                    //{
                    drawLightAndDarkness(elapsed);
                    //}
                }

                if (gv.mod.spritesUnderOverlays)
                {
                    drawOtherSprites();
                    //drawTopFullScreenEffects();
                }

                /*
                if (gv.mod.useAllTileSystem)
                {
                    //if (gv.mod.fogOfWarOpacity == 1.0f)
                    //{
                        drawLightAndDarkness(elapsed);
                    //}
                }
                */

                //new method for drawing shade for linked tiles on links
                drawLinkShades();
                drawFogOfWar();
                drawMainMapFloatyText();
                drawFloatyTextPool();
                //drawPermanentTextOnParty();
                if (gv.mod.useSmoothMovement)
                {
                    drawFloatyTextByPixelPool();
                }
                //drawLightAndDarkness(elapsed);

                //test weather under fog of war, darkness and tint of daytime
                if (!gv.mod.spritesUnderOverlays)
                {
                    drawSprites();
                    if (!gv.mod.currentArea.isOverviewMap)
                    {
                        //drawTopFullScreenEffects();
                    }
                }

                bool hideOverlayNeeded = false;
                if (gv.mod.currentArea.UseDayNightCycle)
                {
                    //drawOverlayTints();
                    hideOverlayNeeded = true;
                }

                if (hideOverlayNeeded)
                {
                    drawBlackTilesOverTints();
                    hideOverlayNeeded = false;
                }
                //drawFogOfWar();
            }

            //drawLightAndDarkness(elapsed);

            //drawSprites();
            //drawTopFullScreenEffects();
            drawPermanentTextOnParty();
            if ((showClock) && (!hideClock))
            {
                drawMainMapClockText();
            }

            if (gv.showHotKeys)
            {
                drawMainMapHotKeys();
            }
            //finalBlackenOffMapScreen();
            drawUiLayout();//ressource heavy
            drawMiniMap();
            if (gv.mod.useMinimalisticUI)
            {
                if (gv.mod.logFadeCounter > 0)
                {
                    gv.mod.logFadeCounter--;
                }

                if ((gv.mod.logFadeCounter <= 0) && (gv.mod.logOpacity >= 0.006))
                {
                    gv.mod.logOpacity -= 0.006f;
                }

                /*
                if (gv.mod.interfaceFadeCounter > 0)
                {
                    if (!gv.mod.interfaceCounterHalted)
                    {
                        gv.mod.interfaceFadeCounter--;
                    }
                }

                if (gv.mod.interfaceFadeCounter <= 0)
                {
                    gv.mod.firstXPossible = true;
                        hideClock = true;

                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {
                            //hides right
                            if (pnl.hidingXIncrement > 0)
                            {
                                if (pnl.currentLocX > pnl.shownLocX)
                                {
                                    //pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                            //hides down
                            else if (pnl.hidingYIncrement > 0)
                            {
                                if (pnl.currentLocY > pnl.shownLocY)
                                {
                                    if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                                    {
                                        continue;
                                    }
                                    //pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                            //hides up
                            else if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    //pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                        }
                    }
                
                    */
            }
        }

        //not used anymore (With extended playerOffsetY)
        public void finalBlackenOffMapScreen()
        {
            drawRowOfBlack(gv.playerOffsetY * 2 + 1);
            drawRowOfBlack(gv.playerOffsetY * 2 + 2);
            //gv.cc.setToBorderPixDistancesMainMap();
        }

        public void drawLinkShades()
        {

            //#region new system
            gv.mod.indexOfNorthernNeighbour = -1;
            gv.mod.indexOfSouthernNeighbour = -1;
            gv.mod.indexOfEasternNeighbour = -1;
            gv.mod.indexOfWesternNeighbour = -1;
            gv.mod.indexOfNorthEasternNeighbour = -1;
            gv.mod.indexOfNorthWesternNeighbour = -1;
            gv.mod.indexOfSouthEasternNeighbour = -1;
            gv.mod.indexOfSouthWesternNeighbour = -1;

            gv.mod.seamlessModififierMinX = 0;
            gv.mod.seamlessModififierMaxX = 0;
            gv.mod.seamlessModififierMinY = 0;
            gv.mod.seamlessModififierMaxY = 0;

            #region neighbours
            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
            {
                gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        gv.mod.indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        gv.mod.indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
            {
                gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        gv.mod.indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        gv.mod.indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }
            #endregion

            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

            //if (gv.mod.currentArea.sourceBitmapName != "")
            //{
            for (int x = minX; x < maxX; x++)
            {
                for (int y = minY; y < maxY; y++)
                {

                    bool situationFound = false;
            bool drawTile = true;
            int index = -1;
            Tile tile = new Tile();

            //nine situations where a tile can be:
            //tile on north-western map (diagonal situation)
            if ((x < 0) && (y < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                {
                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfNorthWesternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on south-westernmap (diagonal situation)
            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                {
                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfSouthWesternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on south-easternmap (diagonal situation)
            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                {
                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfSouthEasternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on north-easternmap (diagonal situation)
            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                {
                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfNorthEasternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on western map
            if ((x < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfWesternNeighbour != -1)
                {
                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                    int transformedY = y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfWesternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on southern map
            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfSouthernNeighbour != -1)
                {
                    int transformedX = x;
                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfSouthernNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on eastern map
            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfEasternNeighbour != -1)
                {
                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                    int transformedY = y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfEasternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on northern map
            if ((y < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfNorthernNeighbour != -1)
                {
                    int transformedX = x;
                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfNorthernNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile is on current map
            if (!situationFound)
            {
                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
            }

            if (drawTile)
            {

                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                        //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                        //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                        float scalerX = 1;
                        float scalerY = 1;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);
                        //IbRect src = new IbRect(0, 0, tile.tileBitmap0.PixelSize.Width, tile.tileBitmap0.PixelSize.Height);
                        //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                        //for (int x = minX; x < maxX; x++)
                        //{
                        //for (int y = minY; y < maxY; y++)
                        //{
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        if (tile.linkedToMasterMap)
                        {
                            IbRect srcBlackTile = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                            //IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst, false, 0.75f);
                        }
                    }
                }
                //}
            }
        }

        public void drawWorldMap()
        {

          
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                gv.mod.indexOfNorthernNeighbour = -1;
                gv.mod.indexOfSouthernNeighbour = -1;
                gv.mod.indexOfEasternNeighbour = -1;
                gv.mod.indexOfWesternNeighbour = -1;
                gv.mod.indexOfNorthEasternNeighbour = -1;
                gv.mod.indexOfNorthWesternNeighbour = -1;
                gv.mod.indexOfSouthEasternNeighbour = -1;
                gv.mod.indexOfSouthWesternNeighbour = -1;

                gv.mod.seamlessModififierMinX = -3;
                gv.mod.seamlessModififierMaxX = 0;
                gv.mod.seamlessModififierMinY = -3;
                gv.mod.seamlessModififierMaxY = 0;

                #region neighbours
                if ((gv.mod.currentArea.northernNeighbourArea != "" && gv.mod.currentArea.northernNeighbourArea != "none") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "none")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "none")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "" && gv.mod.currentArea.southernNeighbourArea != "none") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "none")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "none")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "" && gv.mod.currentArea.westernNeighbourArea != "none") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "none")
                    {

                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "none")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "" && gv.mod.currentArea.easternNeighbourArea != "none") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "none")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "" && gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "none")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion
                //foreach (Area a in gv.mod.moduleAreasObjects)
                //mins were -3
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                //was -1
                if (minX < -gv.mod.seamlessModififierMinX - 3)
                {
                    minX = -gv.mod.seamlessModififierMinX - 3;
                }
                //was -1
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 3) { minY = -gv.mod.seamlessModififierMinY - 3; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 2;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX+1) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX+1; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                //new system
                if (gv.mod.useFastRender)
                {
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //check whether x or y extreme, use tile from neighbour then
                            //loop thruogh are with neigbhour names and find index
                            //adjust black tile for border
                            //this is inside layer 0, adjust for all
                            //handle corner, ie draw to two side situations
                            //use tile 1 and tile2 in this case, to draw in two directions
                            //IMPORTANT NOTE:  disable cache cleaning on area change
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile)
                            {

                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                //layer 0
                                for (int layerCounter = 0; layerCounter <= 6; layerCounter++)
                                {
                                   
                                       
                                    
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;

                                    if (layerCounter == 0 && tile.Layer0Filename != "blank")
                                    {
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer0Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer0Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap0 = gv.cc.LoadBitmap(tile.Layer0Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                            //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                            //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                            float scalerX = 1;
                                            float scalerY = 1;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap0.PixelSize.Width, tile.tileBitmap0.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap0);
                                            //gv.DrawBitmap(tile.tileBitmap0, src, dst); 

                                            //gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated = true;
                                            if (gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated)
                                            {
                                                gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, false);
                                            }

                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                            //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                            //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                            float scalerX = 1;
                                            float scalerY = 1;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);

                                            //gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated = true;
                                            if (gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated)
                                            {
                                                gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, false, 1f, true);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, false, 1f, false);
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                    //layercounter 1
                                    if (layerCounter == 1 && tile.Layer1Filename != "blank")
                                    {
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer1Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer1Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            //tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = tile.tileBitmap1.PixelSize.Width / 100;
                                            float scalerY = tile.tileBitmap1.PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap1.PixelSize.Width, tile.tileBitmap1.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap1);
                                            //gv.DrawBitmap(tile.tileBitmap1, src, dst);
                                            gv.DrawBitmap(tile.tileBitmap1, src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale, tile.Layer1Opacity);
                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                            float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale, tile.Layer1Opacity);

                                        }

                                    }

                                    //layerCounter2
                                    if (layerCounter == 2 && tile.Layer2Filename != "blank")
                                    {
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer2Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer2Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            //tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = tile.tileBitmap2.PixelSize.Width / 100;
                                            float scalerY = tile.tileBitmap2.PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap2.PixelSize.Width, tile.tileBitmap2.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap2);
                                            //gv.DrawBitmap(tile.tileBitmap2, src, dst);
                                            gv.DrawBitmap(tile.tileBitmap2, src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale, tile.Layer2Opacity);
                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                            float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale, tile.Layer2Opacity);

                                        }
                                    }

                                    //layerCounter3
                                    if (layerCounter == 3 && tile.Layer3Filename != "blank")
                                    {
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer3Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer3Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            //tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = tile.tileBitmap3.PixelSize.Width / 100;
                                            float scalerY = tile.tileBitmap3.PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap3.PixelSize.Width, tile.tileBitmap3.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap3);
                                            //gv.DrawBitmap(tile.tileBitmap3, src, dst);
                                            gv.DrawBitmap(tile.tileBitmap3, src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale, tile.Layer3Opacity);
                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                            float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale, tile.Layer3Opacity);

                                        }
                                    }

                                    if (layerCounter == 4 && tile.Layer4Filename != "blank")
                                    {
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer4Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer4Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap4 = gv.cc.LoadBitmap(tile.Layer4Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            //tile.tileBitmap4 = gv.cc.LoadBitmap(tile.Layer4Filename);

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = tile.tileBitmap4.PixelSize.Width / 100;
                                            float scalerY = tile.tileBitmap4.PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap4.PixelSize.Width, tile.tileBitmap4.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap4);
                                            //gv.DrawBitmap(tile.tileBitmap4, src, dst);
                                            gv.DrawBitmap(tile.tileBitmap4, src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale, tile.Layer4Opacity);
                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                            float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale, tile.Layer4Opacity);

                                        }

                                    }

                                    //entrance lights
                                    if (layerCounter == 5)
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = gv.cc.longShadow.PixelSize.Width / 100;
                                        float scalerY = gv.cc.longShadow.PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);

                                        IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);

                                        IbRect dstNorth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY - gv.squareSize, brX, brY);
                                        IbRect dstEast = new IbRect(tlX + gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        IbRect dstSouth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY + gv.squareSize, brX, brY);
                                        IbRect dstWest = new IbRect(tlX - gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        //**********************************
                                        if (tile.transitionToMasterDirection == "E")
                                        {
                                            if (gv.mod.currentArea.masterOfThisArea != "none")
                                            {
                                                //krah
                                                // gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.25f);
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 90, false, 0, 0, 1, 1, 0.3f);
                                                //gv.DrawBitmap()
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstEast, 90, false, 0, 0, 1, 1, 0.3f);
                                            }

                                        }
                                        if (tile.transitionToMasterDirection == "W")
                                        {
                                            if (gv.mod.currentArea.masterOfThisArea != "none")
                                            {
                                                //krah
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 270, false, 0, 0, 1, 1, 0.3f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstWest, 270, false, 0, 0, 1, 1, 0.3f);
                                            }
                                        }
                                        if (tile.transitionToMasterDirection == "N")
                                        {
                                            if (gv.mod.currentArea.masterOfThisArea != "none")
                                            {
                                                //krah
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 0, false, 0, 0, 1, 1, 0.3f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.3f);
                                            }
                                        }
                                        if (tile.transitionToMasterDirection == "S")
                                        {
                                            if (gv.mod.currentArea.masterOfThisArea != "none")
                                            {
                                                //krah
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 180, false, 0, 0, 1, 1, 0.3f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstSouth, 180, false, 0, 0, 1, 1, 0.3f);
                                            }
                                        }

                                        //**********************************

                                        if (tile.isEWBridge)
                                        {
                                            if (tile.drawEntranceLights)
                                            {
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.25f);
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstSouth, 180, false, 0, 0, 1, 1, 0.25f);
                                            }
                                            //DrawD2DBitmap(GetFromBitmapList("shortShadow"), src, dst, 180, false, 0, 0, 1, 1, 0.6f);
                                            //gv.mod.currentArea.PlayerIsUnderBridge = 

                                        }

                                        if (tile.isNSBridge)
                                        {
                                            if (tile.drawEntranceLights)
                                            {
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstWest, 270, false, 0, 0, 1, 1, 0.25f);
                                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstEast, 90, false, 0, 0, 1, 1, 0.25f);
                                            }
                                        }

                                        if (tile.drawDownStairShadows)
                                        {
                                            if (tile.hasDownStairShadowS)
                                            {
                                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 0, false, 0, 0);
                                            }

                                            if (tile.hasDownStairShadowW)
                                            {
                                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 90, false, 0, 0);
                                            }

                                            if (tile.hasDownStairShadowN)
                                            {
                                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 180, false, 0, 0);
                                            }

                                            if (tile.hasDownStairShadowE)
                                            {
                                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 270, false, 0, 0);
                                            }
                                        }

                                    }
                                
                                    //layerCounter5
                                    if (layerCounter == 6 && tile.Layer5Filename != "blank")
                                    {
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer5Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer5Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap5 = gv.cc.LoadBitmap(tile.Layer5Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            //tile.tileBitmap5 = gv.cc.LoadBitmap(tile.Layer5Filename);

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = tile.tileBitmap5.PixelSize.Width / 100;
                                            float scalerY = tile.tileBitmap5.PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap5.PixelSize.Width, tile.tileBitmap5.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap5);
                                            //gv.DrawBitmap(tile.tileBitmap5, src, dst);
                                            gv.DrawBitmap(tile.tileBitmap5, src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);
                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                            float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);

                                        }
                                    }

                                   


                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxx
                                }
                            }
                        }
                    }
                }
                //slow system, old
                else
                {

                    if (gv.mod.currentArea.sourceBitmapName != "")
                    {
                        #region Draw Layer 0
                        for (int x = minX; x < maxX; x++)
                        {
                            for (int y = minY; y < maxY; y++)
                            {
                                //check whether x or y extreme, use tile from neighbour then
                                //loop thruogh are with neigbhour names and find index
                                //adjust black tile for border
                                //this is inside layer 0, adjust for all
                                //handle corner, ie draw to two side situations
                                //use tile 1 and tile2 in this case, to draw in two directions
                                //IMPORTANT NOTE:  disable cache cleaning on area change
                                bool situationFound = false;
                                bool drawTile = true;
                                int index = -1;
                                Tile tile = new Tile();

                                //nine situations where a tile can be:
                                //tile on north-western map (diagonal situation)
                                if ((x < 0) && (y < 0) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                        int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfNorthWesternNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on south-westernmap (diagonal situation)
                                if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                        int transformedY = y - gv.mod.currentArea.MapSizeY;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfSouthWesternNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on south-easternmap (diagonal situation)
                                if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                    {
                                        int transformedX = x - gv.mod.currentArea.MapSizeX;
                                        int transformedY = y - gv.mod.currentArea.MapSizeY;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfSouthEasternNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on north-easternmap (diagonal situation)
                                if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                    {
                                        int transformedX = x - gv.mod.currentArea.MapSizeX;
                                        int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfNorthEasternNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on western map
                                if ((x < 0) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                        int transformedY = y;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfWesternNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on southern map
                                if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = y - gv.mod.currentArea.MapSizeY;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfSouthernNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on eastern map
                                if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = x - gv.mod.currentArea.MapSizeX;
                                        int transformedY = y;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfEasternNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile on northern map
                                if ((y < 0) && (!situationFound))
                                {
                                    situationFound = true;
                                    if (gv.mod.indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                        tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                        index = gv.mod.indexOfNorthernNeighbour;
                                        if (tile.Layer0Filename == "t_a_blank")
                                        {
                                            drawTile = false;
                                        }
                                    }
                                    else
                                    {
                                        drawTile = false;
                                    }
                                }
                                //tile is on current map
                                if (!situationFound)
                                {
                                    tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                }

                                if (drawTile)
                                {
                                    try
                                    {

                                        bool tileBitmapIsLoadedAlready = false;
                                        int indexOfLoadedTile = -1;
                                        for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                        {
                                            if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer0Filename)
                                            {
                                                tileBitmapIsLoadedAlready = true;
                                                indexOfLoadedTile = i;
                                                break;
                                            }
                                        }

                                        //hurghx
                                        if (!tileBitmapIsLoadedAlready)
                                        {
                                            gv.mod.loadedTileBitmapsNames.Add(tile.Layer0Filename);
                                            string backup = gv.mod.currentArea.sourceBitmapName;
                                            if (index != -1)
                                            {
                                                gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                            }
                                            tile.tileBitmap0 = gv.cc.LoadBitmap(tile.Layer0Filename);
                                            //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                            gv.mod.currentArea.sourceBitmapName = backup;

                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                            //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                            //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                            float scalerX = 1;
                                            float scalerY = 1;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, tile.tileBitmap0.PixelSize.Width, tile.tileBitmap0.PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                            gv.mod.loadedTileBitmaps.Add(tile.tileBitmap0);
                                            //gv.DrawBitmap(tile.tileBitmap0, src, dst); 

                                            //gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated = true;
                                            if (gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated)
                                            {
                                                gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, false);
                                            }

                                        }
                                        else
                                        {
                                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                            //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                            //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                            //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                            float scalerX = 1;
                                            float scalerY = 1;
                                            int brX = (int)(gv.squareSize * scalerX);
                                            int brY = (int)(gv.squareSize * scalerY);
                                            IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                            //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);

                                            //gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated = true;
                                            if (gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated)
                                            {
                                                gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, false, 1f, true);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, false, 1f, false);
                                            }


                                        }

                                        //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                    }
                                    catch
                                    {
                                        //int i = 2;
                                    }
                                }
                            }
                        }
                        #endregion
                    }
                    #region Draw Layer 1
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                   
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                          
                            if (drawTile && tile.Layer1Filename != "t_a_blank")
                            {
                                try
                                {

                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;
                                    for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                    {
                                        if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer1Filename)
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = i;
                                            break;
                                        }
                                    }

                                    //hurghx
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(tile.Layer1Filename);
                                        string backup = gv.mod.currentArea.sourceBitmapName;
                                        if (index != -1)
                                        {
                                            gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                        }
                                        tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);
                                        //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                        gv.mod.currentArea.sourceBitmapName = backup;

                                        //tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);

                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = tile.tileBitmap1.PixelSize.Width / 100;
                                        float scalerY = tile.tileBitmap1.PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, tile.tileBitmap1.PixelSize.Width, tile.tileBitmap1.PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        gv.mod.loadedTileBitmaps.Add(tile.tileBitmap1);
                                        //gv.DrawBitmap(tile.tileBitmap1, src, dst);
                                        gv.DrawBitmap(tile.tileBitmap1, src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale, tile.Layer1Opacity);
                                    }
                                    else
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                        float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale, tile.Layer1Opacity);

                                    }

                                    //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                }
                                catch { }
                            }
                        }
                    }
                    #endregion
                    #region Draw Layer 2
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile && tile.Layer2Filename != "t_a_blank")
                            {
                                try
                                {

                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;
                                    for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                    {
                                        if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer2Filename)
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = i;
                                            break;
                                        }
                                    }

                                    //hurghx
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(tile.Layer2Filename);
                                        string backup = gv.mod.currentArea.sourceBitmapName;
                                        if (index != -1)
                                        {
                                            gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                        }
                                        tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);
                                        //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                        gv.mod.currentArea.sourceBitmapName = backup;
                                        //tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);

                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = tile.tileBitmap2.PixelSize.Width / 100;
                                        float scalerY = tile.tileBitmap2.PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, tile.tileBitmap2.PixelSize.Width, tile.tileBitmap2.PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        gv.mod.loadedTileBitmaps.Add(tile.tileBitmap2);
                                        //gv.DrawBitmap(tile.tileBitmap2, src, dst);
                                        gv.DrawBitmap(tile.tileBitmap2, src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale, tile.Layer2Opacity);

                                    }
                                    else
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                        float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale, tile.Layer2Opacity);

                                    }

                                    //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                }
                                catch { }
                            }
                        }
                    }
                    #endregion
                    #region Draw Layer 3
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile && tile.Layer3Filename != "t_a_blank")
                            {
                                try
                                {

                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;
                                    for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                    {
                                        if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer3Filename)
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = i;
                                            break;
                                        }
                                    }

                                    //hurghx
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(tile.Layer3Filename);
                                        string backup = gv.mod.currentArea.sourceBitmapName;
                                        if (index != -1)
                                        {
                                            gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                        }
                                        tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);
                                        //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                        gv.mod.currentArea.sourceBitmapName = backup;
                                        //tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);

                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = tile.tileBitmap3.PixelSize.Width / 100;
                                        float scalerY = tile.tileBitmap3.PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, tile.tileBitmap3.PixelSize.Width, tile.tileBitmap3.PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        gv.mod.loadedTileBitmaps.Add(tile.tileBitmap3);
                                        //gv.DrawBitmap(tile.tileBitmap3, src, dst);
                                        gv.DrawBitmap(tile.tileBitmap3, src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale, tile.Layer3Opacity);

                                    }
                                    else
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                        float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale, tile.Layer3Opacity);
                                    }

                                    //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                }
                                catch { }
                            }
                        }
                    }
                    #endregion
                    #region Draw Layer 4
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile && tile.Layer4Filename != "t_a_blank")
                            {
                                try
                                {

                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;
                                    for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                    {
                                        if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer4Filename)
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = i;
                                            break;
                                        }
                                    }

                                    //hurghx
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(tile.Layer4Filename);
                                        string backup = gv.mod.currentArea.sourceBitmapName;
                                        if (index != -1)
                                        {
                                            gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                        }
                                        tile.tileBitmap4 = gv.cc.LoadBitmap(tile.Layer4Filename);
                                        //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                        gv.mod.currentArea.sourceBitmapName = backup;
                                        //tile.tileBitmap4 = gv.cc.LoadBitmap(tile.Layer4Filename);

                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = tile.tileBitmap4.PixelSize.Width / 100;
                                        float scalerY = tile.tileBitmap4.PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, tile.tileBitmap4.PixelSize.Width, tile.tileBitmap4.PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        gv.mod.loadedTileBitmaps.Add(tile.tileBitmap4);
                                        //gv.DrawBitmap(tile.tileBitmap4, src, dst);
                                        gv.DrawBitmap(tile.tileBitmap4, src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale, tile.Layer4Opacity);

                                    }
                                    else
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                        float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale, tile.Layer4Opacity);

                                    }

                                    //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                }
                                catch { }
                            }
                        }
                    }
                    #endregion

                    #region Draw Entrance lights
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile)
                            {
                                /*
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                float scalerX = tile.tileBitmap5.PixelSize.Width / 100;
                                float scalerY = tile.tileBitmap5.PixelSize.Height / 100;
                                int brX = (int)(gv.squareSize * scalerX);
                                int brY = (int)(gv.squareSize * scalerY);
                                IbRect src = new IbRect(0, 0, tile.tileBitmap5.PixelSize.Width, tile.tileBitmap5.PixelSize.Height);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                */
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                float scalerX = gv.cc.longShadow.PixelSize.Width / 100;
                                float scalerY = gv.cc.longShadow.PixelSize.Height / 100;
                                int brX = (int)(gv.squareSize * scalerX);
                                int brY = (int)(gv.squareSize * scalerY);

                                IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);

                                IbRect dstNorth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY - gv.squareSize, brX, brY);
                                IbRect dstEast = new IbRect(tlX + gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                IbRect dstSouth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY + gv.squareSize, brX, brY);
                                IbRect dstWest = new IbRect(tlX - gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                //**********************************
                                if (tile.transitionToMasterDirection == "E")
                                {
                                    if (gv.mod.currentArea.masterOfThisArea != "none")
                                    {
                                        //krah
                                        // gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.25f);
                                        gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 90, false, 0, 0, 1, 1, 0.3f);
                                        //gv.DrawBitmap()
                                    }
                                    else
                                    {
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstEast, 90, false, 0, 0, 1, 1, 0.3f);
                                    }

                                }
                                if (tile.transitionToMasterDirection == "W")
                                {
                                    if (gv.mod.currentArea.masterOfThisArea != "none")
                                    {
                                        //krah
                                        gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 270, false, 0, 0, 1, 1, 0.3f);
                                    }
                                    else
                                    {
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstWest, 270, false, 0, 0, 1, 1, 0.3f);
                                    }
                                }
                                if (tile.transitionToMasterDirection == "N")
                                {
                                    if (gv.mod.currentArea.masterOfThisArea != "none")
                                    {
                                        //krah
                                        gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 0, false, 0, 0, 1, 1, 0.3f);
                                    }
                                    else
                                    {
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.3f);
                                    }
                                }
                                if (tile.transitionToMasterDirection == "S")
                                {
                                    if (gv.mod.currentArea.masterOfThisArea != "none")
                                    {
                                        //krah
                                        gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 180, false, 0, 0, 1, 1, 0.3f);
                                    }
                                    else
                                    {
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstSouth, 180, false, 0, 0, 1, 1, 0.3f);
                                    }
                                }

                                //**********************************

                                if (tile.isEWBridge)
                                {
                                    if (tile.drawEntranceLights)
                                    {
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.25f);
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstSouth, 180, false, 0, 0, 1, 1, 0.25f);
                                    }
                                    //DrawD2DBitmap(GetFromBitmapList("shortShadow"), src, dst, 180, false, 0, 0, 1, 1, 0.6f);
                                    //gv.mod.currentArea.PlayerIsUnderBridge = 

                                }

                                if (tile.isNSBridge)
                                {
                                    if (tile.drawEntranceLights)
                                    {
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstWest, 270, false, 0, 0, 1, 1, 0.25f);
                                        gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstEast, 90, false, 0, 0, 1, 1, 0.25f);
                                    }
                                }

                                if (tile.drawDownStairShadows)
                                {
                                    if (tile.hasDownStairShadowS)
                                    {
                                        gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 0, false, 0, 0);
                                    }

                                    if (tile.hasDownStairShadowW)
                                    {
                                        gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 90, false, 0, 0);
                                    }

                                    if (tile.hasDownStairShadowN)
                                    {
                                        gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 180, false, 0, 0);
                                    }

                                    if (tile.hasDownStairShadowE)
                                    {
                                        gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 270, false, 0, 0);
                                    }
                                }

                            }
                        }
                    }
                    #endregion


                    #region Draw Layer 5
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile && tile.Layer5Filename != "t_a_blank")
                            {
                                try
                                {

                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;
                                    for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                    {
                                        if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer5Filename)
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = i;
                                            break;
                                        }
                                    }

                                    //hurghx
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(tile.Layer5Filename);
                                        string backup = gv.mod.currentArea.sourceBitmapName;
                                        if (index != -1)
                                        {
                                            gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                        }
                                        tile.tileBitmap5 = gv.cc.LoadBitmap(tile.Layer5Filename);
                                        //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                        gv.mod.currentArea.sourceBitmapName = backup;
                                        //tile.tileBitmap5 = gv.cc.LoadBitmap(tile.Layer5Filename);

                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = tile.tileBitmap5.PixelSize.Width / 100;
                                        float scalerY = tile.tileBitmap5.PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, tile.tileBitmap5.PixelSize.Width, tile.tileBitmap5.PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        gv.mod.loadedTileBitmaps.Add(tile.tileBitmap5);
                                        //gv.DrawBitmap(tile.tileBitmap5, src, dst);
                                        gv.DrawBitmap(tile.tileBitmap5, src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);
                                        /*
                                        if (gv.mod.currentArea.isOverviewMap)
                                        {
                                            tlX = (x - gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapX + gv.playerOffsetX) * gv.squareSize;
                                            tlY = (y - gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapY + gv.playerOffsetY) * gv.squareSize;
                                            src = new IbRect(0, 0, tile.tileBitmap5.PixelSize.Width, tile.tileBitmap5.PixelSize.Height);
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                            //gv.DrawBitmap(tile.tileBitmap5, src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);
                                            if (gv.mod.showPartyToken)
                                            {
                                                gv.DrawBitmap(gv.mod.partyTokenBitmap, src, dst, !gv.mod.playerList[0].combatFacingLeft);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.mod.playerList[gv.mod.selectedPartyLeader].token, src, dst, !gv.mod.playerList[0].combatFacingLeft);
                                            }

                                        }
                                        */

                                    }
                                    else
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                        float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);
                                    }

                                    //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                }
                                catch { }
                            }
                        }
                    }
                    #endregion

                    #region Draw Black Squares
                    //drawColumnOfBlack(gv.playerOffsetX*2+2);
                    //MAY NOT NEED THIS WITH NEW FULL SCREEN gv.modE
                    //draw black squares to make sure and hide any large tiles that have over drawn outside the visible map area
                    /*int mapStartLocationInSquares = 6;
                    int mapSizeInSquares = gv.playerOffset + gv.playerOffset + 1;
                    int mapRightEndSquare = mapStartLocationInSquares + mapSizeInSquares;
                    if (!gv.useLargeLayout) { mapStartLocationInSquares = 4; }
                    IbRect srcBlackTile = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);

                    //draw left side squares
                    for (int x = mapStartLocationInSquares - 2; x < mapStartLocationInSquares; x++)
                    {
                        for (int y = 0; y < mapSizeInSquares; y++)
                        {
                            IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                            gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                        }
                    }
                    //draw right side squares
                    for (int x = mapRightEndSquare; x < mapRightEndSquare + 2; x++)
                    {
                        for (int y = 0; y < mapSizeInSquares; y++)
                        {
                            IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                            gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                        }
                    }
                    //draw top squares
                    for (int x = mapStartLocationInSquares - 2; x < mapRightEndSquare + 2; x++)
                    {
                        IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, -1 * gv.squareSize, gv.squareSize, gv.squareSize);
                        gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                    }
                    //draw bottom squares
                    for (int x = mapStartLocationInSquares - 2; x < mapRightEndSquare + 2; x++)
                    {
                        for (int y = mapSizeInSquares; y < mapSizeInSquares + 2; y++)
                        {
                            IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                            gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                        }
                    }*/
                    //draw black tiles over large tiles when party is near edges of map
                    //drawBlackTilesOverTints();
                    #endregion

                    #endregion
                }
            }
            else //old system using single image background and no load tile images on demand
            {
                #region old system
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 2; // use 2 so that extends down to bottom of screen
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 2
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer2Filename), src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 3
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer3Filename), src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 4
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer4Filename), src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 5
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer5Filename), src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale);
                        }
                        catch { }
                    }
                }
                #endregion

                #endregion
            }

            /*
            if (gv.mod.currentArea.isOverviewMap)
            {
                int tlX = (gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapX + gv.playerOffsetX) * gv.squareSize;
                int tlY = (gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapY + gv.playerOffsetY) * gv.squareSize;
                IbRect src = new IbRect(0, 0, gv.mod.partyTokenBitmap.PixelSize.Width, gv.mod.partyTokenBitmap.PixelSize.Height);
                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                //gv.DrawBitmap(tile.tileBitmap5, src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);
                if (gv.mod.showPartyToken)
                {
                    gv.DrawBitmap(gv.mod.partyTokenBitmap, src, dst, !gv.mod.playerList[0].combatFacingLeft);
                }
                else
                {
                    gv.DrawBitmap(gv.mod.playerList[gv.mod.selectedPartyLeader].token, src, dst, !gv.mod.playerList[0].combatFacingLeft);
                }

            }
            */
        }

        
        /*
        public void drawHeightLevelShadows()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                gv.mod.indexOfNorthernNeighbour = -1;
                gv.mod.indexOfSouthernNeighbour = -1;
                gv.mod.indexOfEasternNeighbour = -1;
                gv.mod.indexOfWesternNeighbour = -1;
                gv.mod.indexOfNorthEasternNeighbour = -1;
                gv.mod.indexOfNorthWesternNeighbour = -1;
                gv.mod.indexOfSouthEasternNeighbour = -1;
                gv.mod.indexOfSouthWesternNeighbour = -1;

                gv.mod.seamlessModififierMinX = 0;
                gv.mod.seamlessModififierMaxX = 0;
                gv.mod.seamlessModififierMinY = 0;
                gv.mod.seamlessModififierMaxY = 0;

                #region neighbours
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX) 
                        {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }
                        
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }
                        
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion
                //foreach (Area a in gv.mod.moduleAreasObjects)

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX -1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY +1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;

                                //now we know the potentially shaded tile, we need information on how it is shaded
                                //this requires information on the height levels of all neighbouring tiles, relative to the current tile's height
                                //this requires a loop checking the tiles neighbouring the current tile
                                //main difficulty is that the neighbouring tiles can very well be on different maps than the currrent tile
                                //consequence is we will need to nest the above mechanism again 
                                for (int nx = -1; nx < 2; nx++)
                                {
                                    for (int ny = -1; ny < 2; ny++)
                                    {
                                        //nine situations where a shadow granting tile can be:
                                        //shadow granting tile on north-western map (diagonal situation)
                                        if ((x + nx < 0) && (y + ny < 0) && (!situationFound))
                                        {

                                        }
                                    }
                                }
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer1Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer1Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;

                                    //tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap1.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap1.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap1.PixelSize.Width, tile.tileBitmap1.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap1);
                                    gv.DrawBitmap(tile.tileBitmap1, src, dst);
                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion
                
                #endregion
            }
            else //old system using single image background and no load tile images on demand
            {
                #region old system
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 2; // use 2 so that extends down to bottom of screen
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 2
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer2Filename), src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 3
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer3Filename), src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 4
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer4Filename), src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 5
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer5Filename), src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale);
                        }
                        catch { }
                    }
                }
                #endregion

                #endregion
            }
        }
        */

        public void drawTopFullScreenEffects()
        {
            #region dst tile preparation (min and max)  

            int indexOfNorthernNeighbour = -1;
            int indexOfSouthernNeighbour = -1;
            int indexOfEasternNeighbour = -1;
            int indexOfWesternNeighbour = -1;
            int indexOfNorthEasternNeighbour = -1;
            int indexOfNorthWesternNeighbour = -1;
            int indexOfSouthEasternNeighbour = -1;
            int indexOfSouthWesternNeighbour = -1;

            int seamlessModififierMinX = 0;
            int seamlessModififierMaxX = 0;
            int seamlessModififierMinY = 0;
            int seamlessModififierMaxY = 0;

            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
            {
                seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
            {
                seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            //set up teh min and max dst tiles to iterate through, ie draw on into the map area and that on a tile by tile basis 
            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX;
            if (minX < -seamlessModififierMinX) { minX = -seamlessModififierMinX; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY;
            if (minY < -seamlessModififierMinY) { minY = -seamlessModififierMinY; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY; }
            #endregion
            //hurgh
            #region Draw full screen layer 1
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer1 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer1) && (gv.mod.currentArea.FullScreenEffectLayer1IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive1))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect1);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride1 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 15;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 750;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1.0f;
                    float defaultOverrideSpeedY1 = 1.0f;
                    int defaultOverrideDelayLimit1 = 110;
                    string defaultOverrideIsNoScrollSource1 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.075f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.075f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.45f;
                    float defaultOverrideSpeedY1 = -0.55f;
                    int defaultOverrideDelayLimit1 = 470;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }


                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.15f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = -2.8f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1f;
                    float defaultOverrideSpeedY1 = 1f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                    gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX1;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY1;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed1 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride1 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter1 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter1 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter1 >= (gv.mod.currentArea.numberOfCyclesPerOccurence1))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter1 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence1 * -1;
                        if (gv.mod.currentArea.changeFrameCounter1 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade1)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == (gv.mod.currentArea.numberOfCyclesPerOccurence1 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging1)
                    {
                        gv.mod.currentArea.changeCounter1 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter1 > gv.mod.currentArea.changeLimit1)
                        {
                            gv.mod.currentArea.changeCounter1 = 0;
                            gv.mod.currentArea.changeFrameCounter1 += 1;
                            if (gv.mod.currentArea.changeFrameCounter1 > gv.mod.currentArea.changeNumberOfFrames1)
                            {
                                gv.mod.currentArea.changeFrameCounter1 = 1;
                            }
                        }
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1 + gv.mod.currentArea.changeFrameCounter1.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect1.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX1;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX1 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY1 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX1 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {

                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer1)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;


                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;

                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders1)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion


                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource1 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);

                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion

            #region Draw full screen layer 2
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer2 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer2) && (gv.mod.currentArea.FullScreenEffectLayer2IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive2))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect2);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride2 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 15;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 750;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1.0f;
                    float defaultOverrideSpeedY2 = 1.0f;
                    int defaultOverrideDelayLimit2 = 110;
                    string defaultOverrideIsNoScrollSource2 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.075f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.075f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.45f;
                    float defaultOverrideSpeedY2 = -0.55f;
                    int defaultOverrideDelayLimit2 = 470;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }


                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.15f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = -2.8f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1f;
                    float defaultOverrideSpeedY2 = 1f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                    gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX2;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY2;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed2 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride2 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter2 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter2 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter2 >= (gv.mod.currentArea.numberOfCyclesPerOccurence2))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter2 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence2 * -1;
                        if (gv.mod.currentArea.changeFrameCounter2 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade2)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == (gv.mod.currentArea.numberOfCyclesPerOccurence2 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging2)
                    {
                        gv.mod.currentArea.changeCounter2 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter2 > gv.mod.currentArea.changeLimit2)
                        {
                            gv.mod.currentArea.changeCounter2 = 0;
                            gv.mod.currentArea.changeFrameCounter2 += 1;
                            if (gv.mod.currentArea.changeFrameCounter2 > gv.mod.currentArea.changeNumberOfFrames2)
                            {
                                gv.mod.currentArea.changeFrameCounter2 = 1;
                            }
                        }
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2 + gv.mod.currentArea.changeFrameCounter2.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect2.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX2;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX2 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY2 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX2 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer2)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource2 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 3
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer3 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer3) && (gv.mod.currentArea.FullScreenEffectLayer3IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive3))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect3);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride3 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 15;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 750;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1.0f;
                    float defaultOverrideSpeedY3 = 1.0f;
                    int defaultOverrideDelayLimit3 = 110;
                    string defaultOverrideIsNoScrollSource3 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.075f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.075f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.45f;
                    float defaultOverrideSpeedY3 = -0.55f;
                    int defaultOverrideDelayLimit3 = 470;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }


                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.15f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = -2.8f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1f;
                    float defaultOverrideSpeedY3 = 1f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                    gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX3;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY3;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed3 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride3 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter3 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter3 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter3 >= (gv.mod.currentArea.numberOfCyclesPerOccurence3))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter3 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence3 * -1;
                        if (gv.mod.currentArea.changeFrameCounter3 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade3)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == (gv.mod.currentArea.numberOfCyclesPerOccurence3 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging3)
                    {
                        gv.mod.currentArea.changeCounter3 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter3 > gv.mod.currentArea.changeLimit3)
                        {
                            gv.mod.currentArea.changeCounter3 = 0;
                            gv.mod.currentArea.changeFrameCounter3 += 1;
                            if (gv.mod.currentArea.changeFrameCounter3 > gv.mod.currentArea.changeNumberOfFrames3)
                            {
                                gv.mod.currentArea.changeFrameCounter3 = 1;
                            }
                        }
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3 + gv.mod.currentArea.changeFrameCounter3.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect3.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX3;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY3;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX3 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY3 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX3 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY3 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer3)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource3 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 4
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer4 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer4) && (gv.mod.currentArea.FullScreenEffectLayer4IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive4))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect4);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride4 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 15;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 750;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1.0f;
                    float defaultOverrideSpeedY4 = 1.0f;
                    int defaultOverrideDelayLimit4 = 110;
                    string defaultOverrideIsNoScrollSource4 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.075f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.075f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.45f;
                    float defaultOverrideSpeedY4 = -0.55f;
                    int defaultOverrideDelayLimit4 = 470;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }


                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.15f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = -2.8f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1f;
                    float defaultOverrideSpeedY4 = 1f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                    gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX4;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY4;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed4 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride4 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter4 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter4 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter4 >= (gv.mod.currentArea.numberOfCyclesPerOccurence4))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter4 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence4 * -1;
                        if (gv.mod.currentArea.changeFrameCounter4 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade4)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == (gv.mod.currentArea.numberOfCyclesPerOccurence4 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging4)
                    {
                        gv.mod.currentArea.changeCounter4 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter4 > gv.mod.currentArea.changeLimit4)
                        {
                            gv.mod.currentArea.changeCounter4 = 0;
                            gv.mod.currentArea.changeFrameCounter4 += 1;
                            if (gv.mod.currentArea.changeFrameCounter4 > gv.mod.currentArea.changeNumberOfFrames4)
                            {
                                gv.mod.currentArea.changeFrameCounter4 = 1;
                            }
                        }
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4 + gv.mod.currentArea.changeFrameCounter4.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect4.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX4;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY4;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX4 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY4 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX4 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY4 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer4)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource4 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 5
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer5 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer5) && (gv.mod.currentArea.FullScreenEffectLayer5IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive5) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect5);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride5 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 15;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 750;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1.0f;
                    float defaultOverrideSpeedY5 = 1.0f;
                    int defaultOverrideDelayLimit5 = 110;
                    string defaultOverrideIsNoScrollSource5 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.075f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.075f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.45f;
                    float defaultOverrideSpeedY5 = -0.55f;
                    int defaultOverrideDelayLimit5 = 470;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }


                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.15f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = -2.8f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1f;
                    float defaultOverrideSpeedY5 = 1f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                    gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX5;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY5;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed5 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride5 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter5 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter5 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter5 >= (gv.mod.currentArea.numberOfCyclesPerOccurence5))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter5 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence5 * -1;
                        if (gv.mod.currentArea.changeFrameCounter5 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade5)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == (gv.mod.currentArea.numberOfCyclesPerOccurence5 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5));
                        }
                    }

                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }

                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging5)
                    {
                        gv.mod.currentArea.changeCounter5 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter5 > gv.mod.currentArea.changeLimit5)
                        {
                            gv.mod.currentArea.changeCounter5 = 0;
                            gv.mod.currentArea.changeFrameCounter5 += 1;
                            if (gv.mod.currentArea.changeFrameCounter5 > gv.mod.currentArea.changeNumberOfFrames5)
                            {
                                gv.mod.currentArea.changeFrameCounter5 = 1;
                            }
                        }
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5 + gv.mod.currentArea.changeFrameCounter5.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect5.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX5;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY5;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX5 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY5 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX5 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY5 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer5)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource5 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 6
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer6 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer6) && (gv.mod.currentArea.FullScreenEffectLayer6IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive6) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect6);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride6 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 15;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 750;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1.0f;
                    float defaultOverrideSpeedY6 = 1.0f;
                    int defaultOverrideDelayLimit6 = 110;
                    string defaultOverrideIsNoScrollSource6 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.075f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.075f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.45f;
                    float defaultOverrideSpeedY6 = -0.55f;
                    int defaultOverrideDelayLimit6 = 470;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }


                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.15f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = -2.8f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1f;
                    float defaultOverrideSpeedY6 = 1f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                    gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX6;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY6;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed6 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride6 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter6 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter6 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter6 >= (gv.mod.currentArea.numberOfCyclesPerOccurence6))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter6 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence6 * -1;
                        if (gv.mod.currentArea.changeFrameCounter6 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade6)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == (gv.mod.currentArea.numberOfCyclesPerOccurence6 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging6)
                    {
                        gv.mod.currentArea.changeCounter6 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter6 > gv.mod.currentArea.changeLimit6)
                        {
                            gv.mod.currentArea.changeCounter6 = 0;
                            gv.mod.currentArea.changeFrameCounter6 += 1;
                            if (gv.mod.currentArea.changeFrameCounter6 > gv.mod.currentArea.changeNumberOfFrames6)
                            {
                                gv.mod.currentArea.changeFrameCounter6 = 1;
                            }
                        }
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6 + gv.mod.currentArea.changeFrameCounter6.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect6.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX6;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY6;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX6 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY6 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX6 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY6 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer6)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource6 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 7
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer7 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer7) && (gv.mod.currentArea.FullScreenEffectLayer7IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive7) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect7);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride7 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 15;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 750;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1.0f;
                    float defaultOverrideSpeedY7 = 1.0f;
                    int defaultOverrideDelayLimit7 = 110;
                    string defaultOverrideIsNoScrollSource7 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.075f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.075f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.45f;
                    float defaultOverrideSpeedY7 = -0.55f;
                    int defaultOverrideDelayLimit7 = 470;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }


                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.15f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = -2.8f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1f;
                    float defaultOverrideSpeedY7 = 1f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                    gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX7;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY7;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed7 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride7 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter7 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter7 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter7 >= (gv.mod.currentArea.numberOfCyclesPerOccurence7))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter7 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence7 * -1;
                        if (gv.mod.currentArea.changeFrameCounter7 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade7)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == (gv.mod.currentArea.numberOfCyclesPerOccurence7 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging7)
                    {
                        gv.mod.currentArea.changeCounter7 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter7 > gv.mod.currentArea.changeLimit7)
                        {
                            gv.mod.currentArea.changeCounter7 = 0;
                            gv.mod.currentArea.changeFrameCounter7 += 1;
                            if (gv.mod.currentArea.changeFrameCounter7 > gv.mod.currentArea.changeNumberOfFrames7)
                            {
                                gv.mod.currentArea.changeFrameCounter7 = 1;
                            }
                        }
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7 + gv.mod.currentArea.changeFrameCounter7.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect7.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX7;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY7;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX7 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY7 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX7 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY7 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer7)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource7 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 8
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X800 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer8 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer8) && (gv.mod.currentArea.FullScreenEffectLayer8IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive8) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect8);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride8 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 15;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 750;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1.0f;
                    float defaultOverrideSpeedY8 = 1.0f;
                    int defaultOverrideDelayLimit8 = 110;
                    string defaultOverrideIsNoScrollSource8 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.075f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.075f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.45f;
                    float defaultOverrideSpeedY8 = -0.55f;
                    int defaultOverrideDelayLimit8 = 470;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }


                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.15f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = -2.8f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1f;
                    float defaultOverrideSpeedY8 = 1f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                    gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX8;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY8;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed8 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride8 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter8 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter8 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter8 >= (gv.mod.currentArea.numberOfCyclesPerOccurence8))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter8 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence8 * -1;
                        if (gv.mod.currentArea.changeFrameCounter8 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade8)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == (gv.mod.currentArea.numberOfCyclesPerOccurence8 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging8)
                    {
                        gv.mod.currentArea.changeCounter8 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter8 > gv.mod.currentArea.changeLimit8)
                        {
                            gv.mod.currentArea.changeCounter8 = 0;
                            gv.mod.currentArea.changeFrameCounter8 += 1;
                            if (gv.mod.currentArea.changeFrameCounter8 > gv.mod.currentArea.changeNumberOfFrames8)
                            {
                                gv.mod.currentArea.changeFrameCounter8 = 1;
                            }
                        }
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8 + gv.mod.currentArea.changeFrameCounter8.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect8.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX8;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY8;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX8 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY8 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX8 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY8 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer8)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource8 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 9
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X900 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer9 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer9) && (gv.mod.currentArea.FullScreenEffectLayer9IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive9) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect9);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride9 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 15;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 750;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1.0f;
                    float defaultOverrideSpeedY9 = 1.0f;
                    int defaultOverrideDelayLimit9 = 110;
                    string defaultOverrideIsNoScrollSource9 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.075f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.075f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.45f;
                    float defaultOverrideSpeedY9 = -0.55f;
                    int defaultOverrideDelayLimit9 = 470;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }


                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.15f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = -2.8f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1f;
                    float defaultOverrideSpeedY9 = 1f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                    gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX9;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY9;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed9 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride9 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter9 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter9 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter9 >= (gv.mod.currentArea.numberOfCyclesPerOccurence9))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter9 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence9 * -1;
                        if (gv.mod.currentArea.changeFrameCounter9 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade9)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == (gv.mod.currentArea.numberOfCyclesPerOccurence9 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging9)
                    {
                        gv.mod.currentArea.changeCounter9 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter9 > gv.mod.currentArea.changeLimit9)
                        {
                            gv.mod.currentArea.changeCounter9 = 0;
                            gv.mod.currentArea.changeFrameCounter9 += 1;
                            if (gv.mod.currentArea.changeFrameCounter9 > gv.mod.currentArea.changeNumberOfFrames9)
                            {
                                gv.mod.currentArea.changeFrameCounter9 = 1;
                            }
                        }
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9 + gv.mod.currentArea.changeFrameCounter9.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect9.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX9;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY9;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX9 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY9 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX9 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY9 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer9)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource9 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 10
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X1000 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer10 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer10) && (gv.mod.currentArea.FullScreenEffectLayer10IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive10) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect10);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride10 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 15;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 750;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1.0f;
                    float defaultOverrideSpeedY10 = 1.0f;
                    int defaultOverrideDelayLimit10 = 110;
                    string defaultOverrideIsNoScrollSource10 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.075f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.075f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.45f;
                    float defaultOverrideSpeedY10 = -0.55f;
                    int defaultOverrideDelayLimit10 = 470;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }


                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.15f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = -2.8f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1f;
                    float defaultOverrideSpeedY10 = 1f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                    gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX10;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY10;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed10 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride10 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter10 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter10 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter10 >= (gv.mod.currentArea.numberOfCyclesPerOccurence10))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter10 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence10 * -1;
                        if (gv.mod.currentArea.changeFrameCounter10 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade10)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == (gv.mod.currentArea.numberOfCyclesPerOccurence10 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging10)
                    {
                        gv.mod.currentArea.changeCounter10 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter10 > gv.mod.currentArea.changeLimit10)
                        {
                            gv.mod.currentArea.changeCounter10 = 0;
                            gv.mod.currentArea.changeFrameCounter10 += 1;
                            if (gv.mod.currentArea.changeFrameCounter10 > gv.mod.currentArea.changeNumberOfFrames10)
                            {
                                gv.mod.currentArea.changeFrameCounter10 = 1;
                            }
                        }
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10 + gv.mod.currentArea.changeFrameCounter10.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect10.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX10;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY10;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX10 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY10 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX10 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY10 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer10)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource10 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion   
        }

        public void drawBottomFullScreenEffects()
        {
            #region dst tile preparation (min and max)  

            int indexOfNorthernNeighbour = -1;
            int indexOfSouthernNeighbour = -1;
            int indexOfEasternNeighbour = -1;
            int indexOfWesternNeighbour = -1;
            int indexOfNorthEasternNeighbour = -1;
            int indexOfNorthWesternNeighbour = -1;
            int indexOfSouthEasternNeighbour = -1;
            int indexOfSouthWesternNeighbour = -1;

            int seamlessModififierMinX = 0;
            int seamlessModififierMaxX = 0;
            int seamlessModififierMinY = 0;
            int seamlessModififierMaxY = 0;

            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
            {
                seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
            {
                seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            //set up teh min and max dst tiles to iterate through, ie draw on into the map area and that on a tile by tile basis 
            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX;
            if (minX < -seamlessModififierMinX) { minX = -seamlessModififierMinX; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY;
            if (minY < -seamlessModififierMinY) { minY = -seamlessModififierMinY; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY; }
            #endregion
            //hurgh
            #region Draw full screen layer 1
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer1 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer1) && (!gv.mod.currentArea.FullScreenEffectLayer1IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive1))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect1);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride1 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 15;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 750;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1.0f;
                    float defaultOverrideSpeedY1 = 1.0f;
                    int defaultOverrideDelayLimit1 = 110;
                    string defaultOverrideIsNoScrollSource1 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.075f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.075f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.45f;
                    float defaultOverrideSpeedY1 = -0.55f;
                    int defaultOverrideDelayLimit1 = 470;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }


                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.15f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = -2.8f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1f;
                    float defaultOverrideSpeedY1 = 1f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                    gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX1;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY1;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed1 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride1 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter1 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter1 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter1 >= (gv.mod.currentArea.numberOfCyclesPerOccurence1))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter1 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence1 * -1;
                        if (gv.mod.currentArea.changeFrameCounter1 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade1)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == (gv.mod.currentArea.numberOfCyclesPerOccurence1 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging1)
                    {
                        gv.mod.currentArea.changeCounter1 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter1 > gv.mod.currentArea.changeLimit1)
                        {
                            gv.mod.currentArea.changeCounter1 = 0;
                            gv.mod.currentArea.changeFrameCounter1 += 1;
                            if (gv.mod.currentArea.changeFrameCounter1 > gv.mod.currentArea.changeNumberOfFrames1)
                            {
                                gv.mod.currentArea.changeFrameCounter1 = 1;
                            }
                        }
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1 + gv.mod.currentArea.changeFrameCounter1.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect1.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX1;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX1 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY1 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX1 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {

                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer1)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;


                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;

                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders1)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion


                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource1 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);

                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion

            #region Draw full screen layer 2
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer2 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer2) && (!gv.mod.currentArea.FullScreenEffectLayer2IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive2))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect2);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride2 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 15;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 750;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1.0f;
                    float defaultOverrideSpeedY2 = 1.0f;
                    int defaultOverrideDelayLimit2 = 110;
                    string defaultOverrideIsNoScrollSource2 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.075f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.075f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.45f;
                    float defaultOverrideSpeedY2 = -0.55f;
                    int defaultOverrideDelayLimit2 = 470;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }


                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.15f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = -2.8f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1f;
                    float defaultOverrideSpeedY2 = 1f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                    gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX2;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY2;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed2 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride2 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter2 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter2 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter2 >= (gv.mod.currentArea.numberOfCyclesPerOccurence2))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter2 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence2 * -1;
                        if (gv.mod.currentArea.changeFrameCounter2 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade2)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == (gv.mod.currentArea.numberOfCyclesPerOccurence2 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging2)
                    {
                        gv.mod.currentArea.changeCounter2 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter2 > gv.mod.currentArea.changeLimit2)
                        {
                            gv.mod.currentArea.changeCounter2 = 0;
                            gv.mod.currentArea.changeFrameCounter2 += 1;
                            if (gv.mod.currentArea.changeFrameCounter2 > gv.mod.currentArea.changeNumberOfFrames2)
                            {
                                gv.mod.currentArea.changeFrameCounter2 = 1;
                            }
                        }
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2 + gv.mod.currentArea.changeFrameCounter2.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect2.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX2;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX2 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY2 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX2 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer2)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource2 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 3
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer3 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer3) && (!gv.mod.currentArea.FullScreenEffectLayer3IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive3))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect3);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride3 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 15;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 750;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1.0f;
                    float defaultOverrideSpeedY3 = 1.0f;
                    int defaultOverrideDelayLimit3 = 110;
                    string defaultOverrideIsNoScrollSource3 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.075f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.075f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.45f;
                    float defaultOverrideSpeedY3 = -0.55f;
                    int defaultOverrideDelayLimit3 = 470;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }


                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.15f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = -2.8f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1f;
                    float defaultOverrideSpeedY3 = 1f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                    gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX3;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY3;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed3 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride3 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter3 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter3 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter3 >= (gv.mod.currentArea.numberOfCyclesPerOccurence3))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter3 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence3 * -1;
                        if (gv.mod.currentArea.changeFrameCounter3 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade3)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == (gv.mod.currentArea.numberOfCyclesPerOccurence3 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging3)
                    {
                        gv.mod.currentArea.changeCounter3 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter3 > gv.mod.currentArea.changeLimit3)
                        {
                            gv.mod.currentArea.changeCounter3 = 0;
                            gv.mod.currentArea.changeFrameCounter3 += 1;
                            if (gv.mod.currentArea.changeFrameCounter3 > gv.mod.currentArea.changeNumberOfFrames3)
                            {
                                gv.mod.currentArea.changeFrameCounter3 = 1;
                            }
                        }
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3 + gv.mod.currentArea.changeFrameCounter3.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect3.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX3;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY3;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX3 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY3 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX3 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY3 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer3)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource3 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 4
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer4 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer4) && (!gv.mod.currentArea.FullScreenEffectLayer4IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive4))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect4);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride4 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 15;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 750;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1.0f;
                    float defaultOverrideSpeedY4 = 1.0f;
                    int defaultOverrideDelayLimit4 = 110;
                    string defaultOverrideIsNoScrollSource4 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.075f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.075f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.45f;
                    float defaultOverrideSpeedY4 = -0.55f;
                    int defaultOverrideDelayLimit4 = 470;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }


                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.15f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = -2.8f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1f;
                    float defaultOverrideSpeedY4 = 1f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                    gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX4;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY4;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed4 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride4 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter4 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter4 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter4 >= (gv.mod.currentArea.numberOfCyclesPerOccurence4))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter4 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence4 * -1;
                        if (gv.mod.currentArea.changeFrameCounter4 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade4)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == (gv.mod.currentArea.numberOfCyclesPerOccurence4 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging4)
                    {
                        gv.mod.currentArea.changeCounter4 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter4 > gv.mod.currentArea.changeLimit4)
                        {
                            gv.mod.currentArea.changeCounter4 = 0;
                            gv.mod.currentArea.changeFrameCounter4 += 1;
                            if (gv.mod.currentArea.changeFrameCounter4 > gv.mod.currentArea.changeNumberOfFrames4)
                            {
                                gv.mod.currentArea.changeFrameCounter4 = 1;
                            }
                        }
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4 + gv.mod.currentArea.changeFrameCounter4.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect4.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX4;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY4;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX4 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY4 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX4 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY4 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer4)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource4 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 5
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer5 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer5) && (!gv.mod.currentArea.FullScreenEffectLayer5IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive5) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect5);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride5 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 15;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 750;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1.0f;
                    float defaultOverrideSpeedY5 = 1.0f;
                    int defaultOverrideDelayLimit5 = 110;
                    string defaultOverrideIsNoScrollSource5 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.075f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.075f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.45f;
                    float defaultOverrideSpeedY5 = -0.55f;
                    int defaultOverrideDelayLimit5 = 470;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }


                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.15f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = -2.8f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1f;
                    float defaultOverrideSpeedY5 = 1f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                    gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX5;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY5;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed5 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride5 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter5 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter5 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter5 >= (gv.mod.currentArea.numberOfCyclesPerOccurence5))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter5 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence5 * -1;
                        if (gv.mod.currentArea.changeFrameCounter5 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade5)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == (gv.mod.currentArea.numberOfCyclesPerOccurence5 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5));
                        }
                    }

                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }

                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging5)
                    {
                        gv.mod.currentArea.changeCounter5 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter5 > gv.mod.currentArea.changeLimit5)
                        {
                            gv.mod.currentArea.changeCounter5 = 0;
                            gv.mod.currentArea.changeFrameCounter5 += 1;
                            if (gv.mod.currentArea.changeFrameCounter5 > gv.mod.currentArea.changeNumberOfFrames5)
                            {
                                gv.mod.currentArea.changeFrameCounter5 = 1;
                            }
                        }
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5 + gv.mod.currentArea.changeFrameCounter5.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect5.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX5;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY5;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX5 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY5 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX5 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY5 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer5)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource5 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 6
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer6 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer6) && (!gv.mod.currentArea.FullScreenEffectLayer6IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive6) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect6);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride6 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 15;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 750;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1.0f;
                    float defaultOverrideSpeedY6 = 1.0f;
                    int defaultOverrideDelayLimit6 = 110;
                    string defaultOverrideIsNoScrollSource6 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.075f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.075f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.45f;
                    float defaultOverrideSpeedY6 = -0.55f;
                    int defaultOverrideDelayLimit6 = 470;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }


                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.15f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = -2.8f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1f;
                    float defaultOverrideSpeedY6 = 1f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                    gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX6;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY6;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed6 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride6 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter6 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter6 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter6 >= (gv.mod.currentArea.numberOfCyclesPerOccurence6))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter6 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence6 * -1;
                        if (gv.mod.currentArea.changeFrameCounter6 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade6)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == (gv.mod.currentArea.numberOfCyclesPerOccurence6 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging6)
                    {
                        gv.mod.currentArea.changeCounter6 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter6 > gv.mod.currentArea.changeLimit6)
                        {
                            gv.mod.currentArea.changeCounter6 = 0;
                            gv.mod.currentArea.changeFrameCounter6 += 1;
                            if (gv.mod.currentArea.changeFrameCounter6 > gv.mod.currentArea.changeNumberOfFrames6)
                            {
                                gv.mod.currentArea.changeFrameCounter6 = 1;
                            }
                        }
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6 + gv.mod.currentArea.changeFrameCounter6.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect6.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX6;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY6;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX6 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY6 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX6 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY6 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer6)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource6 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 7
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer7 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer7) && (!gv.mod.currentArea.FullScreenEffectLayer7IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive7) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect7);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride7 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 15;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 750;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1.0f;
                    float defaultOverrideSpeedY7 = 1.0f;
                    int defaultOverrideDelayLimit7 = 110;
                    string defaultOverrideIsNoScrollSource7 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.075f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.075f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.45f;
                    float defaultOverrideSpeedY7 = -0.55f;
                    int defaultOverrideDelayLimit7 = 470;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }


                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.15f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = -2.8f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1f;
                    float defaultOverrideSpeedY7 = 1f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                    gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX7;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY7;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed7 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride7 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter7 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter7 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter7 >= (gv.mod.currentArea.numberOfCyclesPerOccurence7))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter7 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence7 * -1;
                        if (gv.mod.currentArea.changeFrameCounter7 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade7)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == (gv.mod.currentArea.numberOfCyclesPerOccurence7 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging7)
                    {
                        gv.mod.currentArea.changeCounter7 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter7 > gv.mod.currentArea.changeLimit7)
                        {
                            gv.mod.currentArea.changeCounter7 = 0;
                            gv.mod.currentArea.changeFrameCounter7 += 1;
                            if (gv.mod.currentArea.changeFrameCounter7 > gv.mod.currentArea.changeNumberOfFrames7)
                            {
                                gv.mod.currentArea.changeFrameCounter7 = 1;
                            }
                        }
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7 + gv.mod.currentArea.changeFrameCounter7.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect7.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX7;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY7;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX7 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY7 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX7 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY7 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer7)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource7 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 8
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X800 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer8 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer8) && (!gv.mod.currentArea.FullScreenEffectLayer8IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive8) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect8);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride8 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 15;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 750;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1.0f;
                    float defaultOverrideSpeedY8 = 1.0f;
                    int defaultOverrideDelayLimit8 = 110;
                    string defaultOverrideIsNoScrollSource8 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.075f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.075f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.45f;
                    float defaultOverrideSpeedY8 = -0.55f;
                    int defaultOverrideDelayLimit8 = 470;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }


                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.15f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = -2.8f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1f;
                    float defaultOverrideSpeedY8 = 1f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                    gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX8;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY8;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed8 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride8 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter8 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter8 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter8 >= (gv.mod.currentArea.numberOfCyclesPerOccurence8))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter8 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence8 * -1;
                        if (gv.mod.currentArea.changeFrameCounter8 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade8)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == (gv.mod.currentArea.numberOfCyclesPerOccurence8 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging8)
                    {
                        gv.mod.currentArea.changeCounter8 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter8 > gv.mod.currentArea.changeLimit8)
                        {
                            gv.mod.currentArea.changeCounter8 = 0;
                            gv.mod.currentArea.changeFrameCounter8 += 1;
                            if (gv.mod.currentArea.changeFrameCounter8 > gv.mod.currentArea.changeNumberOfFrames8)
                            {
                                gv.mod.currentArea.changeFrameCounter8 = 1;
                            }
                        }
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8 + gv.mod.currentArea.changeFrameCounter8.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect8.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX8;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY8;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX8 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY8 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX8 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY8 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer8)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource8 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 9
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X900 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer9 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer9) && (!gv.mod.currentArea.FullScreenEffectLayer9IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive9) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect9);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride9 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 15;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 750;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1.0f;
                    float defaultOverrideSpeedY9 = 1.0f;
                    int defaultOverrideDelayLimit9 = 110;
                    string defaultOverrideIsNoScrollSource9 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.075f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.075f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.45f;
                    float defaultOverrideSpeedY9 = -0.55f;
                    int defaultOverrideDelayLimit9 = 470;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }


                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.15f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = -2.8f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1f;
                    float defaultOverrideSpeedY9 = 1f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                    gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX9;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY9;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed9 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride9 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter9 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter9 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter9 >= (gv.mod.currentArea.numberOfCyclesPerOccurence9))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter9 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence9 * -1;
                        if (gv.mod.currentArea.changeFrameCounter9 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade9)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == (gv.mod.currentArea.numberOfCyclesPerOccurence9 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging9)
                    {
                        gv.mod.currentArea.changeCounter9 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter9 > gv.mod.currentArea.changeLimit9)
                        {
                            gv.mod.currentArea.changeCounter9 = 0;
                            gv.mod.currentArea.changeFrameCounter9 += 1;
                            if (gv.mod.currentArea.changeFrameCounter9 > gv.mod.currentArea.changeNumberOfFrames9)
                            {
                                gv.mod.currentArea.changeFrameCounter9 = 1;
                            }
                        }
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9 + gv.mod.currentArea.changeFrameCounter9.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect9.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX9;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY9;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX9 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY9 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX9 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY9 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer9)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource9 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 10
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X1000 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer10 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer10) && (!gv.mod.currentArea.FullScreenEffectLayer10IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive10) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect10);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride10 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 15;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 750;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1.0f;
                    float defaultOverrideSpeedY10 = 1.0f;
                    int defaultOverrideDelayLimit10 = 110;
                    string defaultOverrideIsNoScrollSource10 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.075f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.075f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.45f;
                    float defaultOverrideSpeedY10 = -0.55f;
                    int defaultOverrideDelayLimit10 = 470;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }


                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.15f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = -2.8f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1f;
                    float defaultOverrideSpeedY10 = 1f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                    gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX10;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY10;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed10 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride10 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter10 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter10 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter10 >= (gv.mod.currentArea.numberOfCyclesPerOccurence10))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter10 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence10 * -1;
                        if (gv.mod.currentArea.changeFrameCounter10 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade10)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == (gv.mod.currentArea.numberOfCyclesPerOccurence10 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging10)
                    {
                        gv.mod.currentArea.changeCounter10 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter10 > gv.mod.currentArea.changeLimit10)
                        {
                            gv.mod.currentArea.changeCounter10 = 0;
                            gv.mod.currentArea.changeFrameCounter10 += 1;
                            if (gv.mod.currentArea.changeFrameCounter10 > gv.mod.currentArea.changeNumberOfFrames10)
                            {
                                gv.mod.currentArea.changeFrameCounter10 = 1;
                            }
                        }
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10 + gv.mod.currentArea.changeFrameCounter10.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect10.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX10;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY10;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX10 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY10 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX10 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY10 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer10)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource10 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion   
        }

        public void drawMap()
        {
            int bmpWidth = gv.cc.bmpMap.PixelSize.Width;
            int bmpHeight = gv.cc.bmpMap.PixelSize.Height;
            int dstX = (gv.playerOffsetX - gv.mod.PlayerLocationX) * gv.squareSize;
            int dstY = (gv.playerOffsetY - gv.mod.PlayerLocationY) * gv.squareSize;
            int dstWidth = (int)(bmpWidth * 2 * gv.screenDensity); //assumes squares are 50x50 in this image
            int dstHeight = (int)(bmpHeight * 2 * gv.screenDensity); //assumes squares are 50x50 in this image

            IbRect src = new IbRect(0, 0, bmpWidth, bmpHeight);
            IbRect dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels, dstY, dstWidth, dstHeight);
            gv.DrawBitmap(gv.cc.bmpMap, src, dst);

            drawColumnOfBlack(-1);
            drawColumnOfBlack(-2);
            drawRowOfBlack(-1);
            drawColumnOfBlack(gv.playerOffsetX * 2 + 1);
            drawColumnOfBlack(gv.playerOffsetX * 2 + 2);
            //hurgh16
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 3);
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 4);
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 5);
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 6);
            drawRowOfBlack(gv.playerOffsetY * 2 + 2);
        }

        public void drawProps()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                //1
                //think I am gonna use the drawworldmap routines here, too

                //XXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //player near northern border
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                {
                    seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near southern  border
                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near western border
                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                {
                    seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near eastern border
                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                bool situationFound = false;
                //int relevantIndex = -1;
                List<int> relevantIndices = new List<int>();
                int northernmodifier = 0;
                int easternmodifier = 0;
                int westernmodifier = 0;
                int southernmodifier = 0;

                //northwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthWesternNeighbour);
                }
                //northeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthEasternNeighbour);
                }
                //southwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthWesternNeighbour);
                }
                //southeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthEasternNeighbour);
                }
                //north
                if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthernNeighbour);
                }
                //south
                if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthernNeighbour);
                }
                //west
                if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfWesternNeighbour);
                }
                //east
                if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfEasternNeighbour);
                }


                //current map
                //if (!situationFound)
                //{
                int currentAreaIndex = 0;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                    {
                        currentAreaIndex = i;
                        relevantIndices.Add(i);
                    }
                }
                //}


                //XXXXXXXXXXXXXXXXXXXXXXXX
                for (int i = 0; i < relevantIndices.Count; i++)
                {//2

                    int backupLocationX = -1;
                    int backupLocationY = -1;

                    foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                    {//3
                     //only for on-movers (the movers use drawMovingProps below)
                     //if ((p.isShown) && (!p.isMover) && (p.token != null))
                        bool nonTimeDriven = true;
                        if (p.MoverType == "daily" || p.MoverType == "weekly" || p.MoverType == "monthly" || p.MoverType == "yearly")
                        {
                            nonTimeDriven = false;
                        }
                        int indexOfLoadedTile = -1;
                        if ((p.isShown) && (nonTimeDriven == true) && p.scriptFilename != "gaJumpChasm.cs")
                        {//hurghkarl

                            //try
                            //{
                            //gv.cc.DisposeOfBitmap(ref p.token);
                            //}
                            //catch { }

                            //p.token = gv.cc.LoadBitmap(p.ImageFileName);

                            try
                            {
                                //insert1                        
                                bool tileBitmapIsLoadedAlready = false;
                                //int indexOfLoadedTile = -1;
                                for (int j = 0; j < gv.mod.loadedTileBitmapsNames.Count; j++)
                                {
                                    if ((gv.mod.loadedTileBitmapsNames[j] == p.ImageFileName) && (!gv.mod.loadedTileBitmaps[j].IsDisposed))
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = j;
                                        p.token = gv.mod.loadedTileBitmaps[j];
                                        break;
                                    }
                                }

                                //gehörtdiewelt
                                //insert2
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(p.ImageFileName);
                                    p.token = gv.cc.LoadBitmap(p.ImageFileName);
                                    gv.mod.loadedTileBitmaps.Add(p.token);
                                    indexOfLoadedTile = gv.mod.loadedTileBitmaps.Count - 1;
                                }
                            }
                            catch
                            { }



                            backupLocationX = p.LocationX;
                            backupLocationY = p.LocationY;

                            //XXXXXXXXXXXXXXXXXXX
                            situationFound = false;

                            //northwest
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Filename))
                                //if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //northeast
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //southwest
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Filename))

                                //if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //southeast
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //north
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Filename))

                                //if ((seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //south
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Filename))

                                //if ((seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //west
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Filename))

                                //if ((seamlessModififierMinX > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                }
                            }

                            //east
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                }
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXX

                            //distance check
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {//5
                             //prop X - playerX
                             //get dst rct based on distance of prop to  palyer
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                //adjust size of props
                                if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                    dst = new IbRect(x + (int)(gv.squareSize * 5 / 8) - dstXshift - (int)(((dstW / 4) * 0.375f)), y + (int)(gv.squareSize * 3 / 8) - dstYshift - (int)(((dstH / 4) * 0.375f)), (int)((dstW / 4) * 1.75f), (int)((dstH / 4) * 1.75f));

                                }
                                else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                                    dst = new IbRect(x + (int)(gv.squareSize / 2) - dstXshift - (int)(((dstW / 2) * 0.15f)), y + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2) * 1.3f), (int)((dstH / 2) * 1.3f));

                                }

                                //draw the prop
                                if (((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp)) && ((!p.isMover) || relevantIndices[i] != currentAreaIndex) && !p.isStealthed && !p.wasKilled)
                                {
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, !p.PropFacingLeft, p.opacity);
                                    //}

                                    //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                    if (gv.mod.showInteractionState == true)
                                    {//6
                                        if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                            src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }

                                        else if (p.unavoidableConversation)
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                            src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }

                                        else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                            src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }



                                    }//6
                                     /*
                                     int partyLevelAverage = 0;
                                     foreach (Player pc in gv.mod.playerList)
                                     {
                                         partyLevelAverage += pc.classLevel;
                                     }

                                     partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                                     int numberOfSkulls = 0;

                                     if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                     {
                                         foreach (Encounter enc in gv.mod.moduleEncountersList)
                                         {
                                             if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                             {
                                                 if (enc.challengeLevel > (partyLevelAverage + 5))
                                                 {
                                                     numberOfSkulls = 3;
                                                 }
                                                 else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                 {
                                                     numberOfSkulls = 2;
                                                 }
                                                 else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                 {
                                                     numberOfSkulls = 1;
                                                 }
                                             }
                                         }
                                     }
                                     bool drawChallengeHidden = false;
                                     if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                     {
                                         foreach (Encounter enc in gv.mod.moduleEncountersList)
                                         {
                                             if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                             {
                                                 if (enc.challengeHidden)
                                                 {
                                                     numberOfSkulls = 0;
                                                     drawChallengeHidden = true;
                                                 }
                                                 break;
                                             }
                                         }
                                     }
                                     /*
                                     if (gv.mod.currentArea.Props[i].movementSpeed != -1)
                                     {
                                         IbRect dstSkull = new IbRect();
                                         dstSkull.Height = (int)(dst.Height / 2);
                                         dstSkull.Width = (int)(dst.Width / 2);
                                         dstSkull.Left = dst.Left + src.Width / 2; 
                                         dstSkull.Top = dst.Top - (int)(dst.Height / 3) + src.Height / 2;
                                         int shift = 1 * (int)(dst.Width / 4);
                                         //shift = 1 * (int)(dst.Width / 4);
                                         dstSkull.Left += shift;
                                         gv.DrawText(gv.mod.currentArea.Props[i].movementSpeed.ToString(), dstSkull.Left, dstSkull.Top);
                                     }

                                     if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                                     {
                                         int shift = 0;
                                         //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                         src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                         IbRect dstSkull = new IbRect();
                                         dstSkull.Height = (int)(dst.Height / 2);
                                         dstSkull.Width = (int)(dst.Width / 2);
                                         dstSkull.Left = dst.Left;
                                         dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                         shift = 1 * (int)(dst.Width / 4);
                                         dstSkull.Left += shift;
                                         gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                         //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                                     }
                                     if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                                     {
                                         int shift = 0;
                                         for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                         {

                                             //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                             src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                             IbRect dstSkull = new IbRect();
                                             dstSkull.Height = (int)(dst.Height / 3);
                                             dstSkull.Width = (int)(dst.Width / 3);
                                             dstSkull.Left = dst.Left;
                                             dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                             shift = i2 * (int)(dst.Width / 3);
                                             dstSkull.Left += shift;
                                             gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                             //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                         }
                                     }//this
                                     */

                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    //enter code for skipping triggers of prop here
                                    if (p.showSneakThroughSymbol)
                                    {
                                        int numberOfSkulls = 1;
                                        int shift = 0;
                                        for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                        {

                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                            src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                            IbRect dstSkull = new IbRect();
                                            dstSkull.Height = (int)(dst.Height / 3);
                                            dstSkull.Width = (int)(dst.Width / 3);
                                            dstSkull.Left = dst.Left;
                                            dstSkull.Top = dst.Top;
                                            shift = i2 * (int)(dst.Width / 3);
                                            dstSkull.Left += shift;
                                            gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        }
                                    }

                                    if (p.isCurrentlyChasing)
                                    {
                                        int numberOfSkulls = 2;
                                        int shift = 0;
                                        for (int i2 = 1; i2 < numberOfSkulls; i2++)
                                        {

                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                            src = new IbRect(0, 0, gv.cc.isChasingSymbol.PixelSize.Width, gv.cc.isChasingSymbol.PixelSize.Height);
                                            IbRect dstSkull = new IbRect();
                                            dstSkull.Height = (int)(dst.Height / 3 * 2.0f);
                                            dstSkull.Width = (int)(dst.Width / 3 * 2.0f);
                                            dstSkull.Left = dst.Left - 2 * (int)(dst.Height / 3);
                                            dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                            shift = (int)((i2 + 0.5f) * (dst.Width / 3f)); dstSkull.Left += shift;
                                            //großvater
                                            gv.DrawBitmap(gv.cc.isChasingSymbol, src, dstSkull);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        }
                                    }

                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                }

                            }//5

                            p.LocationX = backupLocationX;
                            p.LocationY = backupLocationY;

                        }//4
                    }//3


                }//2
                /*
                //normal prop draw routine
                foreach (Prop p in gv.mod.currentArea.Props)
                {//3
                 //only for non-movers (the movers use drawMovingProps below)
                    if ((p.isShown) && (!p.isMover) && (p.token != null))
                    {//4

                        //distance check
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {//5
                         //prop X - playerX
                         //get dst rct based on distance of prop to  palyer
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                            //adjust size of props
                            if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                            }
                            else if (gv.mod.currentArea.useMiniProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                            }

                            //draw the prop
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                            if (gv.mod.showInteractionState == true)
                            {//6
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (p.unavoidableConversation)
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }
                            }//6
                        }//5
                    }//4
                }//3
                */
                #endregion
            }
            else //old system
            {
                #region old system
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (!p.isMover) && p.scriptFilename != "gaJumpChasm.cs")
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                            if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                            {
                                //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                dst = new IbRect(x + (int)(gv.squareSize * 5 / 8) - dstXshift - (int)(((dstW / 4) * 0.375f)), y + (int)(gv.squareSize * 3 / 8) - dstYshift - (int)(((dstH / 4) * 0.375f)), (int)((dstW / 4) * 1.75f), (int)((dstH / 4) * 1.75f));

                            }
                            else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2) * 1.3f), (int)((dstH / 2) * 1.3f));
                            }
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp) && !p.isStealthed && !p.wasKilled)
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState == true && !p.isStealthed && !p.wasKilled)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (p.unavoidableConversation)
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }
                            }

                            if (p.showSneakThroughSymbol)
                            {
                                int numberOfSkulls = 1;
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top;
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            if (p.isCurrentlyChasing)
                            {
                                int numberOfSkulls = 2;
                                int shift = 0;
                                for (int i2 = 1; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.isChasingSymbol.PixelSize.Width, gv.cc.isChasingSymbol.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3 * 2.0f);
                                    dstSkull.Width = (int)(dst.Width / 3 * 2.0f);
                                    dstSkull.Left = dst.Left - 2 * (int)(dst.Height / 3);
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = (int)((i2 + 0.5f) * (dst.Width / 3f)); dstSkull.Left += shift;
                                    //großvater
                                    gv.DrawBitmap(gv.cc.isChasingSymbol, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            /*
                            int partyLevelAverage = 0;
                            foreach (Player pc in gv.mod.playerList)
                            {
                                partyLevelAverage += pc.classLevel;
                            }

                            partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                            int numberOfSkulls = 0;

                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeLevel > (partyLevelAverage + 5))
                                        {
                                            numberOfSkulls = 3;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 3))
                                        {
                                            numberOfSkulls = 2;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 1))
                                        {
                                            numberOfSkulls = 1;
                                        }
                                    }
                                }
                            }
                            bool drawChallengeHidden = false;
                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeHidden)
                                        {
                                            numberOfSkulls = 0;
                                            drawChallengeHidden = true;
                                        }
                                        break;
                                    }
                                }
                            }
                            /*
                            if (gv.mod.currentArea.Props[i].movementSpeed != -1)
                            {
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left + src.Width / 2;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3) + src.Height / 2;
                                int shift = 1 * (int)(dst.Width / 4);
                                //shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawText(gv.mod.currentArea.Props[i].movementSpeed.ToString(), dstSkull.Left, dstSkull.Top);
                            }
                            

                            if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                            }
                            if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }//this
                            */
                        }
                    }
                }
                #endregion
            }
        }

        public void drawPropsOverParty()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                //1
                //think I am gonna use the drawworldmap routines here, too

                //XXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //player near northern border
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                {
                    seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near southern  border
                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near western border
                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                {
                    seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near eastern border
                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                bool situationFound = false;
                //int relevantIndex = -1;
                List<int> relevantIndices = new List<int>();
                int northernmodifier = 0;
                int easternmodifier = 0;
                int westernmodifier = 0;
                int southernmodifier = 0;

                //northwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthWesternNeighbour);
                }
                //northeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthEasternNeighbour);
                }
                //southwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthWesternNeighbour);
                }
                //southeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthEasternNeighbour);
                }
                //north
                if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthernNeighbour);
                }
                //south
                if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthernNeighbour);
                }
                //west
                if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfWesternNeighbour);
                }
                //east
                if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfEasternNeighbour);
                }


                //current map
                //if (!situationFound)
                //{
                int currentAreaIndex = 0;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                        {
                            currentAreaIndex = i;
                            relevantIndices.Add(i);
                        }
                    } 
                //}
                

                //XXXXXXXXXXXXXXXXXXXXXXXX
                for (int i = 0; i < relevantIndices.Count; i++)
                {//2

                    int backupLocationX = -1;
                    int backupLocationY = -1;

                    foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                    {//3
                     //only for on-movers (the movers use drawMovingProps below)
                     //if ((p.isShown) && (!p.isMover) && (p.token != null))
                        bool nonTimeDriven = true;
                        if (p.MoverType == "daily" || p.MoverType == "weekly" || p.MoverType == "monthly" || p.MoverType == "yearly")
                        {
                            nonTimeDriven = false;
                        }
                        int indexOfLoadedTile = -1;
                        if ((p.isShown) && (nonTimeDriven == true) && p.scriptFilename == "gaJumpChasm.cs")
                        {//hurghkarl

                            //try
                            //{
                            //gv.cc.DisposeOfBitmap(ref p.token);
                            //}
                            //catch { }

                            //p.token = gv.cc.LoadBitmap(p.ImageFileName);

                            try
                            {
                                //insert1                        
                                bool tileBitmapIsLoadedAlready = false;
                                //int indexOfLoadedTile = -1;
                                for (int j = 0; j < gv.mod.loadedTileBitmapsNames.Count; j++)
                                {
                                    if ((gv.mod.loadedTileBitmapsNames[j] == p.ImageFileName) && (!gv.mod.loadedTileBitmaps[j].IsDisposed))
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = j;
                                        p.token = gv.mod.loadedTileBitmaps[j];
                                        break;
                                    }
                                }

                                //gehörtdiewelt
                                //insert2
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(p.ImageFileName);
                                    p.token = gv.cc.LoadBitmap(p.ImageFileName);
                                    gv.mod.loadedTileBitmaps.Add(p.token);
                                    indexOfLoadedTile = gv.mod.loadedTileBitmaps.Count - 1;
                                }
                            }
                            catch
                            { }



                            backupLocationX = p.LocationX;
                            backupLocationY = p.LocationY;

                            //XXXXXXXXXXXXXXXXXXX
                            situationFound = false;

                            //northwest
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Filename))
                                //if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //northeast
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //southwest
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Filename))

                                //if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //southeast
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //north
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Filename))

                                //if ((seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //south
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Filename))

                                //if ((seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //west
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Filename))

                                //if ((seamlessModififierMinX > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                }
                            }

                            //east
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                }
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXX

                            //distance check
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {//5
                             //prop X - playerX
                             //get dst rct based on distance of prop to  palyer
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames-1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                //adjust size of props
                                if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                    dst = new IbRect(x + (int)(gv.squareSize * 5 / 8) - dstXshift - (int)(((dstW / 4) * 0.375f)), y + (int)(gv.squareSize * 3 / 8) - dstYshift - (int)(((dstH / 4) * 0.375f)), (int)((dstW / 4)*1.75f), (int)((dstH / 4)*1.75f));

                                }
                                else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                                    dst = new IbRect(x + (int)(gv.squareSize / 2 ) - dstXshift - (int)(((dstW / 2) * 0.15f)), y + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));

                                }

                                //draw the prop
                                if (((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp)) && ((!p.isMover) || relevantIndices[i] != currentAreaIndex) && !p.isStealthed && !p.wasKilled)
                                {
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, !p.PropFacingLeft, p.opacity);
                                    //}

                                    //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                    if (gv.mod.showInteractionState == true)
                                    {//6
                                        if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                            src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }

                                        else if (p.unavoidableConversation)
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                            src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }

                                        else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                            src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }



                                    }//6
                                     /*
                                     int partyLevelAverage = 0;
                                     foreach (Player pc in gv.mod.playerList)
                                     {
                                         partyLevelAverage += pc.classLevel;
                                     }

                                     partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                                     int numberOfSkulls = 0;

                                     if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                     {
                                         foreach (Encounter enc in gv.mod.moduleEncountersList)
                                         {
                                             if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                             {
                                                 if (enc.challengeLevel > (partyLevelAverage + 5))
                                                 {
                                                     numberOfSkulls = 3;
                                                 }
                                                 else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                 {
                                                     numberOfSkulls = 2;
                                                 }
                                                 else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                 {
                                                     numberOfSkulls = 1;
                                                 }
                                             }
                                         }
                                     }
                                     bool drawChallengeHidden = false;
                                     if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                     {
                                         foreach (Encounter enc in gv.mod.moduleEncountersList)
                                         {
                                             if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                             {
                                                 if (enc.challengeHidden)
                                                 {
                                                     numberOfSkulls = 0;
                                                     drawChallengeHidden = true;
                                                 }
                                                 break;
                                             }
                                         }
                                     }
                                     /*
                                     if (gv.mod.currentArea.Props[i].movementSpeed != -1)
                                     {
                                         IbRect dstSkull = new IbRect();
                                         dstSkull.Height = (int)(dst.Height / 2);
                                         dstSkull.Width = (int)(dst.Width / 2);
                                         dstSkull.Left = dst.Left + src.Width / 2; 
                                         dstSkull.Top = dst.Top - (int)(dst.Height / 3) + src.Height / 2;
                                         int shift = 1 * (int)(dst.Width / 4);
                                         //shift = 1 * (int)(dst.Width / 4);
                                         dstSkull.Left += shift;
                                         gv.DrawText(gv.mod.currentArea.Props[i].movementSpeed.ToString(), dstSkull.Left, dstSkull.Top);
                                     }

                                     if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                                     {
                                         int shift = 0;
                                         //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                         src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                         IbRect dstSkull = new IbRect();
                                         dstSkull.Height = (int)(dst.Height / 2);
                                         dstSkull.Width = (int)(dst.Width / 2);
                                         dstSkull.Left = dst.Left;
                                         dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                         shift = 1 * (int)(dst.Width / 4);
                                         dstSkull.Left += shift;
                                         gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                         //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                                     }
                                     if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                                     {
                                         int shift = 0;
                                         for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                         {

                                             //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                             src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                             IbRect dstSkull = new IbRect();
                                             dstSkull.Height = (int)(dst.Height / 3);
                                             dstSkull.Width = (int)(dst.Width / 3);
                                             dstSkull.Left = dst.Left;
                                             dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                             shift = i2 * (int)(dst.Width / 3);
                                             dstSkull.Left += shift;
                                             gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                             //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                         }
                                     }//this
                                     */

                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    //enter code for skipping triggers of prop here
                                    if (p.showSneakThroughSymbol)
                                    {
                                        int numberOfSkulls = 1;
                                        int shift = 0;
                                        for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                        {

                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                            src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                            IbRect dstSkull = new IbRect();
                                            dstSkull.Height = (int)(dst.Height / 3);
                                            dstSkull.Width = (int)(dst.Width / 3);
                                            dstSkull.Left = dst.Left;
                                            dstSkull.Top = dst.Top;
                                            shift = i2 * (int)(dst.Width / 3);
                                            dstSkull.Left += shift;
                                            gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        }
                                    }

                                    if (p.isCurrentlyChasing)
                                    {
                                        int numberOfSkulls = 2;
                                        int shift = 0;
                                        for (int i2 = 1; i2 < numberOfSkulls; i2++)
                                        {

                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                            src = new IbRect(0, 0, gv.cc.isChasingSymbol.PixelSize.Width, gv.cc.isChasingSymbol.PixelSize.Height);
                                            IbRect dstSkull = new IbRect();
                                            dstSkull.Height = (int)(dst.Height / 3 * 2.0f);
                                            dstSkull.Width = (int)(dst.Width / 3 * 2.0f);
                                            dstSkull.Left = dst.Left - 2*(int)(dst.Height / 3);
                                            dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                            shift = (int)((i2 + 0.5f) * (dst.Width / 3f)); dstSkull.Left += shift;
                                            //großvater
                                            gv.DrawBitmap(gv.cc.isChasingSymbol, src, dstSkull);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        }
                                    }

                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                }

                            }//5

                            p.LocationX = backupLocationX;
                            p.LocationY = backupLocationY;

                        }//4
                    }//3


                }//2
                /*
                //normal prop draw routine
                foreach (Prop p in gv.mod.currentArea.Props)
                {//3
                 //only for non-movers (the movers use drawMovingProps below)
                    if ((p.isShown) && (!p.isMover) && (p.token != null))
                    {//4

                        //distance check
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {//5
                         //prop X - playerX
                         //get dst rct based on distance of prop to  palyer
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                            //adjust size of props
                            if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                            }
                            else if (gv.mod.currentArea.useMiniProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                            }

                            //draw the prop
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                            if (gv.mod.showInteractionState == true)
                            {//6
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (p.unavoidableConversation)
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }
                            }//6
                        }//5
                    }//4
                }//3
                */
                #endregion
            }
            else //old system
            {
                #region old system
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (!p.isMover) && p.scriptFilename == "gaJumpChasm.cs")
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                            if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                            {
                                //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                dst = new IbRect(x + (int)(gv.squareSize * 5 / 8) - dstXshift - (int)(((dstW / 4) * 0.375f)), y + (int)(gv.squareSize * 3 / 8) - dstYshift - (int)(((dstH / 4) * 0.375f)), (int)((dstW / 4) * 1.75f), (int)((dstH / 4) * 1.75f));

                            }
                            else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));
                            }
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp) && !p.isStealthed && !p.wasKilled)
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState == true && !p.isStealthed && !p.wasKilled)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (p.unavoidableConversation)
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }
                            }

                            if (p.showSneakThroughSymbol)
                            {
                                int numberOfSkulls = 1;
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top;
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            if (p.isCurrentlyChasing)
                            {
                                int numberOfSkulls = 2;
                                int shift = 0;
                                for (int i2 = 1; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.isChasingSymbol.PixelSize.Width, gv.cc.isChasingSymbol.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3 * 2.0f);
                                    dstSkull.Width = (int)(dst.Width / 3 * 2.0f);
                                    dstSkull.Left = dst.Left - 2*(int)(dst.Height / 3);
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = (int)((i2 + 0.5f) * (dst.Width / 3f)); dstSkull.Left += shift;
                                    //großvater
                                    gv.DrawBitmap(gv.cc.isChasingSymbol, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            /*
                            int partyLevelAverage = 0;
                            foreach (Player pc in gv.mod.playerList)
                            {
                                partyLevelAverage += pc.classLevel;
                            }

                            partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                            int numberOfSkulls = 0;

                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeLevel > (partyLevelAverage + 5))
                                        {
                                            numberOfSkulls = 3;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 3))
                                        {
                                            numberOfSkulls = 2;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 1))
                                        {
                                            numberOfSkulls = 1;
                                        }
                                    }
                                }
                            }
                            bool drawChallengeHidden = false;
                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeHidden)
                                        {
                                            numberOfSkulls = 0;
                                            drawChallengeHidden = true;
                                        }
                                        break;
                                    }
                                }
                            }
                            /*
                            if (gv.mod.currentArea.Props[i].movementSpeed != -1)
                            {
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left + src.Width / 2;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3) + src.Height / 2;
                                int shift = 1 * (int)(dst.Width / 4);
                                //shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawText(gv.mod.currentArea.Props[i].movementSpeed.ToString(), dstSkull.Left, dstSkull.Top);
                            }
                            

                            if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                            }
                            if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }//this
                            */
                        }
                    }
                }
                #endregion
            }
        }

        public void drawBrigdePropsOverPlayer()
        {
            if (gv.mod.currentArea.PlayerIsUnderBridge)
            {
                if (gv.mod.useAllTileSystem)
                {
                    #region new system
                    //1
                    //think I am gonna use the drawworldmap routines here, too

                    //XXXXXXXXXXXXXXXXXXXXXXXX
                    int indexOfNorthernNeighbour = -1;
                    int indexOfSouthernNeighbour = -1;
                    int indexOfEasternNeighbour = -1;
                    int indexOfWesternNeighbour = -1;
                    int indexOfNorthEasternNeighbour = -1;
                    int indexOfNorthWesternNeighbour = -1;
                    int indexOfSouthEasternNeighbour = -1;
                    int indexOfSouthWesternNeighbour = -1;

                    int seamlessModififierMinX = 0;
                    int seamlessModififierMaxX = 0;
                    int seamlessModififierMinY = 0;
                    int seamlessModififierMaxY = 0;

                    //player near northern border
                    if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                    {
                        seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                            {
                                indexOfNorthernNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                                {
                                    indexOfNorthEasternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                                {
                                    indexOfNorthWesternNeighbour = i;
                                }
                            }
                        }
                    }

                    //player near southern  border
                    if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                    {

                        seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                            {
                                indexOfSouthernNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                                {
                                    indexOfSouthEasternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                                {
                                    indexOfSouthWesternNeighbour = i;
                                }
                            }
                        }
                    }

                    //player near western border
                    if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                    {
                        seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                            {
                                indexOfWesternNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                                {
                                    indexOfNorthWesternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                                {
                                    indexOfSouthWesternNeighbour = i;
                                }
                            }
                        }
                    }

                    //player near eastern border
                    if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                    {
                        seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                            {
                                indexOfEasternNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                                {
                                    indexOfNorthEasternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                                {
                                    indexOfSouthEasternNeighbour = i;
                                }
                            }
                        }
                    }

                    bool situationFound = false;
                    //int relevantIndex = -1;
                    List<int> relevantIndices = new List<int>();
                    int northernmodifier = 0;
                    int easternmodifier = 0;
                    int westernmodifier = 0;
                    int southernmodifier = 0;

                    //northwest
                    if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfNorthWesternNeighbour);
                    }
                    //northeast
                    if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfNorthEasternNeighbour);
                    }
                    //southwest
                    if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfSouthWesternNeighbour);
                    }
                    //southeast
                    if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfSouthEasternNeighbour);
                    }
                    //north
                    if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfNorthernNeighbour);
                    }
                    //south
                    if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfSouthernNeighbour);
                    }
                    //west
                    if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfWesternNeighbour);
                    }
                    //east
                    if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfEasternNeighbour);
                    }
                    /*
                    //current map
                    if (!situationFound)
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                            {
                                relevantIndex = i;
                            }
                        } 
                    }
                    */

                    //XXXXXXXXXXXXXXXXXXXXXXXX
                    for (int i = 0; i < relevantIndices.Count; i++)
                    {//2

                        int backupLocationX = -1;
                        int backupLocationY = -1;

                        foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                        {//3
                         //only for on-movers (the movers use drawMovingProps below)
                         //if ((p.isShown) && (!p.isMover) && (p.token != null))
                            bool nonTimeDriven = true;
                            if (p.MoverType == "daily" || p.MoverType == "weekly" || p.MoverType == "monthly" || p.MoverType == "yearly")
                            {
                                nonTimeDriven = false;
                            }
                            int indexOfLoadedTile = -1;
                            if ((p.isShown) && (nonTimeDriven == true))
                            {//hurghkarl

                                //try
                                //{
                                //gv.cc.DisposeOfBitmap(ref p.token);
                                //}
                                //catch { }

                                //p.token = gv.cc.LoadBitmap(p.ImageFileName);

                                try
                                {
                                    //insert1                        
                                    bool tileBitmapIsLoadedAlready = false;
                                    //int indexOfLoadedTile = -1;
                                    for (int j = 0; j < gv.mod.loadedTileBitmapsNames.Count; j++)
                                    {
                                        if ((gv.mod.loadedTileBitmapsNames[j] == p.ImageFileName) && (!gv.mod.loadedTileBitmaps[j].IsDisposed))
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = j;
                                            break;
                                        }
                                    }

                                    //insert2
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(p.ImageFileName);
                                        p.token = gv.cc.LoadBitmap(p.ImageFileName);
                                        gv.mod.loadedTileBitmaps.Add(p.token);
                                        indexOfLoadedTile = gv.mod.loadedTileBitmaps.Count - 1;

                                    }
                                }
                                catch
                                { }



                                backupLocationX = p.LocationX;
                                backupLocationY = p.LocationY;

                                //XXXXXXXXXXXXXXXXXXX
                                situationFound = false;

                                //northwest
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Filename))
                                    //if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                        p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                    }
                                }

                                //northeast
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Filename))

                                    //if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                        p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                    }
                                }

                                //southwest
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Filename))

                                    //if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                        p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                    }
                                }

                                //southeast
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Filename))

                                    //if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                        p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                    }
                                }

                                //north
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Filename))

                                    //if ((seamlessModififierMinY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                    }
                                }

                                //south
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Filename))

                                    //if ((seamlessModififierMaxY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                    }
                                }

                                //west
                                if (indexOfWesternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Filename))

                                    //if ((seamlessModififierMinX > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    }
                                }

                                //east
                                if (indexOfEasternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Filename))

                                    //if ((seamlessModififierMaxX > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    }
                                }

                                //XXXXXXXXXXXXXXXXXXXXXXXX

                                //distance check
                                if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                    && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                                {//5
                                 //prop X - playerX
                                 //get dst rct based on distance of prop to  palyer
                                    int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                    int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                    int dstW = (int)((((float)gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                    int dstH = (int)((((float)(gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                    int dstXshift = (dstW - gv.squareSize) / 2;
                                    int dstYshift = (dstH - gv.squareSize) / 2;
                                    int framePosition = p.currentFrameNumber;
                                    if (p.inverseAnimationDirection)
                                    {
                                        framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                    }
                                    IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                                    IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                    //adjust size of props
                                    if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                    {

                                       //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                        dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 4) * 0.3375f)), (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY - (int)(((dstH / 4) * 0.3375f)), (int)((dstW / 4) * 1.675f), (int)((dstH / 4) * 1.675f));

                                    }
                                    else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                    {
                                        dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));
                                    }

                                    //draw the prop
                                    if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                    {
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, !p.PropFacingLeft, p.opacity);
                                    }

                                    //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                    if (gv.mod.showInteractionState == true)
                                    {//6
                                        if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                            src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }

                                        else if (p.unavoidableConversation)
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                            src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }

                                        else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                        {
                                            //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                            src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                            gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                            //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            //continue;
                                        }
                                    }//6
                                   
                                    
                                }//5

                                p.LocationX = backupLocationX;
                                p.LocationY = backupLocationY;

                            }//4
                        }//3


                    }//2

                    //normal prop draw routine
                    foreach (Prop p in gv.mod.currentArea.Props)
                    {//3
                     //only for on-movers (the movers use drawMovingProps below)
                        if ((p.isShown) && (!p.isMover) && (p.token != null))
                        {//4

                            //distance check
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {//5
                             //prop X - playerX
                             //get dst rct based on distance of prop to  palyer
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                //adjust size of props
                                if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 4) * 0.3375f)), (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY - (int)(((dstH / 4) * 0.3375f)), (int)((dstW / 4) * 1.675f), (int)((dstH / 4) * 1.675f));

                                }
                                else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));
                                }

                                //draw the prop
                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                if (gv.mod.showInteractionState == true)
                                {//6
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (p.unavoidableConversation)
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }
                                }//6

                                /*
                                int partyLevelAverage = 0;
                                foreach (Player pc in gv.mod.playerList)
                                {
                                    partyLevelAverage += pc.classLevel;
                                }

                                partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                                int numberOfSkulls = 0;

                                if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                {
                                    foreach (Encounter enc in gv.mod.moduleEncountersList)
                                    {
                                        if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                        {
                                            if (enc.challengeLevel > (partyLevelAverage + 5))
                                            {
                                                numberOfSkulls = 3;
                                            }
                                            else if (enc.challengeLevel > (partyLevelAverage + 3))
                                            {
                                                numberOfSkulls = 2;
                                            }
                                            else if (enc.challengeLevel > (partyLevelAverage + 1))
                                            {
                                                numberOfSkulls = 1;
                                            }
                                        }
                                    }
                                }
                                bool drawChallengeHidden = false;
                                if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                {
                                    foreach (Encounter enc in gv.mod.moduleEncountersList)
                                    {
                                        if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                        {
                                            if (enc.challengeHidden)
                                            {
                                                numberOfSkulls = 0;
                                                drawChallengeHidden = true;
                                            }
                                            break;
                                        }
                                    }
                                }

                                if (drawChallengeHidden)
                                {
                                    int shift = 0;
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                    src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 2);
                                    dstSkull.Width = (int)(dst.Width / 2);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = 1 * (int)(dst.Width / 4);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                                }
                                if (numberOfSkulls > 0)
                                {
                                    int shift = 0;
                                    for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                    {

                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                        src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                        IbRect dstSkull = new IbRect();
                                        dstSkull.Height = (int)(dst.Height / 3);
                                        dstSkull.Width = (int)(dst.Width / 3);
                                        dstSkull.Left = dst.Left;
                                        dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                        shift = i2 * (int)(dst.Width / 3);
                                        dstSkull.Left += shift;
                                        gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    }
                                }
                                */
                            }//5
                        }//4
                    }//3
                    #endregion
                }
                else //old system
                {
                    #region old system
                    foreach (Prop p in gv.mod.currentArea.Props)
                    {
                        if ((p.isShown) && (!p.isMover))
                        {
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {
                                //prop X - playerX
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 4) * 0.3375f)), (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY - (int)(((dstH / 4) * 0.3375f)), (int)((dstW / 4) * 1.675f), (int)((dstH / 4) * 1.675f));

                                }
                                else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));
                                }
                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                if (gv.mod.showInteractionState == true)
                                {
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (p.unavoidableConversation)
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
            }
        }

        public void drawMovingProps(float elapsed)
        {
            if (gv.mod.useSmoothMovement == true)
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (!p.isUnderBridge) && (p.token != null))
                    {
                        if ((p.LocationX + 1 >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX - 1 <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY + 1 >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY - 1 <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            //float xDimension = p.token.PixelSize.Width * p.sizeFactor;
                            //float yDimension = p.propFrameHeight * p.sizeFactor;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            if (p.destinationPixelPositionXList.Count > 0)
                            {
                                if ((p.destinationPixelPositionXList[0] >= (p.currentPixelPositionX - 0)) && (p.destinationPixelPositionXList[0] <= (p.currentPixelPositionX + 0)))
                                {
                                    if (p.destinationPixelPositionYList[0] > p.currentPixelPositionY)
                                    {
                                        p.currentPixelPositionY += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY >= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);

                                        }
                                    }
                                    else
                                    {
                                        p.currentPixelPositionY -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY <= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);
                                        }

                                    }
                                }
                                else if ((p.destinationPixelPositionYList[0] >= (p.currentPixelPositionY - 0)) && (p.destinationPixelPositionYList[0] <= (p.currentPixelPositionY + 0)))
                                {
                                    {
                                        if (p.destinationPixelPositionXList[0] > p.currentPixelPositionX)
                                        {
                                            p.currentPixelPositionX += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX >= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                        else
                                        {
                                            p.currentPixelPositionX -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX <= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                    }
                                }

                            }//end, set dst

                            int playerPositionXInPix = 0;
                            int playerPositionYInPix = 0;

                            if (p.destinationPixelPositionXList.Count <= 0)
                            {
                                p.destinationPixelPositionXList.Clear();
                                p.destinationPixelPositionXList = new List<int>();
                                p.destinationPixelPositionYList.Clear();
                                p.destinationPixelPositionYList = new List<int>();

                                //set the currentPixel position of the props
                                int xOffSetInSquares = p.LocationX - gv.mod.PlayerLocationX;
                                int yOffSetInSquares = p.LocationY - gv.mod.PlayerLocationY;
                                playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                                playerPositionYInPix = gv.playerOffsetY * gv.squareSize;

                                p.currentPixelPositionX = playerPositionXInPix + (xOffSetInSquares * gv.squareSize);
                                p.currentPixelPositionY = playerPositionYInPix + (yOffSetInSquares * gv.squareSize);
                            }


                            playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                            playerPositionYInPix = gv.playerOffsetY * gv.squareSize + gv.oYshift;

                            float floatConvertedToSquareDistanceX = (p.currentPixelPositionX - playerPositionXInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceX = (int)Math.Ceiling(floatConvertedToSquareDistanceX);

                            float floatConvertedToSquareDistanceY = (p.currentPixelPositionY - playerPositionYInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceY = (int)Math.Ceiling(floatConvertedToSquareDistanceY);

                            int SquareThatPixIsOnX = gv.mod.PlayerLocationX + ConvertedToSquareDistanceX;
                            int SquareThatPixIsOnY = gv.mod.PlayerLocationY + ConvertedToSquareDistanceY;

                            int tileNumberOfPropSquare = SquareThatPixIsOnX + (SquareThatPixIsOnY * gv.mod.currentArea.MapSizeX);

                            //cast the pix position to int in order to draw it at nearly exact loc
                            int pixDistanceOfPropToPlayerX = ((int)p.currentPixelPositionX - playerPositionXInPix);
                            if (pixDistanceOfPropToPlayerX < 0)
                            {
                                pixDistanceOfPropToPlayerX *= -1;
                            }
                            int pixDistanceOfPropToPlayerY = ((int)p.currentPixelPositionY - playerPositionYInPix);
                            if (pixDistanceOfPropToPlayerY < 0)
                            {
                                pixDistanceOfPropToPlayerY *= -1;
                            }

                            if ((pixDistanceOfPropToPlayerX <= ((gv.playerOffsetX + 1) * gv.squareSize)) && (pixDistanceOfPropToPlayerY <= ((gv.playerOffsetY + 1) * gv.squareSize)))
                            {
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;


                                //set up idle move code

                                int randXInt = 0;
                                int randYInt = 0;
                                float randX = 0;
                                float randY = 0;
                                int decider = 0;
                                int moveChance = 100;

                                //the lower the number, the sooner and more often it stops
                                int stopIdleChance = (int)(30f * (30f / elapsed));

                                decider = gv.sf.RandInt(stopIdleChance);
                                if ((decider == 1) && (p.inactiveTimer == 0))
                                {
                                    p.inactiveTimer += gv.sf.RandInt(2);
                                }

                                if (p.inactiveTimer != 0)
                                {
                                    int decider2 = gv.sf.RandInt(100);
                                    int waitPeriodIncreaseChance = (int)(50f * (elapsed / 30f));

                                    if (decider2 < waitPeriodIncreaseChance)
                                    {
                                        p.inactiveTimer += gv.sf.RandInt(4);
                                    }
                                }

                                if (p.inactiveTimer > 240)
                                {
                                    p.inactiveTimer = 0;
                                }

                                if ((gv.sf.RandInt(100) <= moveChance) && (p.inactiveTimer == 0))
                                {
                                    randXInt = gv.sf.RandInt(100);
                                    randX = ((randXInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = -1 * randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = true;
                                            p.straightLineDistanceX = 0;
                                        }

                                    }
                                    else if (p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = false;
                                            p.straightLineDistanceX = 0;
                                        }
                                    }

                                    randYInt = gv.sf.RandInt(100);
                                    randY = ((randYInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = -1 * randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = true;
                                            p.straightLineDistanceY = 0;
                                        }

                                    }
                                    else if (p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = false;
                                            p.straightLineDistanceY = 0;
                                        }
                                    }

                                    //p.roamDistanceX += (randX * 7f / 10f);
                                    //p.roamDistanceY += (randY * 7f / 10f);
                                    p.roamDistanceX += (randX);
                                    p.roamDistanceY += (randY);
                                }
                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxx
                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxx
                                #region idle lilmits
                                //stopmichael

                                //north on map
                                if (p.roamDistanceY < 0)
                                {
                                    if ((p.LocationY - 1) > 0)
                                    {
                                        //north not walkable             
                                        if (!gv.mod.currentArea.Tiles[(p.LocationY - 1) * gv.mod.currentArea.MapSizeX + p.LocationX].Walkable)
                                        {
                                            p.roamDistanceY = 0;
                                        }

                                        //north has different height
                                        else if (gv.mod.currentArea.Tiles[(p.LocationY - 1) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel != gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                        {
                                            p.roamDistanceY = 0;
                                        }

                                        //party is north of prop
                                        else if (p.LocationX == gv.mod.PlayerLocationX && (p.LocationY - 1) == gv.mod.PlayerLocationY)
                                        {
                                            p.roamDistanceY = 0;
                                        }

                                        //other prop is north of prop
                                        else
                                        {
                                            foreach (Prop Obstacle in gv.mod.currentArea.Props)
                                            {
                                                if ((p.LocationY - 1) == Obstacle.LocationY && (p.LocationX) == Obstacle.LocationX)
                                                {
                                                    p.roamDistanceY = 0;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                //west on map
                                if (p.roamDistanceX < 0)
                                {
                                    if ((p.LocationX - 1) > 0)
                                    {
                                        //west not walkable             
                                        if (!gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + (p.LocationX-1)].Walkable)
                                        {
                                            p.roamDistanceX = 0;
                                        }

                                        //west has different height
                                        else if (gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + (p.LocationX-1)].heightLevel != gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                        {
                                            p.roamDistanceX = 0;
                                        }

                                        //party is west of prop
                                        else if ((p.LocationX-1) == gv.mod.PlayerLocationX && (p.LocationY) == (gv.mod.PlayerLocationY))
                                        {
                                            p.roamDistanceX = 0;
                                        }

                                        //other prop is west of prop
                                        else
                                        {
                                            foreach (Prop Obstacle in gv.mod.currentArea.Props)
                                            {
                                                if ((p.LocationY) == Obstacle.LocationY && (p.LocationX-1) == Obstacle.LocationX)
                                                {
                                                    p.roamDistanceX = 0;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                //south on map
                                if (p.roamDistanceY > 0)
                                {
                                    if ((p.LocationY + 1) < gv.mod.currentArea.MapSizeY)
                                    {
                                        //south not walkable             
                                        if (!gv.mod.currentArea.Tiles[(p.LocationY + 1) * gv.mod.currentArea.MapSizeX + p.LocationX].Walkable)
                                        {
                                            p.roamDistanceY = 0;
                                        }

                                        //south has different height
                                        else if (gv.mod.currentArea.Tiles[(p.LocationY + 1) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel != gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                        {
                                            p.roamDistanceY = 0;
                                        }

                                        //party is south of prop
                                        else if (p.LocationX == gv.mod.PlayerLocationX && (p.LocationY + 1) == gv.mod.PlayerLocationY)
                                        {
                                            p.roamDistanceY = 0;
                                        }

                                        //other prop is south of prop
                                        else
                                        {
                                            foreach (Prop Obstacle in gv.mod.currentArea.Props)
                                            {
                                                if ((p.LocationY + 1) == Obstacle.LocationY && (p.LocationX) == Obstacle.LocationX)
                                                {
                                                    p.roamDistanceY = 0;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                //east on map
                                if (p.roamDistanceX > 0)
                                {
                                    if ((p.LocationX + 1) < gv.mod.currentArea.MapSizeX)
                                    {
                                        //east not walkable             
                                        if (!gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + (p.LocationX + 1)].Walkable)
                                        {
                                            p.roamDistanceX = 0;
                                        }

                                        //east has different height
                                        else if (gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + (p.LocationX + 1)].heightLevel != gv.mod.currentArea.Tiles[(p.LocationY) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                        {
                                            p.roamDistanceX = 0;
                                        }

                                        //party is east of prop
                                        else if ((p.LocationX+1) == gv.mod.PlayerLocationX && (p.LocationY) == (gv.mod.PlayerLocationY ))
                                        {
                                            p.roamDistanceX = 0;
                                        }

                                        //other prop is east of prop
                                        else
                                        {
                                            foreach (Prop Obstacle in gv.mod.currentArea.Props)
                                            {
                                                if ((p.LocationY) == Obstacle.LocationY && (p.LocationX + 1) == Obstacle.LocationX)
                                                {
                                                    p.roamDistanceX = 0;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                #endregion
                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                IbRect dst = new IbRect((int)p.currentPixelPositionX - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY - dstYshift + (int)p.roamDistanceY, dstW, dstH);

                                if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY, (int)(dstW / 4), (int)(dstH / 4));
                                    //dst = new IbRect(x + (int)(gv.squareSize * 5 / 8) - dstXshift - (int)(((dstW / 4) * 0.375f)), y + (int)(gv.squareSize * 3 / 8) - dstYshift - (int)(((dstH / 4) * 0.375f)), (int)((dstW / 4) * 1.75f), (int)((dstH / 4) * 1.75f));
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 4) * 0.3375f)), (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY - (int)(((dstH / 4) * 0.3375f)), (int)((dstW / 4)*1.675f), (int)((dstH / 4)*1.675f));

                                }
                                else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift + (int)p.roamDistanceY - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));
                                }

                                if ( ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp)) && !p.isStealthed && !p.wasKilled)
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                if (gv.mod.showInteractionState == true && !p.isStealthed && !p.wasKilled)
                                {
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (p.unavoidableConversation)
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }
                                }
                                if (p.showSneakThroughSymbol)
                                {
                                    int numberOfSkulls = 1;
                                    int shift = 0;
                                    for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                    {

                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                        src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                        IbRect dstSkull = new IbRect();
                                        dstSkull.Height = (int)(dst.Height / 3);
                                        dstSkull.Width = (int)(dst.Width / 3);
                                        dstSkull.Left = dst.Left;
                                        dstSkull.Top = dst.Top;
                                        shift = i2 * (int)(dst.Width / 3);
                                        dstSkull.Left += shift;
                                        gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    }
                                }
                                if (p.isCurrentlyChasing)
                                {
                                    int numberOfSkulls = 2;
                                    int shift = 0;
                                    for (int i2 = 1; i2 < numberOfSkulls; i2++)
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                        src = new IbRect(0, 0, gv.cc.isChasingSymbol.PixelSize.Width, gv.cc.isChasingSymbol.PixelSize.Height);
                                        IbRect dstSkull = new IbRect();
                                        dstSkull.Height = (int)(dst.Height / 3 * 2.0f);
                                        dstSkull.Width = (int)(dst.Width / 3 * 2.0f);
                                        dstSkull.Left = dst.Left - 2*(int)(dst.Height / 3);
                                        dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                        shift = (int)((i2 + 0.5f) * (dst.Width / 3f)); dstSkull.Left += shift;
                                        //großvater
                                        gv.DrawBitmap(gv.cc.isChasingSymbol, src, dstSkull);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    }
                                }
                                /*
                                    int partyLevelAverage = 0;
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        partyLevelAverage += pc.classLevel;
                                    }

                                    partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                                    int numberOfSkulls = 0;

                                    if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                    {
                                        foreach (Encounter enc in gv.mod.moduleEncountersList)
                                        {
                                            if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                            {
                                                if (enc.challengeLevel > (partyLevelAverage + 5))
                                                {
                                                    numberOfSkulls = 3;
                                                }
                                                else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                {
                                                    numberOfSkulls = 2;
                                                }
                                                else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                {
                                                    numberOfSkulls = 1;
                                                }
                                            }
                                        }
                                    }
                                bool drawChallengeHidden = false;
                                if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                                {
                                    foreach (Encounter enc in gv.mod.moduleEncountersList)
                                    {
                                        if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                        {
                                            if (enc.challengeHidden)
                                            {
                                                numberOfSkulls = 0;
                                                drawChallengeHidden = true;
                                            }
                                            break;
                                        }
                                    }
                                }
                                /*
                                if (gv.mod.currentArea.Props[i].movementSpeed != -1)
                                {
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 2);
                                    dstSkull.Width = (int)(dst.Width / 2);
                                    dstSkull.Left = dst.Left + src.Width / 2;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3) + src.Height / 2;
                                    int shift = 1 * (int)(dst.Width / 4);
                                    //shift = 1 * (int)(dst.Width / 4);
                                    dstSkull.Left += shift;
                                    gv.DrawText(gv.mod.currentArea.Props[i].movementSpeed.ToString(), dstSkull.Left, dstSkull.Top);
                                }
                                
                                if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                                {
                                    int shift = 0;
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                    src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 2);
                                    dstSkull.Width = (int)(dst.Width / 2);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = 1 * (int)(dst.Width / 4);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                                }
                                if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                                {
                                    int shift = 0;
                                    for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                    {

                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                        src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                        IbRect dstSkull = new IbRect();
                                        dstSkull.Height = (int)(dst.Height / 3);
                                        dstSkull.Width = (int)(dst.Width / 3);
                                        dstSkull.Left = dst.Left;
                                        dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                        shift = i2 * (int)(dst.Width / 3);
                                        dstSkull.Left += shift;
                                        gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    }
                                }
                                */
                            }

                        }
                    }
                }
                for (int i = 0; i < gv.mod.currentArea.Tiles.Count; i++)
                {

                    float floatPositionY = i / gv.mod.currentArea.MapSizeX;
                    int positionY = (int)Math.Floor(floatPositionY);
                    int positionX = i % gv.mod.currentArea.MapSizeX;
                    int dist = 0;
                    int deltaX = (int)Math.Abs((positionX - gv.mod.PlayerLocationX));
                    int deltaY = (int)Math.Abs((positionY - gv.mod.PlayerLocationY));
                    if (deltaX > deltaY)
                    {
                        dist = deltaX;
                    }
                    else
                    {
                        dist = deltaY;
                    }
                    if ((dist == (gv.playerOffsetX + 1)) || (dist == (gv.playerOffsetX + 2)))
                    {
                        int squareInPixelsX = ((positionX - gv.mod.PlayerLocationX) * gv.squareSize) + gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                        int squareInPixelsY = ((positionY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                        IbRect src2 = new IbRect(0, 0, gv.squareSize, gv.squareSize);
                        IbRect dst2 = new IbRect(squareInPixelsX, squareInPixelsY, gv.squareSize, gv.squareSize);
                        //NOT USEDgv.DrawBitmap(gv.cc.black_tile, src2, dst2);
                    }
                }

            }
            else
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (!p.isUnderBridge) && (p.token != null))
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);
                            if (((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp)) && !p.isStealthed && !p.wasKilled)
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState && !p.isStealthed && !p.wasKilled)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (p.unavoidableConversation)
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }
                            }
                            if (p.showSneakThroughSymbol)
                            {
                                int numberOfSkulls = 1;
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top;
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            if (p.isCurrentlyChasing)
                            {
                                int numberOfSkulls = 2;
                                int shift = 0;
                                for (int i2 = 1; i2 < numberOfSkulls; i2++)
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.isChasingSymbol.PixelSize.Width, gv.cc.isChasingSymbol.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3 * 2.0f);
                                    dstSkull.Width = (int)(dst.Width / 3 * 2.0f);
                                    dstSkull.Left = dst.Left - 2*(int)(dst.Height / 3);
                                    dstSkull.Top = dst.Top -(int)(dst.Height / 3);
                                    shift = (int)((i2 + 0.5f) * (dst.Width / 3f)); dstSkull.Left += shift;
                                    //großvater
                                    gv.DrawBitmap(gv.cc.isChasingSymbol, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            /*
                            int partyLevelAverage = 0;
                            foreach (Player pc in gv.mod.playerList)
                            {
                                partyLevelAverage += pc.classLevel;
                            }

                            partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                            int numberOfSkulls = 0;

                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeLevel > (partyLevelAverage + 5))
                                        {
                                            numberOfSkulls = 3;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 3))
                                        {
                                            numberOfSkulls = 2;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 1))
                                        {
                                            numberOfSkulls = 1;
                                        }
                                    }
                                }
                            }
                            bool drawChallengeHidden = false;
                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeHidden)
                                        {
                                            numberOfSkulls = 0;
                                            drawChallengeHidden = true;
                                        }
                                        break;
                                    }
                                }
                            }
                            /*
                            if (p.movementSpeed != -1)
                            {
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left + src.Width / 2;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3) + src.Height / 2;
                                int shift = 1 * (int)(dst.Width / 4);
                                //shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawText(p.movementSpeed.ToString(), dstSkull.Left, dstSkull.Top);
                            }
                            
                            if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                            }
                            if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            */
                        }
                    }
                }
            }
        }

        public void drawMovingPropsUnderBridge(float elapsed)
        {
            foreach (Prop p in gv.mod.currentArea.Props)
            {
                if ((p.isShown) && (p.isMover))
                {
                    if ((p.LocationX == 2) && (p.LocationY == 3))
                    {
                        int i = 0;
                    }

                    if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isEWBridge || gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isNSBridge)
                    {
                        if (gv.mod.currentArea.Tiles[p.lastLocationY * gv.mod.currentArea.MapSizeX + p.lastLocationX].heightLevel + 1 == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                        {
                            p.isUnderBridge = true;
                        }
                        else
                        {
                            p.isUnderBridge = false;
                        }
                    }
                    else
                    {
                        p.isUnderBridge = false;
                    }
                }
            }

            if (gv.mod.useSmoothMovement == true)
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (p.isUnderBridge) && (p.token != null))
                    {
                        if ((p.LocationX + 1 >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX - 1 <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY + 1 >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY - 1 <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            //float xDimension = p.token.PixelSize.Width * p.sizeFactor;
                            //float yDimension = p.propFrameHeight * p.sizeFactor;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            if (p.destinationPixelPositionXList.Count > 0)
                            {
                                if ((p.destinationPixelPositionXList[0] >= (p.currentPixelPositionX - 0)) && (p.destinationPixelPositionXList[0] <= (p.currentPixelPositionX + 0)))
                                {
                                    if (p.destinationPixelPositionYList[0] > p.currentPixelPositionY)
                                    {
                                        p.currentPixelPositionY += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY >= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);

                                        }
                                    }
                                    else
                                    {
                                        p.currentPixelPositionY -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY <= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);
                                        }

                                    }
                                }
                                else if ((p.destinationPixelPositionYList[0] >= (p.currentPixelPositionY - 0)) && (p.destinationPixelPositionYList[0] <= (p.currentPixelPositionY + 0)))
                                {
                                    {
                                        if (p.destinationPixelPositionXList[0] > p.currentPixelPositionX)
                                        {
                                            p.currentPixelPositionX += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX >= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                        else
                                        {
                                            p.currentPixelPositionX -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX <= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                    }
                                }

                            }//end, set dst

                            int playerPositionXInPix = 0;
                            int playerPositionYInPix = 0;

                            if (p.destinationPixelPositionXList.Count <= 0)
                            {
                                p.destinationPixelPositionXList.Clear();
                                p.destinationPixelPositionXList = new List<int>();
                                p.destinationPixelPositionYList.Clear();
                                p.destinationPixelPositionYList = new List<int>();

                                //set the currentPixel position of the props
                                int xOffSetInSquares = p.LocationX - gv.mod.PlayerLocationX;
                                int yOffSetInSquares = p.LocationY - gv.mod.PlayerLocationY;
                                playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                                playerPositionYInPix = gv.playerOffsetY * gv.squareSize;

                                p.currentPixelPositionX = playerPositionXInPix + (xOffSetInSquares * gv.squareSize);
                                p.currentPixelPositionY = playerPositionYInPix + (yOffSetInSquares * gv.squareSize);
                            }


                            playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                            playerPositionYInPix = gv.playerOffsetY * gv.squareSize + gv.oYshift;

                            float floatConvertedToSquareDistanceX = (p.currentPixelPositionX - playerPositionXInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceX = (int)Math.Ceiling(floatConvertedToSquareDistanceX);

                            float floatConvertedToSquareDistanceY = (p.currentPixelPositionY - playerPositionYInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceY = (int)Math.Ceiling(floatConvertedToSquareDistanceY);

                            int SquareThatPixIsOnX = gv.mod.PlayerLocationX + ConvertedToSquareDistanceX;
                            int SquareThatPixIsOnY = gv.mod.PlayerLocationY + ConvertedToSquareDistanceY;

                            int tileNumberOfPropSquare = SquareThatPixIsOnX + (SquareThatPixIsOnY * gv.mod.currentArea.MapSizeX);

                            //cast the pix position to int in order to draw it at nearly exact loc
                            int pixDistanceOfPropToPlayerX = ((int)p.currentPixelPositionX - playerPositionXInPix);
                            if (pixDistanceOfPropToPlayerX < 0)
                            {
                                pixDistanceOfPropToPlayerX *= -1;
                            }
                            int pixDistanceOfPropToPlayerY = ((int)p.currentPixelPositionY - playerPositionYInPix);
                            if (pixDistanceOfPropToPlayerY < 0)
                            {
                                pixDistanceOfPropToPlayerY *= -1;
                            }

                            if ((pixDistanceOfPropToPlayerX <= ((gv.playerOffsetX + 1) * gv.squareSize)) && (pixDistanceOfPropToPlayerY <= ((gv.playerOffsetY + 1) * gv.squareSize)))
                            {
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;


                                //set up idle move code

                                int randXInt = 0;
                                int randYInt = 0;
                                float randX = 0;
                                float randY = 0;
                                int decider = 0;
                                int moveChance = 100;

                                //the lower the number, the sooner and more often it stops
                                int stopIdleChance = (int)(30f * (30f / elapsed));

                                decider = gv.sf.RandInt(stopIdleChance);
                                if ((decider == 1) && (p.inactiveTimer == 0))
                                {
                                    p.inactiveTimer += gv.sf.RandInt(2);
                                }

                                if (p.inactiveTimer != 0)
                                {
                                    int decider2 = gv.sf.RandInt(100);
                                    int waitPeriodIncreaseChance = (int)(50f * (elapsed / 30f));

                                    if (decider2 < waitPeriodIncreaseChance)
                                    {
                                        p.inactiveTimer += gv.sf.RandInt(4);
                                    }
                                }

                                if (p.inactiveTimer > 240)
                                {
                                    p.inactiveTimer = 0;
                                }

                                if ((gv.sf.RandInt(100) <= moveChance) && (p.inactiveTimer == 0))
                                {
                                    randXInt = gv.sf.RandInt(100);
                                    randX = ((randXInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = -1 * randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = true;
                                            p.straightLineDistanceX = 0;
                                        }

                                    }
                                    else if (p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = false;
                                            p.straightLineDistanceX = 0;
                                        }
                                    }

                                    randYInt = gv.sf.RandInt(100);
                                    randY = ((randYInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = -1 * randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = true;
                                            p.straightLineDistanceY = 0;
                                        }

                                    }
                                    else if (p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = false;
                                            p.straightLineDistanceY = 0;
                                        }
                                    }

                                    p.roamDistanceX += (randX * 7f / 10f);
                                    p.roamDistanceY += (randY * 7f / 10f);
                                }


                                IbRect dst = new IbRect((int)p.currentPixelPositionX - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY - dstYshift + (int)p.roamDistanceY, dstW, dstH);

                                if (gv.mod.currentArea.useSuperTinyProps && !p.alwaysDrawNormalSize)
                                {
                                    //dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY, (int)(dstW / 4), (int)(dstH / 4));
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 4) * 0.3375f)), (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY - (int)(((dstH / 4) * 0.3375f)), (int)((dstW / 4) * 1.675f), (int)((dstH / 4) * 1.675f));

                                }
                                else if (gv.mod.currentArea.useMiniProps && !p.alwaysDrawNormalSize)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift + (int)p.roamDistanceX - (int)(((dstW / 2) * 0.15f)), (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift + (int)p.roamDistanceY - (int)(((dstH / 2) * 0.15f)), (int)((dstW / 2)*1.3f), (int)((dstH / 2)*1.3f));
                                }

                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp) && !p.isStealthed && !p.wasKilled)
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                if (gv.mod.showInteractionState == true && !p.isStealthed && !p.wasKilled)
                                {
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (p.unavoidableConversation)
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }

                                    else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                        gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                        //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        //continue;
                                    }
                                }
                               
                            }

                        }
                    }
                }
                for (int i = 0; i < gv.mod.currentArea.Tiles.Count; i++)
                {

                    float floatPositionY = i / gv.mod.currentArea.MapSizeX;
                    int positionY = (int)Math.Floor(floatPositionY);
                    int positionX = i % gv.mod.currentArea.MapSizeX;
                    int dist = 0;
                    int deltaX = (int)Math.Abs((positionX - gv.mod.PlayerLocationX));
                    int deltaY = (int)Math.Abs((positionY - gv.mod.PlayerLocationY));
                    if (deltaX > deltaY)
                    {
                        dist = deltaX;
                    }
                    else
                    {
                        dist = deltaY;
                    }
                    if ((dist == (gv.playerOffsetX + 1)) || (dist == (gv.playerOffsetX + 2)))
                    {
                        int squareInPixelsX = ((positionX - gv.mod.PlayerLocationX) * gv.squareSize) + gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                        int squareInPixelsY = ((positionY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                        IbRect src2 = new IbRect(0, 0, gv.squareSize, gv.squareSize);
                        IbRect dst2 = new IbRect(squareInPixelsX, squareInPixelsY, gv.squareSize, gv.squareSize);
                        //NOT USEDgv.DrawBitmap(gv.cc.black_tile, src2, dst2);
                    }
                }

            }
            else
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (p.isUnderBridge) && (p.token != null))
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp) && !p.isStealthed && !p.wasKilled)
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState && !p.isStealthed && !p.wasKilled)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, gv.cc.encounter_indicator.PixelSize.Width, gv.cc.encounter_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.encounter_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (p.unavoidableConversation)
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.mandatory_conversation_indicator.PixelSize.Width, gv.cc.mandatory_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.mandatory_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }

                                else if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, gv.cc.optional_conversation_indicator.PixelSize.Width, gv.cc.optional_conversation_indicator.PixelSize.Height);
                                    gv.DrawBitmap(gv.cc.optional_conversation_indicator, src, dst);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    //continue;
                                }
                            }
                            /*
                            int partyLevelAverage = 0;
                            foreach (Player pc in gv.mod.playerList)
                            {
                                partyLevelAverage += pc.classLevel;
                            }
                            
                            partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                            int numberOfSkulls = 0;

                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeLevel > (partyLevelAverage + 5))
                                        {
                                            numberOfSkulls = 3;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 3))
                                        {
                                            numberOfSkulls = 2;
                                        }
                                        else if (enc.challengeLevel > (partyLevelAverage + 1))
                                        {
                                            numberOfSkulls = 1;
                                        }
                                    }
                                }
                            }

                            bool drawChallengeHidden = false;
                            if (p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "")
                            {
                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                {
                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                    {
                                        if (enc.challengeHidden)
                                        {
                                            numberOfSkulls = 0;
                                            drawChallengeHidden = true;
                                        }
                                        break;
                                    }
                                }
                            }

                            if (drawChallengeHidden && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeHidden");
                                src = new IbRect(0, 0, gv.cc.challengeHidden.PixelSize.Width, gv.cc.challengeHidden.PixelSize.Height);
                                IbRect dstSkull = new IbRect();
                                dstSkull.Height = (int)(dst.Height / 2);
                                dstSkull.Width = (int)(dst.Width / 2);
                                dstSkull.Left = dst.Left;
                                dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                shift = 1 * (int)(dst.Width / 4);
                                dstSkull.Left += shift;
                                gv.DrawBitmap(gv.cc.challengeHidden, src, dstSkull);
                                //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);

                            }
                            if (numberOfSkulls > 0 && !p.isStealthed && !p.wasKilled)
                            {
                                int shift = 0;
                                for (int i2 = 0; i2 < numberOfSkulls; i2++)
                                {

                                    //Bitmap interactionStateIndicator = gv.cc.LoadBitmap("challengeSkull");
                                    src = new IbRect(0, 0, gv.cc.challengeSkull.PixelSize.Width, gv.cc.challengeSkull.PixelSize.Height);
                                    IbRect dstSkull = new IbRect();
                                    dstSkull.Height = (int)(dst.Height / 3);
                                    dstSkull.Width = (int)(dst.Width / 3);
                                    dstSkull.Left = dst.Left;
                                    dstSkull.Top = dst.Top - (int)(dst.Height / 3);
                                    shift = i2 * (int)(dst.Width / 3);
                                    dstSkull.Left += shift;
                                    gv.DrawBitmap(gv.cc.challengeSkull, src, dstSkull);
                                    //gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                }
                            }
                            */
                        }
                    }
                }
            }
        }

        public void drawMiniMap()
        {
            if (showMiniMap)
            {
                int pW = (int)((float)gv.screenWidth / 100.0f);
                int pH = (int)((float)gv.screenHeight / 100.0f);
                int shift = pW;

                //minimap should be 4 squares wide
                int minimapSquareSizeInPixels = 4 * gv.squareSize / gv.mod.currentArea.MapSizeX;
                int drawW = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeX;
                int drawH = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeY;

                /*TODO
                    //draw a dark border
                    Paint pnt = new Paint();
                    pnt.setColor(Color.DKGRAY);
                    pnt.setStrokeWidth(pW * 2);
                    pnt.setStyle(Paint.Style.STROKE);	
                    canvas.drawRect(new Rect(gv.oXshift, pH, gv.oXshift + drawW + pW, pH + drawH + pW), pnt);
                */
                //draw minimap
                if (minimap == null) { resetMiniMapBitmap(); }
                IbRect src = new IbRect(0, 0, minimap.PixelSize.Width, minimap.PixelSize.Height);
                IbRect dst = new IbRect(pW, pH, drawW, drawH);
                gv.DrawBitmap(minimap, src, dst);

                //draw Fog of War
                if (gv.mod.currentArea.UseMiniMapFogOfWar)
                {
                    for (int x = 0; x < this.gv.mod.currentArea.MapSizeX; x++)
                    {
                        for (int y = 0; y < this.gv.mod.currentArea.MapSizeY; y++)
                        {
                            int xx = x * minimapSquareSizeInPixels;
                            int yy = y * minimapSquareSizeInPixels;
                            src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                            dst = new IbRect(pW + xx, pH + yy, minimapSquareSizeInPixels, minimapSquareSizeInPixels);
                            if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Visible)
                            {
                                gv.DrawBitmap(gv.cc.black_tile, src, dst);
                            }
                        }
                    }
                }

                //draw a location marker square RED
                int x2 = gv.mod.PlayerLocationX * minimapSquareSizeInPixels;
                int y2 = gv.mod.PlayerLocationY * minimapSquareSizeInPixels;
                src = new IbRect(0, 0, gv.cc.pc_dead.PixelSize.Width, gv.cc.pc_dead.PixelSize.Height);
                dst = new IbRect(pW + x2, pH + y2, minimapSquareSizeInPixels, minimapSquareSizeInPixels);
                gv.DrawBitmap(gv.cc.pc_dead, src, dst);
            }
        }

        public void drawPlayer()
        {
            //if (!gv.mod.currentArea.PlayerIsUnderBridge)
            //{
            if (gv.mod.selectedPartyLeader >= gv.mod.playerList.Count)
            {
                gv.mod.selectedPartyLeader = 0;
            }
            int x = gv.playerOffsetX * gv.squareSize;
            int y = gv.playerOffsetY * gv.squareSize;
            int shift = gv.squareSize / 5;
            if (gv.mod.currentArea.useMiniProps)
            {
                shift = (int)((shift / 2));
            }
            else if (gv.mod.currentArea.useSuperTinyProps)
            {
                shift = (int)shift / 4;
            }
            IbRect src = new IbRect(0, 0, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width);
            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
            if (gv.mod.showPartyToken)
            {

                /*
                if (gv.mod.currentArea.useMiniProps)
                {

                    dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                    {
                        dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                    }
                    else
                    {
                        dst.Left -= (int)(gv.squareSize / 4) + (int)(dst.Width * 0.075f);
                    }
                    //-(int)(((dstW / 2) * 0.25f))
                    dst.Height -= (int)(dst.Height / 2);
                    dst.Height = (int)(dst.Height * 1.5f);
                    dst.Width -= (int)(dst.Width / 2);
                    dst.Width = (int)(dst.Width * 1.5f);
                }
                else if (gv.mod.currentArea.useSuperTinyProps)
                {
                    dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                    {
                        dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                    }
                    else
                    {
                        dst.Left -= (int)(gv.squareSize * 3 / 8) + (int)(dst.Width * 0.075f * 0.4f);
                    }
                    dst.Height -= (int)(dst.Height * 3 / 4);
                    dst.Width -= (int)(dst.Width * 3 / 4);
                }
                */

                if (gv.mod.currentArea.useMiniProps)
                {
                    dst.Top += (int)(gv.squareSize / 4) - (int)(dst.Height * 0.050f);
                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                    {
                        dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                    }
                    else
                    {
                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                        dst.Left += gv.squareSize * 2 / 4;
                    }
                    dst.Height -= (int)(dst.Height / 2);
                    dst.Height = (int)(dst.Height * 1.3f);
                    dst.Width -= (int)(dst.Width / 2);
                    dst.Width = (int)(dst.Width * 1.3f);
                }
                else if (gv.mod.currentArea.useSuperTinyProps)
                {
                    dst.Top += (int)(gv.squareSize * 3 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                    {
                        dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                    }
                    else
                    {
                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                        dst.Left += gv.squareSize * 3 / 4;
                    }
                    dst.Height -= (int)(dst.Height * 3 / 4);
                    dst.Height = (int)(dst.Height * 1.4f);
                    dst.Width -= (int)(dst.Width * 3 / 4);
                    dst.Width = (int)(dst.Width * 1.4f);
                }
                if (!gv.mod.currentArea.PlayerIsUnderBridge)
                {
                    gv.DrawBitmap(gv.mod.partyTokenBitmap, src, dst, !gv.mod.playerList[0].combatFacingLeft, true);
                }

                //shift = storeShift;

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXxx

                //gv.DrawBitmap(gv.mod.partyTokenBitmap, src, dst, !gv.mod.playerList[0].combatFacingLeft);
            }
            else
            {
                #region oldfull
                /*
                if ((showFullParty) && (gv.mod.playerList.Count > 1))
                {
                    if (gv.mod.playerList[0].combatFacingLeft == true)
                    {
                        gv.oXshift = gv.oXshift + shift / 2;
                        shift = shift / 4 * 3;
                    }
                    else
                    {
                        shift = shift / 4 * 3;
                    }
                    int reducedSquareSize = gv.squareSize * 2 / 3;
                    for (int i = gv.mod.playerList.Count - 1; i >= 0; i--)
                    {
                        if ((i == 0) && (i != gv.mod.selectedPartyLeader))
                        {

                            if (gv.mod.playerList[0].combatFacingLeft == false)
                            {
                                dst = new IbRect(x + gv.oXshift + (5 * shift / 2) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else
                            {
                                dst = new IbRect(x + gv.oXshift + (shift) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            //dst = new IbRect(x + gv.oXshift + shift + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);

                            if (gv.mod.currentArea.useMiniProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                                    dst.Left += gv.squareSize * 2 / 4;
                                }
                                dst.Height -= (int)(dst.Height / 2);
                                dst.Height = (int)(dst.Height * 1.5f);
                                dst.Width -= (int)(dst.Width / 2);
                                dst.Width = (int)(dst.Width  * 1.5f);
                            }
                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                    dst.Left += gv.squareSize * 3 / 4;
                                }
                                dst.Height -= (int)(dst.Height * 3 / 4);
                                dst.Height = (int)(dst.Height * 1.4f);
                                dst.Width -= (int)(dst.Width * 3 / 4);
                                dst.Width = (int)(dst.Width * 1.4f);
                            }

                            gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                        }
                        if ((i == 1) && (i != gv.mod.selectedPartyLeader))
                        {
                            dst = new IbRect(x + gv.oXshift - shift + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);

                            if (gv.mod.currentArea.useMiniProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Height * 0.075f);
                                    dst.Left += gv.squareSize * 2 / 4;
                                }
                                dst.Height -= (int)(dst.Height / 2);
                                dst.Height = (int)(dst.Height * 1.5f);
                                dst.Width -= (int)(dst.Width / 2);
                                dst.Width = (int)(dst.Width * 1.5f);
                            }

                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                    dst.Left += gv.squareSize * 3 / 4;
                                }
                                dst.Height -= (int)(dst.Height * 3 / 4);
                                dst.Height = (int)(dst.Height * 1.4f);
                                dst.Width -= (int)(dst.Width * 3 / 4);
                                dst.Width = (int)(dst.Width * 1.4f);
                            }

                            gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                        }
                        if ((i == 2) && (i != gv.mod.selectedPartyLeader))
                        {
                            if (gv.mod.selectedPartyLeader == 0)
                            {
                                if (gv.mod.playerList[0].combatFacingLeft == false)
                                {
                                    dst = new IbRect(x + gv.oXshift + (5 * shift / 2) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                            }
                            else if (gv.mod.selectedPartyLeader == 1)
                            {
                                dst = new IbRect(x + gv.oXshift - (shift) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }

                            if (gv.mod.currentArea.useMiniProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                                    dst.Left += gv.squareSize * 2 / 4;
                                }
                                dst.Height -= (int)(dst.Height / 2);
                                dst.Height = (int)(dst.Height * 1.5f);
                                dst.Width -= (int)(dst.Width / 2);
                                dst.Width = (int)(dst.Width * 1.5f);
                            }
                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                    dst.Left += gv.squareSize * 3 / 4;
                                }
                                dst.Height -= (int)(dst.Height * 3 / 4);
                                dst.Height = (int)(dst.Height * 1.4f);
                                dst.Width -= (int)(dst.Width * 3 / 4);
                                dst.Width = (int)(dst.Width * 1.4f);
                            }

                            gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                        }
                        if ((i == 3) && (i != gv.mod.selectedPartyLeader))
                        {

                            if (gv.mod.selectedPartyLeader == 0)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 1)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 2)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 125 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }

                            if (gv.mod.currentArea.useMiniProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                                    dst.Left += gv.squareSize * 2 / 4;
                                }
                                dst.Height -= (int)(dst.Height / 2);
                                dst.Width -= (int)(dst.Width / 2);
                            }
                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                    dst.Left += gv.squareSize * 3 / 4;
                                }
                                dst.Height -= (int)(dst.Height * 3 / 4);
                                dst.Height = (int)(dst.Height * 1.4f);
                                dst.Width -= (int)(dst.Width * 3 / 4);
                                dst.Width = (int)(dst.Width * 1.4f);
                            }

                            gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                        }
                        if ((i == 4) && (i != gv.mod.selectedPartyLeader))
                        {
                            if (gv.mod.selectedPartyLeader == 0)
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 1)
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 2)
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 3)
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }

                            if (gv.mod.currentArea.useMiniProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                                    dst.Left += gv.squareSize * 2 / 4;
                                }
                                dst.Height -= (int)(dst.Height / 2);
                                dst.Width -= (int)(dst.Width / 2);
                            }
                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                    dst.Left += gv.squareSize * 3 / 4;
                                }
                                dst.Height -= (int)(dst.Height * 3 / 4);
                                dst.Height = (int)(dst.Height * 1.4f);
                                dst.Width -= (int)(dst.Width * 3 / 4);
                                dst.Width = (int)(dst.Width * 1.4f);
                            }

                            gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                        }

                        if ((i == 5) && (i != gv.mod.selectedPartyLeader))
                        {
                            if (gv.mod.selectedPartyLeader == 0)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 250 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 1)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 2)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 3)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else if (gv.mod.selectedPartyLeader == 4)
                            {
                                dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }
                            else
                            {
                                dst = new IbRect(x + gv.oXshift - (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                            }

                            if (gv.mod.currentArea.useMiniProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.050f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                                    dst.Left += gv.squareSize * 2 / 4;
                                }
                                dst.Height -= (int)(dst.Height / 2);
                                dst.Width -= (int)(dst.Width / 2);
                            }
                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst.Top += (int)(gv.squareSize * 1 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                                if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                {
                                    dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                                }
                                else
                                {
                                    dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                    dst.Left += gv.squareSize * 3 / 4;
                                }
                                dst.Height -= (int)(dst.Height * 3 / 4);
                                dst.Height = (int)(dst.Height * 1.4f);
                                dst.Width -= (int)(dst.Width * 3 / 4);
                                dst.Width = (int)(dst.Width * 1.4f);
                            }

                            gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                        }
                    }

                    if (gv.mod.playerList[0].combatFacingLeft == true)
                    {
                        shift = gv.squareSize / 5; 
                        if (gv.mod.currentArea.useMiniProps)
                        {
                            shift = (int)shift / 2;
                        }
                        else if (gv.mod.currentArea.useSuperTinyProps)
                        {
                            shift = (int)shift / 4;
                        }
                        gv.oXshift = gv.oXshift - shift / 2;
                    }
                    else
                    {
                        //gv.oXshift = gv.oXshift + shift / 2;
                    }
                }
                */
                #endregion
                bool drawBecauseSteppedOnNeighbour = false;
                //stepped south, look for northern neighbour
                if (gv.mod.drawPartyDirection == "up")
                {
                    if (gv.mod.PlayerLocationY == 0 && gv.mod.currentArea.northernNeighbourArea != "none")
                    {
                        drawBecauseSteppedOnNeighbour = true;
                    }
                }
                //stepped north, look for southern neighbour
                if (gv.mod.drawPartyDirection == "down")
                {
                    if (gv.mod.PlayerLocationY == (gv.mod.currentArea.MapSizeY - 1) && gv.mod.currentArea.southernNeighbourArea != "none")
                    {
                        drawBecauseSteppedOnNeighbour = true;
                    }
                }
                //stepped east, look for western neighbour
                if (gv.mod.drawPartyDirection == "left")
                {
                    if (gv.mod.PlayerLocationX == 0 && gv.mod.currentArea.westernNeighbourArea != "none")
                    {
                        drawBecauseSteppedOnNeighbour = true;
                    }
                }
                //stepped west, look for eastern neighbour
                if (gv.mod.drawPartyDirection == "right")
                {
                    if (gv.mod.PlayerLocationX == (gv.mod.currentArea.MapSizeX - 1) && gv.mod.currentArea.easternNeighbourArea != "none")
                    {
                        drawBecauseSteppedOnNeighbour = true;
                    }
                }

                //TODO: ctahc crashes becaus echeckign for non-existent tiles near map border
                //stepped south, look for EW-bridge north
                bool hideUnderBridge = false;
                if (gv.mod.drawPartyDirection == "up")
                {
                    if (gv.mod.PlayerLocationY - 1 > 0)
                    {
                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY - 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isEWBridge)
                        {
                            hideUnderBridge = true;
                        }
                    }
                }

                //stepped north, look for EW-bridge south
                if (gv.mod.drawPartyDirection == "down")
                {
                    if (gv.mod.PlayerLocationY + 1 < gv.mod.currentArea.MapSizeY)
                    {
                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY + 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isEWBridge)
                        {
                            hideUnderBridge = true;
                        }
                    }
                }

                //stepped east, look for NS-bridge west
                if (gv.mod.drawPartyDirection == "left")
                {
                    if (gv.mod.PlayerLocationX - 1 > 0)
                    {
                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX - 1].isNSBridge)
                        {
                            hideUnderBridge = true;
                        }
                    }
                }

                //stepped west, look for NS-bridge east
                if (gv.mod.drawPartyDirection == "right")
                {
                    if (gv.mod.PlayerLocationX + 1 < gv.mod.currentArea.MapSizeX)
                    {
                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX + 1].isNSBridge)
                        {
                            hideUnderBridge = true;
                        }
                    }
                }

                //moving prop on tail
                bool propOnTail = false;
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (!p.isStealthed && (p.isMover || p.stealthSkipsPropTriggers) && p.LocationX == gv.mod.PlayerLastLocationX && p.LocationY == gv.mod.PlayerLastLocationY)
                    {
                        if (!drawBecauseSteppedOnNeighbour)
                        {
                            propOnTail = true;
                        }
                    }
                }

                if ((gv.mod.justTransitioned == false && !hideUnderBridge && !propOnTail) || drawBecauseSteppedOnNeighbour)
                {
                    if ((showFullParty) && (gv.mod.playerList.Count > 1) && gv.mod.drawPartyDirection != "none")
                    {
                        int drawCounter = 0;
                        int tailXChange = 0;
                        int tailYChange = 0;

                        if (gv.mod.drawPartyDirection == "up")
                        {
                            tailYChange = -1 * gv.squareSize;
                        }
                        else if (gv.mod.drawPartyDirection == "down")
                        {
                            tailYChange = 1 * gv.squareSize;
                        }
                        else if (gv.mod.drawPartyDirection == "right")
                        {
                            tailXChange = 1 * gv.squareSize;
                        }
                        else if (gv.mod.drawPartyDirection == "left")
                        {
                            tailXChange = -1 * gv.squareSize;
                        }

                        foreach (Player p in gv.mod.playerList)
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                            dst.Top += (int)(gv.squareSize * 3 / 8) - (int)(dst.Height * 0.075f * 0.4f); //37,5 -3 == 34,5
                            if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                            {
                                dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                            }
                            else
                            {
                                dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                                dst.Left += gv.squareSize * 3 / 4;
                            }
                            dst.Height -= (int)(dst.Height * 3 / 4);
                            dst.Height = (int)(dst.Height * 1.2f);
                            dst.Width -= (int)(dst.Width * 3 / 4);
                            dst.Width = (int)(dst.Width * 1.2f);

                            //up
                            // 0 1
                            // 2 3
                            // 4 5

                            //5 4
                            //3 2
                            //1 0
                            //down

                            //left //1 3 5
                            //0 2 4

                            //4 2 0 //right
                            //5 3 1



                            if (p != gv.mod.playerList[gv.mod.selectedPartyLeader])
                            {
                                if (drawCounter == 0)
                                {
                                    if (gv.mod.drawPartyDirection == "down")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "up")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "right")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "left")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize));
                                    }
                                }
                                else if (drawCounter == 1)
                                {
                                    if (gv.mod.drawPartyDirection == "down")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "up")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "right")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "left")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize));
                                    }
                                }
                                else if (drawCounter == 2)
                                {
                                    if (gv.mod.drawPartyDirection == "down")
                                    {
                                        dst.Top += tailYChange;
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "up")
                                    {
                                        dst.Top += tailYChange;
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "right")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                        dst.Left += tailXChange;
                                    }
                                    else if (gv.mod.drawPartyDirection == "left")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                        dst.Left += tailXChange;
                                    }
                                }
                                else if (drawCounter == 3)
                                {
                                    if (gv.mod.drawPartyDirection == "down")
                                    {
                                        dst.Top += tailYChange;
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "up")
                                    {
                                        dst.Top += tailYChange;
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "right")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                        dst.Left += tailXChange;
                                    }
                                    else if (gv.mod.drawPartyDirection == "left")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                        dst.Left += tailXChange;
                                    }
                                }
                                else if (drawCounter == 4)
                                {
                                    if (gv.mod.drawPartyDirection == "down")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "up")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "right")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "left")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize));
                                    }
                                }
                                else if (drawCounter == 5)
                                {

                                    if (gv.mod.drawPartyDirection == "down")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "up")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "right")
                                    {
                                        dst.Top += (tailYChange - (int)(0.3f * gv.squareSize) + (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange + (int)(0.3f * gv.squareSize));
                                    }
                                    else if (gv.mod.drawPartyDirection == "left")
                                    {
                                        dst.Top += (tailYChange + (int)(0.3f * gv.squareSize) - (int)(0.14f * gv.squareSize));
                                        dst.Left += (tailXChange - (int)(0.3f * gv.squareSize));
                                    }
                                }

                                if (gv.mod.drawPartyDirection != "none")
                                {
                                    //if (!gv.mod.currentArea.PlayerIsUnderBridge)
                                    //{
                                        gv.DrawBitmap(p.token, src, dst, !gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft, true);
                                    //}
                                }

                                drawCounter++;
                            }
                        }
                    }
                }
                //always draw party leader on top
                int storeShift = shift;
                shift = 0;
                if (gv.mod.selectedPartyLeader == 0)
                {
                    if (showFullParty)
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                    else
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                }
                else if (gv.mod.selectedPartyLeader == 1)
                {
                    if (showFullParty)
                    {
                        dst = new IbRect(x + gv.oXshift + shift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                    else
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                }
                else if (gv.mod.selectedPartyLeader == 2)
                {
                    if (showFullParty)
                    {
                        dst = new IbRect(x + gv.oXshift - shift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                    else
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                }
                else if (gv.mod.selectedPartyLeader == 3)
                {
                    if (showFullParty)
                    {
                        dst = new IbRect(x + gv.oXshift + (shift * 2) + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                    else
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                }
                else if (gv.mod.selectedPartyLeader == 4)
                {
                    if (showFullParty)
                    {
                        dst = new IbRect(x + gv.oXshift - (shift * 2) + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                    else
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                }
                else if (gv.mod.selectedPartyLeader == 5)
                {
                    if (showFullParty)
                    {
                        dst = new IbRect(x + gv.oXshift - (shift * 3) + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                    else
                    {
                        dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                    }
                }

                if (gv.mod.currentArea.useMiniProps)
                {
                    dst.Top += (int)(gv.squareSize / 4) - (int)(dst.Height * 0.050f);
                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                    {
                        dst.Left += (int)(gv.squareSize / 4) - (int)(dst.Width * 0.075f);
                    }
                    else
                    {
                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100) + (int)(dst.Width * 0.075f);
                        dst.Left += gv.squareSize * 2 / 4;
                    }
                    dst.Height -= (int)(dst.Height / 2);
                    dst.Height = (int)(dst.Height * 1.3f);
                    dst.Width -= (int)(dst.Width / 2);
                    dst.Width = (int)(dst.Width * 1.3f);
                }
                else if (gv.mod.currentArea.useSuperTinyProps)
                {
                    dst.Top += (int)(gv.squareSize * 3 / 8) - (int)(dst.Height * 0.075f * 0.4f);
                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                    {
                        dst.Left += (int)(gv.squareSize * 3 / 8) - (int)(dst.Width * 0.075f * 0.4f);
                    }
                    else
                    {
                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100) + (int)(dst.Width * 0.075f * 0.4f);
                        dst.Left += gv.squareSize * 3 / 4;
                    }
                    dst.Height -= (int)(dst.Height * 3 / 4);
                    dst.Height = (int)(dst.Height * 1.4f);
                    dst.Width -= (int)(dst.Width * 3 / 4);
                    dst.Width = (int)(dst.Width * 1.4f);
                }
                if (!gv.mod.currentArea.PlayerIsUnderBridge)
                {
                    gv.DrawBitmap(gv.mod.playerList[gv.mod.selectedPartyLeader].token, src, dst, !gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft, true);
                }
                    shift = storeShift;
            }
        //}
        }

        public void drawGrid()
        {
            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX;
            if (minX < 0) { minX = 0; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY;
            if (minY < 0) { minY = 0; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

            for (int x = minX; x < maxX; x++)
            {
                for (int y = minY; y < maxY; y++)
                {
                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.walkBlocked.PixelSize.Width, gv.cc.walkBlocked.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                    if (gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                    {
                        gv.DrawBitmap(gv.cc.losBlocked, src, dst);
                    }
                    if (gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Walkable != true)
                    {
                        gv.DrawBitmap(gv.cc.walkBlocked, src, dst);
                    }
                    else
                    {
                        gv.DrawBitmap(gv.cc.walkPass, src, dst);
                    }
                }
            }
        }
    
        public void drawMainMapFloatyText()
        {
            int txtH = (int)gv.drawFontRegHeight;

            if (gv.cc.floatyText != "none" && gv.cc.floatyText != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyText, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize*1f), gv.cc.floatyTextLoc.Y + y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                gv.DrawTextCenter(gv.cc.floatyText, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
            }

            if (gv.cc.floatyText2 != "none" && gv.cc.floatyText2 != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyText2, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + y + txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                gv.DrawTextCenter(gv.cc.floatyText2, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
            }

            if (gv.cc.floatyText3 != "none" && gv.cc.floatyText3 != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyText3, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + y + txtH*2, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                gv.DrawTextCenter(gv.cc.floatyText3, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + txtH*2, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
            }

            if (gv.cc.floatyText4 != "none" && gv.cc.floatyText4 != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyText4, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + y + txtH * 3, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                gv.DrawTextCenter(gv.cc.floatyText4, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + txtH * 3, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
            }

            if (gv.cc.floatyText0 != "none" && gv.cc.floatyText0 != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyText0, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + y, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                gv.DrawTextCenter(gv.cc.floatyText0, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
            }

            if (gv.cc.floatyTextA != "none" && gv.cc.floatyTextA != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyTextA, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + y - txtH*2, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                gv.DrawTextCenter(gv.cc.floatyTextA, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH * 2, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
            }

            if (gv.cc.floatyTextB != "none" && gv.cc.floatyTextB != "")
            {
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y + y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Black);
                    }
                }

                if (gv.cc.floatyTextB.Contains("Mandatory"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Yellow);
                }
                else if (gv.cc.floatyTextB.Contains("Optional"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Lime);
                }
                else if (gv.cc.floatyTextB.Contains("Very Hard"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Orange);
                }
                else if (gv.cc.floatyTextB.Contains("Hard"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Yellow);
                }
                else if (gv.cc.floatyTextB.Contains("Easy"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Lime);
                }
                else if (gv.cc.floatyTextB.Contains("Normal"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.White);
                }
                else if (gv.cc.floatyTextB.Contains("Deadly"))
                {
                    gv.DrawTextCenter(gv.cc.floatyTextB, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels - (int)(gv.squareSize * 1f), gv.cc.floatyTextLoc.Y - txtH, (int)(gv.squareSize * 3f), 1000), 0.8f, Color.Red);
                }
            }
        }
        public void drawOverlayTints()
        {
            IbRect src = new IbRect(0, 0, gv.cc.tint_sunset.PixelSize.Width, gv.cc.tint_sunset.PixelSize.Height);
            //IbRect dst = new IbRect(gv.oXshift + mapStartLocXinPixels, 0, (gv.squareSize * (gv.playerOffsetX * 2 + 1)), (gv.squareSize * (gv.playerOffsetY * 2 + 2)));
            IbRect dst = new IbRect(mapStartLocXinPixels-gv.oXshift, -gv.oYshift, (gv.squareSize * (gv.playerOffsetX * 2 + 1))+ 2*gv.oXshift + gv.pS, (gv.squareSize * (gv.playerOffsetY * 2 + 2)) + gv.pS);

            int dawn = 5 * 60;
            int sunrise = 6 * 60;
            int day = 7 * 60;
            int sunset = 17 * 60;
            int dusk = 18 * 60;
            int night = 20 * 60;
            int time = gv.mod.WorldTime % 1440;
            if ((time >= dawn) && (time < sunrise))
            {
                gv.DrawBitmap(gv.cc.tint_dawn, src, dst);
            }
            else if ((time >= sunrise) && (time < day))
            {
                gv.DrawBitmap(gv.cc.tint_sunrise, src, dst);
            }
            else if ((time >= day) && (time < sunset))
            {
                //no tint for day
            }
            else if ((time >= sunset) && (time < dusk))
            {
                gv.DrawBitmap(gv.cc.tint_sunset, src, dst);
            }
            else if ((time >= dusk) && (time < night))
            {
                gv.DrawBitmap(gv.cc.tint_dusk, src, dst);
            }
            else if ((time >= night) || (time < dawn))
            {
                gv.DrawBitmap(gv.cc.tint_night, src, dst, false, 0.75f);
            }

        }

        public void drawWeatherSprites()
        {
            if (gv.mod.currentArea.areaWeatherName != "" && gv.mod.currentArea.areaWeatherName != "none")
            {
                //hurgh1000
                //gv.cc.addLogText("lime", gv.mod.currentArea.areaWeatherName.ToString());

                foreach (Sprite spr in spriteList)
                {
                    if (spr.movementMethod.Contains("rain") || spr.movementMethod.Contains("snow") || spr.movementMethod.Contains("sandStorm"))
                    {
                        spr.Draw(gv);
                    }
                }


                foreach (Sprite spr in spriteList)
                {
                    if (spr.movementMethod.Contains("lightning") || spr.movementMethod.Contains("fog") || spr.movementMethod.Contains("clouds"))
                    {
                        spr.Draw(gv);
                    }
                }
            }
        }

        public void drawOtherSprites()
        {
            

            foreach (Sprite spr in spriteList)
            {
                if (!spr.movementMethod.Contains("lightning") && !spr.movementMethod.Contains("fog") && !spr.movementMethod.Contains("clouds") && !spr.movementMethod.Contains("rain") && !spr.movementMethod.Contains("snow") && !spr.movementMethod.Contains("sandStorm"))
                {
                    spr.Draw(gv);
                }
            }

            drawBlackTilesOverTints();
        }

        public void drawSprites()
        {
           if (gv.mod.currentArea.areaWeatherName != "" && gv.mod.currentArea.areaWeatherName != "none")
           {
           //hurgh1000
           //gv.cc.addLogText("lime", gv.mod.currentArea.areaWeatherName.ToString());

            foreach (Sprite spr in spriteList)
                {
                    if (spr.movementMethod.Contains("rain") || spr.movementMethod.Contains("snow") || spr.movementMethod.Contains("sandStorm"))
                    {
                        spr.Draw(gv);
                    }
                }


                foreach (Sprite spr in spriteList)
                {
                    if (spr.movementMethod.Contains("lightning") || spr.movementMethod.Contains("fog") || spr.movementMethod.Contains("clouds"))
                    {
                        spr.Draw(gv);
                    }
                }
            }

            foreach (Sprite spr in spriteList)
            {
                if (!spr.movementMethod.Contains("lightning") && !spr.movementMethod.Contains("fog") && !spr.movementMethod.Contains("clouds") &&!spr.movementMethod.Contains("rain") && !spr.movementMethod.Contains("snow") && !spr.movementMethod.Contains("sandStorm"))
                {
                    spr.Draw(gv);
                }
            }

            drawBlackTilesOverTints();
        }
        //not used for now; later :-)
        /*public void drawOverlayWeather()
        {
            //memo to self: in second step do animation by drawing two partial rectangles of same source that change size with time, upper and lower rect, and cast to same target dst, but shifted
            //the source picture must be identical top and bottom lines, other wise we will see a clear dividing line
            //idea that one source bitmap can be used all itself to simulate scrolling down if called in shifting chunks
            //part that scrolls out of lower screen border appears again at top screen border
            //second memo to self: in game settings implement several speed settings for animation speed (pixel move per call multiplier) so that players can adjust prop anim and weatehr anim speed themselves
            //third memo to self: descripe current weather type next to current time in the game ui
            IbRect src = new IbRect(0, 0, gv.cc.tint_rain.PixelSize.Width, gv.cc.tint_rain.PixelSize.Height);
            IbRect dst = new IbRect(gv.oXshift + mapStartLocXinPixels, 0, (gv.squareSize * 9), (gv.squareSize * 9));
            int dawn = 5 * 60;
            int sunrise = 6 * 60;
            int day = 7 * 60;
            int sunset = 17 * 60;
            int dusk = 18 * 60;
            int night = 20 * 60;
            int time = gv.mod.WorldTime % 1440;
            if ((time >= dawn) && (time < sunrise))
            {
                gv.DrawBitmap(gv.cc.tint_dawn, src, dst);
            }
            else if ((time >= sunrise) && (time < day))
            {
                gv.DrawBitmap(gv.cc.tint_sunrise, src, dst);
            }
            else if ((time >= day) && (time < sunset))
            {
                //no tint for day
            }
            else if ((time >= sunset) && (time < dusk))
            {
                gv.DrawBitmap(gv.cc.tint_sunset, src, dst);
            }
            else if ((time >= dusk) && (time < night))
            {
                gv.DrawBitmap(gv.cc.tint_dusk, src, dst);
            }
            else if ((time >= night) || (time < dawn))
            {
                gv.DrawBitmap(gv.cc.tint_night, src, dst);
            }

        }*/

        public void drawMainMapHotKeys()
        {
            int txtH = (int)gv.drawFontRegHeight;
            int lineCounter = -1;
            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Show/Hide Hotkeys: H", new IbRect(x+gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y+(gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Show/Hide Hotkeys: H", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4*gv.pS, (gv.playerOffsetX-8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Hide/Show HUD (Mode: Static): X", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Hide/Show HUD (Mode: Static): X", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Hide/Show HUD (Mode: Dynamic): F / NumBlock 0 / Insert", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Hide/Show HUD (Mode: Dynamic): F / NumBlock 0 / Insert", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Party Light on/off (using first light source in inventory): T", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Party Light on/off (using first light source in inventory): T", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Active search: SPACE", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Active search: SPACE", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Wait one step: Y / Z", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Wait one step: Y / Z", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Quick save: F5", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Quick save: F5", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Change Party Leader: E / (D or arrow right) / right MB click on portrait", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Change Party Leader: E / (D or arrow right) / right MB click on portrait", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Change Party Leader reverse: Q / (A or arrow left) / right MB click on portrait", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Change Party Leader reverse: Q / (A or arrow left) / right MB click on portrait", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Scroll log up: R / (W or arrow up) / mouse wheel up", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Scroll log up: R / (W or arrow up) / mouse wheel up", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Scroll log down: V / (S or arrow down) / mouse wheel down", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Scroll log down: V / (S or arrow down) / mouse wheel down", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move up: Keypad8 / (W or arrow up)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Move up: Keypad8 / (W or arrow up)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move down: Keypad2 / (S or arrow down)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Move down: Keypad2 / (S or arrow down)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move right: Keypad6 / (D or arrow right)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Move right: Keypad6 / (D or arrow right)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Move left: Keypad4 / (A or arrow left)", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Move left: Keypad4 / (A or arrow left)", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;

            for (int x = -1; x <= 1; x++)
            {
                for (int y = -1; y <= 1; y++)
                {
                    gv.DrawText("Debug mode: B", new IbRect(x + gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, y + (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Black);
                }
            }
            gv.DrawText("Debug mode: B", new IbRect(gv.oXshift + (gv.playerOffsetY) * gv.squareSize - 4 * gv.pS, (gv.playerOffsetX - 8) * gv.squareSize + (int)(txtH * 1.25f * lineCounter) + (int)(3 * gv.pS), 1000, 100), 1.0f, Color.Red);
            lineCounter++;
        }


        public void drawMainMapClockText()
        {
            //gegenstände
            int timeofday = gv.mod.WorldTime % (24 * 60);
            int hour = timeofday / 60;
            int minute = timeofday % 60;
            string sMinute = minute + "";
            if (minute < 10)
            {
                sMinute = "0" + minute;
            }

            int txtH = (int)gv.drawFontRegHeight;


            //assuming 28 days in 12 Months, ie 336 days a year
            //notation example: 13:17, Tuesday, 9th of March 1213

            string coordText = " (" + gv.mod.PlayerLocationX + "," + gv.mod.PlayerLocationY + ")";

            if (gv.mod.useComplexCoordinateSystem)
            {
                //start of NEW SYSTEM

                //structure below:
                //1. is party light on?
                //2. has area an ingame name?
                //3. is ration system used?
                //results in 8 combinations
                //all using a double draw rountine: one for the black letter border, one for the core color of the letter  

                //in the new system we gonna split this into 2 sections:

                //top section
                //one for the top row three buttons showing: zoom level (with time passing per step as button text), rations (number as button text) and torches (light units as button text)
                //zoom level button will show a different icon, depending on whether props is in the current area are drawn normal, small or tiny
                //gonna have to shorten and move down the log by about half a square's size

                //bottom section
                //hour and minute, calendar date
                //up to three rows of info for zone:area, zone:area, zone: area 
                //the screen space taken should always be minimal, so when already on most zoomed out level only one row is used

                //three potential strings for the location info lines
                string zoom0Line = "";
                string zoom1Line = "";
                string zoom2Line = "";
                int pushLinesUpBy = 0;

                //determine zoom level
                int zoomLevel = 2;
                if (gv.mod.currentArea.useMiniProps)
                {
                    zoomLevel = 1;
                    pushLinesUpBy = 1;
                }
                else if (gv.mod.currentArea.useSuperTinyProps)
                {
                    zoomLevel = 0;
                    pushLinesUpBy = 2;
                }

                zoomLevel = 0;
                //fully zoomed out (far)
                if (zoomLevel == 0)
                {
                    //now we have to find out whether current area's zone name OR as current area's ingame name are different from none/"" 
                    //if (gv.mod.currentArea.zoneName != "none" && gv.mod.currentArea.zoneName != "")
                    //{
                        //zoom0Line += gv.mod.currentArea.zoneName + "[L" + gv.mod.currentArea.zoneFloorLevel + "," + gv.mod.currentArea.zoneX + "," + gv.mod.currentArea.zoneY + "]";
                    //}

                    if (gv.mod.currentArea.inGameAreaName != "none" && gv.mod.currentArea.inGameAreaName != "")
                    {
                        //if (gv.mod.currentArea.zoneName != "none" && gv.mod.currentArea.zoneName != "")
                        //{
                            //zoom0Line += ": ";
                        //}
                        zoom0Line += gv.mod.currentArea.inGameAreaName + " (" + gv.mod.PlayerLocationX + "," + gv.mod.PlayerLocationY + ")";
                    }
                    //now draw the lines for date&time top and location info below 
                    //two lines: date on top and current area's zone name as well as current area's ingame name
                    if (gv.mod.useMinimalisticUI)
                    {
                        //draw black frames around font
                        for (int x = -1; x <= 1; x++)
                        {
                            for (int y = -1; y <= 1; y++)
                            {
                                if (!gv.mod.useComplexCoordinateSystem)
                                {
                                    gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS - (int)(2.5 * gv.pS * 0) + 2 * gv.pS, 600, 100), 1.0f, Color.Black);
                                }
                                else
                                {
                                    gv.DrawTextLeft(gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS - (int)(2.5 * gv.pS * 0) + 2 * gv.pS, 600, 100), 1.0f, Color.Black);
                                }
                                gv.DrawTextLeft(zoom0Line, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS) + (int)(2.5 * gv.pS * 0) + 2 * gv.pS, 600, 100), 1.0f, Color.Black);
                            }
                        }
                        //draw font itself (white)
                        if (!gv.mod.useComplexCoordinateSystem)
                        {
                            gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS - (int)(2.5 * gv.pS * 0) + 2 * gv.pS, 600, 100), 1.0f, Color.White);
                        }
                        else
                        {
                            gv.DrawTextLeft(gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS - (int)(2.5 * gv.pS * 0) + 2 * gv.pS, 600, 100), 1.0f, Color.White);
                        }
                        gv.DrawTextLeft(zoom0Line, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS) + (int)(2.5 * gv.pS * 0) + 2 * gv.pS, 600, 100), 1.0f, Color.White);

                    }
                }

                //zoomed one level in (middle)
                if (zoomLevel == 1)
                {
                    //now we have to find out whether current area's zone name OR as current area's ingame name are different from none/"" 
                    if (gv.mod.currentArea.zoneName != "none" && gv.mod.currentArea.zoneName != "")
                    {
                        zoom0Line += gv.mod.currentArea.zoneName + "[L" + gv.mod.currentArea.zoneFloorLevel + "," + gv.mod.currentArea.zoneX + "," + gv.mod.currentArea.zoneY + "]";
                    }

                    if (gv.mod.currentArea.inGameAreaName != "none" && gv.mod.currentArea.inGameAreaName != "")
                    {
                        if (gv.mod.currentArea.zoneName != "none" && gv.mod.currentArea.zoneName != "")
                        { 
                            zoom0Line += ": ";
                        }
                        zoom0Line += gv.mod.currentArea.inGameAreaName + "(" + gv.mod.PlayerLocationX + "," + gv.mod.PlayerLocationY + ")";
                    }

                    //now build info for zoom1Line (read in zoneMotherArea name from current area, then use motehr area to get zone of mother area 
                    if (gv.mod.currentArea.zoneMotherAreaName != "none" && gv.mod.currentArea.zoneMotherAreaName != "")
                    {
                        foreach (Area a in gv.mod.moduleAreasObjects)
                        {
                            if (a.Filename == gv.mod.currentArea.zoneMotherAreaName)
                            {
                                if (a.zoneName != "none" && a.zoneName != "")
                                {
                                    zoom1Line += a.zoneName + "[L" + a.zoneFloorLevel + "," + a.zoneX + "," + a.zoneY + "]";
                                    zoom1Line += ": ";
                                }
                                zoom1Line += a.inGameAreaName + "(" + gv.mod.currentArea.zoneMotherAreaX + "," + gv.mod.currentArea.zoneMotherAreaX + ")";
                            }
                        }

                    }
                    //now draw the lines for date&time top and location info below 
                    //two lines: date on top and current area's zone name as well as current area's ingame name
                    if (gv.mod.useMinimalisticUI)
                    {
                        //draw black frames around font
                        for (int x = -1; x <= 1; x++)
                        {
                            for (int y = -1; y <= 1; y++)
                            {
                                gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS - (int)(2.5 * gv.pS * 1)+ gv.pS + (int)0.0 * gv.pS, 600, 100), 1.0f, Color.Black);
                                gv.DrawTextLeft(zoom1Line, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 1)+gv.pS, 600, 100), 1.0f, Color.Black);
                                gv.DrawTextLeft(zoom0Line, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 0) + 2*gv.pS, 600, 100), 1.0f, Color.Black);
                            }
                        }
                        //draw font itself (white)
                        gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS - (int)(2.5 * gv.pS * 1) + gv.pS + (int)0.0*gv.pS, 600, 100), 1.0f, Color.White);
                        gv.DrawTextLeft(zoom1Line, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 1)+gv.pS, 600, 100), 1.0f, Color.White);
                        gv.DrawTextLeft(zoom0Line, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 0) + 2*gv.pS, 600, 100), 1.0f, Color.White);
                    }
                }

                //zoomed two levels in (close)
                if (zoomLevel == 2)
                {
                    //now we have to find out whether current area's zone name OR as current area's ingame name are different from none/"" 
                    if (gv.mod.currentArea.zoneName != "none" && gv.mod.currentArea.zoneName != "")
                    {
                        zoom0Line = gv.mod.currentArea.zoneName + "[L" + gv.mod.currentArea.zoneFloorLevel + "," + gv.mod.currentArea.zoneX + "," + gv.mod.currentArea.zoneY + "]";
                    }

                    if (gv.mod.currentArea.inGameAreaName != "none" && gv.mod.currentArea.inGameAreaName != "")
                    {
                        if (gv.mod.currentArea.zoneName != "none" && gv.mod.currentArea.zoneName != "")
                        {
                            zoom0Line += ": ";
                        }
                        zoom0Line += gv.mod.currentArea.inGameAreaName + "(" + gv.mod.PlayerLocationX + "," + gv.mod.PlayerLocationY + ")";
                    }

                    //now build info for zoom1Line (read in zoneMotherArea name from current area, then use motehr area to get zone of mother area 
                    if (gv.mod.currentArea.zoneMotherAreaName != "none" && gv.mod.currentArea.zoneMotherAreaName != "")
                    {
                        foreach (Area a in gv.mod.moduleAreasObjects)
                        {
                            if (a.Filename == gv.mod.currentArea.zoneMotherAreaName)
                            {
                                if (a.zoneName != "none" && a.zoneName != "")
                                {
                                    zoom1Line = a.zoneName + "[L" + a.zoneFloorLevel + "," + a.zoneX + "," + a.zoneY + "]";
                                    zoom1Line += ": ";
                                }
                                zoom1Line += a.inGameAreaName + "(" + gv.mod.currentArea.zoneMotherAreaX + "," + gv.mod.currentArea.zoneMotherAreaX + ")";



                                //integrate grandma here, so we can work with a
                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                //now build info for zoom2Line (read in zoneMotherArea name from mother area, then use hits grandma area to get zone of grandma area 
                                if (a.zoneMotherAreaName != "none" && a.zoneMotherAreaName != "")
                                {
                                    foreach (Area grandA in gv.mod.moduleAreasObjects)
                                    {
                                        if (grandA.Filename == a.zoneMotherAreaName)
                                        {
                                            if (grandA.zoneName != "none" && grandA.zoneName != "")
                                            {
                                                zoom2Line = grandA.zoneName + "[L" + grandA.zoneFloorLevel + "," + grandA.zoneX + "," + grandA.zoneY + "]";
                                                zoom2Line += ": ";
                                            }
                                            zoom2Line += grandA.inGameAreaName + "(" + a.zoneMotherAreaX + "," + a.zoneMotherAreaX + ")";
                                        }
                                    }
                                }
                            }


                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        }
                    }


                    //now draw the lines for date&time top and location info below 
                    //two lines: date on top and current area's zone name as well as current area's ingame name
                    if (gv.mod.useMinimalisticUI)
                    {
                        //draw black frames around font
                        for (int x = -1; x <= 1; x++)
                        {
                            for (int y = -1; y <= 1; y++)
                            {
                                gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS - (int)(2.5 * gv.pS * 2 +0.5*gv.pS), 600, 100), 1.0f, Color.Black);
                                gv.DrawTextLeft(zoom2Line, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 2), 600, 100), 1.0f, Color.Black);
                                gv.DrawTextLeft(zoom1Line, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 1) + gv.pS, 600, 100), 1.0f, Color.Black);
                                gv.DrawTextLeft(zoom0Line, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 0) + 2*gv.pS, 600, 100), 1.0f, Color.Black);
                            }
                        }
                        //draw font itself (white)
                        gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS - (int)(2.5 * gv.pS * 2 + 0.5*gv.pS), 600, 100), 1.0f, Color.White);
                        gv.DrawTextLeft(zoom2Line, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 2), 600, 100), 1.0f, Color.White);
                        gv.DrawTextLeft(zoom1Line, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 1) + gv.pS, 600, 100), 1.0f, Color.White);
                        gv.DrawTextLeft(zoom0Line, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS) - (int)(2.5 * gv.pS * 0) + 2*gv.pS, 600, 100), 1.0f, Color.White);
                    }
                }
            }
            else if (!gv.mod.useComplexCoordinateSystem)
            {
                //old system
                if (gv.mod.useMinimalisticUI)
                {
                    for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            if (gv.mod.partyLightOn)
                            {
                                gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 600, 100), 1.0f, Color.Black);
                                if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                                {
                                    if (gv.mod.useRationSystem)
                                    {
                                        gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText + ", " + "R(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + "T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS +3, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                    else
                                    {
                                        gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText + ", " + "T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                }
                                else
                                {
                                    if (gv.mod.useRationSystem)
                                    {
                                        gv.DrawTextLeft("R(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + "T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                    else
                                    {
                                        gv.DrawTextLeft("T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                }
                                //gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 600, 100), 1.0f, Color.Black);
                            }
                            else
                            {
                                gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 600, 100), 1.0f, Color.Black);
                                if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                                {
                                    if (gv.mod.useRationSystem)
                                    {
                                        gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText + ", " + "R(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                    else
                                    {
                                        gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                }
                                else
                                {
                                    if (gv.mod.useRationSystem)
                                    {
                                        gv.DrawTextLeft("R(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                    else
                                    {
                                        //gv.DrawText("Rations(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                    }
                                }
                            }
                        }
                    }
                    if (gv.mod.partyLightOn)
                    {
                        gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);
                        if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                        {
                            if (gv.mod.useRationSystem)
                            {
                                gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText + ", " + "R(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + "T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);
                            }
                            else
                            {
                                gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText + ", " + "T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);

                            }

                        }
                        else
                        {
                            if (gv.mod.useRationSystem)
                            {
                                gv.DrawTextLeft("R(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + "T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);
                            }
                            else
                            {
                                gv.DrawTextLeft("T" + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);

                            }
                        }
                        //gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);
                    }
                    else
                    {
                        gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);
                        if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                        {
                            if (gv.mod.useRationSystem)
                            {
                                gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText + ", " + "R(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5f * gv.pS), 600, 100), 1.0f, Color.White);
                            }
                            else
                            {
                                gv.DrawTextLeft(gv.mod.currentArea.inGameAreaName + coordText, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5f * gv.pS), 600, 100), 1.0f, Color.White);

                            }
                        }
                        else
                        {
                            if (gv.mod.useRationSystem)
                            {
                                gv.DrawTextLeft("R(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5f * gv.pS), 600, 100), 1.0f, Color.White);
                            }

                        }
                        //gv.DrawText(hour + ":" + sMinute, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);

                    }
                }
                else
                {
                    for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 1) * gv.squareSize, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 100, 100), 1.0f, Color.Black);
                        }
                    }
                    gv.DrawTextLeft(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 1) * gv.squareSize, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 100, 100), 1.0f, Color.White);

                }
            } 
        }
        public void drawFogOfWar()
        {
            #region new system
            if (gv.mod.useAllTileSystem)
            {
                /*
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;
                 * */



            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            #region neighbours
            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                #region go through tiles
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {

                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (int)gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (int)gv.squareSize;
                                //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                float scalerX = 1.0f;
                                float scalerY = 1.0f;
                                int brX = gv.squareSize;
                                int brY = gv.squareSize;
                                IbRect src = new IbRect(0, 0, 100, 100);
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.2f), (int)(brY * 1.2f));
                                if (gv.mod.fogOfWarOpacity != 1.0f)
                                {
                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX), (int)(brY));
                                }
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * 1.09f), (int)(brY * 1.1f));
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, gv.squareSize, gv.squareSize);
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX + gv.ox, brY + 3);



                                if (tile.Visible == false)
                                {
                                    if (gv.mod.useMathGridFade)
                                    {
                                        gv.DrawBitmap(gv.cc.offScreen, src, dst, false, 1.0f, false);
                                    }
                                    else
                                    {
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, false, 1.0f * gv.mod.fogOfWarOpacity, false);
                                    }
                                }

                                //code for math grid fade, ie diferent fade speeds for fading tiles
                                else if ((tile.Visible == true) && ( (tile.opacity > 0) ) && (gv.mod.useMathGridFade) )
                                {
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + (int)(brX * 0.05f), tlY + (int)(brY * 0.05f), brX - (int)(brX * 0.05f), brY - (int)(brY * 0.05f));
                                   
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    if (tile.fadeMode == 0)
                                    {
                                        tile.fadeMode = gv.sf.RandInt(3);
                                    }

                                    int chance = gv.sf.RandInt(75);
                                    if (tile.fadeMode == 1)
                                    {
                                        if (chance > 50)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreen5, src, dst, 0, false, 1.0f * tile.opacity5);
                                        gv.DrawBitmap(gv.cc.offScreen6, src, dst, 0, false, 0.5f * tile.opacity6);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity5, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity6, false);

                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                    }
                                    if (tile.fadeMode == 2)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreen6, src, dst, 0, false, 1.0f * tile.opacity6);
                                        gv.DrawBitmap(gv.cc.offScreen7, src, dst, 0, false, 0.5f * tile.opacity7);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 1.0f * tile.opacity6, false);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 0.5f * tile.opacity7, false);
                                    }

                                    if (tile.fadeMode == 3)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreen7, src, dst, 0, false, 1.0f * tile.opacity7);
                                        gv.DrawBitmap(gv.cc.offScreen5, src, dst, 0, false, 0.5f * tile.opacity5);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity7, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity5, false);
                                    }
                                    tile.opacity = tile.opacity - 0.07f;
                                }

                                //code for black tile fade, fade with same speed
                                //to do
                                else if ((tile.Visible == true) && ((tile.opacity > 0)) && (!gv.mod.useMathGridFade) && (gv.mod.fogOfWarOpacity == 1.0f))
                                {
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + (int)(brX * 0.05f), tlY + (int)(brY * 0.05f), brX - (int)(brX * 0.05f), brY - (int)(brY * 0.05f));

                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    if (tile.fadeMode == 0)
                                    {
                                        tile.fadeMode = gv.sf.RandInt(3);
                                    }

                                    int chance = gv.sf.RandInt(75);
                                    if (tile.fadeMode == 1)
                                    {
                                        if (chance > 50)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity5);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity6);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity5, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity6, false);

                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                    }
                                    if (tile.fadeMode == 2)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity6);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity7);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 1.0f * tile.opacity6, false);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 0.5f * tile.opacity7, false);
                                    }

                                    if (tile.fadeMode == 3)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity7);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity5);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity7, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity5, false);
                                    }
                                    tile.opacity = tile.opacity - 0.07f;
                                }

                                //semi transparent fog of war
                                else if ((tile.Visible == true) && ((tile.opacity > 0)) && (!gv.mod.useMathGridFade) && (gv.mod.fogOfWarOpacity != 1.0f))
                                {
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + (int)(brX * 0.05f), tlY + (int)(brY * 0.05f), brX - (int)(brX * 0.05f), brY - (int)(brY * 0.05f));
                                    float transparencyFactor = (gv.mod.fogOfWarOpacity / 2.0f);

                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    if (tile.fadeMode == 0)
                                    {
                                        tile.fadeMode = gv.sf.RandInt(3);
                                    }

                                    int chance = gv.sf.RandInt(75);
                                    if (tile.fadeMode == 1)
                                    {
                                        if (chance > 50)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity5 * transparencyFactor);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity6 * transparencyFactor);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity5, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity6, false);

                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                    }
                                    if (tile.fadeMode == 2)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity6 * transparencyFactor);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity7 * transparencyFactor);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 1.0f * tile.opacity6, false);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 0.5f * tile.opacity7, false);
                                    }

                                    if (tile.fadeMode == 3)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity7 * transparencyFactor);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity5 * transparencyFactor);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity7, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity5, false);
                                    }
                                    tile.opacity = tile.opacity - 0.07f;
                                }

                                //else if (tile.Visible == false)
                                //{
                                //gv.DrawBitmap(gv.cc.black_tile2, src, dst, false, 1.0f, false);
                                //}
                            }
                            catch { }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #region old system
            else //old system using single image background and no load tile images on demand
            {
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX-1;
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY-1;
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 2;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 3;
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Visible)
                        {
                            gv.DrawBitmap(gv.cc.black_tile, src, dst);
                        }
                    }
                }
            }
            #endregion
        }

        public void drawPartyHalo(float elapsed)
        {
            /*
            bool underBridge = false;
          
            if (gv.mod.currentArea.Tiles[gv.mod.PlayerLastLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLastLocationX].heightLevel != gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel)
            {
                if (!gv.mod.currentArea.Tiles[gv.mod.PlayerLastLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLastLocationX].isNSBridge && !gv.mod.currentArea.Tiles[gv.mod.PlayerLastLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLastLocationX].isEWBridge)
                {
                    if (gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isNSBridge || gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isEWBridge)
                    {
                        underBridge = true;
                    }
                }
            }
            */

            //if (!underBridge)
                if (!gv.mod.currentArea.PlayerIsUnderBridge)
                {
                //if (gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isLit.Count <= 1)
                //{
                #region halo pass: go through tiles only for halos
                int minX = gv.mod.PlayerLocationX;
                int minY = gv.mod.PlayerLocationY;
                int maxX = gv.mod.PlayerLocationX;
                int maxY = gv.mod.PlayerLocationY;

                for (int x = minX; x < maxX + 1; x++)
                {
                    for (int y = minY; y < maxY + 1; y++)
                    {
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                        if (drawTile)
                        {
                            bool lightOn = false;
                            foreach (bool light in tile.isLit)
                            {
                                if (light)
                                {
                                    lightOn = true;
                                    break;
                                }
                            }

                            try
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (gv.squareSize);
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (gv.squareSize);
                                //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                float scalerX = 1;
                                float scalerY = 1;
                                int brX = (int)(gv.squareSize * scalerX);
                                int brY = (int)(gv.squareSize * scalerY);
                                float scaler = gv.sf.RandInt(30);
                                //int shifter = gv.sf.RandInt(5);
                                //scaler = 1 + (scaler / 100f);
                                scaler = 1f;
                                //shifter = 0;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    //shifter = 0;
                                    //shifterY = 0;
                                }
                                IbRect src = new IbRect(0, 0, 100, 100);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                float flickerReduction = 1;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    flickerReduction = 1.5f;
                                }

                                if ((tile.isFocalPoint) && (lightOn))
                                {
                                    //color of light source
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //if (lightOn)
                                    //{
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - (int)(0.125f * gv.squareSize), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - (int)(0.125f * gv.squareSize), (int)(brX * scaler) + (int)(0.25f * gv.squareSize), (int)(brY * scaler) + (int)(0.25f * gv.squareSize));

                                    bool drawLightHalo = false;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= night) || (time < dawn))
                                        {
                                            drawLightHalo = true;
                                        }
                                    }
                                    else
                                    {
                                        drawLightHalo = true;
                                    }

                                    if ((!gv.mod.currentArea.useLightSystem) || (!tile.hasHalo))
                                    {
                                        drawLightHalo = false;
                                    }
                                    // is only count hwen isLit and intensity > 0, catch 0, make 1

                                    float opacityDivider = 1.3f;
                                    //int focalCounter = 0;
                                    for (int i = 0; i < tile.lightSourceFocalHaloIntensity.Count; i++)
                                    {
                                        if (tile.isLit[i])
                                        {
                                            if (tile.lightSourceFocalHaloIntensity[i] > 0)
                                            {
                                                opacityDivider++;
                                            }
                                        }
                                    }
                                    //opacityDivider = 2;
                                    if (drawLightHalo)
                                    {
                                        //int extension = 6 - (int)(flicker / 7f);
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5, (int)(brX * scaler) + 2 * extension - 10, (int)(brY * scaler) + 2 * extension - 10);
                                        //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                        if ((x == gv.mod.PlayerLocationX) && (y == gv.mod.PlayerLocationY) && gv.mod.partyLightOn)
                                        {
                                            int extension = 6 - (int)(flicker / 7f);
                                            int extension2 = 13 - (int)(flicker / 3f);
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                            if (gv.mod.partyLightColor.Contains("yellow"))
                                            {
                                                gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider,true);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, ((0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f))) / opacityDivider, true);
                                            }
                                            else if (gv.mod.partyLightColor.Contains("blue"))
                                            {
                                                gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider, true);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, ((0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f))) / opacityDivider, true);
                                            }
                                            else if (gv.mod.partyLightColor.Contains("green"))
                                            {
                                                gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider, true);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, ((0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f))) / opacityDivider, true);
                                            }
                                            else if (gv.mod.partyLightColor.Contains("red"))
                                            {
                                                gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider, true);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, ((0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f))) / opacityDivider, true);
                                            }
                                            else if (gv.mod.partyLightColor.Contains("orange"))
                                            {
                                                gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider, true);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, ((0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f))) / opacityDivider, true);
                                            }
                                            else if (gv.mod.partyLightColor.Contains("purple"))
                                            {
                                                gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider, true);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, ((0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f))) / opacityDivider,true);
                                            }
                                        }

                                        //if (!gv.mod.noHaloAddToParty)
                                        //{
                                        //for (int z = 0; z < tile.tileLightSourceTag.Count; z++)
                                        for (int z = 0; z < tile.lightSourceFocalHaloIntensity.Count; z++)
                                        //foreach (string s in tile.tileLightSourceTag)
                                        {

                                            if (tile.isLit[z])
                                            {
                                                if (tile.tileLightSourceTag[z].Contains("prp_lightYellow"))
                                                {
                                                    int extension = 6 - (int)(flicker / 7f);
                                                    int extension2 = 13 - (int)(flicker / 3f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                    gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, tile.lightSourceRingHaloIntensity[z] * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider,true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, ((0.10f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f))) / opacityDivider,true);

                                                    //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.10f + 2.25f * 0.3f * (0.425f - flicker / 200f));

                                                }

                                                if (tile.tileLightSourceTag[z].Contains("prp_lightGreen"))
                                                {
                                                    int extension = 6 - (int)(flicker / 7f);
                                                    int extension2 = 13 - (int)(flicker / 3f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                    gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider, true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, ((0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f))) / opacityDivider,true);
                                                }

                                                if (tile.tileLightSourceTag[z].Contains("prp_lightRed"))
                                                {
                                                    int extension = 6 - (int)(flicker / 7f);
                                                    int extension2 = 13 - (int)(flicker / 3f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                    gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider,true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, ((0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f))) / opacityDivider,true);
                                                }

                                                if (tile.tileLightSourceTag[z].Contains("prp_lightBlue"))
                                                {
                                                    int extension = 6 - (int)(flicker / 7f);
                                                    int extension2 = 13 - (int)(flicker / 3f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                    gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider,true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, ((0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f))) / opacityDivider,true);
                                                }

                                                if (tile.tileLightSourceTag[z].Contains("prp_lightPurple"))
                                                {
                                                    int extension = 6 - (int)(flicker / 7f);
                                                    int extension2 = 13 - (int)(flicker / 3f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                    gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider,true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, ((0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f))) / opacityDivider,true);
                                                }

                                                if (tile.tileLightSourceTag[z].Contains("prp_lightOrange"))
                                                {
                                                    int extension = 6 - (int)(flicker / 7f);
                                                    int extension2 = 13 - (int)(flicker / 3f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                    gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f) / opacityDivider,true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, ((0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f))) / opacityDivider,true);
                                                }
                                            }
                                        }
                                        //}

                                    }
                                }//close focal light
                            }//close try
                            catch
                            { }
                        }//close draw tile condition
                    }//close inner tile loop
                }//clsoe outer tile loop

                #endregion
            }
        }

        public void drawLightAndDarkness(float elapsed)
        {
            #region new system
            if (gv.mod.useAllTileSystem)
            {
                #region neighbours
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                flickerDelayCounter += elapsed / 1000f * 30f;

                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (tile.lightRadius * gv.squareSize), tlY - (tile.lightRadius * gv.squareSize), brX * (1 + tile.lightRadius * 2), brY * (1 + tile.lightRadius * 2));
                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                //tile.flicker = 0;
                //flicker = 1.15f;
                if (flickerDelayCounter > (0.635f * gv.mod.currentArea.flickerSlowDownFactor))
                {
                    if (flickerRise)
                    {
                        flicker2++;
                        //flicker2++;
                        //tile.affectedByFlickerAlready = true;
                        /*
                        int decider = gv.sf.RandInt(2);
                        if (decider == 1)
                        {
                            flicker++;
                        }
                        else
                        {
                            
                        }
                        
                        else
                        {
                            flicker++;
                            flicker++;
                            flicker++;
                        }
                        */
                    }
                    else
                    {
                        //tile.affectedByFlickerAlready = true;
                        //flicker2--;
                        //int decider = gv.sf.RandInt(3);
                        //if (decider >= 2)
                        //{
                            //flicker2--;
                        flicker2--;
                        //}
                        //else
                        //{

                        //}

                        /*
                        int decider = gv.sf.RandInt(1);
                        if (decider == 1)
                        {
                            flicker--;
                        }
                        else if (decider == 2)
                        {
                            flicker--;
                            flicker--;
                        }
                        else
                        {
                            flicker--;
                            flicker--;
                            flicker--;
                        }
                        */
                    }

                    if (flicker2 == 10)
                    {
                        int decider = gv.sf.RandInt(100);
                        if (decider <= 20)
                        {
                            if (flickerRise == false)
                            {
                                flickerRise = true;
                            }
                            else
                            {
                                flickerRise = false;
                            }
                        }
                    }

                    if (flicker2 == 20)
                    {
                        int decider = gv.sf.RandInt(100);
                        if (decider <= 20)
                        {
                            if (flickerRise == false)
                            {
                                //flickerRise = true;
                            }
                            else
                            {
                                flickerRise = false;
                            }
                        }
                    }

                    if (flicker2 == 30)
                    {
                        int decider = gv.sf.RandInt(100);
                        if (decider <= 20)
                        {
                            if (flickerRise == false)
                            {
                                //flickerRise = true;
                            }
                            else
                            {
                                flickerRise = false;
                            }
                        }
                    }

                    if (flicker2 >= 45)
                    {
                        flickerRise = false;
                    }
                    if (flicker2 <= 0)
                    {
                        flickerRise = true;
                    }

                    flickerDelayCounter = 0;
                }

                //flicker = 9 + (flicker2/2.75f);
                flicker = gv.mod.currentArea.minimumDarkness + gv.mod.currentArea.maxLightMultiplier*(flicker2*3f/4f);

                if(gv.mod.currentArea.noFlicker)
                {
                    flicker = gv.mod.currentArea.minimumDarkness + 8;
                }
                //flicker = flicker2;
                /*
                int decider3 = gv.sf.RandInt(30);
                if (decider3 == 1)
                {
                    shifterPause = true;
                }

                if (shifterPause == true)
                {
                     int decider4 = gv.sf.RandInt(15);
                     if (decider4 == 1)
                     {
                         shifterPause = false;
                     }
                }
                 */
                //shifterPause = true;

                if (shifterPause == false)
                {
                    shifterDelayCounter += elapsed / 1000f * 30f;
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (tile.lightRadius * gv.squareSize), tlY - (tile.lightRadius * gv.squareSize), brX * (1 + tile.lightRadius * 2), brY * (1 + tile.lightRadius * 2));
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                    //tile.flicker = 0;
                    //1.15
                    if (shifterDelayCounter > (1.75f * gv.mod.currentArea.shifterSlowDownFactor))
                    {
                        if (shifterRise)
                        {

                            //int decider = gv.sf.RandInt(1);
                            //if (decider == 1)
                            //{
                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifter++;
                            }
                            //tile.affectedByFlickerAlready = true;
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker++;
                            }
                            else if (decider == 2)
                            {
                                flicker++;
                                flicker++;
                            }
                            else
                            {
                                flicker++;
                                flicker++;
                                flicker++;
                            }
                            */
                        }
                        else
                        {
                            //tile.affectedByFlickerAlready = true;
                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifter--;
                            }
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker--;
                            }
                            else if (decider == 2)
                            {
                                flicker--;
                                flicker--;
                            }
                            else
                            {
                                flicker--;
                                flicker--;
                                flicker--;
                            }
                            */
                        }
                        if (shifter >= 2)
                        {
                            shifterRise = false;
                        }
                        if (shifter <= -2)
                        {
                            shifterRise = true;
                        }

                        shifterDelayCounter = 0;
                    }

                    shifterYDelayCounter += elapsed / 1000f * 30f;
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (tile.lightRadius * gv.squareSize), tlY - (tile.lightRadius * gv.squareSize), brX * (1 + tile.lightRadius * 2), brY * (1 + tile.lightRadius * 2));
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                    //tile.flicker = 0;
                    if (shifterYDelayCounter > (1.75f * gv.mod.currentArea.flickerSlowDownFactor))
                    {
                        if (shifterYRise)
                        {

                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifterY++;
                            }
                            //tile.affectedByFlickerAlready = true;
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker++;
                            }
                            else if (decider == 2)
                            {
                                flicker++;
                                flicker++;
                            }
                            else
                            {
                                flicker++;
                                flicker++;
                                flicker++;
                            }
                            */
                        }
                        else
                        {
                            //tile.affectedByFlickerAlready = true;
                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifterY--;
                            }
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker--;
                            }
                            else if (decider == 2)
                            {
                                flicker--;
                                flicker--;
                            }
                            else
                            {
                                flicker--;
                                flicker--;
                                flicker--;
                            }
                            */
                        }
                        if (shifterY >= 2)
                        {
                            shifterYRise = false;
                        }
                        if (shifterY <= -2)
                        {
                            shifterYRise = true;
                        }

                        shifterYDelayCounter = 0;
                    }
                }

                /*
                int shifter = 0;
                int shifterY = 0;
                
                int decider2 = gv.sf.RandInt(100);
                int decider3 = gv.sf.RandInt(2);
                if (decider2 <= 3)
                {
                    shifter = gv.sf.RandInt(1);
                    if (decider3 == 1)
                    {
                        //shifter++;
                        shifter = shifter * -1;
                    }
                    //else
                    //{
                        //shifter--;
                    //}

                    //if (shifter > 10)
                    //{
                        //shifter
                    //}
                }

                decider2 = gv.sf.RandInt(100);
                decider3 = gv.sf.RandInt(2);
                if (decider2 <= 3)
                {
                    shifterY = gv.sf.RandInt(1);
                    if (decider3 == 1)
                    {
                        shifterY = shifterY * -1;
                    }
                }
                */
                if (gv.mod.currentArea.noPositionShift)
                {
                    shifterY = 0;
                    shifter = 0;
                }

                if (gv.mod.fogOfWarOpacity != 1.0f)
                {
                    shifterY = 0;
                    shifter = 0;
                }

                //if (gv.mod.fogOfWarOpacity == 1.0f)
                //{
                    #region halo pass: go through tiles only for halos
                    for (int x = minX; x < maxX + 1; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            if ((gv.mod.PlayerLocationX == x) && (gv.mod.PlayerLocationY == y))
                            {
                                continue;
                            }
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile)
                            {
                                bool lightOn = false;
                                foreach (bool light in tile.isLit)
                                {
                                    if (light)
                                    {
                                        lightOn = true;
                                        break;
                                    }
                                }

                                try
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (gv.squareSize);
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (gv.squareSize);
                                    //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                    //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                    //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                    float scalerX = 1;
                                    float scalerY = 1;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    float scaler = gv.sf.RandInt(30);
                                    //int shifter = gv.sf.RandInt(5);
                                    //scaler = 1 + (scaler / 100f);
                                    scaler = 1f;
                                    //shifter = 0;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        //shifter = 0;
                                        //shifterY = 0;
                                    }
                                    IbRect src = new IbRect(0, 0, 100, 100);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                    float flickerReduction = 1;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        flickerReduction = 1.5f;
                                    }

                                    if ((tile.isFocalPoint) && (lightOn))
                                    {
                                        //color of light source
                                        //if (!gv.mod.currentArea.UseDayNightCycle)
                                        //{
                                        //if (lightOn)
                                        //{
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - (int)(0.125f * gv.squareSize), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - (int)(0.125f * gv.squareSize), (int)(brX * scaler) + (int)(0.25f * gv.squareSize), (int)(brY * scaler) + (int)(0.25f * gv.squareSize));

                                        bool drawLightHalo = false;
                                        if (gv.mod.currentArea.UseDayNightCycle)
                                        {
                                            int dawn = 5 * 60;
                                            int sunrise = 6 * 60;
                                            int day = 7 * 60;
                                            int sunset = 17 * 60;
                                            int dusk = 18 * 60;
                                            int night = 20 * 60;
                                            int time = gv.mod.WorldTime % 1440;
                                            if ((time >= night) || (time < dawn))
                                            {
                                                drawLightHalo = true;
                                            }
                                        }
                                        else
                                        {
                                            drawLightHalo = true;
                                        }

                                        if ((!gv.mod.currentArea.useLightSystem) || (!tile.hasHalo))
                                        {
                                            drawLightHalo = false;
                                        }

                                        if (drawLightHalo)
                                        {
                                        //int extension = 6 - (int)(flicker / 7f);
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5, (int)(brX * scaler) + 2 * extension - 10, (int)(brY * scaler) + 2 * extension - 10);
                                        //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                        //schönhauserstraße
                                        if ((x == gv.mod.PlayerLocationX) && (y == gv.mod.PlayerLocationY) && gv.mod.partyLightOn)
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                if (gv.mod.partyLightColor.Contains("yellow"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f),true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)),true);
                                                }
                                                else if (gv.mod.partyLightColor.Contains("blue"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f),true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)),true);
                                                }
                                                else if (gv.mod.partyLightColor.Contains("green"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f),true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)),true);
                                                }
                                                else if (gv.mod.partyLightColor.Contains("red"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f),true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)),true);
                                                }
                                                else if (gv.mod.partyLightColor.Contains("orange"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f),true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)),true);
                                                }
                                                else if (gv.mod.partyLightColor.Contains("purple"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f),true);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)),true);
                                                }
                                            }

                                        //entführt
                                        bool tileIsTooExtreme = false;
                                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                        {
                                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                            {
                                                tileIsTooExtreme = true;
                                                //gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                            }
                                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                            {
                                                tileIsTooExtreme = true;
                                                //gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                            }
                                        }

                                        //for (int z = 0; z < tile.tileLightSourceTag.Count; z++)
                                        for (int z = 0; z < tile.lightSourceFocalHaloIntensity.Count; z++)
                                            //foreach (string s in tile.tileLightSourceTag)
                                            {
                                                bool draw = false;
                                                //determine whether tile is onscreen
                                                //(x - gv.mod.PlayerLocationX + gv.playerOffsetX)
                                                if ((x <= gv.mod.PlayerLocationX + gv.playerOffsetX) && (x >= gv.mod.PlayerLocationX - gv.playerOffsetX))
                                                {
                                                    if ((y <= gv.mod.PlayerLocationY + gv.playerOffsetY) && (y >= gv.mod.PlayerLocationY - gv.playerOffsetY))
                                                    {
                                                        draw = true;
                                                    }

                                                    /*
                                                    if (gv.mod.noHaloAddToParty)
                                                    {
                                                    if ((x <= gv.mod.PlayerLocationX + 2) && (x >= gv.mod.PlayerLocationX - 2))
                                                    {
                                                        if ((y <= gv.mod.PlayerLocationY + 2) && (y >= gv.mod.PlayerLocationY - 2))
                                                        {
                                                            draw = false;
                                                        }
                                                    }
                                                    
                                                }
                                                */

                                                }


                                                if ((tile.isLit[z]) && (draw) && !tileIsTooExtreme)
                                                {
                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightYellow"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, tile.lightSourceRingHaloIntensity[z] * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, (0.10f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));

                                                        //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                        //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.10f + 2.25f * 0.3f * (0.425f - flicker / 200f));

                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightGreen"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightRed"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightBlue"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightPurple"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightOrange"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }
                                                }
                                            }

                                        }
                                    }//close focal light
                                }//close try
                                catch
                                { }
                            }//close draw tile condition
                        }//close inner tile loop
                    }//clsoe outer tile loop

                    #endregion
                //}  
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                #region go through tiles
                for (int x = minX; x < maxX+1; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {

                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            bool lightOn = false;
                            foreach (bool light in tile.isLit)
                            {
                                if (light)
                                {
                                    lightOn = true;
                                    break;
                                }
                            }

                            try
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (gv.squareSize);
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (gv.squareSize);
                                //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                float scalerX = 1;
                                float scalerY = 1;
                                int brX = (int)(gv.squareSize * scalerX);
                                int brY = (int)(gv.squareSize * scalerY);
                                float scaler = gv.sf.RandInt(30);
                                //int shifter = gv.sf.RandInt(5);
                                //scaler = 1 + (scaler / 100f);
                                scaler = 1f;
                                //shifter = 0;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    //shifter = 0;
                                    //shifterY = 0;
                                }
                                IbRect src = new IbRect(0, 0, 100, 100);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler-1)*brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                int indexOfRelevantLightSource = 0;
                                int sorter = -1;
                                string oldTilePosition = "none";
                                string comparePosition = "";
                                for (int p = 0; p < tile.priority.Count; p++)
                                {
                                    if (tile.priority[p] == sorter)
                                    {
                                        //treat as special cornerOverlay tile (like an N2 tile but going up to full dark, like brigher part of N4)
                                        if (sorter == 1)
                                        {
                                           
                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                            }
                                        }
                                        else if (sorter == 2)
                                        {
                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlayBright";
                                            }
                                            /*
                                            /*
                                                                                        if (tile.tilePositionInLitArea[p] == "S4")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        if (tile.tilePositionInLitArea[p] == "S0")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        if (tile.tilePositionInLitArea[p] == "N4")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        if (tile.tilePositionInLitArea[p] == "N0")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        */
                                        }
                                        //treat as N2 tile
                                        else if (sorter == 3)
                                        {

                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "N2";
                                            }
                                        }
                                        
                                        //treat as N tile
                                        else
                                        {

                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "N";
                                            }
                                        }
                                    }

                                    if (tile.priority[p] > sorter)
                                    {
                                        sorter = tile.priority[p];
                                        indexOfRelevantLightSource = p;
                                        comparePosition = tile.tilePositionInLitArea[indexOfRelevantLightSource];
                                        //tagOFLightSource = tile.tileLightSourceTag;
                                        //if (oldTilePosition != "none")
                                        //{
                                        //tile.tilePositionInLitArea[indexOfRelevantLightSource] = oldTilePosition;
                                        // }
                                    }
                                }

                                float flickerReduction = 1;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    flickerReduction = 1.5f;
                                }

                                //entführt
                                bool tileIsTooExtreme = false;
                                if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                {
                                    if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                    {
                                        tileIsTooExtreme = true;
                                        //gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                    }
                                    if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                    {
                                        tileIsTooExtreme = true;
                                        /*
                                        IbRect dstE = new IbRect();
                                        dstE.Width = (dst.Width+1)/2;
                                        dstE.Height = (dst.Height+1)/2;
                                        dstE.Top = dst.Top;
                                        dstE.Left = dst.Left;
                                        gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0);
                                        dstE.Left += dstE.Width;
                                        gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0);
                                        dstE.Left -= dstE.Width;
                                        dstE.Top += dstE.Height;
                                        gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0);
                                        dstE.Left += dstE.Width;
                                        gv.DrawBitmap(gv.cc.tooDeep, src, dstE, 0, false, 0, 0);
                                        */
                                    }
                                }


                                if ((tile.isFocalPoint)  && (lightOn))
                                {
                                    
                                    //color of light source
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //if (lightOn)
                                    //{
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - (int)(0.125f * gv.squareSize), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - (int)(0.125f * gv.squareSize), (int)(brX * scaler) + (int)(0.25f * gv.squareSize), (int)(brY * scaler) + (int)(0.25f * gv.squareSize));
                                    /*
                                    bool drawLightHalo = false;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= night) || (time < dawn))
                                        {
                                            drawLightHalo = true;
                                        }
                                    }
                                    else
                                    {
                                        drawLightHalo = true;
                                    }

                                    if (drawLightHalo)
                                    {
                                        //int extension = 6 - (int)(flicker / 7f);
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5, (int)(brX * scaler) + 2 * extension - 10, (int)(brY * scaler) + 2 * extension - 10);
                                        //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                        int extension = 6 - (int)(flicker / 7f);
                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 2*gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 2*gv.squareSize);
                                        gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                }
                                */

                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false,0.75f *0.75f * (0.225f - flicker / 400f));
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                    //}
                                    //}

                                    //flicker the area light (black darkness or time of day ususally)
                                    if (gv.mod.currentArea.UseDayNightCycle && tile.Visible)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            //gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f / flickerReduction * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            //zach
                                            //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.75f / flickerReduction * 1.0f * flicker / 100f);
                                            if ((gv.mod.currentArea.useLightSystem) && !tileIsTooExtreme)
                                            {
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.25f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                            }

                                        }
                                    }
                                    //dark area
                                    //connect to area is dark?
                                    else if (tile.Visible)
                                    {
                                        if ((gv.mod.currentArea.useLightSystem) && !tileIsTooExtreme)
                                        {
                                            //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0.075f * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.75f * flicker / 100f);
                                            //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                        }
                                        else if ((gv.mod.currentArea.useLightSystem) && tileIsTooExtreme)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * gv.mod.fogOfWarOpacity);
                                        }


                                        }

                                    if ((!tile.Visible) && (gv.mod.fogOfWarOpacity == 1.0f))
                                    {
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * scaler), (int)(brY * scaler));
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f);
                                    }
                                }

                                else if ((tile.isCentreOfLightCircle)  && (lightOn))
                                {
                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false, 0.75f * 0.75f * (0.225f - flicker / 400f));
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 0.9f * (0.125f - flicker/400f));
                                    //}
                                    float extraDarkness = 1;
                                   
                                        if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NE") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NW") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SE") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SW"))
                                        {
                                            extraDarkness = 1.25f;
                                        }
                                        //to DO XXX
                                    if (gv.mod.currentArea.UseDayNightCycle && tile.Visible)
                                    {
                                        /*
                                        //entführt
                                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                        {
                                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                            }
                                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                            }
                                        }
                                        */
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            //gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, extraDarkness * 0.85f * 2.75f / flickerReduction * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            //hurgh10000
                                            if (gv.mod.currentArea.useLightSystem && !tileIsTooExtreme)
                                            {
                                                if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NW"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.25f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NE"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.25f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SW"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.25f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SE"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.25f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);

                                                }
                                                else
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.25f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);

                                                }
                                            }
                                            else
                                            {
                                                /*
                                                //entführt
                                                if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                                {
                                                    if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                                    {
                                                        gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                                    }
                                                    if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                                    {
                                                        gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                                    }
                                                }
                                                */
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                            }

                                            }//night closing closing

                                    }//use time of day closing 

                                    //dark area
                                    //connect to area is dark?
                                    else if (tile.Visible)
                                    {
                                        /*
                                        //entführt david
                                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                        {
                                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                            }
                                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                            }
                                        }
                                        */

                                        if (gv.mod.currentArea.useLightSystem && !tileIsTooExtreme)
                                        {

                                            if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NW"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler));
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NE"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler));
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SW"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SE"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);


                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);
                                            }
                                        }
                                        else if (gv.mod.currentArea.useLightSystem && tileIsTooExtreme)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * gv.mod.fogOfWarOpacity);
                                        }

                                        //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);
                                        
                                    }
                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0.55f * flicker / 100f);
                                    if (!tile.Visible)
                                    {
                                        /*
                                        //entführt
                                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                        {
                                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                            }
                                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                            }
                                        }
                                        */
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * scaler), (int)(brY * scaler));
                                        if (gv.mod.fogOfWarOpacity == 1.0f)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f);
                                        }
                                    }
                                }

                                else if ((tile.isOtherPartOfLightCircle) && (lightOn))
                                {

                                    /*
                                    //entführt
                                    if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                    {
                                        if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                        {
                                            gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                        }
                                        if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                        {
                                            gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                        }
                                    }
                                    */
                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false, 0.75f * 0.75f * (0.225f - flicker / 400f));
                                    //do nothing,the overlapping and scaled light circle graphic does t already
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false, 0.9f * (0.125f - flicker/400f));
                                    //}
                                    float extraDarkness = 1;
                                    foreach (string position in tile.tilePositionInLitArea)
                                    {
                                        if  ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N3") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E1") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N0") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N4") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S0") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S4") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W1"))
                                        {
                                            extraDarkness = 1.5f;
                                        }
                                        if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlay") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S1") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S3") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E3") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W3"))
                                        {
                                            extraDarkness = 1.5f;
                                        }
                                    }
                                    if (gv.mod.currentArea.UseDayNightCycle && tile.Visible)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            //gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, extraDarkness * gv.mod.nightTimeDarkness * 3.75f / flickerReduction * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            if (gv.mod.currentArea.useLightSystem && !tileIsTooExtreme)
                                            {
                                                if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                                {

                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler));
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 1.0f * gv.mod.nightTimeDarkness * flicker / 100f * 1.2f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);


                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W1"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);

                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E1"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S1"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);

                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);

                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N0"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N4"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S0"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S4"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlay"))
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.75f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlayBright"))
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.75f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                                }

                                                //normal tile
                                                else
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.5f * 0.5f * 1.5f * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * gv.mod.nightTimeDarkness * flicker / 100f * 1.2f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, extraDarkness * gv.mod.nightTimeDarkness * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                            }
                                            else
                                            {
                                                //hurgh54
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                            }
                                        }//night time closing

                                    }//use time of day closing


                                    //dark area
                                    //connect to area is dark?
                                    else if (tile.Visible)
                                    {
                                        /*
                                        if (position == "NE")
                                        {
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                            gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);

                                            gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);

                                            gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);

                                        }
                                        */
                                        if (gv.mod.currentArea.useLightSystem && !tileIsTooExtreme)
                                        {
                                            float darknessWeighter = 0.15f + 1.05f * 0.675f * 2.5f * flicker / 100f;
                                            if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, darknessWeighter);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, darknessWeighter);
                                            }
                                            /*
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                            }
                                            */


                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N0"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 4);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N4"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 4, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 4, (int)(brY * scaler) + 4);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S0"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S4"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 3, (int)(brX * scaler) + 3, (int)(brY * scaler) + 3);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlay"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, darknessWeighter);
                                                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlayBright"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, darknessWeighter * 2f / 3f);
                                                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                            }
                                        }
                                        else if (gv.mod.currentArea.useLightSystem && tileIsTooExtreme)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * gv.mod.fogOfWarOpacity);
                                        }
                                    }
                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 1.20f * flicker/100f);
                                    if (!tile.Visible)
                                    {
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        if (gv.mod.fogOfWarOpacity == 1.0f)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f);
                                        }
                                    }
                                }
                                else if ((tile.Visible)) 
                                {
                                    int flickerExtensionX = 0;
                                    int flickerExtensionY = 0;
                                    int flickerEarlyStartX = 0;
                                    int flickerEarlyStartY = 0;

                                    if (!gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        //flickerExtensionX = 4;
                                        //flickerExtensionY = 4;
                                        //flickerEarlyStartX = -2;
                                        //flickerEarlyStartY = -2;
                                    }
                                    /*
                                    if (x == (maxX - 1))
                                    {
                                        flickerExtensionX = 10;
                                    }
                                    if (y == (maxY - 1))
                                    {
                                        flickerExtensionY = 10;
                                    }
                                    if (x == (minX))
                                    {
                                        flickerExtensionX = 20;
                                        flickerEarlyStartX = -20;
                                    }
                                    if (y == (minY))
                                    {
                                        flickerExtensionY = 20;
                                        flickerEarlyStartY = -20;
                                    }
                                    */
                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + flickerEarlyStartX, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + flickerEarlyStartY, (int)(brX * scaler)+ flickerExtensionX, (int)(brY * scaler) + flickerExtensionY);

                                    //draw black tile
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * scaler), (int)(brY * scaler));
                                    if (!gv.mod.currentArea.UseDayNightCycle)
                                    {

                                        //entführt
                                        /*
                                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                        {
                                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                            }
                                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                            }
                                        }
                                        */

                                        if (gv.mod.currentArea.useLightSystem)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * gv.mod.fogOfWarOpacity);
                                        }
                                    }
                                    else if (tile.Visible)
                                    {
                                        /*
                                        //entführt
                                        if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                        {
                                            if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                            }
                                            if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                            {
                                                gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                            }
                                        }
                                        */

                                        //do daytime tinting here
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0.55f);
                                            gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                        }
                                    }
                                    
                                }
                                /*
                                //entführt
                                if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                {
                                    if (tile.heightLevel > gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel + 2)
                                    {
                                        gv.DrawBitmap(gv.cc.tooHigh, src, dst, 0, false, 0, 0);
                                    }
                                    if (tile.heightLevel < gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel - 2)
                                    {
                                        gv.DrawBitmap(gv.cc.tooDeep, src, dst, 0, false, 0, 0);
                                    }
                                }
                                */
                            }
                            catch { }

                        }
                    }
                }
                #endregion

            }
            #endregion
            #region old system
            else //old system using single image background and no load tile images on demand
            {
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 1;
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 1;
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 2;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 3;
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Visible)
                        {
                            gv.DrawBitmap(gv.cc.black_tile, src, dst);
                        }
                    }
                }
            }
            #endregion
        }
        public void drawBlackTilesOverTints()
        {
            #region new system
            if (gv.mod.useAllTileSystem)
            {
                int width = gv.playerOffsetX * 2 + 1;
                int height = gv.playerOffsetY * 2 + 1;

                //if (gv.mod.currentArea.westernNeighbourArea == "")
                //{
                    //at left edge
                    for (int i = -1; i < gv.playerOffsetX - gv.mod.PlayerLocationX + 1; i++)
                    {
                         drawColumnOfBlack(i);
                    }
                //}

                //if (gv.mod.currentArea.northernNeighbourArea == "")
                //{
                    //at top edge
                    for (int i = -1; i < gv.playerOffsetY - gv.mod.PlayerLocationY; i++)
                    {
                        drawRowOfBlack(i);
                    }
                //}
                //if (gv.mod.currentArea.easternNeighbourArea == "")
                //{
                    //at right edge
                    for (int i = 0; i <= gv.playerOffsetX + gv.mod.PlayerLocationX - gv.mod.currentArea.MapSizeX; i++)
                    {
                        drawColumnOfBlack(width - i);
                    }
                //}
                //if (gv.mod.currentArea.southernNeighbourArea == "")
                //{
                    //at bottom edge
                    for (int i = -1; i <= gv.playerOffsetY + gv.mod.PlayerLocationY - gv.mod.currentArea.MapSizeY + 1; i++)
                    {
                        drawRowOfBlack(height - i);
                    }
                //}
            }
            #endregion
            #region old system
            else //old system using single image background and no load tile images on demand
            {
                int width = gv.playerOffsetX * 2 + 1;
                int height = gv.playerOffsetY * 2 + 1;

                //at left edge
                for (int i = -2; i < gv.playerOffsetX - gv.mod.PlayerLocationX; i++)
                {
                    drawColumnOfBlack(i);                    
                }

                //at top edge
                for (int i = -2; i < gv.playerOffsetY - gv.mod.PlayerLocationY; i++)
                {
                    drawRowOfBlack(i);
                }

                //at right edge
                for (int i = -1; i <= gv.playerOffsetX + gv.mod.PlayerLocationX - gv.mod.currentArea.MapSizeX + 1; i++)
                {
                    drawColumnOfBlack(width - i);                    
                }

                //at bottom edge
                for (int i = -1; i <= gv.playerOffsetY + gv.mod.PlayerLocationY - gv.mod.currentArea.MapSizeY + 1; i++)
                {
                    drawRowOfBlack(height - i);
                }
            }
            #endregion
        }
        public void drawFloatyTextPool()
        {
            if (floatyTextPool.Count > 0)
            {
                int txtH = (int)gv.drawFontRegHeight;
                //int pH = (int)((float)gv.screenHeight / 200.0f);

                foreach (FloatyText ft in floatyTextPool)
                {
                    if (gv.cc.getDistance(ft.location, new Coordinate(gv.mod.PlayerLastLocationX, gv.mod.PlayerLocationY)) > 3)
                    {
                        continue; //out of range from view so skip drawing floaty message
                    }

                    //location.X should be the the props actual map location in squares (not screen location)
                    int xLoc = (ft.location.X + gv.playerOffsetX - gv.mod.PlayerLocationX) * gv.squareSize;
                    int yLoc = ((ft.location.Y + gv.playerOffsetY - gv.mod.PlayerLocationY) * gv.squareSize) - (ft.z);

                    for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            gv.DrawText(ft.value, new IbRect(xLoc + x + gv.oXshift + mapStartLocXinPixels - (int)(1.5f *gv.squareSize), yLoc + y + txtH, gv.squareSize * 4, 1000), 0.8f, Color.Black);
                        }
                    }
                    Color colr = Color.Yellow;
                    if (ft.color.Equals("yellow"))
                    {
                        colr = Color.Yellow;
                    }
                    else if (ft.color.Equals("blue"))
                    {
                        colr = Color.Blue;
                    }
                    else if (ft.color.Equals("green"))
                    {
                        colr = Color.Lime;
                    }
                    else if (ft.color.Equals("red"))
                    {
                        colr = Color.Red;
                    }
                    else
                    {
                        colr = Color.White;
                    }
                    gv.DrawText(ft.value, new IbRect(xLoc + gv.oXshift + mapStartLocXinPixels - (int)(1.5f * gv.squareSize), yLoc + txtH, gv.squareSize * 4, 1000), 0.8f, colr);
                }
            }
        }

        public void drawFloatyTextByPixelPool()
        {
            if (floatyTextByPixelPool.Count > 0)
            {
                int txtH = (int)gv.drawFontRegHeight;
                
                foreach (FloatyTextByPixel ft in floatyTextByPixelPool)
                {
                    int playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                    int playerPositionYInPix = gv.playerOffsetY * gv.squareSize + gv.oYshift;

                    float floatConvertedToSquareDistanceX = (ft.floatyCarrier2.currentPixelPositionX - playerPositionXInPix) / gv.squareSize;
                    int ConvertedToSquareDistanceX = (int)Math.Ceiling(floatConvertedToSquareDistanceX);

                    float floatConvertedToSquareDistanceY = (ft.floatyCarrier2.currentPixelPositionY - playerPositionYInPix) / gv.squareSize;
                    int ConvertedToSquareDistanceY = (int)Math.Ceiling(floatConvertedToSquareDistanceY);

                    int SquareThatPixIsOnX = gv.mod.PlayerLocationX + ConvertedToSquareDistanceX;
                    int SquareThatPixIsOnY = gv.mod.PlayerLocationY + ConvertedToSquareDistanceY;


                    if (gv.cc.getDistance(new Coordinate (SquareThatPixIsOnX, SquareThatPixIsOnY), new Coordinate(gv.mod.PlayerLastLocationX, gv.mod.PlayerLocationY)) > 3)
                    {
                        continue; //out of range from view so skip drawing floaty message
                    }

                   

                    //location.X should be the the props actual map location in squares (not screen location)
                    int xLoc = (int)(ft.floatyCarrier2.currentPixelPositionX);
                    int yLoc = (int)(ft.floatyCarrier2.currentPixelPositionY) - (ft.z);

                    for (int x = -1; x <= 1; x++)
                    {
                        for (int y = -1; y <= 1; y++)
                        {
                            gv.DrawText(ft.value, new IbRect(xLoc + x, yLoc + y + txtH, gv.squareSize * 2, 1000), 0.8f, Color.Black);
                        }
                    }
                    Color colr = Color.Yellow;
                    if (ft.color.Equals("yellow"))
                    {
                        colr = Color.Yellow;
                    }
                    else if (ft.color.Equals("blue"))
                    {
                        colr = Color.Blue;
                    }
                    else if (ft.color.Equals("green"))
                    {
                        colr = Color.Lime;
                    }
                    else if (ft.color.Equals("red"))
                    {
                        colr = Color.Red;
                    }
                    else
                    {
                        colr = Color.White;
                    }
                    gv.DrawText(ft.value, new IbRect(xLoc, yLoc + txtH, gv.squareSize * 2, 1000), 0.8f, colr);
                }
            }
        }

        public void updateTraitsPanel()
        {
            for (int i = 0; i <= gv.mod.playerList.Count - 1; i++)
            {
                if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp <= 0)
                {
                    gv.mod.selectedPartyLeader++;
                    if (gv.mod.selectedPartyLeader > gv.mod.playerList.Count - 1)
                    {
                        gv.mod.selectedPartyLeader = 0;
                    }
                }
                if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp > 0)
                {
                    break;
                }
            }

            foreach (IB2Panel pnl in mainUiLayout.panelList)
            {
                if (pnl.tag == "TraitsPanel")
                {
                    int relevantTraitsCounter = 0;
                    string method = "";
                    List<string> traitTypesShownAlready = new List<string>();
                    foreach (Trait t in gv.mod.moduleTraitsList)
                    {
                        if (t.showOnMainMap)
                        {
                            foreach (string type in traitTypesShownAlready)
                            {
                                if (type.Contains(t.tag))
                                {
                                    continue;
                                }
                            }
                            traitTypesShownAlready.Add(t.tag);

                            int power = gv.cc.getTraitPower(t.tag, t.methodOfChecking);
                            bool isHighest = false;
                            int power2 = gv.cc.getTraitPower(t.tag, "highest");
                            if (power >= power2)
                            {
                                isHighest = true;
                            }
                            if ((t.methodOfChecking == "leader") ||(t.methodOfChecking == "Leader") || (t.methodOfChecking == "-1"))
                            {
                                method = " Ld";
                            }
                            else if ((t.methodOfChecking == "lowest") || (t.methodOfChecking == "Lowest") || (t.methodOfChecking == "-3"))
                            {
                                method = " Lo";
                            }
                            else if ((t.methodOfChecking == "highest") || (t.methodOfChecking == "Highest") || (t.methodOfChecking == "-2"))
                            {
                                method = " Hi";
                            }
                            else if ((t.methodOfChecking == "average") || (t.methodOfChecking == "Average") || (t.methodOfChecking == "-4"))
                            {
                                method = " Av";
                            }
                            else if ((t.methodOfChecking == "allMustSucceed") || (t.methodOfChecking == "AllMustSucceed") || (t.methodOfChecking == "-5"))
                            {
                                method = " All";
                            }
                            else if ((t.methodOfChecking == "oneMustSucceed") || (t.methodOfChecking == "OneMustSucceed") || (t.methodOfChecking == "-6"))
                            {
                                method = " One";
                            }


                            if (!gv.mod.hideZeroPowerTraits)
                            {
                                //if (power > 0)
                                //{
                                    pnl.buttonList[relevantTraitsCounter].tag = t.tag;
                                    pnl.buttonList[relevantTraitsCounter].show = true;
                                    pnl.buttonList[relevantTraitsCounter].btnState = buttonState.Normal;
                                    pnl.buttonList[relevantTraitsCounter].scaler = 0.4f;
                                    if (t.tag.Contains(gv.mod.tagOfMovementSpeedTrait))
                                    {
                                        int speedSum = power + gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].speedModifier;
                                        if (isHighest)
                                        {
                                            pnl.buttonList[relevantTraitsCounter].Text = speedSum.ToString() + method + "green";
                                        }
                                        else
                                        {
                                            pnl.buttonList[relevantTraitsCounter].Text = speedSum.ToString() + method;
                                        }
                                    }
                                    else
                                    {
                                    if (isHighest)
                                    {
                                        pnl.buttonList[relevantTraitsCounter].Text = power.ToString() + method + "green";
                                    }
                                    else
                                    {
                                        pnl.buttonList[relevantTraitsCounter].Text = power.ToString() + method;
                                    }
                                    }
                                    pnl.buttonList[relevantTraitsCounter].Img2Filename = t.traitImage;
                                    pnl.buttonList[relevantTraitsCounter].Img2OffFilename = t.traitImage + "_off";
                                //}
                                /*
                                else
                                {
                                    pnl.buttonList[relevantTraitsCounter].tag = t.tag;
                                    pnl.buttonList[relevantTraitsCounter].show = true;
                                    pnl.buttonList[relevantTraitsCounter].btnState = buttonState.Off;
                                    pnl.buttonList[relevantTraitsCounter].scaler = 0.4f;
                                    if (t.tag.Contains(gv.mod.tagOfMovementSpeedTrait))
                                    {
                                        int speedSum = power + gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].speedModifier;
                                        pnl.buttonList[relevantTraitsCounter].Text = speedSum.ToString() + method;
                                    }
                                    else
                                    {
                                        pnl.buttonList[relevantTraitsCounter].Text = power.ToString() + method;
                                    }
                                    pnl.buttonList[relevantTraitsCounter].Img2Filename = t.traitImage;
                                    pnl.buttonList[relevantTraitsCounter].Img2OffFilename = t.traitImage + "_off";
                                }
                                */
                            }
                            //hide zero power traits
                            else
                            {
                                if (power > 0)
                                {
                                    pnl.buttonList[relevantTraitsCounter].tag = t.tag;
                                    pnl.buttonList[relevantTraitsCounter].show = true;
                                    pnl.buttonList[relevantTraitsCounter].btnState = buttonState.Normal;
                                    pnl.buttonList[relevantTraitsCounter].scaler = 0.4f;
                                    pnl.buttonList[relevantTraitsCounter].Text = power.ToString() + method;
                                    pnl.buttonList[relevantTraitsCounter].Img2Filename = t.traitImage;
                                    pnl.buttonList[relevantTraitsCounter].Img2OffFilename = t.traitImage + "_off";
                                }
                                else
                                {
                                    pnl.buttonList[relevantTraitsCounter].tag = t.tag;
                                    pnl.buttonList[relevantTraitsCounter].show = false;
                                    pnl.buttonList[relevantTraitsCounter].btnState = buttonState.Off;
                                    pnl.buttonList[relevantTraitsCounter].scaler = 0.4f;
                                    pnl.buttonList[relevantTraitsCounter].Text = power.ToString() + method;
                                    pnl.buttonList[relevantTraitsCounter].Img2Filename = t.traitImage;
                                    pnl.buttonList[relevantTraitsCounter].Img2OffFilename = t.traitImage + "_off";
                                }
                            }
                            relevantTraitsCounter++;
                        }
                    }
                }
            }
        }

        public void drawColumnOfBlack(int col)
        {
            if (gv.mod.useAllTileSystem)
            {
                int delayedStart = 0;
                int earlyEnd = 0;
                bool isLeftCall = false;
                bool isRightCall = false;

                //left side
                if (gv.mod.PlayerLocationX < gv.playerOffsetX + 1)
                {
                    isLeftCall = true;
                    if ((gv.mod.indexOfNorthWesternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinY + 2;
                    }

                    if ((gv.mod.indexOfSouthWesternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxY + 1;
                    }
                }

                //right side
                if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                {
                    isRightCall = true;
                    if ((gv.mod.indexOfNorthEasternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinY + 2;
                    }

                    if ((gv.mod.indexOfSouthEasternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxY + 1;
                    }

                }


                for (int y = -1 + delayedStart; y < gv.playerOffsetY * 2 + 1 + 2 - earlyEnd; y++)
                {
                    int tlX = col * gv.squareSize;
                    int tlY = y * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 1.0f), tlY - (int)(brY * 1.1f), (int)(brX * 1.3f), (int)(brY * 1.25f));
                    /*
                    if (col >= (gv.playerOffsetX * 2 + 2))
                    {
                        dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 1.0f), tlY - (int)(brY * 1.1f), (int)(brX * 1.4f), (int)(brY * 1.1));
                    }
                    else
                    {
                        dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 1.0f), tlY - (int)(brY * 1.1f), (int)(brX * 1.2f), (int)(brY * 1.1));
                    }
                    */

                    bool skipDraw = false;

                    float pixDistanceToBorderOfThisAreaNorth = gv.mod.PlayerLocationY;
                    if (pixDistanceToBorderOfThisAreaNorth > gv.playerOffsetY)
                    {
                        pixDistanceToBorderOfThisAreaNorth = gv.playerOffsetY;
                    }
                    pixDistanceToBorderOfThisAreaNorth = (pixDistanceToBorderOfThisAreaNorth + 1.5f) * gv.squareSize;

                    float pixDistanceToBorderOfThisAreaSouth = (gv.mod.currentArea.MapSizeY - 1) - gv.mod.PlayerLocationY;
                    if (pixDistanceToBorderOfThisAreaSouth > gv.playerOffsetY)
                    {
                        pixDistanceToBorderOfThisAreaSouth = gv.playerOffsetY;
                    }
                    pixDistanceToBorderOfThisAreaSouth = (pixDistanceToBorderOfThisAreaSouth + 1.5f) * gv.squareSize;

                    if ((isLeftCall) && (gv.mod.indexOfWesternNeighbour != -1))
                    {
                        if (((y - 2) * gv.squareSize >= ((gv.playerOffsetY * gv.squareSize) - pixDistanceToBorderOfThisAreaNorth)) && (y * gv.squareSize <= gv.screenHeight / 2 + pixDistanceToBorderOfThisAreaSouth))
                        {
                            if (col <= gv.playerOffsetX)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if ((isRightCall) && (gv.mod.indexOfEasternNeighbour != -1))
                    {
                        if (((y - 2) * gv.squareSize >= ((gv.playerOffsetY * gv.squareSize) - pixDistanceToBorderOfThisAreaNorth)) && (y * gv.squareSize <= gv.screenHeight / 2 + pixDistanceToBorderOfThisAreaSouth))
                        {
                            if (col > gv.playerOffsetX)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if (!skipDraw)
                    {
                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                        //gv.DrawBitmap(gv.cc.hitSymbol, src, dst);
                    }
                }
            }
            else
            {
                for (int y = -1; y < gv.playerOffsetY * 2 + 1 + 2; y++)
                {
                    int tlX = col * gv.squareSize;
                    int tlY = y * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + mapStartLocXinPixels + gv.oXshift, tlY, brX, brY);

                    gv.DrawBitmap(gv.cc.black_tile, src, dst);
                }
            }
            
        }
        public void drawRowOfBlack(int row)
        {
            if (gv.mod.useAllTileSystem)
            {
                int delayedStart = 0;
                int earlyEnd = 0;
                bool isTopCall = false;
                bool isDownCall = false;

                //top side
                if (gv.mod.PlayerLocationY < gv.playerOffsetY + 1)
                {
                    isTopCall = true;
                    if ((gv.mod.indexOfNorthWesternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinX + 1;
                    }

                    if ((gv.mod.indexOfNorthEasternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxX + 2;
                    }

                }

                //down side
                else if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                {
                    isDownCall = true;
                    if ((gv.mod.indexOfSouthWesternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinX + 1;
                    }

                    if ((gv.mod.indexOfSouthEasternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxX + 2;
                    }

                }

                for (int x = -1 + delayedStart; x < gv.playerOffsetX * 2 + 1 + 2 - earlyEnd; x++)
                {
                    int tlX = x * gv.squareSize;
                    int tlY = row * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.2f), (int)(brY * 1.25f));
                    bool skipDraw = false;

                    float pixDistanceToBorderOfThisAreaWest = gv.mod.PlayerLocationX;
                    if (pixDistanceToBorderOfThisAreaWest > gv.playerOffsetX)
                    {
                        pixDistanceToBorderOfThisAreaWest = gv.playerOffsetX;
                    }
                    pixDistanceToBorderOfThisAreaWest = (pixDistanceToBorderOfThisAreaWest + 1.5f) * gv.squareSize;

                    float pixDistanceToBorderOfThisAreaEast = (gv.mod.currentArea.MapSizeX - 1) - gv.mod.PlayerLocationX;
                    if (pixDistanceToBorderOfThisAreaEast > gv.playerOffsetX)
                    {
                        pixDistanceToBorderOfThisAreaEast = gv.playerOffsetX;
                    }
                    pixDistanceToBorderOfThisAreaEast = (pixDistanceToBorderOfThisAreaEast + 1.5f) * gv.squareSize;


                    if ((isTopCall) && (gv.mod.indexOfNorthernNeighbour != -1))
                    {
                        if ((x * gv.squareSize >= (((gv.playerOffsetX+1) * gv.squareSize) - pixDistanceToBorderOfThisAreaWest)) && ((x+2) * gv.squareSize <= gv.screenWidth / 2 + pixDistanceToBorderOfThisAreaEast))
                        {
                            if (row <= gv.playerOffsetY)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if ((isDownCall) && (gv.mod.indexOfSouthernNeighbour != -1))
                    {
                        if ((x * gv.squareSize >= (((gv.playerOffsetX+1) * gv.squareSize) - pixDistanceToBorderOfThisAreaWest)) && ((x+2) * gv.squareSize <= gv.screenWidth / 2 + pixDistanceToBorderOfThisAreaEast))
                        {
                            if (row > gv.playerOffsetY)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if (!skipDraw)
                    {
                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                        //gv.DrawBitmap(gv.cc.hitSymbol, src, dst);
                    }
                }
            }
            else
            {
                for (int x = -1; x < gv.playerOffsetX * 2 + 1 + 2; x++)
                {
                    int tlX = x * gv.squareSize;
                    int tlY = row * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                    gv.DrawBitmap(gv.cc.black_tile, src, dst);
                }
            }
        }
         
               
        public void drawUiLayout()
        {
            //SET PORTRAITS
            foreach (IB2Panel pnl in mainUiLayout.panelList)
            {
                if (pnl.tag.Equals("portraitPanel"))
                {
                    foreach (IB2Portrait ptr in pnl.portraitList)
                    {
                        ptr.show = false;
                    }
                    int index = 0;
                    if (index < gv.mod.playerList.Count)
                    {
                        foreach (Player pc in gv.mod.playerList)
                        {
                            pnl.portraitList[index].show = true;
                            pnl.portraitList[index].ImgFilename = pc.portraitFilename;
                            pnl.portraitList[index].TextHP = pc.hp + "/" + pc.hpMax;
                            pnl.portraitList[index].TextSP = pc.sp + "/" + pc.spMax;
                            pnl.portraitList[index].levelUpSymbol = "+";
                            pnl.portraitList[index].chatSymbol = "Chat";

                            //DRAW LEVEL UP INDICATOR
                            if (pc.IsReadyToAdvanceLevel())
                            {
                                pnl.portraitList[index].levelUpSymbol = "+";
                            }
                            else
                            {
                                pnl.portraitList[index].levelUpSymbol = "";
                            }

                            //DRAW CHAT INDICATOR
                            if (pc.hasNewChatOption.Count > 0)
                            {
                                pnl.portraitList[index].chatSymbol = "Chat";
                            }
                            else
                            {
                                pnl.portraitList[index].chatSymbol = "";
                            }

                            if (gv.mod.selectedPartyLeader == index)
                            {
                                pnl.portraitList[index].glowOn = true;
                            }
                            else
                            {
                                pnl.portraitList[index].glowOn = false;
                            }
                            index++;
                        }
                    }
                    break;
                }
            }

            mainUiLayout.Draw();
        }

        public void addFloatyText(int sqrX, int sqrY, String value, String color, int length)
        {
            floatyTextPool.Add(new FloatyText(sqrX, sqrY, value, color, length));
        }

        public void addFloatyText(Prop floatyCarrier, String value, String color, int length)
        {
            floatyTextByPixelPool.Add(new FloatyTextByPixel (floatyCarrier, value, color, length));
        }

        public void buildWeatherEffectObject (string name, string tag)
        {
            //not needed anymore, was for converting weather script 
            WeatherEffect we = new WeatherEffect();
            we.name = name;
            we.tag = tag;
            for (int j = 0; j < 6; j++)
            {
                if (j == 0)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer5;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName5;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer5IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur5;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence5;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders5;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel5;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging5;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit5;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames5;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade5;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride5;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX5;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY5;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit5;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource5;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript5;
                }

                if (j == 1)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer6;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName6;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer6IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur6;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence6;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders6;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel6;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging6;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit6;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames6;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade6;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride6;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX6;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY6;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit6;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource6;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript6;
                }

                if (j == 2)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer7;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName7;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer7IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur7;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence7;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders7;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel7;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging7;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit7;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames7;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade7;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride7;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX7;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY7;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit7;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource7;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript7;
                }

                if (j == 3)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer8;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName8;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer8IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur8;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence8;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders8;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel8;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging8;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit8;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames8;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade8;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride8;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX8;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY8;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit8;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource8;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript8;
                }

                if (j == 4)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer9;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName9;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer9IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur9;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence9;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders9;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel9;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging9;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit9;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames9;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade9;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride9;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX9;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY9;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit9;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource9;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript9;
                }

                if (j == 5)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer10;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName10;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer10IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur10;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence10;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders10;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel10;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging10;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit10;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames10;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade10;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride10;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX10;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY10;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit10;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource10;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript10;
                }

            }
            gv.mod.moduleWeatherEffectsList.Add(we);
        }

        //to test new layout system, change this to onTouchMain
        public void onTouchMain(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                    int x2 = (int)e.X;
                    int y2 = (int)e.Y;
                    if (y2 < (gv.screenHeight - 2 * gv.squareSize) && x2 < (gv.screenWidth - 2 * gv.squareSize))
                    {
                        gv.moveTimerRuns = true;
                    }
                    //isMoving = true;
                    break;

                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;

                    //NEW SYSTEM
                    mainUiLayout.setHover(x, y);

                    //Draw Floaty Text On Mouse Over Prop
                    int gridx = (int)(e.X - 2*gv.oXshift - 1) / gv.squareSize;
                    int gridy = (int)(e.Y - gv.oYshift - 1) / gv.squareSize;
                    int actualX = gv.mod.PlayerLocationX + (gridx - gv.playerOffsetX);
                    int actualY = gv.mod.PlayerLocationY + (gridy - gv.playerOffsetY);
                    gv.cc.floatyText = "";
                    gv.cc.floatyText2 = "";
                    gv.cc.floatyText3 = "";
                    gv.cc.floatyText4 = "";
                    gv.cc.floatyText0 = "";
                    gv.cc.floatyTextA = "";
                    gv.cc.floatyTextB = "";


                    //karmasutra: other areas

                    //current area
                    foreach (Prop p in gv.mod.currentArea.Props)
                        {
                        if (!p.isStealthed)
                        {
                            bool tooMuchHeightDifference = false;
                            if (gv.mod.blendOutTooHighAndTooDeepTiles)
                            {
                                if ((gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel > gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel + 2) || (gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel < gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel - 2))
                                {
                                    tooMuchHeightDifference = true;
                                }
                            }
                            //if ((p.LocationX == actualX) && (p.LocationY == actualY))
                            //if ((p.currentPixelPositionX - gv.oXshift >= e.X && p.currentPixelPositionX - gv.oXshift <= (e.X + gv.squareSize)) && (p.currentPixelPositionY >= e.Y && p.currentPixelPositionY <= (e.Y + gv.squareSize)))
                            if ((e.X - 1 >= p.currentPixelPositionX && e.X <= p.currentPixelPositionX + gv.squareSize) && (e.Y - 1 >= p.currentPixelPositionY + (gv.squareSize / 2) && e.Y <= p.currentPixelPositionY + gv.squareSize + (gv.squareSize / 2)) && !tooMuchHeightDifference)
                            {
                                bool lightIsNoProblem = false;
                                if ((!gv.mod.currentArea.useLightSystem) || (gv.mod.currentArea.UseDayNightCycle))
                                {
                                     lightIsNoProblem = true;
                                }
                                else
                                {
                                    bool foundTrue = false;

                                   
                                    foreach (bool state in gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].isLit)
                                    {
                                        if (state)
                                        {
                                            foundTrue = true;
                                            break;
                                        }
                                    }
                                    if (foundTrue)
                                    {
                                        lightIsNoProblem = true;
                                    }
                                }

                                if ((!p.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].Visible) && lightIsNoProblem)
                                {
                                    gv.cc.floatyText = p.MouseOverText;
                                    float floatyPushUp = 0;

                                    if (gv.cc.floatyText.Length <= 20)
                                    {
                                        floatyPushUp = 0.0f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 35)
                                    {
                                        floatyPushUp = 0.0f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 52)
                                    {
                                        floatyPushUp = 0.12f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 70)
                                    {
                                        floatyPushUp = 0.3f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 87)
                                    {
                                        floatyPushUp = 0.7f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 105)
                                    {
                                        floatyPushUp = 1.0f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 122)
                                    {
                                        floatyPushUp = 1.35f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 140)
                                    {
                                        floatyPushUp = 1.5f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 157)
                                    {
                                        floatyPushUp = 1.62f;
                                    }
                                    else if (gv.cc.floatyText.Length <= 175)
                                    {
                                        floatyPushUp = 1.75f;
                                    }
                                    else
                                    {
                                        floatyPushUp = 2.0f;
                                    }
                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, gridy * gv.squareSize - (int)(floatyPushUp * gv.squareSize));
                                }
                                //futturman
                                //Current:
                                //A:-
                                //B:- 
                                //0: encounter name
                                //2: speed /stationary
                                //3/none: stealth
                                //4: chaser and spot

                                //New:
                                //A Name / Encounter name: "Kobold Warband!
                                //B Challenge Rating: "Very Hard Enc Lvl 13" (white - Easy, blue - Normal, yellow - Hard, orange - Very Hard, red - Deadly) OR "Mandatory Convo" (always yellow) OR "Avoidable Convo" (always green)
                                //0 Mover type: "Patrol" (Stationary, Patrol, Random, Daily, Weekly, Monthly, Yearly)  
                                //2 Hide & Seek: "Hide 14, Seek 13" (No Stealther, No Chaser)
                                //3 Speed, with chances: "Speed 7, 0:15%, 2:15% (Speed value, inclduing move chances) 


                                //Stationary, No Chaser
                                //Stealth 27, Spot 56
                                //Allows sneak through
                                //Speed 7, 0:15%, 2:15%

                                //A Name / Encounter name: "Kobold Warband" (white)
                                //B Challenge Rating: "Very Hard Enc Lvl 13" (white - Easy, blue - Normal, yellow - Hard, orange - Very Hard, red - Deadly) OR "Mandatory Convo" (always yellow) OR "Avoidable Convo" (always green)
                                //0 Mover type: "Patrol, Chaser" (Stationary, Patrol, Random, Daily, Weekly, Monthly, Yearly)(white) + Chaser/No Chaser (red/green)  
                                //2 Hide & Seek: "Stealth 14, Spot 13"(white) (No Stealther(green), All seeing(red))
                                //3 Can be bypassed by Shadow? "Allows sneak through" (green), "No sneak through" (red)
                                //4 Speed, with chances: "Speed 7, 0:15%, 2:15% (speed value, including move chances)(white), or "slow" in green

                                if (((p.EncounterWhenOnPartySquare != "none") || (p.ConversationWhenOnPartySquare != "none")) && (gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].Visible) && lightIsNoProblem && !p.isStealthed && (p.MouseOverText != "none" || p.MouseOverText != "None" || p.MouseOverText != ""))
                                {

                                    //gv.cc.floatyTextA
                                    if (p.ingameShownEncName != "none")
                                    {
                                        gv.cc.floatyTextA = p.ingameShownEncName;
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                    }

                                    //gv.cc.floatyTextB
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                    int partyLevelAverage = 0;
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        partyLevelAverage += pc.classLevel;
                                    }

                                    partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                                    //int numberOfSkulls = 0;
                                    bool showAsEncounter = false;

                                    if (p.ConversationWhenOnPartySquare != "none" && p.ConversationWhenOnPartySquare != "None" && p.ConversationWhenOnPartySquare != "")
                                    {
                                        if (p.alwaysFlagAsEncounter)
                                        {
                                            showAsEncounter = true;
                                        }
                                    }

                                    if ((p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "None" && p.EncounterWhenOnPartySquare != "") && ((p.ConversationWhenOnPartySquare == "none" || p.ConversationWhenOnPartySquare == "None" || p.ConversationWhenOnPartySquare == "")))
                                    {
                                        foreach (Encounter enc in gv.mod.moduleEncountersList)
                                        {
                                            if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                            {
                                                if (!enc.challengeHidden)
                                                {
                                                    if (enc.challengeLevel > (partyLevelAverage + 5))
                                                    {
                                                        gv.cc.floatyTextB = "Deadly Enc Lvl " + enc.challengeLevel.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                    {
                                                        gv.cc.floatyTextB = "Very Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                    {
                                                        gv.cc.floatyTextB = "Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else if (enc.challengeLevel > (partyLevelAverage - 2))
                                                    {
                                                        gv.cc.floatyTextB = "Normal Enc Lvl " + enc.challengeLevel.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else
                                                    {
                                                        gv.cc.floatyTextB = "Easy Enc Lvl " + enc.challengeLevel.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                }
                                                //challenge hidden
                                                else
                                                {
                                                    gv.cc.floatyTextB = "Unknown Enc Lvl";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                            }
                                        }
                                    }
                                    else if (showAsEncounter)
                                    {
                                        if (p.challengeLevelAssignedForEncounterInConvo != 0)
                                        {
                                            if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage + 5))
                                            {
                                                gv.cc.floatyTextB = "Deadly Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                            else if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage + 3))
                                            {
                                                gv.cc.floatyTextB = "Very Hard Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                            else if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage + 1))
                                            {
                                                gv.cc.floatyTextB = "Hard Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                            else if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage - 2))
                                            {
                                                gv.cc.floatyTextB = "Normal Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                            else
                                            {
                                                gv.cc.floatyTextB = "Easy Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                        }
                                        //use the level on the encounter event
                                        else
                                        {
                                            foreach (Encounter enc in gv.mod.moduleEncountersList)
                                            {
                                                if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                                {
                                                    if (!enc.challengeHidden)
                                                    {
                                                        if (enc.challengeLevel > (partyLevelAverage + 5))
                                                        {
                                                            gv.cc.floatyTextB = "Deadly Enc Lvl " + enc.challengeLevel.ToString();
                                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                        }
                                                        else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                        {
                                                            gv.cc.floatyTextB = "Very Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                        }
                                                        else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                        {
                                                            gv.cc.floatyTextB = "Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                        }
                                                        else if (enc.challengeLevel > (partyLevelAverage - 2))
                                                        {
                                                            gv.cc.floatyTextB = "Normal Enc Lvl " + enc.challengeLevel.ToString();
                                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                        }
                                                        else
                                                        {
                                                            gv.cc.floatyTextB = "Easy Enc Lvl " + enc.challengeLevel.ToString();
                                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                        }
                                                    }
                                                    //challenge hidden
                                                    else
                                                    {
                                                        gv.cc.floatyTextB = "Unknown Enc Lvl";
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (p.unavoidableConversation && p.ConversationWhenOnPartySquare != "none" && p.ConversationWhenOnPartySquare != "None" && p.ConversationWhenOnPartySquare != "")
                                    {
                                        gv.cc.floatyTextB = "Mandatory Convo";
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                    }
                                    else if (!p.unavoidableConversation && p.ConversationWhenOnPartySquare != "none" && p.ConversationWhenOnPartySquare != "None" && p.ConversationWhenOnPartySquare != "")
                                    {
                                        gv.cc.floatyTextB = "Optional Convo";
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                    }

                                    //mover type
                                    //0, mover type and chase
                                    if (p.isChaser)
                                    {

                                        if (!p.isMover)
                                        {
                                            gv.cc.floatyText0 = "Post (Chaser)";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }

                                        else if (p.MoverType.Equals("post"))
                                        {
                                            gv.cc.floatyText0 = "Post (Chaser)";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                        else if (p.MoverType.Equals("random"))
                                        {
                                            gv.cc.floatyText0 = "Random (Chaser)";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                        else if (p.MoverType.Equals("Patrol"))
                                        {
                                            gv.cc.floatyText0 = "Patrol (Chaser)";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                        else if (p.MoverType.Equals("Daily"))
                                        {
                                            gv.cc.floatyText0 = "Daily (Chaser)";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                    }
                                    //no chaser
                                    else
                                    {

                                        if (!p.isMover)
                                        {
                                            gv.cc.floatyText0 = "Stationary";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }

                                        else if (p.MoverType.Equals("post"))
                                        {
                                            gv.cc.floatyText0 = "Stationary";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                        else if (p.MoverType.Equals("random"))
                                        {
                                            gv.cc.floatyText0 = "Random";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                        else if (p.MoverType.Equals("Patrol"))
                                        {
                                            gv.cc.floatyText0 = "Patrol";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                        else if (p.MoverType.Equals("Daily"))
                                        {
                                            gv.cc.floatyText0 = "Daily";
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                        }
                                    }

                                    //2 Hide & Seek: "Stealth 14, Spot 13"(white) (No Stealther(green), All seeing(red))
                                    //block stealth (3)
                                    int checkModifier = 0;
                                    string textBlock = "";
                                    if ((p.stealth != -1))
                                    {
                                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                        int darkAdder = 0;
                                        int tileAdder = 0;
                                        Coordinate pcCoord = new Coordinate();
                                        Coordinate propCoord = new Coordinate();
                                        pcCoord.X = gv.mod.PlayerLocationX;
                                        pcCoord.Y = gv.mod.PlayerLocationY;

                                        propCoord.X = p.LocationX;
                                        propCoord.Y = p.LocationY;
                                        tileAdder = gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].stealthModifier;
                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                                        {
                                            darkAdder = 4;
                                        }
                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                                        {
                                            darkAdder = 12;
                                        }

                                        //factor in lit state and tile stealtModifier
                                        checkModifier = (gv.cc.getDistance(pcCoord, propCoord) - 1) * 2 + darkAdder + tileAdder;

                                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                        // textBlock += "Stealth " + (p.stealth - 10 + checkModifier).ToString() + ", ";
                                        textBlock += "Stealth " + (p.stealth - 10).ToString();
                                        if (checkModifier < 0)
                                        {
                                            textBlock += checkModifier.ToString() + ", ";
                                        }
                                        if (checkModifier > 0)
                                        {
                                            textBlock += "+" + checkModifier.ToString() + ", ";
                                        }
                                        if (checkModifier == 0)
                                        {
                                            textBlock += ", ";
                                        }
                                    }
                                    else
                                    {
                                        textBlock += "No Stealther, ";
                                    }

                                    if (p.spotEnemy != -1)
                                    {
                                        if (p.isChaser)
                                        {
                                            int tileAdder = 0;
                                            int darkAdder = 0;
                                            tileAdder = gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationY].stealthModifier;
                                            if (gv.sf.CheckIsInDarkness("party", "night"))
                                            {
                                                darkAdder = 4;
                                            }
                                            if (gv.sf.CheckIsInDarkness("party", "noLight"))
                                            {
                                                darkAdder = 12;
                                            }
                                            Coordinate pcCoord = new Coordinate();
                                            Coordinate propCoord = new Coordinate();
                                            pcCoord.X = gv.mod.PlayerLocationX;
                                            pcCoord.Y = gv.mod.PlayerLocationY;
                                            propCoord.X = p.LocationX;
                                            propCoord.Y = p.LocationY;

                                            //factor in lit state and tile stealtModifier
                                            checkModifier = (gv.cc.getDistance(pcCoord, propCoord) - 1) * 2 - 4 + darkAdder + tileAdder;
                                            //textBlock += "Spot " + (p.spotEnemy - 10 - checkModifier).ToString();
                                            textBlock += "Spot " + (p.spotEnemy - 10).ToString();
                                            if (checkModifier < 0)
                                            {
                                                textBlock += "+" + (checkModifier * -1).ToString();
                                            }
                                            if (checkModifier > 0)
                                            {
                                                textBlock += "-" + checkModifier.ToString();
                                            }
                                            //checkModifier = -4 + darkAdder + tileAdder;
                                        }
                                        else
                                        {
                                            textBlock += "No Spot";
                                            int tileAdder = 0;
                                            int darkAdder = 0;
                                            tileAdder = gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationY].stealthModifier;
                                            if (gv.sf.CheckIsInDarkness("party", "night"))
                                            {
                                                darkAdder = 4;
                                            }
                                            if (gv.sf.CheckIsInDarkness("party", "noLight"))
                                            {
                                                darkAdder = 12;
                                            }
                                            checkModifier = -4 + darkAdder + tileAdder;
                                        }
                                    }
                                    else
                                    {
                                        if (p.isChaser)
                                        {
                                            textBlock += "All seeing";
                                        }
                                        else
                                        {
                                            textBlock += "No Spot";
                                        }
                                    }
                                    gv.cc.floatyText2 = textBlock;
                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                    //3 Can be bypassed by Shadow? "Allows sneak through" (green), "No sneak through" (red)
                                    if (p.stealthSkipsPropTriggers)
                                    {
                                        //gv.cc.floatyText3 = "Allows sneak through";
                                        gv.cc.floatyText3 = "Sneak through DC " + (p.spotEnemy - 10 - checkModifier + 5).ToString();
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                    }
                                    else
                                    {
                                        gv.cc.floatyText3 = "No sneak through";
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                    }
                                    //4 Speed, with chances: "Speed 7, 0:15%, 2:15% (speed value, including move chances)(white), or "slow" in green
                                    if (p.isMover)
                                    {
                                        if (p.movementSpeed != -1)
                                        {
                                            //speed comparison
                                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                            int Move0Chance = 0;
                                            int Move2Chance = 0;

                                            int relativeSpeed = gv.mod.partySpeed - p.movementSpeed;

                                            //prop is lightning fast (<= -13); Double:75% , None:0% 
                                            if (relativeSpeed <= -13)
                                            {
                                                Move0Chance = 0;
                                                Move2Chance = 75;
                                            }
                                            //prop is very fast (-8 til -12); Double:50% , None:5%
                                            if (relativeSpeed <= -8 && relativeSpeed >= -12)
                                            {
                                                Move0Chance = 5;
                                                Move2Chance = 50;
                                            }
                                            //prop is fast (-3 til -7); Double:30% , None:10%
                                            if (relativeSpeed <= -3 && relativeSpeed >= -7)
                                            {
                                                Move0Chance = 10;
                                                Move2Chance = 30;
                                            }
                                            //prop at default (-2 til +2); Double:15% , None:15%
                                            if (relativeSpeed <= 2 && relativeSpeed >= -2)
                                            {
                                                Move0Chance = 15;
                                                Move2Chance = 15;
                                            }
                                            //prop is slow (+3 til +7); Double:10% , None:30%
                                            if (relativeSpeed <= 7 && relativeSpeed >= 3)
                                            {
                                                Move0Chance = 30;
                                                Move2Chance = 10;
                                            }
                                            //prop is very slow (+8 til +12); Double:5% , None:50%
                                            if (relativeSpeed <= 12 && relativeSpeed >= 8)
                                            {
                                                Move0Chance = 50;
                                                Move2Chance = 5;
                                            }
                                            //prop is almost standing (>= +13); Double:0% , None:75%
                                            if (relativeSpeed >= 13)
                                            {
                                                Move0Chance = 75;
                                                Move2Chance = 0;
                                            }

                                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                            gv.cc.floatyText4 = "Speed " + p.movementSpeed.ToString() + ", 0:" + Move0Chance.ToString() + "%, 2:" + Move2Chance.ToString() + "%";
                                        }
                                        else
                                        {
                                            //Move0Chance = 40;
                                            //Move2Chance = 0;

                                            gv.cc.floatyText4 = "Slow, 0:40%, 2:0%";
                                        }
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                    }
                                    else
                                    {
                                        gv.cc.floatyText4 = "Does not move";
                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                    }

                                    }
                                }//up to here
                            }
                       }

                    //get diagonal neighbours
                    string NeighbourNE = "";
                    string NeighbourNW = "";
                    string NeighbourSE = "";
                    string NeighbourSW = "";
                    foreach (Area a in gv.mod.moduleAreasObjects)
                    {
                        if (a.Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            if (a.easternNeighbourArea != "none" && a.easternNeighbourArea != "" && a.easternNeighbourArea != "None")
                            {
                                NeighbourNE = a.easternNeighbourArea;
                            }

                            if (a.westernNeighbourArea != "none" && a.westernNeighbourArea != "" && a.westernNeighbourArea != "None")
                            {
                                NeighbourNW = a.westernNeighbourArea;
                            }
                        }

                        if (a.Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            if (a.northernNeighbourArea != "none" && a.northernNeighbourArea != "" && a.northernNeighbourArea != "None")
                            {
                                NeighbourNE = a.northernNeighbourArea;
                            }

                            if (a.southernNeighbourArea != "none" && a.southernNeighbourArea != "" && a.southernNeighbourArea != "None")
                            {
                                NeighbourSE = a.southernNeighbourArea;
                            }
                        }

                        if (a.Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            if (a.easternNeighbourArea != "none" && a.easternNeighbourArea != "" && a.easternNeighbourArea != "None")
                            {
                                NeighbourSE = a.easternNeighbourArea;
                            }

                            if (a.westernNeighbourArea != "none" && a.westernNeighbourArea != "" && a.westernNeighbourArea != "None")
                            {
                                NeighbourSW = a.westernNeighbourArea;
                            }
                        }

                        if (a.Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            if (a.northernNeighbourArea != "none" && a.northernNeighbourArea != "" && a.northernNeighbourArea != "None")
                            {
                                NeighbourNW = a.northernNeighbourArea;
                            }

                            if (a.southernNeighbourArea != "none" && a.southernNeighbourArea != "" && a.southernNeighbourArea != "None")
                            {
                                NeighbourSW = a.southernNeighbourArea;
                            }
                        }
                    }

                        //now the neighbouring areas
                        foreach (Area a in gv.mod.moduleAreasObjects)
                        {

                            if (a.Filename == gv.mod.currentArea.easternNeighbourArea || a.Filename == gv.mod.currentArea.westernNeighbourArea || a.Filename == gv.mod.currentArea.northernNeighbourArea || a.Filename == gv.mod.currentArea.southernNeighbourArea || a.Filename == NeighbourNE || a.Filename == NeighbourNW || a.Filename == NeighbourSE || a.Filename == NeighbourSW)
                            {
                            foreach (Prop p in a.Props)
                            {
                                if (!p.isStealthed)
                                { 
                                bool tooMuchHeightDifference = false;
                                if (gv.mod.blendOutTooHighAndTooDeepTiles)
                                {
                                    if ((gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel > a.Tiles[p.LocationY * a.MapSizeX + p.LocationX].heightLevel + 2) || (gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].heightLevel < a.Tiles[p.LocationY * a.MapSizeX + p.LocationX].heightLevel - 2))
                                    {
                                        tooMuchHeightDifference = true;
                                    }
                                }
                                if ((e.X - 1 >= p.currentPixelPositionX && e.X <= p.currentPixelPositionX + gv.squareSize) && (e.Y - 1 >= p.currentPixelPositionY + (gv.squareSize / 2) && e.Y <= p.currentPixelPositionY + gv.squareSize + (gv.squareSize / 2)) && !tooMuchHeightDifference)
                                { 
                                        actualX = p.LocationX;
                                        actualY = p.LocationY;

                                        bool lightIsNoProblem = false;
                                        if ((!a.useLightSystem) || (a.UseDayNightCycle))
                                        {
                                            lightIsNoProblem = true;
                                        }
                                        else
                                        {
                                            bool foundTrue = false;

                                            /*
                                            if (gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].isLit.Count > 0)
                                            {
                                                lightIsNoProblem = true;
                                            }
                                            */
                                            foreach (bool state in a.Tiles[actualY * a.MapSizeX + actualX].isLit)
                                            {
                                                if (state)
                                                {
                                                    foundTrue = true;
                                                    break;
                                                }
                                            }
                                            if (foundTrue)
                                            {
                                                lightIsNoProblem = true;
                                            }
                                        }

                                        if ((!p.MouseOverText.Equals("none")) && (a.Tiles[actualY * a.MapSizeX + actualX].Visible) && lightIsNoProblem)
                                        {
                                            gv.cc.floatyText = p.MouseOverText;
                                            float floatyPushUp = 0;

                                            if (gv.cc.floatyText.Length <= 20)
                                            {
                                                floatyPushUp = 0.0f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 35)
                                            {
                                                floatyPushUp = 0.0f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 52)
                                            {
                                                floatyPushUp = 0.12f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 70)
                                            {
                                                floatyPushUp = 0.3f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 87)
                                            {
                                                floatyPushUp = 0.7f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 105)
                                            {
                                                floatyPushUp = 1.0f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 122)
                                            {
                                                floatyPushUp = 1.35f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 140)
                                            {
                                                floatyPushUp = 1.5f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 157)
                                            {
                                                floatyPushUp = 1.62f;
                                            }
                                            else if (gv.cc.floatyText.Length <= 175)
                                            {
                                                floatyPushUp = 1.75f;
                                            }
                                            else
                                            {
                                                floatyPushUp = 2.0f;
                                            }
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, gridy * gv.squareSize - (int)(floatyPushUp * gv.squareSize));
                                        }
                                        if (((p.EncounterWhenOnPartySquare != "none") || (p.ConversationWhenOnPartySquare != "none")) && (gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].Visible) && lightIsNoProblem && !p.isStealthed && (p.MouseOverText != "none" || p.MouseOverText != "None" || p.MouseOverText != ""))
                                        {

                                            //gv.cc.floatyTextA
                                            if (p.ingameShownEncName != "none")
                                            {
                                                gv.cc.floatyTextA = p.ingameShownEncName;
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }

                                            //gv.cc.floatyTextB
                                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                            int partyLevelAverage = 0;
                                            foreach (Player pc in gv.mod.playerList)
                                            {
                                                partyLevelAverage += pc.classLevel;
                                            }

                                            partyLevelAverage = (int)(partyLevelAverage / gv.mod.playerList.Count);

                                            //int numberOfSkulls = 0;
                                            bool showAsEncounter = false;

                                            if (p.ConversationWhenOnPartySquare != "none" && p.ConversationWhenOnPartySquare != "None" && p.ConversationWhenOnPartySquare != "")
                                            {
                                                if (p.alwaysFlagAsEncounter)
                                                {
                                                    showAsEncounter = true;
                                                }
                                            }

                                            if ((p.EncounterWhenOnPartySquare != "none" && p.EncounterWhenOnPartySquare != "None" && p.EncounterWhenOnPartySquare != "") && ((p.ConversationWhenOnPartySquare == "none" || p.ConversationWhenOnPartySquare == "None" || p.ConversationWhenOnPartySquare == "")))
                                            {
                                                foreach (Encounter enc in gv.mod.moduleEncountersList)
                                                {
                                                    if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                                    {
                                                        if (!enc.challengeHidden)
                                                        {
                                                            if (enc.challengeLevel > (partyLevelAverage + 5))
                                                            {
                                                                gv.cc.floatyTextB = "Deadly Enc Lvl " + enc.challengeLevel.ToString();
                                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                            }
                                                            else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                            {
                                                                gv.cc.floatyTextB = "Very Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                            }
                                                            else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                            {
                                                                gv.cc.floatyTextB = "Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                            }
                                                            else if (enc.challengeLevel > (partyLevelAverage - 2))
                                                            {
                                                                gv.cc.floatyTextB = "Normal Enc Lvl " + enc.challengeLevel.ToString();
                                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                            }
                                                            else
                                                            {
                                                                gv.cc.floatyTextB = "Easy Enc Lvl " + enc.challengeLevel.ToString();
                                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                            }
                                                        }
                                                        //challenge hidden
                                                        else
                                                        {
                                                            gv.cc.floatyTextB = "Unknown Enc Lvl";
                                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                        }
                                                    }
                                                }
                                            }
                                            else if (showAsEncounter)
                                            {
                                                if (p.challengeLevelAssignedForEncounterInConvo != 0)
                                                {
                                                    if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage + 5))
                                                    {
                                                        gv.cc.floatyTextB = "Deadly Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage + 3))
                                                    {
                                                        gv.cc.floatyTextB = "Very Hard Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage + 1))
                                                    {
                                                        gv.cc.floatyTextB = "Hard Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else if (p.challengeLevelAssignedForEncounterInConvo > (partyLevelAverage - 2))
                                                    {
                                                        gv.cc.floatyTextB = "Normal Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                    else
                                                    {
                                                        gv.cc.floatyTextB = "Easy Enc Lvl " + p.challengeLevelAssignedForEncounterInConvo.ToString();
                                                        gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                    }
                                                }
                                                //use the level on the encounter event
                                                else
                                                {
                                                    foreach (Encounter enc in gv.mod.moduleEncountersList)
                                                    {
                                                        if (enc.encounterName == p.EncounterWhenOnPartySquare)
                                                        {
                                                            if (!enc.challengeHidden)
                                                            {
                                                                if (enc.challengeLevel > (partyLevelAverage + 5))
                                                                {
                                                                    gv.cc.floatyTextB = "Deadly Enc Lvl " + enc.challengeLevel.ToString();
                                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                                }
                                                                else if (enc.challengeLevel > (partyLevelAverage + 3))
                                                                {
                                                                    gv.cc.floatyTextB = "Very Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                                }
                                                                else if (enc.challengeLevel > (partyLevelAverage + 1))
                                                                {
                                                                    gv.cc.floatyTextB = "Hard Enc Lvl " + enc.challengeLevel.ToString();
                                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                                }
                                                                else if (enc.challengeLevel > (partyLevelAverage - 2))
                                                                {
                                                                    gv.cc.floatyTextB = "Normal Enc Lvl " + enc.challengeLevel.ToString();
                                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                                }
                                                                else
                                                                {
                                                                    gv.cc.floatyTextB = "Easy Enc Lvl " + enc.challengeLevel.ToString();
                                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                                }
                                                            }
                                                            //challenge hidden
                                                            else
                                                            {
                                                                gv.cc.floatyTextB = "Unknown Enc Lvl";
                                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (p.unavoidableConversation && p.ConversationWhenOnPartySquare != "none" && p.ConversationWhenOnPartySquare != "None" && p.ConversationWhenOnPartySquare != "")
                                            {
                                                gv.cc.floatyTextB = "Mandatory Convo";
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                            }
                                            else if (!p.unavoidableConversation && p.ConversationWhenOnPartySquare != "none" && p.ConversationWhenOnPartySquare != "None" && p.ConversationWhenOnPartySquare != "")
                                            {
                                                gv.cc.floatyTextB = "Optional Convo";
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                            }

                                            //mover type
                                            //0, mover type and chase
                                            if (p.isChaser)
                                            {

                                                if (!p.isMover)
                                                {
                                                    gv.cc.floatyText0 = "Post (Chaser)";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }

                                                else if (p.MoverType.Equals("post"))
                                                {
                                                    gv.cc.floatyText0 = "Post (Chaser)";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                                else if (p.MoverType.Equals("random"))
                                                {
                                                    gv.cc.floatyText0 = "Random (Chaser)";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                                else if (p.MoverType.Equals("Patrol"))
                                                {
                                                    gv.cc.floatyText0 = "Patrol (Chaser)";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                                else if (p.MoverType.Equals("Daily"))
                                                {
                                                    gv.cc.floatyText0 = "Daily (Chaser)";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                            }
                                            //no chaser
                                            else
                                            {

                                                if (!p.isMover)
                                                {
                                                    gv.cc.floatyText0 = "Stationary";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }

                                                else if (p.MoverType.Equals("post"))
                                                {
                                                    gv.cc.floatyText0 = "Stationary";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                                else if (p.MoverType.Equals("random"))
                                                {
                                                    gv.cc.floatyText0 = "Random";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                                else if (p.MoverType.Equals("Patrol"))
                                                {
                                                    gv.cc.floatyText0 = "Patrol";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                                else if (p.MoverType.Equals("Daily"))
                                                {
                                                    gv.cc.floatyText0 = "Daily";
                                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                                }
                                            }

                                            //2 Hide & Seek: "Stealth 14, Spot 13"(white) (No Stealther(green), All seeing(red))
                                            //block stealth (3)
                                            int checkModifier = 0;
                                            string textBlock = "";
                                            if ((p.stealth != -1))
                                            {
                                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                                int darkAdder = 0;
                                                int tileAdder = 0;
                                                Coordinate pcCoord = new Coordinate();
                                                Coordinate propCoord = new Coordinate();
                                                pcCoord.X = gv.mod.PlayerLocationX;
                                                pcCoord.Y = gv.mod.PlayerLocationY;

                                                propCoord.X = p.LocationX;
                                                propCoord.Y = p.LocationY;
                                                tileAdder = gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].stealthModifier;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                                                {
                                                    darkAdder = 12;
                                                }

                                                //factor in lit state and tile stealtModifier
                                                checkModifier = (gv.cc.getDistance(pcCoord, propCoord) - 1) * 2 + darkAdder + tileAdder;

                                                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                                // textBlock += "Stealth " + (p.stealth - 10 + checkModifier).ToString() + ", ";
                                                textBlock += "Stealth " + (p.stealth - 10).ToString();
                                                if (checkModifier < 0)
                                                {
                                                    textBlock += checkModifier.ToString() + ", ";
                                                }
                                                if (checkModifier > 0)
                                                {
                                                    textBlock += "+" + checkModifier.ToString() + ", ";
                                                }
                                                if (checkModifier == 0)
                                                {
                                                    textBlock += ", ";
                                                }
                                            }
                                            else
                                            {
                                                textBlock += "No Stealther, ";
                                            }

                                            if (p.spotEnemy != -1)
                                            {
                                                if (p.isChaser)
                                                {
                                                    int tileAdder = 0;
                                                    int darkAdder = 0;
                                                    tileAdder = gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationY].stealthModifier;
                                                    if (gv.sf.CheckIsInDarkness("party", "night"))
                                                    {
                                                        darkAdder = 4;
                                                    }
                                                    if (gv.sf.CheckIsInDarkness("party", "noLight"))
                                                    {
                                                        darkAdder = 12;
                                                    }
                                                    Coordinate pcCoord = new Coordinate();
                                                    Coordinate propCoord = new Coordinate();
                                                    pcCoord.X = gv.mod.PlayerLocationX;
                                                    pcCoord.Y = gv.mod.PlayerLocationY;
                                                    propCoord.X = p.LocationX;
                                                    propCoord.Y = p.LocationY;

                                                    //factor in lit state and tile stealtModifier
                                                    checkModifier = (gv.cc.getDistance(pcCoord, propCoord) - 1) * 2 - 4 + darkAdder + tileAdder;
                                                    //textBlock += "Spot " + (p.spotEnemy - 10 - checkModifier).ToString();
                                                    textBlock += "Spot " + (p.spotEnemy - 10).ToString();
                                                    if (checkModifier < 0)
                                                    {
                                                        textBlock += "+" + (checkModifier*-1).ToString();
                                                    }
                                                    if (checkModifier > 0)
                                                    {
                                                        textBlock += "-" + checkModifier.ToString();
                                                    }
                                                    //checkModifier = -4 + darkAdder + tileAdder;
                                                }
                                                else
                                                {
                                                    textBlock += "No Spot";
                                                    int tileAdder = 0;
                                                    int darkAdder = 0;
                                                    tileAdder = gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationY].stealthModifier;
                                                    if (gv.sf.CheckIsInDarkness("party", "night"))
                                                    {
                                                        darkAdder = 4;
                                                    }
                                                    if (gv.sf.CheckIsInDarkness("party", "noLight"))
                                                    {
                                                        darkAdder = 12;
                                                    }
                                                    checkModifier = -4 + darkAdder + tileAdder;
                                                }
                                            }
                                            else
                                            {
                                                if (p.isChaser)
                                                {
                                                    textBlock += "All seeing";
                                                }
                                                else
                                                {
                                                    textBlock += "No Spot";
                                                }
                                            }
                                            gv.cc.floatyText2 = textBlock;
                                            gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                            //3 Can be bypassed by Shadow? "Allows sneak through" (green), "No sneak through" (red)
                                            if (p.stealthSkipsPropTriggers)
                                            {
                                                //gv.cc.floatyText3 = "Allows sneak through";
                                                gv.cc.floatyText3 = "Sneak through DC " + (p.spotEnemy - 10 - checkModifier + 5).ToString();
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                            }
                                            else
                                            {
                                                gv.cc.floatyText3 = "No sneak through";
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                            //4 Speed, with chances: "Speed 7, 0:15%, 2:15% (speed value, including move chances)(white), or "slow" in green
                                            if (p.isMover)
                                            {
                                                if (p.movementSpeed != -1)
                                                {
                                                    //speed comparison
                                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                                    int Move0Chance = 0;
                                                    int Move2Chance = 0;

                                                    int relativeSpeed = gv.mod.partySpeed - p.movementSpeed;

                                                    //prop is lightning fast (<= -13); Double:75% , None:0% 
                                                    if (relativeSpeed <= -13)
                                                    {
                                                        Move0Chance = 0;
                                                        Move2Chance = 75;
                                                    }
                                                    //prop is very fast (-8 til -12); Double:50% , None:5%
                                                    if (relativeSpeed <= -8 && relativeSpeed >= -12)
                                                    {
                                                        Move0Chance = 5;
                                                        Move2Chance = 50;
                                                    }
                                                    //prop is fast (-3 til -7); Double:30% , None:10%
                                                    if (relativeSpeed <= -3 && relativeSpeed >= -7)
                                                    {
                                                        Move0Chance = 10;
                                                        Move2Chance = 30;
                                                    }
                                                    //prop at default (-2 til +2); Double:15% , None:15%
                                                    if (relativeSpeed <= 2 && relativeSpeed >= -2)
                                                    {
                                                        Move0Chance = 15;
                                                        Move2Chance = 15;
                                                    }
                                                    //prop is slow (+3 til +7); Double:10% , None:30%
                                                    if (relativeSpeed <= 7 && relativeSpeed >= 3)
                                                    {
                                                        Move0Chance = 30;
                                                        Move2Chance = 10;
                                                    }
                                                    //prop is very slow (+8 til +12); Double:5% , None:50%
                                                    if (relativeSpeed <= 12 && relativeSpeed >= 8)
                                                    {
                                                        Move0Chance = 50;
                                                        Move2Chance = 5;
                                                    }
                                                    //prop is almost standing (>= +13); Double:0% , None:75%
                                                    if (relativeSpeed >= 13)
                                                    {
                                                        Move0Chance = 75;
                                                        Move2Chance = 0;
                                                    }

                                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                                                    gv.cc.floatyText4 = "Speed " + p.movementSpeed.ToString() + ", 0:" + Move0Chance.ToString() + "%, 2:" + Move2Chance.ToString() + "%";
                                                }
                                                else
                                                {
                                                    //Move0Chance = 40;
                                                    //Move2Chance = 0;

                                                    gv.cc.floatyText4 = "Slow, 0:40%, 2:0%";
                                                }
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));
                                            }
                                            else
                                            {
                                                gv.cc.floatyText4 = "Does not move";
                                                gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, (int)((gridy - 1) * gv.squareSize));

                                            }

                                        //}
                                    }//up to here
                                }
                            }
                                }
                            }
                        }

                                //}
                    break;

                case MouseEventType.EventType.MouseUp:
                    gv.moveTimerRuns = false;
                    gv.moveTimerCounter = 0;
                    int actualx = -1000;
                    int actualy = -1000;
                    if (!isMoving)
                    {
                        x = gv.mousePositionX - (int)(gv.squareSize * 15f / 100f);
                        y = gv.mousePositionY - (int)(gv.squareSize * 55f / 100f);

                        //hurgh5555

                        int gridX = x / gv.squareSize;
                        int gridY = y / gv.squareSize;
                        actualx = gv.mod.PlayerLocationX + (gridX - gv.playerOffsetX);
                        actualy = gv.mod.PlayerLocationY + (gridY - gv.playerOffsetY);
                    }

                    isMoving = false;
                    x = (int)e.X;
                    y = (int)e.Y;


                    //NEW SYSTEM
                    string rtn = mainUiLayout.getImpact(x, y);

                    //check to see if toggle or button is using IBScript and do script
                    IB2Button btnScript = mainUiLayout.GetButtonByTag(rtn);
                    if (btnScript != null)
                    {
                        if ((btnScript.IBScript.Equals("none")) || (btnScript.IBScript.Equals("")))
                        {
                            //no IBScript so move on
                        }
                        else if (btnScript.IBScript.Equals("traitdescription"))
                        {
                            string text = "";
                            foreach (Trait t in gv.mod.moduleTraitsList)
                            {
                                if (btnScript.tag == t.tag)
                                {
                                    text = t.description;
                                    break;
                                }
                            }
                            //vitamind
                            //gv.sf.MessageBox(text);
                            gv.sf.MessageBoxHtml(text);
                            
                        }
                        else
                        {
                            gv.cc.doIBScriptBasedOnFilename(btnScript.IBScript, "");
                        }
                    }

                    if (rtn.Equals("tglGrid"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.map_showGrid = false;
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.map_showGrid = true;
                        }
                    }
                    if (rtn.Equals("tglInteractionState"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.showInteractionState = false;
                            gv.cc.addLogText("lime", "Show info about interaction state of NPC and creatures turned OFF");
                    }     
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.showInteractionState = true;
                            gv.cc.addLogText("lime", "Show info about interaction state of NPC and creatures (encounter = red, mandatory conversation = orange and optional conversation = green");
                        }
                    }
                    if (rtn.Equals("tglAvoidConversation"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.avoidInteraction = false;
                            gv.cc.addLogText("lime", "Normal move gv.mode: party does all possible conversations");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.avoidInteraction = true;
                            gv.cc.addLogText("yellow", "In a hurry: Party is avoiding all conversations that are not mandatory");
                        }
                    }

                    if (rtn.Equals("tglClock"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showClock = !showClock;
                    }
                    if (rtn.Equals("tglSound"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.playMusic = false;
                            gv.mod.playSoundFx = false;
                            //TODO gv.screenCombat.tglSoundFx.toggleOn = false;
                            gv.stopMusic();
                            gv.stopAmbient();
                            gv.cc.addLogText("lime", "Music Off, SoundFX Off");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.playMusic = true;
                            gv.mod.playSoundFx = true;
                            //TODO gv.screenCombat.tglSoundFx.toggleOn = true;
                            gv.startMusic();
                            gv.startAmbient();
                            gv.cc.addLogText("lime", "Music On, SoundFX On");
                        }
                    }
                    if (rtn.Equals("tglFullParty"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            showFullParty = false;
                            gv.cc.addLogText("lime", "Show Party Leader");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            showFullParty = true;
                            gv.cc.addLogText("lime", "Show Full Party");
                        }
                    }
                    if (rtn.Equals("tglMoveKeys"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            showMoveKeys = false;
                            gv.cc.addLogText("lime", "WASD for movement, arrow keys for log and leader");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            showMoveKeys = true;
                            gv.cc.addLogText("lime", "Arrow keys for movement, WASD for log and leader");
                        }
                    }
                    if (rtn.Equals("tglMiniMap"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            showMiniMap = false;
                            gv.cc.addLogText("lime", "Hide Mini Map");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            showMiniMap = true;
                            gv.cc.addLogText("lime", "Show Mini Map");
                        }
                    }

                    if (rtn.Equals("btnJournal"))
                    {
                        gv.screenType = "journal";
                    }
                    else if (rtn.Equals("btnOwnZoneMap"))
                    {
                        //enter own zone map from real current area
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            //gv.cc.doUpdate();
                            gv.mod.currentlyOnOwnZone = true;
                            gv.mod.currentlyOnGrandMotherZone = false;
                            gv.mod.currentlyOnMotherZone = false;
                            gv.mod.overviewReturnAreaName = gv.mod.currentArea.Filename;
                            gv.mod.overviewReturnLocationX = gv.mod.PlayerLocationX;
                            gv.mod.overviewReturnLocationY = gv.mod.PlayerLocationY;
                            gv.mod.oldPartyTokenFilename = gv.mod.partyTokenFilename;
                            gv.mod.oldPartyTokenEnabledState = gv.mod.showPartyToken;
                            gv.sf.TogglePartyToken("overviewMapSelectionSquare","true");
                            gv.mod.allowImmediateRetransition = true;
                            Coordinate coord = new Coordinate();
                            coord.X = gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapX;
                            coord.Y = gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapY;
                            gv.cc.doTransitionBasedOnAreaLocation(gv.mod.currentArea.filenameOfOwnZoneMap, gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapX, gv.mod.currentArea.partyPositionMarkerOnOwnZoneMapY);
                            foreach (Tile t in gv.mod.currentArea.Tiles)
                            {
                                if (t.Layer5Filename == "prp_partyposition")
                                {
                                    t.Layer5Filename = "t_blank";
                                }
                            }
                            gv.mod.currentArea.Tiles[coord.Y * gv.mod.currentArea.MapSizeX + coord.X].Layer5Filename = "prp_partyposition";
                            //gv.mod.currentArea.toggledSquaresLayer5FilenameCoords.Add(coord);
                            //gv.mod.currentArea.toggledSquaresLayer5FilenameNames.Add("prp_wmtrans");
                        }
                        //go back to real current area
                        else if (gv.mod.currentArea.isOverviewMap && gv.mod.currentlyOnOwnZone)
                        {
                            //gv.cc.doUpdate();
                            gv.sf.TogglePartyToken(gv.mod.oldPartyTokenFilename, gv.mod.oldPartyTokenEnabledState.ToString());
                            gv.mod.allowImmediateRetransition = true;
                            gv.cc.doTransitionBasedOnAreaLocation(gv.mod.overviewReturnAreaName, gv.mod.overviewReturnLocationX, gv.mod.overviewReturnLocationY);
                            gv.mod.currentlyOnOwnZone = false;
                            gv.mod.currentlyOnMotherZone = false;
                            gv.mod.currentlyOnGrandMotherZone = false;
                            gv.mod.overviewReturnAreaName = "none";
                            gv.mod.overviewReturnLocationX = 0;
                            gv.mod.overviewReturnLocationY = 0;
                        }
                    
                        //go from mother/grandmother overview map to own overview map
                        else if (gv.mod.currentArea.isOverviewMap && !gv.mod.currentlyOnOwnZone)
                        {
                            //must read the target x,y location and target fielname info from old current area
                            foreach (Area a in gv.mod.moduleAreasObjects)
                            {
                                if (a.Filename == gv.mod.overviewReturnAreaName)
                                {
                                    gv.mod.currentlyOnOwnZone = true;
                                    gv.mod.currentlyOnGrandMotherZone = false;
                                    gv.mod.currentlyOnMotherZone = false;
                                    gv.mod.allowImmediateRetransition = true;
                                    Coordinate coord = new Coordinate();
                                    coord.X = a.partyPositionMarkerOnOwnZoneMapX;
                                    coord.Y = a.partyPositionMarkerOnOwnZoneMapY;
                                    gv.cc.doTransitionBasedOnAreaLocation(a.filenameOfOwnZoneMap, a.partyPositionMarkerOnOwnZoneMapX, a.partyPositionMarkerOnOwnZoneMapY);
                                    foreach (Tile t in gv.mod.currentArea.Tiles)
                                    {
                                        if (t.Layer5Filename == "prp_partyposition")
                                        {
                                            t.Layer5Filename = "t_blank";
                                        }
                                    }
                                    gv.mod.currentArea.Tiles[coord.Y * gv.mod.currentArea.MapSizeX + coord.X].Layer5Filename = "prp_partyposition";
                                    break;                                   
                                }
                            }
                        }
                    }
                    else if (rtn.Equals("btnMotherZoneMap"))
                    {
                        //enter own mother zone map from real current area
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            gv.mod.currentlyOnMotherZone = true;
                            gv.mod.currentlyOnGrandMotherZone = false;
                            gv.mod.currentlyOnOwnZone = false;
                            gv.mod.overviewReturnAreaName = gv.mod.currentArea.Filename;
                            gv.mod.overviewReturnLocationX = gv.mod.PlayerLocationX;
                            gv.mod.overviewReturnLocationY = gv.mod.PlayerLocationY;
                            gv.mod.oldPartyTokenFilename = gv.mod.partyTokenFilename;
                            gv.mod.oldPartyTokenEnabledState = gv.mod.showPartyToken;
                            gv.sf.TogglePartyToken("overviewMapSelectionSquare", "true");
                            gv.mod.allowImmediateRetransition = true;
                            Coordinate coord = new Coordinate();
                            coord.X = gv.mod.currentArea.partyPositionMarkerOnMotherZoneMapX;
                            coord.Y = gv.mod.currentArea.partyPositionMarkerOnMotherZoneMapY;
                            gv.cc.doTransitionBasedOnAreaLocation(gv.mod.currentArea.filenameOfMotherZoneMap, gv.mod.currentArea.partyPositionMarkerOnMotherZoneMapX, gv.mod.currentArea.partyPositionMarkerOnMotherZoneMapY);
                            foreach (Tile t in gv.mod.currentArea.Tiles)
                            {
                                if (t.Layer5Filename == "prp_partyposition")
                                {
                                    t.Layer5Filename = "t_blank";
                                }
                            }
                            gv.mod.currentArea.Tiles[coord.Y * gv.mod.currentArea.MapSizeX + coord.X].Layer5Filename = "prp_partyposition";

                        }
                        //go back to real current area
                        else if (gv.mod.currentArea.isOverviewMap && gv.mod.currentlyOnMotherZone)
                        {
                            gv.sf.TogglePartyToken(gv.mod.oldPartyTokenFilename, gv.mod.oldPartyTokenEnabledState.ToString());
                            gv.mod.allowImmediateRetransition = true;
                            gv.cc.doTransitionBasedOnAreaLocation(gv.mod.overviewReturnAreaName, gv.mod.overviewReturnLocationX, gv.mod.overviewReturnLocationY);
                            gv.mod.currentlyOnOwnZone = false;
                            gv.mod.currentlyOnMotherZone = false;
                            gv.mod.currentlyOnGrandMotherZone = false;
                            gv.mod.overviewReturnAreaName = "none";
                            gv.mod.overviewReturnLocationX = 0;
                            gv.mod.overviewReturnLocationY = 0;
                        }

                        //go from own/grandmother overview map to mother overview map
                        else if (gv.mod.currentArea.isOverviewMap && !gv.mod.currentlyOnMotherZone)
                        {
                            //must read the target x,y location and target fielname info from old current area
                            foreach (Area a in gv.mod.moduleAreasObjects)
                            {
                                if (a.Filename == gv.mod.overviewReturnAreaName)
                                {
                                    gv.mod.currentlyOnMotherZone = true;
                                    gv.mod.currentlyOnGrandMotherZone = false;
                                    gv.mod.currentlyOnOwnZone = false;
                                    gv.mod.allowImmediateRetransition = true;
                                    Coordinate coord = new Coordinate();
                                    coord.X = a.partyPositionMarkerOnMotherZoneMapX;
                                    coord.Y = a.partyPositionMarkerOnMotherZoneMapY;
                                    gv.cc.doTransitionBasedOnAreaLocation(a.filenameOfMotherZoneMap, a.partyPositionMarkerOnMotherZoneMapX, a.partyPositionMarkerOnMotherZoneMapY);
                                    foreach (Tile t in gv.mod.currentArea.Tiles)
                                    {
                                        if (t.Layer5Filename == "prp_partyposition")
                                        {
                                            t.Layer5Filename = "t_blank";
                                        }
                                    }
                                    gv.mod.currentArea.Tiles[coord.Y * gv.mod.currentArea.MapSizeX + coord.X].Layer5Filename = "prp_partyposition";

                                    break;
                                }
                            }
                        }
                    }
                    else if (rtn.Equals("btnGrandMotherZoneMap"))
                    {
                        //enter grandmother zone map from real current area
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            gv.mod.currentlyOnGrandMotherZone = true;
                            gv.mod.currentlyOnMotherZone = false;
                            gv.mod.currentlyOnOwnZone = false;
                            gv.mod.overviewReturnAreaName = gv.mod.currentArea.Filename;
                            gv.mod.overviewReturnLocationX = gv.mod.PlayerLocationX;
                            gv.mod.overviewReturnLocationY = gv.mod.PlayerLocationY;
                            gv.mod.oldPartyTokenFilename = gv.mod.partyTokenFilename;
                            gv.mod.oldPartyTokenEnabledState = gv.mod.showPartyToken;
                            gv.sf.TogglePartyToken("overviewMapSelectionSquare", "true");
                            gv.mod.allowImmediateRetransition = true;
                            Coordinate coord = new Coordinate();
                            coord.X = gv.mod.currentArea.partyPositionMarkerOnGrandMotherZoneMapX;
                            coord.Y = gv.mod.currentArea.partyPositionMarkerOnGrandMotherZoneMapY;
                            gv.cc.doTransitionBasedOnAreaLocation(gv.mod.currentArea.filenameOfGrandMotherZoneMap, gv.mod.currentArea.partyPositionMarkerOnGrandMotherZoneMapX, gv.mod.currentArea.partyPositionMarkerOnGrandMotherZoneMapY);
                            foreach (Tile t in gv.mod.currentArea.Tiles)
                            {
                                if (t.Layer5Filename == "prp_partyposition")
                                {
                                    t.Layer5Filename = "t_blank";
                                }
                            }
                            gv.mod.currentArea.Tiles[coord.Y * gv.mod.currentArea.MapSizeX + coord.X].Layer5Filename = "prp_partyposition";

                        }
                        //go back to real current area
                        else if (gv.mod.currentArea.isOverviewMap && gv.mod.currentlyOnGrandMotherZone)
                        {
                            gv.sf.TogglePartyToken(gv.mod.oldPartyTokenFilename, gv.mod.oldPartyTokenEnabledState.ToString());
                            gv.mod.allowImmediateRetransition = true;
                            gv.cc.doTransitionBasedOnAreaLocation(gv.mod.overviewReturnAreaName, gv.mod.overviewReturnLocationX, gv.mod.overviewReturnLocationY);
                            gv.mod.currentlyOnOwnZone = false;
                            gv.mod.currentlyOnMotherZone = false;
                            gv.mod.currentlyOnGrandMotherZone = false;
                            gv.mod.overviewReturnAreaName = "none";
                            gv.mod.overviewReturnLocationX = 0;
                            gv.mod.overviewReturnLocationY = 0;
                        }

                        //go from mother/own overview map to grandmother overview map
                        else if (gv.mod.currentArea.isOverviewMap && !gv.mod.currentlyOnGrandMotherZone)
                        {
                            //must read the target x,y location and target fielname info from old current area
                            foreach (Area a in gv.mod.moduleAreasObjects)
                            {
                                if (a.Filename == gv.mod.overviewReturnAreaName)
                                {
                                    gv.mod.currentlyOnGrandMotherZone = true;
                                    gv.mod.currentlyOnMotherZone = false;
                                    gv.mod.currentlyOnOwnZone = false;
                                    gv.mod.allowImmediateRetransition = true;
                                    Coordinate coord = new Coordinate();
                                    coord.X = a.partyPositionMarkerOnGrandMotherZoneMapX;
                                    coord.Y = a.partyPositionMarkerOnGrandMotherZoneMapY;
                                    gv.cc.doTransitionBasedOnAreaLocation(a.filenameOfGrandMotherZoneMap, a.partyPositionMarkerOnGrandMotherZoneMapX, a.partyPositionMarkerOnGrandMotherZoneMapY);
                                    foreach (Tile t in gv.mod.currentArea.Tiles)
                                    {
                                        if (t.Layer5Filename == "prp_partyposition")
                                        {
                                            t.Layer5Filename = "t_blank";
                                        }
                                    }
                                    gv.mod.currentArea.Tiles[coord.Y * gv.mod.currentArea.MapSizeX + coord.X].Layer5Filename = "prp_partyposition";

                                    break;
                                }
                            }
                        }
                    }
                    else if (rtn.Equals("btnTorch"))
                    {
                        foreach (ItemRefs ir in gv.mod.partyInventoryRefsList)
                        {
                            if (ir.isLightSource)
                            {
                                foreach (Item it in gv.mod.moduleItemsList)
                                {
                                    if (it.resref == ir.resref)
                                    {
                                        gv.cc.doIBScriptBasedOnFilename(it.onUseItemIBScript, it.onUseItemIBScriptParms);
                                        break;
                                    }

                                }
                                break;
                            }
                        }
                    }
                    else if (rtn.Equals("btnParty"))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                    }
                    else if ((rtn.Equals("port0")) && (gv.mod.playerList.Count > 0))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            if (e.Button == MouseButtons.Left)
                            {
                                gv.mod.selectedPartyLeader = 0;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 0;
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if (e.Button == MouseButtons.Right)
                            {
                                gv.mod.selectedPartyLeader = 0;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 0;
                            }
                        }
                    }
                    else if ((rtn.Equals("port1")) && (gv.mod.playerList.Count > 1))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            if (e.Button == MouseButtons.Left)
                            {
                                gv.mod.selectedPartyLeader = 1;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 1;
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);

                            }
                            else if (e.Button == MouseButtons.Right)
                            {
                                gv.mod.selectedPartyLeader = 1;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 1;
                            }
                        }
                    }
                    else if ((rtn.Equals("port2")) && (gv.mod.playerList.Count > 2))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            if (e.Button == MouseButtons.Left)
                            {
                                gv.mod.selectedPartyLeader = 2;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 2;
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if (e.Button == MouseButtons.Right)
                            {
                                gv.mod.selectedPartyLeader = 2;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 2;
                            }
                        }
                    }
                    else if ((rtn.Equals("port3")) && (gv.mod.playerList.Count > 3))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            if (e.Button == MouseButtons.Left)
                            {
                                gv.mod.selectedPartyLeader = 3;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 3;
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if (e.Button == MouseButtons.Right)
                            {
                                gv.mod.selectedPartyLeader = 3;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 3;
                            }
                        }
                    }
                    else if ((rtn.Equals("port4")) && (gv.mod.playerList.Count > 4))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            if (e.Button == MouseButtons.Left)
                            {
                                gv.mod.selectedPartyLeader = 4;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 4;
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if (e.Button == MouseButtons.Right)
                            {
                                gv.mod.selectedPartyLeader = 4;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 4;
                            }
                        }
                    }

                    else if ((rtn.Equals("port5")) && (gv.mod.playerList.Count > 5))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            if (e.Button == MouseButtons.Left)
                            {
                                gv.mod.selectedPartyLeader = 5;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 5;
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if (e.Button == MouseButtons.Right)
                            {
                                gv.mod.selectedPartyLeader = 5;
                                gv.screenMainMap.updateTraitsPanel();
                                gv.cc.partyScreenPcIndex = 5;
                            }
                        }
                    }
                    else if (rtn.Equals("btnInventory"))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            gv.screenType = "inventory";
                            gv.screenInventory.resetInventory(false);
                            gv.cc.tutorialMessageInventory(false);
                        }
                    }
                    else if (rtn.Equals("btnSettings"))
                    {
                        //gv.cc.doSettingsDialogs();
                        gv.Close();
                    }
                    else if (rtn.Equals("btnSave"))
                    {
                        if (gv.mod.allowSave)
                        {
                            gv.cc.doSavesDialog();
                        }
                    }
                    else if (rtn.Equals("btnWait"))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            gv.mod.breakActiveSearch = false;
                            gv.mod.partyIsSearching = true;

                            //active search
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                gv.cc.doUpdate();
                            }
                            if (!gv.mod.breakActiveSearch)
                            {
                                bool costPaid = false;
                                if (gv.mod.activeSearchSPCostPaidByByLeaderOnly)
                                {
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].sp >= gv.mod.activeSearchSPCost)
                                    {
                                        gv.mod.playerList[gv.mod.selectedPartyLeader].sp -= gv.mod.activeSearchSPCost;
                                        costPaid = true;
                                    }
                                }
                                else
                                {
                                    costPaid = true;

                                    foreach (Player p in gv.mod.playerList)
                                    {
                                        if (p.sp < gv.mod.activeSearchSPCost)
                                        {
                                            costPaid = false;
                                            break;
                                        }
                                    }

                                    if (costPaid)
                                    {
                                        foreach (Player p in gv.mod.playerList)
                                        {
                                            p.sp -= gv.mod.activeSearchSPCost;
                                        }
                                    }
                                }
                                if (costPaid)
                                {
                                    gv.mod.activeSearchDoneThisMove = true;
                                    gv.cc.doUpdate();
                                    gv.mod.activeSearchDoneThisMove = false;

                                    //interactive props that react to search (secret doors, traps, hidden info, hidden treasure)
                                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                                    //get diagonal neighbours
                                    NeighbourNE = "";
                                    NeighbourNW = "";
                                    NeighbourSE = "";
                                    NeighbourSW = "";
                                    foreach (Area a in gv.mod.moduleAreasObjects)
                                    {
                                        if (a.Filename == gv.mod.currentArea.northernNeighbourArea)
                                        {
                                            if (a.easternNeighbourArea != "none" && a.easternNeighbourArea != "" && a.easternNeighbourArea != "None")
                                            {
                                                NeighbourNE = a.easternNeighbourArea;
                                            }

                                            if (a.westernNeighbourArea != "none" && a.westernNeighbourArea != "" && a.westernNeighbourArea != "None")
                                            {
                                                NeighbourNW = a.westernNeighbourArea;
                                            }
                                        }

                                        if (a.Filename == gv.mod.currentArea.easternNeighbourArea)
                                        {
                                            if (a.northernNeighbourArea != "none" && a.northernNeighbourArea != "" && a.northernNeighbourArea != "None")
                                            {
                                                NeighbourNE = a.northernNeighbourArea;
                                            }

                                            if (a.southernNeighbourArea != "none" && a.southernNeighbourArea != "" && a.southernNeighbourArea != "None")
                                            {
                                                NeighbourSE = a.southernNeighbourArea;
                                            }
                                        }

                                        if (a.Filename == gv.mod.currentArea.southernNeighbourArea)
                                        {
                                            if (a.easternNeighbourArea != "none" && a.easternNeighbourArea != "" && a.easternNeighbourArea != "None")
                                            {
                                                NeighbourSE = a.easternNeighbourArea;
                                            }

                                            if (a.westernNeighbourArea != "none" && a.westernNeighbourArea != "" && a.westernNeighbourArea != "None")
                                            {
                                                NeighbourSW = a.westernNeighbourArea;
                                            }
                                        }

                                        if (a.Filename == gv.mod.currentArea.westernNeighbourArea)
                                        {
                                            if (a.northernNeighbourArea != "none" && a.northernNeighbourArea != "" && a.northernNeighbourArea != "None")
                                            {
                                                NeighbourNW = a.northernNeighbourArea;
                                            }

                                            if (a.southernNeighbourArea != "none" && a.southernNeighbourArea != "" && a.southernNeighbourArea != "None")
                                            {
                                                NeighbourSW = a.southernNeighbourArea;
                                            }
                                        }
                                    }

                                    bool noPropHere = true;
                                    foreach (Area a in gv.mod.moduleAreasObjects)
                                    {
                                        if (a.Filename == gv.mod.currentArea.Filename || a.Filename == gv.mod.currentArea.easternNeighbourArea || a.Filename == gv.mod.currentArea.westernNeighbourArea || a.Filename == gv.mod.currentArea.northernNeighbourArea || a.Filename == gv.mod.currentArea.southernNeighbourArea || a.Filename == NeighbourNE || a.Filename == NeighbourNW || a.Filename == NeighbourSE || a.Filename == NeighbourSW)
                                        {
                                            foreach (Prop p in a.Props)
                                            {
                                                //add all the other types here
                                                if (p.isSecretDoor || p.isTrapMain || p.isHiddenInfo)
                                                {
                                                    //skill roll script
                                                    //visible state
                                                    string traitMethod = "leader";
                                                    foreach (Trait t in gv.mod.moduleTraitsList)
                                                    {
                                                         if (t.tag.Contains(p.secretDoorTraitTag))
                                                        {
                                                            traitMethod = t.methodOfChecking;
                                                        }

                                                        if (t.tag.Contains(p.trapTraitTag))
                                                        {
                                                            traitMethod = t.methodOfChecking;
                                                        }

                                                        if (t.tag.Contains(p.infoTraitTag))
                                                        {
                                                            traitMethod = t.methodOfChecking;
                                                        }

                                                    }
                                                    int parm1 = gv.mod.selectedPartyLeader;
                                                    if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                                                    {
                                                        parm1 = gv.mod.selectedPartyLeader;
                                                    }
                                                    else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                                                    {
                                                        parm1 = -2;
                                                    }
                                                    else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                                                    {
                                                        parm1 = -3;
                                                    }
                                                    else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                                                    {
                                                        parm1 = -4;
                                                    }
                                                    else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                                                    {
                                                        parm1 = -5;
                                                    }
                                                    else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                                                    {
                                                        parm1 = -6;
                                                    }

                                                    int darkAdder = 0;
                                                    Coordinate pcCoord = new Coordinate();
                                                    Coordinate propCoord = new Coordinate();
                                                    pcCoord.X = gv.mod.PlayerLocationX;
                                                    pcCoord.Y = gv.mod.PlayerLocationY;
                                                    if (a.Filename == gv.mod.currentArea.Filename)
                                                    {
                                                        propCoord.X = p.LocationX;
                                                        propCoord.Y = p.LocationY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == gv.mod.currentArea.northernNeighbourArea)
                                                    {
                                                        propCoord.X = p.LocationX;
                                                        propCoord.Y = p.LocationY - a.MapSizeY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == NeighbourNE)
                                                    {
                                                        propCoord.X = gv.mod.currentArea.MapSizeX + p.LocationX;
                                                        propCoord.Y = p.LocationY - a.MapSizeY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == gv.mod.currentArea.easternNeighbourArea)
                                                    {
                                                        propCoord.X = gv.mod.currentArea.MapSizeX + p.LocationX;
                                                        propCoord.Y = p.LocationY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == NeighbourSE)
                                                    {
                                                        propCoord.X = gv.mod.currentArea.MapSizeX + p.LocationX;
                                                        propCoord.Y = gv.mod.currentArea.MapSizeY + p.LocationY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == gv.mod.currentArea.southernNeighbourArea)
                                                    {
                                                        propCoord.X = p.LocationX;
                                                        propCoord.Y = gv.mod.currentArea.MapSizeY + p.LocationY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == NeighbourSW)
                                                    {
                                                        propCoord.X = p.LocationX - a.MapSizeX;
                                                        propCoord.Y = gv.mod.currentArea.MapSizeY + p.LocationY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == gv.mod.currentArea.westernNeighbourArea)
                                                    {
                                                        propCoord.X = p.LocationX - a.MapSizeX; ;
                                                        propCoord.Y = p.LocationY;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    if (a.Filename == NeighbourNW)
                                                    {
                                                        propCoord.X = p.LocationX - a.MapSizeX;
                                                        propCoord.Y = p.LocationY - a.MapSizeY; ;
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                        {
                                                            darkAdder = 4;
                                                        }
                                                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                        {
                                                            darkAdder = 12;
                                                        }
                                                    }

                                                    int x3 = p.LocationX;
                                                    int y3 = p.LocationY;
                                                    
                                                    //within distance and not on border and active
                                                    if ((gv.cc.getDistance(pcCoord, propCoord) <= 1)  && (x3 < a.MapSizeX - 1 && x3 > 0 && y3 < a.MapSizeY - 1 && y3 > 0) && p.isActive)
                                                    {
                                                        //get trait name
                                                        string traitName = "none";
                                                        foreach (Trait t in gv.mod.moduleTraitsList)
                                                        {
                                                            if (t.tag.Contains(p.secretDoorTraitTag))
                                                            {
                                                                traitName = t.nameOfTraitGroup;
                                                            }

                                                            if (t.tag.Contains(p.trapTraitTag))
                                                            {
                                                                traitName = t.nameOfTraitGroup;
                                                            }
                                                             
                                                            if (t.tag.Contains(p.infoTraitTag))
                                                            {
                                                                traitName = t.nameOfTraitGroup;
                                                            }
                                                        }
                                                        noPropHere = false;
                                                        //secret door section
                                                        if (p.isSecretDoor)
                                                        {
                                                        
                                                            if (gv.sf.CheckPassSkill(parm1, p.secretDoorTraitTag, p.secretDoorDC + darkAdder, true, true))
                                                            {
                                                                //EW direction of secret door
                                                                if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[(p.LocationY + 1) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                                                {
                                                                    if (a.Tiles[y3 * a.MapSizeX + x3].isNSBridge == false)
                                                                        {
                                                                            a.Tiles[y3 * a.MapSizeX + x3].isNSBridge = true;
                                                                        }
                                                                        else
                                                                        {
                                                                            a.Tiles[y3 * a.MapSizeX + x3].isNSBridge = false;
                                                                        }
                                                                    }
                                                                //NS direction of secret door
                                                                else if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX + 1].heightLevel)
                                                                {
                                                                    if (a.Tiles[y3 * a.MapSizeX + x3].isEWBridge == false)
                                                                        {
                                                                            a.Tiles[y3 * a.MapSizeX + x3].isEWBridge = true;
                                                                        }
                                                                        else
                                                                        {
                                                                            a.Tiles[y3 * a.MapSizeX + x3].isEWBridge = false;
                                                                        }
                                                                    }
                                                                   
                                                                    gv.sf.calculateHeightShadows(x3, y3);

                                                                //center
                                                              
                                                                //NS direction of secret door
                                                                if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX + 1].heightLevel)
                                                                {
                                                                   
                                                                        bool centerIn = false; 
                                                                        for (int i = 0; i < a.newEWBridgeState.Count; i++)
                                                                        {
                                                                            if (x3 == a.changedEWBridgeTilesCoordX[i] && y3 == a.changedEWBridgeTilesCoordY[i])
                                                                            {
                                                                                centerIn = true;
                                                                                a.newEWBridgeState[i] = a.Tiles[y3 * a.MapSizeX + x3].isEWBridge;
                                                                            }
                                                                        }

                                                                        if (!centerIn)
                                                                        {
                                                                            a.newEWBridgeState.Add(gv.mod.currentArea.Tiles[y3 * a.MapSizeX + x3].isEWBridge);
                                                                            a.changedEWBridgeTilesCoordX.Add(x3);
                                                                            a.changedEWBridgeTilesCoordY.Add(y3);

                                                                        }
                                                                    }

                                                                //EW direction of secret door
                                                                if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[(p.LocationY + 1) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                                                {
                                                                    bool centerIn = false;
                                                                        for (int i = 0; i < a.newNSBridgeState.Count; i++)
                                                                        {
                                                                            if (x3 == a.changedNSBridgeTilesCoordX[i] && y3 == a.changedNSBridgeTilesCoordY[i])
                                                                            {
                                                                                centerIn = true;
                                                                                a.newNSBridgeState[i] = a.Tiles[y3 * a.MapSizeX + x3].isNSBridge;
                                                                            }
                                                                        }

                                                                        if (!centerIn)
                                                                        {
                                                                            a.newNSBridgeState.Add(a.Tiles[y3 * a.MapSizeX + x3].isNSBridge);
                                                                            a.changedNSBridgeTilesCoordX.Add(x3);
                                                                            a.changedNSBridgeTilesCoordY.Add(y3);
                                                                             
                                                                        }
                                                                    }
                                                                    //secret door has been opened, normal tile now
                                                                    p.isSecretDoor = false;

                                                                //disable any shown message connected
                                                                p.MouseOverText = "none";

                                                                //skill roll success message (A)
                                                                gv.screenMainMap.addFloatyText(x3, y3, "Success: " + traitName + " level " + (p.secretDoorDC+darkAdder-10).ToString() + " matched", "green", 2000);
                                                                gv.cc.addLogText("green", "Success: " + traitName + " level " + (p.secretDoorDC+darkAdder-10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                            }//skill check

                                                            //skill roll failed message (B)
                                                            else
                                                            {
                                                                if (darkAdder == 4)
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+4 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                                }
                                                                else if (darkAdder == 12)
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+12 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                                }
                                                                else
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                                }
                                                            }

                                                        }//secret door subsection end 

                                                        //trap subsection start
                                                        if (p.isTrapMain)
                                                        {

                                                            if (gv.sf.CheckPassSkill(parm1, p.trapTraitTag, p.trapDC + darkAdder, true, true))
                                                            {

                                                                //trap has been disarmed, normal tile now
                                                                //p.isTrapMain = false;
                                                                p.isShown = false;
                                                                p.isActive = false;

                                                                //skill roll succes s message (A)
                                                                gv.screenMainMap.addFloatyText(x3, y3, "Success: " + traitName + " level " + (p.trapDC +darkAdder-10).ToString() + " matched", "green", 2000);
                                                                gv.cc.addLogText("green", "Success: " + traitName + " level " + (p.trapDC+darkAdder-10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                            }//skill check

                                                            //skill roll failed message (B)
                                                            else
                                                            {

                                                                if (darkAdder == 4)
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+4 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                                }
                                                                else if (darkAdder == 12)
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+12 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                                }
                                                                else
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                                }
                                                                //gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC+darkAdder-10).ToString() + " required", "red", 2000);
                                                                //gv.cc.addLogText("red", "Failure: " + traitName + " level" + (p.trapDC+darkAdder-10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                            }

                                                        }//trap subsection end
                                                        
                                                        //hidden info
                                                        if (p.isHiddenInfo)
                                                        {
                                                            if (gv.sf.CheckPassSkill(parm1, p.infoTraitTag, p.infoDC + darkAdder, true, true))
                                                            {
                                                                //display the info
                                                                if (p.floatyAndLogText != "none")
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, p.floatyAndLogText, "green", 2000);
                                                                    gv.cc.addLogText("lime", p.floatyAndLogText);
                                                                    gv.cc.addLogText("white", " Success: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP."); 
                                                                }

                                                                if (p.boxText != "none")
                                                                {
                                                                    gv.sf.MessageBox(p.boxText);
                                                                    gv.cc.addLogText("white", "Success: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP.");
                                                                }

                                                                if (p.conversationName != "none")
                                                                {
                                                                    gv.mod.breakActiveSearch = true;
                                                                    gv.cc.calledConvoFromProp = true;
                                                                    gv.sf.ThisProp = p;
                                                                    gv.cc.doConversationBasedOnTag(p.conversationName);
                                                                    gv.cc.addLogText("white", "Success: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP.");
                                                                }

                                                                //set global
                                                                if (p.globalStringKey != "none")
                                                                {
                                                                    gv.sf.SetGlobalString(p.globalStringKey, p.globalStringValue);
                                                                }

                                                                //disable if show only once
                                                                if (p.showOnlyOnce)
                                                                {
                                                                    //note: the prop graphic itself shall remian visible
                                                                    p.isActive = false;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                if (darkAdder == 4)
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+4 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                                }
                                                                else if (darkAdder == 12)
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+12 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                                }
                                                                else
                                                                {
                                                                    gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                                                    gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                                }
                                                                //gv.screenMainMap.addFloatyText(x3, y3,"Failure: " + traitName + " level " + (p.infoDC + darkAdder -10).ToString() + " required", "red", 2000);
                                                                //gv.cc.addLogText("red","Failure: " + traitName + " level " + (p.infoDC + darkAdder -10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                            }
                                                        }//hidden info subsection end

                                                    }//distance and not on border
                                                }// all SPACE props end
                                            }//loop for all props in area
                                        }//check for this or neighbouring areas
                                    }//loop for all areas

                                    //no qualified prop nearby message (C) 
                                    if(noPropHere)
                                    {
                                        if (gv.mod.activeSearchSPCostPaidByByLeaderOnly)
                                        {
                                            addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "Searching...", "white", 1500);
                                            gv.cc.addLogText("white", "Searching... time passes and " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                        }
                                        else
                                        {
                                            addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "Searching...", "white", 1500);
                                            gv.cc.addLogText("white", "Searching... time passes and everybody loses " + gv.mod.activeSearchSPCost + " SP");
                                        }
                                    }
                                }// sp cost could not be paid
                                else
                                {
                                    addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "Too exhausted to search...", "red", 3000);
                                    gv.cc.addLogText("red", "Too exhausted to search...");
                                }
                            }

                            gv.mod.breakActiveSearch = false;
                            gv.mod.partyIsSearching = false;
                        }
                    }

                    else if (rtn.Equals("btnCastOnMainMap"))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            List<string> pcNames = new List<string>();
                            List<int> pcIndex = new List<int>();
                            pcNames.Add("cancel");

                            int cnt = 0;
                            foreach (Player p in gv.mod.playerList)
                            {
                                if (p.isAlive())
                                {
                                    if (hasMainMapTypeSpell(p))
                                    {
                                        pcNames.Add(p.name + " (" + p.sp + "/" + p.spMax + " SP)");
                                        pcIndex.Add(cnt);
                                    }
                                }
                                cnt++;
                            }

                            //If only one PC, do not show select PC dialog...just go to cast selector
                            if (pcIndex.Count == 1)
                            {
                                try
                                {
                                    gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                                    gv.screenCombat.spellSelectorIndex = 0;
                                    gv.screenType = "mainMapCast";
                                    return;
                                }
                                catch (Exception ex)
                                {
                                    //print error
                                    IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                    gv.errorLog(ex.ToString());
                                    return;
                                }
                            }

                            using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Caster"))
                            {
                                pcSel.ShowDialog();

                                if (pcSel.selectedIndex > 0)
                                {
                                    try
                                    {
                                        gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                        gv.screenCombat.spellSelectorIndex = 0;
                                        gv.screenType = "mainMapCast";
                                    }
                                    catch (Exception ex)
                                    {
                                        IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                        gv.errorLog(ex.ToString());
                                        //print error
                                    }
                                }
                                else if (pcSel.selectedIndex == 0) // selected "cancel"
                                {
                                    //do nothing
                                }
                            }
                        }
                    }

                    //adding lines for trait use button on main map
                    else if (rtn.Equals("btnUseTraitOnMainMap"))
                    {
                        if (!gv.mod.currentArea.isOverviewMap)
                        {
                            List<string> pcNames = new List<string>();
                            List<int> pcIndex = new List<int>();
                            pcNames.Add("cancel");

                            int cnt = 0;
                            foreach (Player p in gv.mod.playerList)
                            {
                                if (p.isAlive())
                                {
                                    if (p.knownOutsideCombatUsableTraitsTags.Count > 0)
                                    {
                                        pcNames.Add(p.name + " (" + p.sp + "/" + p.spMax + " SP)");
                                        pcIndex.Add(cnt);
                                    }
                                }
                                cnt++;
                            }

                            //If only one PC, do not show select PC dialog...just go to cast selector
                            if (pcIndex.Count == 1)
                            {
                                try
                                {
                                    gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                                    gv.screenCombat.spellSelectorIndex = 0;
                                    gv.screenType = "mainMapTraitUse";
                                    return;
                                }
                                catch (Exception ex)
                                {
                                    //print error
                                    IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                    gv.errorLog(ex.ToString());
                                    return;
                                }
                            }

                            using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Character"))
                            {
                                pcSel.ShowDialog();

                                if (pcSel.selectedIndex > 0)
                                {
                                    try
                                    {
                                        gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                        gv.screenCombat.spellSelectorIndex = 0;
                                        gv.screenType = "mainMapTraitUse";
                                    }
                                    catch (Exception ex)
                                    {
                                        IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                        gv.errorLog(ex.ToString());
                                        //print error
                                    }
                                }
                                else if (pcSel.selectedIndex == 0) // selected "cancel"
                                {
                                    //do nothing
                                }
                            }
                        }
                    }

                    else if (rtn.Equals("btnToggleArrows"))
                    {
                        foreach (IB2Panel pnl in mainUiLayout.panelList)
                        {
                            if (pnl.tag.Equals("arrowPanel"))
                            {
                                showArrows = !showArrows;
                                //hides down
                                if (pnl.currentLocY > pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlUpArrow")) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY - 1) >= actualy)))
                    //if (rtn.Equals("ctrlUpArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {

                            //maunzzz
                            bool blockMoveBecausOfCurrentScrolling = false;
                            if (gv.mod.useScrollingSystem)
                            {
                                if (gv.mod.isScrollingNow)
                                {
                                    blockMoveBecausOfCurrentScrolling = true;
                                }
                            }
                            if (!blockMoveBecausOfCurrentScrolling)
                            {
                                if (gv.mod.useScrollingSystem)
                                {
                                    gv.mod.isScrollingNow = true;
                                    gv.mod.scrollingTimer = 100;
                                    gv.mod.scrollingDirection = "up";
                                }
                                bool isTransition = gv.cc.goNorth();
                                if (!isTransition)
                                {
                                    gv.mod.breakActiveSearch = false;
                                    moveUp(true);
                                }
                            }

                            /*
                            bool isTransition = gv.cc.goNorth();
                            if (!isTransition)
                            {
                                bool bumpPropExists = false;
                                bool bumpTriggerExists = false;
                                Trigger bumpTrigger = new Trigger();
                                Prop bumpProp = new Prop();

                                if (gv.mod.PlayerLocationY > 0)
                                {
                                    foreach (Trigger t in gv.mod.currentArea.Triggers)
                                    {
                                        //migh add isBumpTRigger requirement here
                                        if (t.Enabled)
                                        {
                                            foreach (Coordinate p in t.TriggerSquaresList)
                                            {
                                                if ((p.X == gv.mod.PlayerLocationX) && (p.Y == gv.mod.PlayerLocationY - 1))
                                                {
                                                    bumpTriggerExists = true;
                                                    bumpTrigger = t;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    foreach (Prop p in gv.mod.currentArea.Props)
                                    {
                                        if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                        {
                                            if ((p.LocationX == gv.mod.PlayerLocationX) && (p.LocationY == gv.mod.PlayerLocationY - 1))
                                            {
                                                bumpPropExists = true;
                                                bumpProp = p;
                                                gv.sf.ThisProp = bumpProp;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (gv.mod.PlayerLocationY > 0)
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY - 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isSecretPassage)
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationY--;
                                            gv.mod.PlayerLocationY--;
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationY--;
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                    }
                                    else if (bumpPropExists || bumpTriggerExists)
                                    {
                                        if (bumpPropExists)
                                        {
                                            if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                            {
                                                gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                            }

                                            if (bumpProp.ConversationWhenOnPartySquare != "none")
                                            {
                                                //called from prop add?
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                            }

                                            if (bumpProp.EncounterWhenOnPartySquare != "none")
                                            {
                                                gv.mod.EncounterOfTurnDone = true;
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                            }

                                            if (bumpProp.scriptFilename != "none")
                                            {
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                                //code for floaty shown on prop upon script activation
                                                if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                                {
                                                    gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                                }

                                                //code for log, to do
                                                if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                                {
                                                    gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                                }

                                                if (bumpProp.onlyOnce)
                                                {
                                                    bumpProp.isShown = false;
                                                    bumpProp.isActive = false;
                                                }
                                            }
                                        }
                                        else if (bumpTriggerExists)
                                        {
                                            gv.cc.doBumpTrigger(bumpTrigger);
                                        }

                                        //update could be wrong here?
                                        gv.cc.doUpdate();
                                    }
                                }
                            }*/
                        }
                    }
                    else if ((rtn.Equals("ctrlDownArrow")) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY + 1) <= actualy)))
                    //else if (rtn.Equals("ctrlDownArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool blockMoveBecausOfCurrentScrolling = false;
                            if (gv.mod.useScrollingSystem)
                            {
                                if (gv.mod.isScrollingNow)
                                {
                                    blockMoveBecausOfCurrentScrolling = true;
                                }
                            }
                            if (!blockMoveBecausOfCurrentScrolling)
                            {
                                if (gv.mod.useScrollingSystem)
                                {
                                    gv.mod.isScrollingNow = true;
                                    gv.mod.scrollingTimer = 100;
                                    gv.mod.scrollingDirection = "down";
                                }
                                bool isTransition = gv.cc.goSouth();
                                if (!isTransition)
                                {
                                    gv.mod.breakActiveSearch = false;
                                    moveDown(true);
                                }
                            }
                            /*
                            bool isTransition = gv.cc.goSouth();
                            if (!isTransition)
                            {
                                int mapheight = gv.mod.currentArea.MapSizeY;
                                bool bumpPropExists = false;
                                bool bumpTriggerExists = false;
                                Trigger bumpTrigger = new Trigger();
                                Prop bumpProp = new Prop();

                                if (gv.mod.PlayerLocationY < (mapheight - 1))
                                {
                                    foreach (Trigger t in gv.mod.currentArea.Triggers)
                                    {
                                        //migh add isBumpTRigger requirement here
                                        if (t.Enabled)
                                        {
                                            foreach (Coordinate p in t.TriggerSquaresList)
                                            {
                                                if ((p.X == gv.mod.PlayerLocationX) && (p.Y == gv.mod.PlayerLocationY + 1))
                                                {
                                                    bumpTriggerExists = true;
                                                    bumpTrigger = t;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    foreach (Prop p in gv.mod.currentArea.Props)
                                    {
                                        if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                        {
                                            if ((p.LocationX == gv.mod.PlayerLocationX) && (p.LocationY == gv.mod.PlayerLocationY + 1))
                                            {
                                                bumpPropExists = true;
                                                bumpProp = p;
                                                gv.sf.ThisProp = bumpProp;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (gv.mod.PlayerLocationY < (mapheight - 1))
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY + 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isSecretPassage)
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationY++;
                                            gv.mod.PlayerLocationY++;
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationY++;
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                    }
                                    else if (bumpPropExists || bumpTriggerExists)
                                    {
                                        if (bumpPropExists)
                                        {
                                            if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                            {
                                                gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                            }

                                            if (bumpProp.ConversationWhenOnPartySquare != "none")
                                            {
                                                //called from prop add?
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                            }

                                            if (bumpProp.EncounterWhenOnPartySquare != "none")
                                            {
                                                gv.mod.EncounterOfTurnDone = true;
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                            }

                                                if (bumpProp.scriptFilename != "none")
                                                {
                                                    gv.sf.ThisProp = bumpProp;
                                                    gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                                    //code for floaty shown on prop upon script activation
                                                    if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                                    {
                                                        gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                                    }

                                                    //code for log, to do
                                                    if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                                    {
                                                        gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                                    }

                                                    if (bumpProp.onlyOnce)
                                                    {
                                                        bumpProp.isShown = false;
                                                        bumpProp.isActive = false;
                                                    }
                                                }
                                            }
                                        else if (bumpTriggerExists)
                                        {
                                            gv.cc.doBumpTrigger(bumpTrigger);
                                        }

                                        //update could be wrong here?
                                        gv.cc.doUpdate();
                                    }
                                }
                            }*/
                        }
                    }
                    else if ((rtn.Equals("ctrlLeftArrow")) || (((gv.mod.PlayerLocationX - 1) >= actualx) && (gv.mod.PlayerLocationY == actualy)))
                    //else if (rtn.Equals("ctrlLeftArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool blockMoveBecausOfCurrentScrolling = false;
                            if (gv.mod.useScrollingSystem)
                            {
                                if (gv.mod.isScrollingNow)
                                {
                                    blockMoveBecausOfCurrentScrolling = true;
                                }
                            }
                            if (!blockMoveBecausOfCurrentScrolling)
                            {
                                if (gv.mod.useScrollingSystem)
                                {
                                    gv.mod.isScrollingNow = true;
                                    gv.mod.scrollingTimer = 100;
                                    gv.mod.scrollingDirection = "left";
                                }
                                bool isTransition = gv.cc.goWest();
                                if (!isTransition)
                                {
                                    gv.mod.breakActiveSearch = false;
                                    moveLeft(true);
                                }
                            }
                            /*
                            bool isTransition = gv.cc.goWest();
                            if (!isTransition)
                            {
                                bool bumpPropExists = false;
                                bool bumpTriggerExists = false;
                                Trigger bumpTrigger = new Trigger();
                                Prop bumpProp = new Prop();

                                if (gv.mod.PlayerLocationX > 0)
                                {
                                    foreach (Trigger t in gv.mod.currentArea.Triggers)
                                    {
                                        //migh add isBumpTRigger requirement here
                                        if (t.Enabled)
                                        {
                                            foreach (Coordinate p in t.TriggerSquaresList)
                                            {
                                                if ((p.X == gv.mod.PlayerLocationX - 1) && (p.Y == gv.mod.PlayerLocationY))
                                                {
                                                    bumpTriggerExists = true;
                                                    bumpTrigger = t;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    foreach (Prop p in gv.mod.currentArea.Props)
                                    {
                                        if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                        {
                                            if ((p.LocationX == gv.mod.PlayerLocationX - 1) && (p.LocationY == gv.mod.PlayerLocationY))
                                            {
                                                bumpPropExists = true;
                                                bumpProp = p;
                                                gv.sf.ThisProp = bumpProp;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (gv.mod.PlayerLocationX > 0)
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX - 1].isSecretPassage)
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationX--;
                                            gv.mod.PlayerLocationX--;
                                            foreach (Player pc in gv.mod.playerList)
                                            {
                                                if (!pc.combatFacingLeft)
                                                {
                                                    pc.combatFacingLeft = true;
                                                }
                                            }
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationX--;
                                            foreach (Player pc in gv.mod.playerList)
                                            {
                                                if (!pc.combatFacingLeft)
                                                {
                                                    pc.combatFacingLeft = true;
                                                }
                                            }
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                    }
                                    else if (bumpPropExists || bumpTriggerExists)
                                    {
                                        if (bumpPropExists)
                                        {
                                            if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                            {
                                                gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                            }

                                            if (bumpProp.ConversationWhenOnPartySquare != "none")
                                            {
                                                //called from prop add?
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                            }

                                            if (bumpProp.EncounterWhenOnPartySquare != "none")
                                            {
                                                gv.mod.EncounterOfTurnDone = true;
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                            }
                                            if (bumpProp.scriptFilename != "none")
                                            {
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                                //code for floaty shown on prop upon script activation
                                                if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                                {
                                                    gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                                }

                                                //code for log, to do
                                                if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                                {
                                                    gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                                }

                                                if (bumpProp.onlyOnce)
                                                {
                                                    bumpProp.isShown = false;
                                                    bumpProp.isActive = false;
                                                }
                                            }
                                        }
                                        else if (bumpTriggerExists)
                                        {
                                            gv.cc.doBumpTrigger(bumpTrigger);
                                        }

                                        //update could be wrong here?
                                        gv.cc.doUpdate();
                                    }
                                }
                            }*/
                        }
                    }
                    else if ((rtn.Equals("ctrlRightArrow")) || (((gv.mod.PlayerLocationX + 1) <= actualx) && (gv.mod.PlayerLocationY == actualy)))
                    //else if (rtn.Equals("ctrlRightArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool blockMoveBecausOfCurrentScrolling = false;
                            if (gv.mod.useScrollingSystem)
                            {
                                if (gv.mod.isScrollingNow)
                                {
                                    blockMoveBecausOfCurrentScrolling = true;
                                }
                            }
                            if (!blockMoveBecausOfCurrentScrolling)
                            {
                                if (gv.mod.useScrollingSystem)
                                {
                                    gv.mod.isScrollingNow = true;
                                    gv.mod.scrollingTimer = 100;
                                    gv.mod.scrollingDirection = "right";
                                }
                                bool isTransition = gv.cc.goEast();
                                if (!isTransition)
                                {
                                    gv.mod.breakActiveSearch = false;
                                    moveRight(true);
                                }
                            }
                            /*
                            bool isTransition = gv.cc.goEast();
                            if (!isTransition)
                            {
                                int mapwidth = gv.mod.currentArea.MapSizeX;
                                bool bumpPropExists = false;
                                bool bumpTriggerExists = false;
                                Trigger bumpTrigger = new Trigger();
                                Prop bumpProp = new Prop();

                                if (gv.mod.PlayerLocationX < (mapwidth - 1))
                                {
                                    foreach (Trigger t in gv.mod.currentArea.Triggers)
                                    {
                                        //migh add isBumpTRigger requirement here
                                        if (t.Enabled)
                                        {
                                            foreach (Coordinate p in t.TriggerSquaresList)
                                            {
                                                if ((p.X == gv.mod.PlayerLocationX + 1) && (p.Y == gv.mod.PlayerLocationY))
                                                {
                                                    bumpTriggerExists = true;
                                                    bumpTrigger = t;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    foreach (Prop p in gv.mod.currentArea.Props)
                                    {
                                        if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                                        {
                                            if ((p.LocationX == gv.mod.PlayerLocationX + 1) && (p.LocationY == gv.mod.PlayerLocationY))
                                            {
                                                bumpPropExists = true;
                                                bumpProp = p;
                                                gv.sf.ThisProp = bumpProp;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (gv.mod.PlayerLocationX < (mapwidth - 1))
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX + 1].isSecretPassage)
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationX++;
                                            gv.mod.PlayerLocationX++;
                                            foreach (Player pc in gv.mod.playerList)
                                            {
                                                if (pc.combatFacingLeft)
                                                {
                                                    pc.combatFacingLeft = false;
                                                }
                                            }
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                        else
                                        {
                                            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                            gv.mod.PlayerLocationX++;
                                            foreach (Player pc in gv.mod.playerList)
                                            {
                                                if (pc.combatFacingLeft)
                                                {
                                                    pc.combatFacingLeft = false;
                                                }
                                            }
                                            gv.mod.breakActiveSearch = false;
                                            gv.cc.doUpdate();
                                        }
                                    }
                                    else if (bumpPropExists || bumpTriggerExists)
                                    {
                                        if (bumpPropExists)
                                        {
                                            if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                                            {
                                                gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                                            }

                                            if (bumpProp.ConversationWhenOnPartySquare != "none")
                                            {
                                                //called from prop add?
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                                            }

                                            if (bumpProp.EncounterWhenOnPartySquare != "none")
                                            {
                                                gv.mod.EncounterOfTurnDone = true;
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                                            }
                                            if (bumpProp.scriptFilename != "none")
                                            {
                                                gv.sf.ThisProp = bumpProp;
                                                gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                                                //code for floaty shown on prop upon script activation
                                                if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                                                {
                                                    gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                                                }

                                                //code for log, to do
                                                if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                                                {
                                                    gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                                                }

                                                if (bumpProp.onlyOnce)
                                                {
                                                    bumpProp.isShown = false;
                                                    bumpProp.isActive = false;
                                                }
                                            }
                                        }
                                        else if (bumpTriggerExists)
                                        {
                                            gv.cc.doBumpTrigger(bumpTrigger);
                                        }

                                        //update could be wrong here?
                                        gv.cc.doUpdate();
                                    }
                                }
                            }*/
                        }
                    }
                    break;
            }
        }
        //to test new layout system, change this to onTouchMainOld
        /*public void onTouchMainOld(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            gv.cc.ctrlUpArrow.glowOn = false;
            gv.cc.ctrlDownArrow.glowOn = false;
            gv.cc.ctrlLeftArrow.glowOn = false;
            gv.cc.ctrlRightArrow.glowOn = false;
            btnParty.glowOn = false;
            gv.cc.btnInventory.glowOn = false;
            btnJournal.glowOn = false;
            btnSettings.glowOn = false;
            btnSave.glowOn = false;
            btnCastOnMainMap.glowOn = false;
            btnWait.glowOn = false;

            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;

                    //Draw Floaty Text On Mouse Over Prop
                    int gridx = (int)e.X / gv.squareSize;
                    int gridy = (int)e.Y / gv.squareSize;
                    int actualX = gv.mod.PlayerLocationX + (gridx - gv.playerOffsetX);
                    int actualY = gv.mod.PlayerLocationY + (gridy - gv.playerOffsetY);
                    gv.cc.floatyText = "";
                    if (IsTouchInMapWindow(gridx, gridy))
                    {
                        foreach (Prop p in gv.mod.currentArea.Props)
                        {
                            if ((p.LocationX == actualX) && (p.LocationY == actualY))
                            {
                                if (!p.MouseOverText.Equals("none"))
                                {
                                    gv.cc.floatyText = p.MouseOverText;
                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, gridy * gv.squareSize);
                                }
                            }
                        }
                    }

                    

                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlRightArrow.glowOn = true;
                    }
                    else if (btnParty.getImpact(x, y))
                    {
                        btnParty.glowOn = true;
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        gv.cc.btnInventory.glowOn = true;
                    }
                    else if (btnJournal.getImpact(x, y))
                    {
                        btnJournal.glowOn = true;
                    }
                    else if (btnSettings.getImpact(x, y))
                    {
                        btnSettings.glowOn = true;
                    }
                    else if (btnSave.getImpact(x, y))
                    {
                        if (gv.mod.allowSave)
                        {
                            btnSave.glowOn = true;
                        }
                    }
                    else if (btnCastOnMainMap.getImpact(x, y))
                    {
                        btnCastOnMainMap.glowOn = true;
                    }
                    else if (btnWait.getImpact(x, y))
                    {
                        btnWait.glowOn = true;
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;
                    int gridX = (int)e.X / gv.squareSize;
                    int gridY = (int)e.Y / gv.squareSize;
                    int actualx = gv.mod.PlayerLocationX + (gridX - gv.playerOffsetX);
                    int actualy = gv.mod.PlayerLocationY + (gridY - gv.playerOffsetY);

                    gv.cc.ctrlUpArrow.glowOn = false;
                    gv.cc.ctrlDownArrow.glowOn = false;
                    gv.cc.ctrlLeftArrow.glowOn = false;
                    gv.cc.ctrlRightArrow.glowOn = false;
                    btnParty.glowOn = false;
                    gv.cc.btnInventory.glowOn = false;
                    btnJournal.glowOn = false;
                    btnSettings.glowOn = false;
                    btnSave.glowOn = false;
                    btnCastOnMainMap.glowOn = false;
                    btnWait.glowOn = false;

                    if (tglGrid.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglGrid.toggleOn)
                        {
                            tglGrid.toggleOn = false;
                            gv.mod.map_showGrid = false;
                        }
                        else
                        {
                            tglGrid.toggleOn = true;
                            gv.mod.map_showGrid = true;
                        }
                    }

                    if (tglInteractionState.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglInteractionState.toggleOn)
                        {
                            tglInteractionState.toggleOn = false;
                            gv.mod.showInteractionState = false;
                            gv.cc.addLogText("yellow", "Hide info about interaction state of NPC and creatures (encounter = red, mandatory conversation = orange and optional conversation = green");
                        }
                        else
                        {
                            tglInteractionState.toggleOn = true;
                            gv.mod.showInteractionState = true;
                            gv.cc.addLogText("lime", "Show info about interaction state of NPC and creatures (encounter = red, mandatory conversation = orange and optional conversation = green");
                        }
                    }

                    if (tglAvoidConversation.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglAvoidConversation.toggleOn)
                        {
                            tglAvoidConversation.toggleOn = false;
                            gv.mod.avoidInteraction = false;
                            gv.cc.addLogText("lime", "Normal move gv.mode: party does all possible conversations");
                        }
                        else
                        {
                            tglAvoidConversation.toggleOn = true;
                            gv.mod.avoidInteraction = true;
                            gv.cc.addLogText("yellow", "In a hurry: Party is avoiding all conversations that are not mandatory");
                        }
                    }


                    if (tglClock.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglClock.toggleOn)
                        {
                            tglClock.toggleOn = false;
                        }
                        else
                        {
                            tglClock.toggleOn = true;
                        }
                    }
                    if (gv.cc.tglSound.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (gv.cc.tglSound.toggleOn)
                        {
                            gv.cc.tglSound.toggleOn = false;
                            gv.mod.playMusic = false;
                            gv.mod.playSoundFx = false;
                            gv.screenCombat.tglSoundFx.toggleOn = false;
                            gv.stopMusic();
                            gv.stopAmbient();
                            gv.cc.addLogText("lime", "Music Off, SoundFX Off");
                        }
                        else
                        {
                            gv.cc.tglSound.toggleOn = true;
                            gv.mod.playMusic = true;
                            gv.mod.playSoundFx = true;
                            gv.screenCombat.tglSoundFx.toggleOn = true;
                            gv.startMusic();
                            gv.startAmbient();
                            gv.cc.addLogText("lime", "Music On, SoundFX On");
                        }
                    }
                    if (tglFullParty.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglFullParty.toggleOn)
                        {
                            tglFullParty.toggleOn = false;
                            gv.cc.addLogText("lime", "Show Party Leader");
                        }
                        else
                        {
                            tglFullParty.toggleOn = true;
                            gv.cc.addLogText("lime", "Show Full Party");
                        }
                    }
                    //if ((tglMiniMap.getImpact(x, y)) && (gv.mod.currentArea.IsWorldMap))
                    if (tglMiniMap.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglMiniMap.toggleOn)
                        {
                            tglMiniMap.toggleOn = false;
                            gv.cc.addLogText("lime", "Hide Mini Map");
                        }
                        else
                        {
                            tglMiniMap.toggleOn = true;
                            gv.cc.addLogText("lime", "Show Mini Map");
                        }
                    }
                    if ((gv.cc.ctrlUpArrow.getImpact(x, y)) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY - 1) == actualy)))
                    {
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            if (gv.mod.PlayerLocationY > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1) == false)
                                {
                                    
                                    //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationY--;
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                        //else
                        //{
                            //gv.cc.doUpdate();
                        //}
                    }
                    else if ((gv.cc.ctrlDownArrow.getImpact(x, y)) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY + 1) == actualy)))
                    {

                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            int mapheight = gv.mod.currentArea.MapSizeY;
                            if (gv.mod.PlayerLocationY < (mapheight - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1) == false)
                                {
                                   
                                        //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationY++;
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if ((gv.cc.ctrlLeftArrow.getImpact(x, y)) || (((gv.mod.PlayerLocationX - 1) == actualx) && (gv.mod.PlayerLocationY == actualy)))
                    {
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            if (gv.mod.PlayerLocationX > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY) == false)
                                {

                                        //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationX--;
                                    if (!gv.mod.playerList[0].combatFacingLeft)
                                    {
                                        //TODO							    //gv.mod.partyTokenBitmap = gv.cc.flip(gv.mod.partyTokenBitmap);
                                    }
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        if (!pc.combatFacingLeft)
                                        {
                                            pc.combatFacingLeft = true;
                                        }
                                    }
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if ((gv.cc.ctrlRightArrow.getImpact(x, y)) || (((gv.mod.PlayerLocationX + 1) == actualx) && (gv.mod.PlayerLocationY == actualy)))
                    {
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            int mapwidth = gv.mod.currentArea.MapSizeX;
                            if (gv.mod.PlayerLocationX < (mapwidth - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY) == false)
                                {
                                    
                                        //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationX++;
                                    if (gv.mod.playerList[0].combatFacingLeft)
                                    {
                                        //TODO							    gv.mod.partyTokenBitmap = gv.cc.flip(gv.mod.partyTokenBitmap);
                                    }
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        if (pc.combatFacingLeft)
                                        {
                                            pc.combatFacingLeft = false;
                                        }
                                    }
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if (btnParty.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        
                        /*
                        //temporary weather effect object creation code
                        //hurghxxx
                        gv.cc.doIBScriptBasedOnFilename("cloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("cloudsA", "cloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("cloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("cloudsB", "cloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("cloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("cloudsC", "cloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("lightCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightCloudsA", "lightCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("lightCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightCloudsB", "lightCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("lightCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightCloudsC", "lightCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyCloudsA", "heavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyCloudsB", "heavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyCloudsC", "heavyCloudsC1001");

                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsA", "lightRainWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsB", "lightRainWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsC", "lightRainWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsA", "rainWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsB", "rainWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsC", "rainWithCloudsC1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsA", "lightSnowWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsB", "lightSnowWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsC", "lightSnowWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsA", "snowWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsB", "snowWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsC", "snowWithCloudsC1001");


                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsAShowers", "lightRainWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsBShowers", "lightRainWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsCShowers", "lightRainWithCloudsCShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsAShowers", "rainWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsBShowers", "rainWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsCShowers", "rainWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsAShowers", "lightSnowWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsBShowers", "lightSnowWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsCShowers", "lightSnowWithCloudsCShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsAShowers", "snowWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsBShowers", "snowWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsCShowers", "snowWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsA", "rainWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsB", "rainWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsC", "rainWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsAShowers", "rainWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsBShowers", "rainWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsCShowers", "rainWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsA", "snowWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsB", "snowWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsC", "snowWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsAShowers", "snowWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsBShowers", "snowWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsCShowers", "snowWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsA", "heavyRainWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsB", "heavyRainWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsC", "heavyRainWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsAShowers", "heavyRainWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsBShowers", "heavyRainWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsCShowers", "heavyRainWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsA", "heavySnowWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsB", "heavySnowWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsC", "heavySnowWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsAShowers", "heavySnowWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsBShowers", "heavySnowWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsCShowers", "heavySnowWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsA", "heavyRainWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsB", "heavyRainWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsC", "heavyRainWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsAShowers", "heavyRainWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsBShowers", "heavyRainWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsCShowers", "heavyRainWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsA", "heavySnowWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsB", "heavySnowWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsC", "heavySnowWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsAShowers", "heavySnowWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsBShowers", "heavySnowWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsCShowers", "heavySnowWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsAAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsAAndLightning", "heavyRainWithCloudsAAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsBAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsBAndLightning", "heavyRainWithCloudsBAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsCAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsCAndLightning", "heavyRainWithCloudsCAndLightning1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsAAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsAAndLightning", "heavySnowWithCloudsAAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsBAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsBAndLightning", "heavySnowWithCloudsBAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsCAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsCAndLightning", "heavySnowWithCloudsCAndLightning1001");

                        gv.cc.doIBScriptBasedOnFilename("lightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightFog", "lightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("fog", "fullScreenEffectScript");
                        buildWeatherEffectObject("fog", "fog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyFog", "heavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("lightRainWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithLightFog", "lightRainWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithFog", "lightRainWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithHeavyFog", "lightRainWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("rainWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithLightFog", "rainWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithFog", "rainWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyFog", "rainWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithLightFog", "heavyRainWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithFog", "heavyRainWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyFog", "heavyRainWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("lightRainWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithLightFogShowers", "lightRainWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithFogShowers", "lightRainWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithHeavyFogShowers", "lightRainWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("rainWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithLightFogShowers", "rainWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithFogShowers", "rainWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyFogShowers", "rainWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithLightFogShowers", "heavyRainWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithFogShowers", "heavyRainWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyFogShowers", "heavyRainWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithLightFogAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithLightFogAndLightning", "heavyRainWithLightFogAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithFogAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithFogAndLightning", "heavyRainWithFogAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyFogAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyFogAndLightning", "heavyRainWithHeavyFogAndLightning1001");



                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithLightFog", "lightSnowWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithFog", "lightSnowWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithHeavyFog", "lightSnowWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("snowWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithLightFog", "snowWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithFog", "snowWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyFog", "snowWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithLightFog", "heavySnowWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithFog", "heavySnowWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyFog", "heavySnowWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithLightFogShowers", "lightSnowWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithFogShowers", "lightSnowWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithHeavyFogShowers", "lightSnowWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("snowWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithLightFogShowers", "snowWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithFogShowers", "snowWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyFogShowers", "snowWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithLightFogShowers", "heavySnowWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithFogShowers", "heavySnowWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyFogShowers", "heavySnowWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSandStorm", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSandStorm", "lightSandStorm1001");
                        gv.cc.doIBScriptBasedOnFilename("sandStorm", "fullScreenEffectScript");
                        buildWeatherEffectObject("sandStorm", "sandStorm1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySandStorm", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySandStorm", "heavySandStorm1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySandStormAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySandStormAndLightning", "heavySandStormAndLightning1001");

                        gv.cc.doIBScriptBasedOnFilename("clear", "fullScreenEffectScript");
                        buildWeatherEffectObject("clear", "clear1001");
                        
                        //temporara end
                        */
        /*
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if ((gv.cc.ptrPc0.getImpact(x, y)) && (gv.mod.playerList.Count > 0))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 0;
                                    gv.cc.partyScreenPcIndex = 0;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 0;
                                    gv.cc.partyScreenPcIndex = 0;
                                }
                            }
                            else if ((gv.cc.ptrPc1.getImpact(x, y)) && (gv.mod.playerList.Count > 1))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 1;
                                    gv.cc.partyScreenPcIndex = 1;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 1;
                                    gv.cc.partyScreenPcIndex = 1;
                                }
                            }
                            else if ((gv.cc.ptrPc2.getImpact(x, y)) && (gv.mod.playerList.Count > 2))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 2;
                                    gv.cc.partyScreenPcIndex = 2;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 2;
                                    gv.cc.partyScreenPcIndex = 2;
                                }
                            }
                            else if ((gv.cc.ptrPc3.getImpact(x, y)) && (gv.mod.playerList.Count > 3))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 3;
                                    gv.cc.partyScreenPcIndex = 3;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 3;
                                    gv.cc.partyScreenPcIndex = 3;
                                }
                            }
                            else if ((gv.cc.ptrPc4.getImpact(x, y)) && (gv.mod.playerList.Count > 4))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 4;
                                    gv.cc.partyScreenPcIndex = 4;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 4;
                                    gv.cc.partyScreenPcIndex = 4;
                                }
                            }
                            else if ((gv.cc.ptrPc5.getImpact(x, y)) && (gv.mod.playerList.Count > 5))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 5;
                                    gv.cc.partyScreenPcIndex = 5;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 5;
                                    gv.cc.partyScreenPcIndex = 5;
                                }
                            }
                            else if (gv.cc.btnInventory.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.screenType = "inventory";
                                gv.screenInventory.resetInventory();
                                gv.cc.tutorialMessageInventory(false);
                            }
                            else if (btnJournal.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.screenType = "journal";
                            }
                            else if (btnSettings.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.cc.doSettingsDialogs();
                            }
                            else if (btnSave.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                if (gv.mod.allowSave)
                                {
                                    gv.cc.doSavesDialog();
                                }
                            }
                            else if (btnWait.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.cc.doUpdate();
                            }
                            else if (btnCastOnMainMap.getImpact(x, y))
                            {

                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}

                                List<string> pcNames = new List<string>();
                                List<int> pcIndex = new List<int>();
                                pcNames.Add("cancel");

                                int cnt = 0;
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (hasMainMapTypeSpell(p))
                                    {
                                        pcNames.Add(p.name);
                                        pcIndex.Add(cnt);
                                    }
                                    cnt++;
                                }

                                //If only one PC, do not show select PC dialog...just go to cast selector
                                if (pcIndex.Count == 1)
                                {
                                    try
                                    {
                                        gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                                        gv.screenCombat.spellSelectorIndex = 0;
                                        gv.screenType = "mainMapCast";
                                        return;
                                    }
                                    catch (Exception ex)
                                    {
                                        //print error
                                        IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                        gv.errorLog(ex.ToString());
                                        return;
                                    }
                                }

                                using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Caster"))
                                {
                                    pcSel.ShowDialog();

                                    if (pcSel.selectedIndex > 0)
                                    {
                                        try
                                        {
                                            gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                            gv.screenCombat.spellSelectorIndex = 0;
                                            gv.screenType = "mainMapCast";
                                        }
                                        catch (Exception ex)
                                        {
                                            IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                            gv.errorLog(ex.ToString());
                                            //print error
                                        }
                                    }
                                    else if (pcSel.selectedIndex == 0) // selected "cancel"
                                    {
                                        //do nothing
                                    }
                                }
                            }
                            break;
                    }
                }*/

        public void onKeyDown(KeyEventArgs e)
        {
            /*
            if (e.KeyCode == Keys.F)
            {
                //krah krah
                //gv.mod.interfaceFadeCounter = 20;
                gv.mod.interfaceCounterHalted = true;
                if (!hideClock)
                {
                    //hideClock = true;
                }
                else
                {
                    hideClock = false;
                }
                foreach (IB2Panel pnl in mainUiLayout.panelList)
                {

                    //hides right
                    if (pnl.hidingXIncrement > 0)
                    {
                        if (pnl.currentLocX > pnl.shownLocX)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            //pnl.hiding = true;
                        }
                    }
                    //hides down
                    else if (pnl.hidingYIncrement > 0)
                    {
                        if (pnl.currentLocY > pnl.shownLocY)
                        {
                            if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                            {
                                continue;
                            }
                            pnl.showing = true;
                        }
                        else
                        {
                            //pnl.hiding = true;
                        }
                    }
                    //hides up
                    else if (pnl.hidingYIncrement < 0)
                    {
                        if (pnl.currentLocY < pnl.shownLocY)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            //pnl.hiding = true;
                        }
                    }
                }
            }
            //gv.mod.interfaceCounterHalted = true;
            */
        }

        public void onKeyUp(Keys keyData)
        {
            if ((moveDelay()) && (finishedMove))
            {
                if (keyData == Keys.D4 | keyData == Keys.NumPad4)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "left";
                        }
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveLeft(true);
                        }
                    }
                }
                else if (keyData == Keys.ShiftKey)
                {
                    //krah krah
                    //gv.mod.interfaceFadeCounter = 0;
                }
                else if (keyData == Keys.Left && showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "left";
                        }
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveLeft(true);
                        }
                    }
                }
                else if (keyData == Keys.M)
                {
                    if (gv.mod.allowSave)
                    {
                        gv.cc.doSavesDialog();
                    }
                }
                else if (keyData == Keys.A && !showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "left";
                        }
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveLeft(true);
                        }
                    }
                }
                else if (keyData == Keys.D6 | keyData == Keys.NumPad6)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "right";
                        }
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveRight(true);
                        }
                    }
                }
                else if (keyData == Keys.Right && showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "right";
                        }
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveRight(true);
                        }
                    }
                }
                else if (keyData == Keys.D && !showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "right";
                        }
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveRight(true);
                        }
                    }
                }
                else if (keyData == Keys.D8 | keyData == Keys.NumPad8)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "up";
                        }
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveUp(true);
                        }
                    }
                }
                else if (keyData == Keys.Up && showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "up";
                        }
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveUp(true);
                        }
                    }
                }
                else if (keyData == Keys.W && !showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "up";
                        }
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveUp(true);
                        }
                    }
                }
                else if (keyData == Keys.D2 | keyData == Keys.NumPad2)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "down";
                        }
                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveDown(true);
                        }
                    }
                }
                else if (keyData == Keys.Down && showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "down";
                        }
                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveDown(true);
                        }
                    }
                }
                else if (keyData == Keys.S && !showMoveKeys)
                {
                    bool blockMoveBecausOfCurrentScrolling = false;
                    if (gv.mod.useScrollingSystem)
                    {
                        if (gv.mod.isScrollingNow)
                        {
                            blockMoveBecausOfCurrentScrolling = true;
                        }
                    }
                    if (!blockMoveBecausOfCurrentScrolling)
                    {
                        if (gv.mod.useScrollingSystem)
                        {
                            gv.mod.isScrollingNow = true;
                            gv.mod.scrollingTimer = 100;
                            gv.mod.scrollingDirection = "down";
                        }
                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            gv.mod.breakActiveSearch = false;
                            moveDown(true);
                        }
                    }
                }
                //else { }
            }

            if (keyData == Keys.E)
            {

                if (gv.mod.hideInterfaceNextMove)
                {
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {
                            
                            //hides up
                            if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }

                if (!gv.mod.showPartyToken)
                {
                    bool leaderFound = false;
                    while (!leaderFound)
                    {
                        gv.mod.selectedPartyLeader++;
                        if (gv.mod.selectedPartyLeader >= gv.mod.playerList.Count)
                        {
                            gv.mod.selectedPartyLeader = 0;
                        }
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp >= 0)
                        {
                            leaderFound = true;
                        }
                    }
                    gv.mod.permanentPartyText = gv.mod.playerList[gv.mod.selectedPartyLeader].name + " (" + gv.mod.playerList[gv.mod.selectedPartyLeader].sp + " SP)";
                    //addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.playerList[gv.mod.selectedPartyLeader].name, "green", 700);

                    gv.cc.doPropStealth();

                    updateTraitsPanel();
                }
            }

            if (keyData == Keys.Right && !showMoveKeys)
            {
                if (gv.mod.hideInterfaceNextMove)
                {
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {

                            //hides up
                            if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }
                if (!gv.mod.showPartyToken)
                {
                    bool leaderFound = false;
                    while (!leaderFound)
                    {
                        gv.mod.selectedPartyLeader++;
                        if (gv.mod.selectedPartyLeader >= gv.mod.playerList.Count)
                        {
                            gv.mod.selectedPartyLeader = 0;
                        }
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp >= 0)
                         {
                            leaderFound = true;
                        }
                    }
                    //addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.playerList[gv.mod.selectedPartyLeader].name, "green", 700);
                    gv.mod.permanentPartyText = gv.mod.playerList[gv.mod.selectedPartyLeader].name + " (" + gv.mod.playerList[gv.mod.selectedPartyLeader].sp + " SP)";
                    gv.cc.doPropStealth();
                    updateTraitsPanel();
                }
            }

            if (keyData == Keys.D && showMoveKeys)
            {
                if (gv.mod.hideInterfaceNextMove)
                {
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {

                            //hides up
                            if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }
                if (!gv.mod.showPartyToken)
                {
                    bool leaderFound = false;
                    while (!leaderFound)
                    {
                        gv.mod.selectedPartyLeader++;
                        if (gv.mod.selectedPartyLeader >= gv.mod.playerList.Count)
                        {
                            gv.mod.selectedPartyLeader = 0;
                        }
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp >= 0)
                        {
                            leaderFound = true;
                        }
                    }
                    //addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.playerList[gv.mod.selectedPartyLeader].name, "green", 700);
                    gv.mod.permanentPartyText = gv.mod.playerList[gv.mod.selectedPartyLeader].name + " (" + gv.mod.playerList[gv.mod.selectedPartyLeader].sp + " SP)";
                    gv.cc.doPropStealth();
                    updateTraitsPanel();
                }
            }

            if (keyData == Keys.Q)
            {
                if (gv.mod.hideInterfaceNextMove)
                {
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {

                            //hides up
                            if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }

                if (!gv.mod.showPartyToken)
                {
                    bool leaderFound = false;
                    while (!leaderFound)
                    {
                        gv.mod.selectedPartyLeader--;
                        if (gv.mod.selectedPartyLeader < 0)
                        {
                            gv.mod.selectedPartyLeader = gv.mod.playerList.Count - 1; ;
                        }
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp >= 0)
                        {
                            leaderFound = true;
                        }
                    }
                    gv.mod.permanentPartyText = gv.mod.playerList[gv.mod.selectedPartyLeader].name + " (" + gv.mod.playerList[gv.mod.selectedPartyLeader].sp + " SP)";

                    //addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.playerList[gv.mod.selectedPartyLeader].name, "green", 700);
                    gv.cc.doPropStealth();
                    updateTraitsPanel();
                }
            }

            if (keyData == Keys.Left && !showMoveKeys)
            {
                if (gv.mod.hideInterfaceNextMove)
                {
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {

                            //hides up
                            if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }
                if (!gv.mod.showPartyToken)
                {
                    bool leaderFound = false;
                    while (!leaderFound)
                    {
                        gv.mod.selectedPartyLeader--;
                        if (gv.mod.selectedPartyLeader < 0)
                        {
                            gv.mod.selectedPartyLeader = gv.mod.playerList.Count - 1; ;
                        }
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp >= 0)
                        {
                            leaderFound = true;
                        }
                    }
                    //addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.playerList[gv.mod.selectedPartyLeader].name, "green", 700);
                    gv.mod.permanentPartyText = gv.mod.playerList[gv.mod.selectedPartyLeader].name + " (" + gv.mod.playerList[gv.mod.selectedPartyLeader].sp + " SP)";
                    gv.cc.doPropStealth();
                    updateTraitsPanel();
                }
            }

            if (keyData == Keys.A && showMoveKeys)
            {
                if (gv.mod.hideInterfaceNextMove)
                {
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {

                            //hides up
                            if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }
                if (!gv.mod.showPartyToken)
                {
                    bool leaderFound = false;
                    while (!leaderFound)
                    {
                        gv.mod.selectedPartyLeader--;
                        if (gv.mod.selectedPartyLeader < 0)
                        {
                            gv.mod.selectedPartyLeader = gv.mod.playerList.Count - 1; ;
                        }
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].hp >= 0)
                        {
                            leaderFound = true;
                        }
                    }
                    //addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.playerList[gv.mod.selectedPartyLeader].name, "green", 700);
                    gv.mod.permanentPartyText = gv.mod.playerList[gv.mod.selectedPartyLeader].name + " (" + gv.mod.playerList[gv.mod.selectedPartyLeader].sp + " SP)";
                    gv.cc.doPropStealth();
                    updateTraitsPanel();
                }
            }


            if (keyData == Keys.R)
            {
                //scroll log up
                //do same for combat screen
                //wheel 
                //int numberOfTextLinesToMove = e.Delta * SystemInformation.MouseWheelScrollLines / 120;
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(-numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }

            if (keyData == Keys.Up && !showMoveKeys)
            {
                //scroll log up
                //do same for combat screen
                //wheel
                //int numberOfTextLinesToMove = e.Delta * SystemInformation.MouseWheelScrollLines / 120;
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(-numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }

            if (keyData == Keys.Space)
            {
                if (!gv.mod.currentArea.isOverviewMap)
                {
                    gv.mod.breakActiveSearch = false;
                    gv.mod.partyIsSearching = true;

                    //active search
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        gv.cc.doUpdate();
                    }
                    if (!gv.mod.breakActiveSearch)
                    {
                        bool costPaid = false;
                        if (gv.mod.activeSearchSPCostPaidByByLeaderOnly)
                        {
                            if (gv.mod.playerList[gv.mod.selectedPartyLeader].sp >= gv.mod.activeSearchSPCost)
                            {
                                gv.mod.playerList[gv.mod.selectedPartyLeader].sp -= gv.mod.activeSearchSPCost;
                                costPaid = true;
                            }
                        }
                        else
                        {
                            costPaid = true;

                            foreach (Player p in gv.mod.playerList)
                            {
                                if (p.sp < gv.mod.activeSearchSPCost)
                                {
                                    costPaid = false;
                                    break;
                                }
                            }

                            if (costPaid)
                            {
                                foreach (Player p in gv.mod.playerList)
                                {
                                    p.sp -= gv.mod.activeSearchSPCost;
                                }
                            }
                        }
                        if (costPaid)
                        {
                            gv.mod.activeSearchDoneThisMove = true;
                            gv.cc.doUpdate();
                            gv.mod.activeSearchDoneThisMove = false;

                            //interactive props that react to search (secret doors, traps, hidden info, hidden treasure)
                            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx
                            //get diagonal neighbours
                            string NeighbourNE = "";
                            string NeighbourNW = "";
                            string NeighbourSE = "";
                            string NeighbourSW = "";
                            foreach (Area a in gv.mod.moduleAreasObjects)
                            {
                                if (a.Filename == gv.mod.currentArea.northernNeighbourArea)
                                {
                                    if (a.easternNeighbourArea != "none" && a.easternNeighbourArea != "" && a.easternNeighbourArea != "None")
                                    {
                                        NeighbourNE = a.easternNeighbourArea;
                                    }

                                    if (a.westernNeighbourArea != "none" && a.westernNeighbourArea != "" && a.westernNeighbourArea != "None")
                                    {
                                        NeighbourNW = a.westernNeighbourArea;
                                    }
                                }

                                if (a.Filename == gv.mod.currentArea.easternNeighbourArea)
                                {
                                    if (a.northernNeighbourArea != "none" && a.northernNeighbourArea != "" && a.northernNeighbourArea != "None")
                                    {
                                        NeighbourNE = a.northernNeighbourArea;
                                    }

                                    if (a.southernNeighbourArea != "none" && a.southernNeighbourArea != "" && a.southernNeighbourArea != "None")
                                    {
                                        NeighbourSE = a.southernNeighbourArea;
                                    }
                                }

                                if (a.Filename == gv.mod.currentArea.southernNeighbourArea)
                                {
                                    if (a.easternNeighbourArea != "none" && a.easternNeighbourArea != "" && a.easternNeighbourArea != "None")
                                    {
                                        NeighbourSE = a.easternNeighbourArea;
                                    }

                                    if (a.westernNeighbourArea != "none" && a.westernNeighbourArea != "" && a.westernNeighbourArea != "None")
                                    {
                                        NeighbourSW = a.westernNeighbourArea;
                                    }
                                }

                                if (a.Filename == gv.mod.currentArea.westernNeighbourArea)
                                {
                                    if (a.northernNeighbourArea != "none" && a.northernNeighbourArea != "" && a.northernNeighbourArea != "None")
                                    {
                                        NeighbourNW = a.northernNeighbourArea;
                                    }

                                    if (a.southernNeighbourArea != "none" && a.southernNeighbourArea != "" && a.southernNeighbourArea != "None")
                                    {
                                        NeighbourSW = a.southernNeighbourArea;
                                    }
                                }
                            }

                            bool noPropHere = true;
                            foreach (Area a in gv.mod.moduleAreasObjects)
                            {
                                if (a.Filename == gv.mod.currentArea.Filename || a.Filename == gv.mod.currentArea.easternNeighbourArea || a.Filename == gv.mod.currentArea.westernNeighbourArea || a.Filename == gv.mod.currentArea.northernNeighbourArea || a.Filename == gv.mod.currentArea.southernNeighbourArea || a.Filename == NeighbourNE || a.Filename == NeighbourNW || a.Filename == NeighbourSE || a.Filename == NeighbourSW)
                                {
                                    foreach (Prop p in a.Props)
                                    {
                                        //add all the other types here
                                        if (p.isSecretDoor || p.isTrapMain || p.isHiddenInfo)
                                        {
                                            //skill roll script
                                            //visible state
                                            string traitMethod = "leader";
                                            foreach (Trait t in gv.mod.moduleTraitsList)
                                            {
                                                if (t.tag.Contains(p.secretDoorTraitTag))
                                                {
                                                    traitMethod = t.methodOfChecking;
                                                }

                                                if (t.tag.Contains(p.trapTraitTag))
                                                 {
                                                    traitMethod = t.methodOfChecking;
                                                }

                                                if (t.tag.Contains(p.infoTraitTag))
                                                {
                                                    traitMethod = t.methodOfChecking;
                                                }
                                            }
                                            int parm1 = gv.mod.selectedPartyLeader;
                                            if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                                            {
                                                parm1 = gv.mod.selectedPartyLeader;
                                            }
                                            else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                                            {
                                                parm1 = -2;
                                            }
                                            else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                                            {
                                                parm1 = -3;
                                            }
                                            else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                                            {
                                                parm1 = -4;
                                            }
                                            else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                                            {
                                                parm1 = -5;
                                            }
                                            else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                                            {
                                                parm1 = -6;
                                            }

                                            int darkAdder = 0;
                                            Coordinate pcCoord = new Coordinate();
                                            Coordinate propCoord = new Coordinate();
                                            pcCoord.X = gv.mod.PlayerLocationX;
                                            pcCoord.Y = gv.mod.PlayerLocationY;
                                            if (a.Filename == gv.mod.currentArea.Filename)
                                            {
                                                propCoord.X = p.LocationX;
                                                propCoord.Y = p.LocationY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == gv.mod.currentArea.northernNeighbourArea)
                                            {
                                                propCoord.X = p.LocationX;
                                                propCoord.Y = p.LocationY - a.MapSizeY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == NeighbourNE)
                                            {
                                                propCoord.X = gv.mod.currentArea.MapSizeX + p.LocationX;
                                                propCoord.Y = p.LocationY - a.MapSizeY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == gv.mod.currentArea.easternNeighbourArea)
                                            {
                                                propCoord.X = gv.mod.currentArea.MapSizeX + p.LocationX;
                                                propCoord.Y = p.LocationY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == NeighbourSE)
                                            {
                                                propCoord.X = gv.mod.currentArea.MapSizeX + p.LocationX;
                                                propCoord.Y = gv.mod.currentArea.MapSizeY + p.LocationY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == gv.mod.currentArea.southernNeighbourArea)
                                            {
                                                propCoord.X = p.LocationX;
                                                propCoord.Y = gv.mod.currentArea.MapSizeY + p.LocationY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == NeighbourSW)
                                            {
                                                propCoord.X = p.LocationX - a.MapSizeX;
                                                propCoord.Y = gv.mod.currentArea.MapSizeY + p.LocationY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == gv.mod.currentArea.westernNeighbourArea)
                                            {
                                                propCoord.X = p.LocationX - a.MapSizeX; ;
                                                propCoord.Y = p.LocationY;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            if (a.Filename == NeighbourNW)
                                            {
                                                propCoord.X = p.LocationX - a.MapSizeX;
                                                propCoord.Y = p.LocationY - a.MapSizeY; ;
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", a.Filename))
                                                {
                                                    darkAdder = 4;
                                                }
                                                if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", a.Filename))
                                                {
                                                    darkAdder = 12;
                                                }
                                            }

                                            int x3 = p.LocationX;
                                            int y3 = p.LocationY;

                                            //1) within distance and 2) not on border and 3) active
                                            if ((gv.cc.getDistance(pcCoord, propCoord) <= 1) && (x3 < a.MapSizeX - 1 && x3 > 0 && y3 < a.MapSizeY - 1 && y3 > 0) && p.isActive)
                                            {

                                                //get trait name
                                                string traitName = "none";
                                                foreach (Trait t in gv.mod.moduleTraitsList)
                                                {
                                                    if (t.tag.Contains(p.secretDoorTraitTag))
                                                    {
                                                        traitName = t.nameOfTraitGroup;
                                                    }

                                                    if (t.tag.Contains(p.trapTraitTag))
                                                    {
                                                        traitName = t.nameOfTraitGroup;
                                                    }

                                                    if (t.tag.Contains(p.infoTraitTag))
                                                    {
                                                        traitName = t.nameOfTraitGroup;
                                                    }
                                                }

                                                noPropHere = false;
                                                
                                                //secret door section
                                                if (p.isSecretDoor)
                                                {

                                                    if (gv.sf.CheckPassSkill(parm1, p.secretDoorTraitTag, p.secretDoorDC + darkAdder, true, true))
                                                    {
                                                        //EW direction of secret door 
                                                        if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[(p.LocationY + 1) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                                        {
                                                            if (a.Tiles[y3 * a.MapSizeX + x3].isNSBridge == false)
                                                            {
                                                                a.Tiles[y3 * a.MapSizeX + x3].isNSBridge = true;
                                                            }
                                                            else
                                                            {
                                                                a.Tiles[y3 * a.MapSizeX + x3].isNSBridge = false;
                                                            }
                                                        }
                                                        //NS direction of secret door
                                                        else if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX + 1].heightLevel)
                                                        {
                                                            if (a.Tiles[y3 * a.MapSizeX + x3].isEWBridge == false)
                                                            {
                                                                a.Tiles[y3 * a.MapSizeX + x3].isEWBridge = true;
                                                            }
                                                            else
                                                            {
                                                                a.Tiles[y3 * a.MapSizeX + x3].isEWBridge = false;
                                                            }
                                                        }

                                                        gv.sf.calculateHeightShadows(x3, y3);

                                                        //center

                                                        //NS direction of secret door
                                                        if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX + 1].heightLevel)
                                                        {

                                                            bool centerIn = false;
                                                            for (int i = 0; i < a.newEWBridgeState.Count; i++)
                                                            {
                                                                if (x3 == a.changedEWBridgeTilesCoordX[i] && y3 == a.changedEWBridgeTilesCoordY[i])
                                                                {
                                                                    centerIn = true;
                                                                    a.newEWBridgeState[i] = a.Tiles[y3 * a.MapSizeX + x3].isEWBridge;
                                                                }
                                                            }

                                                            if (!centerIn)
                                                            {
                                                                a.newEWBridgeState.Add(gv.mod.currentArea.Tiles[y3 * a.MapSizeX + x3].isEWBridge);
                                                                a.changedEWBridgeTilesCoordX.Add(x3);
                                                                a.changedEWBridgeTilesCoordY.Add(y3);

                                                            }
                                                        }

                                                        //EW direction of secret door
                                                        if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel == gv.mod.currentArea.Tiles[(p.LocationY + 1) * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                                                        {
                                                            bool centerIn = false;
                                                            for (int i = 0; i < a.newNSBridgeState.Count; i++)
                                                            {
                                                                if (x3 == a.changedNSBridgeTilesCoordX[i] && y3 == a.changedNSBridgeTilesCoordY[i])
                                                                {
                                                                    centerIn = true;
                                                                    a.newNSBridgeState[i] = a.Tiles[y3 * a.MapSizeX + x3].isNSBridge;
                                                                }
                                                            }

                                                            if (!centerIn)
                                                            {
                                                                a.newNSBridgeState.Add(a.Tiles[y3 * a.MapSizeX + x3].isNSBridge);
                                                                a.changedNSBridgeTilesCoordX.Add(x3);
                                                                a.changedNSBridgeTilesCoordY.Add(y3);

                                                            }
                                                        }
                                                        //secret door has been opened, normal tile now
                                                        p.isSecretDoor = false;

                                                        //disable any shown message connected
                                                        p.MouseOverText = "none";

                                                        //skill roll success message (A)
                                                        gv.screenMainMap.addFloatyText(x3, y3, "Success: " + traitName + " level " + (p.secretDoorDC+darkAdder-10).ToString() + " matched", "green", 2000);
                                                        gv.cc.addLogText("green", "Success: " + traitName + " level " + (p.secretDoorDC+darkAdder-10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                    }//skill check

                                                    //skill roll failed message (B)
                                                    else
                                                    {
                                                        if (darkAdder == 4)
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+4 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                        }
                                                        else if (darkAdder == 12)
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required (+12 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                        }
                                                        else
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC + darkAdder - 10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                        }
                                                        //gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.secretDoorDC+darkAdder-10).ToString() + " required", "red", 2000);
                                                        //gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.secretDoorDC+darkAdder-10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                    }

                                                }//secret door subsection end
                                                 
                                                //trap subsection start
                                                if (p.isTrapMain)
                                                {

                                                    if (gv.sf.CheckPassSkill(parm1, p.trapTraitTag, p.trapDC + darkAdder, true, true))
                                                    {
                                                        
                                                        //trap has been disarmed, normal tile now
                                                        //p.isTrapMain = false;
                                                        p.isShown = false;
                                                        p.isActive = false;

                                                        //skill roll success message (A)
                                                        gv.screenMainMap.addFloatyText(x3, y3, "Success: "+ traitName + " level " + (p.trapDC+darkAdder-10).ToString() + " matched", "green", 2000);
                                                        gv.cc.addLogText("green", "Success: " + traitName + " level " + (p.trapDC+darkAdder-10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                    }//skill check

                                                    //skill roll failed message (B)
                                                    else
                                                    {
                                                        if (darkAdder == 4)
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+4 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                        }
                                                        else if (darkAdder == 12)
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required (+12 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                        }
                                                        else
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC + darkAdder - 10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                        }
                                                        //gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.trapDC+darkAdder-10).ToString() + " required", "red", 2000);
                                                        //gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.trapDC+darkAdder-10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                    }

                                                }//trap subsection end

                                                //hidden info
                                                if (p.isHiddenInfo)
                                                {
                                                    if (gv.sf.CheckPassSkill(parm1, p.infoTraitTag, p.infoDC + darkAdder, true, true))
                                                    {
                                                        //display the info
                                                        if (p.floatyAndLogText != "none")
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, p.floatyAndLogText, "green", 2000);
                                                            gv.cc.addLogText("lime", p.floatyAndLogText);
                                                             gv.cc.addLogText("white", "Success: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP.");
                                                        }

                                                        if (p.boxText != "none")
                                                        {
                                                            gv.sf.MessageBox(p.boxText);
                                                            gv.cc.addLogText("white", "Success: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP.");

                                                        }

                                                        if (p.conversationName != "none")
                                                        {
                                                            gv.mod.breakActiveSearch = true;
                                                            gv.cc.calledConvoFromProp = true;
                                                            gv.sf.ThisProp = p;
                                                            gv.cc.doConversationBasedOnTag(p.conversationName);
                                                            gv.cc.addLogText("white", "Success: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " matched, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP.");

                                                        }

                                                        //set global
                                                        if (p.globalStringKey != "none")
                                                        {
                                                            gv.sf.SetGlobalString(p.globalStringKey, p.globalStringValue);
                                                        }

                                                        //disable if show only once
                                                        if (p.showOnlyOnce)
                                                        {
                                                            //note: the prop graphic itself shall remian visible
                                                            p.isActive = false;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (darkAdder == 4)
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+4 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                        }
                                                        else if (darkAdder == 12)
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required (+12 for poor visibility), " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                        }
                                                        else
                                                        {
                                                            gv.screenMainMap.addFloatyText(x3, y3, "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                                            gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder - 10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");

                                                        }
                                                        //gv.screenMainMap.addFloatyText(x3, y3,"Failure: " + traitName + " level " + (p.infoDC+darkAdder-10).ToString() + " required ", "red", 2000);
                                                        //gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.infoDC + darkAdder -10).ToString() + " required, " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                                    }
                                                }//hidden info subsection end

                                            }//distance and not on border
                                        }// all SPACE props end
                                    }//loop for all props in area
                                }//check for this or neighbouring areas
                            }//loop for all areas

                            //no qualified prop nearby message (C) 
                            if (noPropHere)
                            {
                                if (gv.mod.activeSearchSPCostPaidByByLeaderOnly)
                                {
                                    addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "Searching...", "white", 1500);
                                    gv.cc.addLogText("white", "Searching... time passes and " + gv.mod.playerList[gv.mod.selectedPartyLeader].name + " loses " + gv.mod.activeSearchSPCost + " SP");
                                }
                                else
                                {
                                    addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "Searching...", "white", 1500);
                                    gv.cc.addLogText("white", "Searching... time passes and everybody loses " + gv.mod.activeSearchSPCost + " SP");

                                }
                            }
                        }// sp cost could not be paid
                        else
                        {
                            addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "Too exhausted to search...", "red", 3000);
                            gv.cc.addLogText("red", "Too exhausted to search...");
                        }
                    }

                    gv.mod.breakActiveSearch = false;
                    gv.mod.partyIsSearching = false;
                }
            }

            if (keyData == Keys.W && showMoveKeys)
            {
                //scroll log up
                //do same for combat screen
                //wheel
                //int numberOfTextLinesToMove = e.Delta * SystemInformation.MouseWheelScrollLines / 120;
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(-numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }

            if (keyData == Keys.G)
            {
                string relevantGridTag = "none";
                foreach (Trigger t in gv.mod.currentArea.Triggers)
                {
                    foreach (Coordinate coord in t.TriggerSquaresList)
                    {
                        if (coord.X == gv.mod.PlayerLocationX && coord.Y == gv.mod.PlayerLocationY)
                        {
                            relevantGridTag = t.TriggerTag;
                        }
                    }
                }
                
                if (relevantGridTag != "none")
                {
                    bool resetParty = false;
                    int resetLocX = 0;
                    int resetLocY = 0;
                    string resetDrawDirection = "left";
                    foreach (Prop p in gv.mod.currentArea.Props)
                    {
                        if (p.pushableGridTriggerTag == relevantGridTag && p.pushableGridCanBeResetViaHotkey)
                        {
                            resetParty = true;
                            resetLocX = p.partyDefaultPushableGridPositionX;
                            resetLocY = p.partyDefaultPushableGridPositionY;
                            resetDrawDirection = p.partyDefaultDrawDirection;
                            p.LocationX = p.pushableStartPositionX;
                            p.LocationY = p.pushableStartPositionY;
                            p.timerTurnsBeforeGridResets = p.turnsBeforeGridResets;
                        }
                    }

                    if (resetParty)
                    {
                        gv.mod.PlayerLocationX = resetLocX;
                        gv.mod.PlayerLocationY = resetLocY;
                        gv.mod.drawPartyDirection = resetDrawDirection;
                        //messaging
                        gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "A sense of déjà-vu overcomes the party...", "green", 3000);
                        gv.cc.addLogText("lime", "A sense of déjà-vu overcomes the party...");
                    }
                }
            }

            if (keyData == Keys.F || keyData == Keys.NumPad0 || keyData == Keys.Insert)
            {
                //krah krah
                //gv.mod.interfaceFadeCounter = 20;
                //gv.mod.interfaceCounterHalted = true;
                gv.mod.hideInterfaceNextMove = true;
                if (!hideClock)
                {
                    //hideClock = true;
                }
                else
                {
                    hideClock = false;
                }
                foreach (IB2Panel pnl in mainUiLayout.panelList)
                {
                    if (pnl.tag != "arrowPanel")
                    {
                        //hides right
                        if (pnl.hidingXIncrement > 0)
                        {
                            if (pnl.currentLocX > pnl.shownLocX)
                            {
                                pnl.showing = true;
                            }
                            else
                            {
                                //pnl.hiding = true;
                            }
                        }
                        //hides down
                        else if (pnl.hidingYIncrement > 0)
                        {
                            if (pnl.currentLocY > pnl.shownLocY)
                            {
                                if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                                {
                                    continue;
                                }
                                pnl.showing = true;
                            }
                            else
                            {
                                //pnl.hiding = true;
                            }
                        }
                        //hides up
                        else if (pnl.hidingYIncrement < 0)
                        {
                            if (pnl.currentLocY < pnl.shownLocY)
                            {
                                pnl.showing = true;
                            }
                            else
                            {
                                //pnl.hiding = true;
                            }
                        }
                    }
                }
            }

            if (keyData == Keys.V)
            {
                //scroll log down
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(+numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }


            if (keyData == Keys.Down && !showMoveKeys)
            {
                //scroll log down
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(+numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }

            if (keyData == Keys.S && showMoveKeys)
            {
                //scroll log down
                int numberOfTextLinesToMove = 1;
                gv.mod.logFadeCounter = 120;
                gv.mod.logOpacity = 1f;

                if (numberOfTextLinesToMove != 0)
                {
                    gv.log.SetCurrentTopLineIndex(+numberOfTextLinesToMove);
                    //gv.Invalidate();
                    //bloodbus
                    //gv.Render(0);
                }
            }

            if (keyData == Keys.F5)
            {
                if (gv.mod.allowSave)
                {
                    gv.cc.QuickSave();
                    gv.cc.addLogText("lime", "Quicksave Completed");
                }
                else
                {
                    gv.cc.addLogText("red", "No save allowed at this time.");
                }
            }
            else if (keyData == Keys.B)
            //gv.mod.KeyDebug = Keys.B;
            //if (keyData == gv.mod.KeyDebug)

            {
                if (gv.mod.debugMode)
                {
                    gv.mod.debugMode = false;
                    gv.cc.addLogText("lime", "debugMode Turned Off");
                }
                else
                {
                    gv.mod.debugMode = true;
                    gv.cc.addLogText("lime", "debugMode Turned On");
                }
            }
            else if (keyData == Keys.I)
            {
                if (!gv.mod.currentArea.isOverviewMap)
                {
                    gv.screenType = "inventory";
                    gv.screenInventory.resetInventory(false);
                    gv.cc.tutorialMessageInventory(false);
                }
            }
            else if (keyData == Keys.J)
            {
                gv.screenType = "journal";
            }
            else if (keyData == Keys.P)
            {
                if (!gv.mod.currentArea.isOverviewMap)
                {
                    gv.screenParty.resetPartyScreen();
                    gv.screenType = "party";
                    gv.cc.tutorialMessageParty(false);
                }
            }
            else if (keyData == Keys.C)
            {
                if (!gv.mod.currentArea.isOverviewMap)
                {
                    List<string> pcNames = new List<string>();
                    List<int> pcIndex = new List<int>();
                    pcNames.Add("cancel");

                    int cnt = 0;
                    foreach (Player p in gv.mod.playerList)
                    {
                        if (hasMainMapTypeSpell(p))
                        {
                            pcNames.Add(p.name + " (" + p.sp + "/" + p.spMax + " SP)");
                            pcIndex.Add(cnt);
                        }
                        cnt++;
                    }

                    //If only one PC, do not show select PC dialog...just go to cast selector
                    if (pcIndex.Count == 1)
                    {
                        try
                        {
                            gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                            gv.screenCombat.spellSelectorIndex = 0;
                            gv.screenType = "mainMapCast";
                            return;
                        }
                        catch (Exception ex)
                        {
                            //print error
                            IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                            gv.errorLog(ex.ToString());
                            return;
                        }
                    }

                    using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Caster"))
                    {
                        pcSel.ShowDialog();

                        if (pcSel.selectedIndex > 0)
                        {
                            try
                            {
                                gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                gv.screenCombat.spellSelectorIndex = 0;
                                gv.screenType = "mainMapCast";
                            }
                            catch (Exception ex)
                            {
                                IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                gv.errorLog(ex.ToString());
                                //print error
                            }
                        }
                        else if (pcSel.selectedIndex == 0) // selected "cancel"
                        {
                            //do nothing
                        }
                    }
                }
            }
            //wait one turn
            else if ((keyData == Keys.Z) || (keyData == Keys.Y))
            {
                gv.cc.doUpdate();
            }
            else if (keyData == Keys.T)
            {
                //todo: add this to torch button
                foreach (ItemRefs ir in gv.mod.partyInventoryRefsList)
                {
                    if (ir.isLightSource)
                    {
                        foreach (Item it in gv.mod.moduleItemsList)
                        {
                            if (it.resref == ir.resref)
                            {
                                gv.cc.doIBScriptBasedOnFilename(it.onUseItemIBScript, it.onUseItemIBScriptParms);
                                break;
                            }

                        }
                        break;
                    }
                }
            }
            //adding lines for trait use via hotkey on main map
            else if (keyData == Keys.U)
            {
                if (!gv.mod.currentArea.isOverviewMap)
                {
                    List<string> pcNames = new List<string>();
                    List<int> pcIndex = new List<int>();
                    pcNames.Add("cancel");

                    int cnt = 0;
                    foreach (Player p in gv.mod.playerList)
                    {
                        if (p.knownOutsideCombatUsableTraitsTags.Count > 0)
                        {
                            pcNames.Add(p.name + " (" + p.sp + "/" + p.spMax + " SP)");
                            pcIndex.Add(cnt);
                        }
                        cnt++;
                    }

                    //If only one PC, do not show select PC dialog...just go to cast selector
                    if (pcIndex.Count == 1)
                    {
                        try
                        {
                            gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                            gv.screenCombat.spellSelectorIndex = 0;
                            gv.screenType = "mainMapTraitUse";
                            return;
                        }
                        catch (Exception ex)
                        {
                            //print error
                            IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                            gv.errorLog(ex.ToString());
                            return;
                        }
                    }

                    using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Character"))
                    {
                        pcSel.ShowDialog();

                        if (pcSel.selectedIndex > 0)
                        {
                            try
                            {
                                gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                gv.screenCombat.spellSelectorIndex = 0;
                                gv.screenType = "mainMapTraitUse";
                            }
                            catch (Exception ex)
                            {
                                IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                gv.errorLog(ex.ToString());
                                //print error
                            }
                        }
                        else if (pcSel.selectedIndex == 0) // selected "cancel"
                        {
                            //do nothing
                        }
                    }
                }
            }


            else if (keyData == Keys.X)
            {

                if (gv.mod.hideInterfaceNextMove == false)
                {
                    if (!hideClock)
                    {
                        hideClock = true;
                    }
                    else
                    {
                        hideClock = false;
                    }
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {
                            /*
                            //hides left
                            if (pnl.hidingXIncrement < 0)
                            {
                                if (pnl.currentLocX < pnl.shownLocX)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                            */
                            //hides right
                            if (pnl.hidingXIncrement > 0)
                            {
                                if (pnl.currentLocX > pnl.shownLocX)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                            //hides down
                            else if (pnl.hidingYIncrement > 0)
                            {
                                if (pnl.currentLocY > pnl.shownLocY)
                                {
                                    if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                                    {
                                        continue;
                                    }
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                            //hides up
                            else if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY || gv.mod.hideInterfaceNextMove)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                        }
                    }
                }
                //coming from dynamic mode
                else
                {
                    if (!hideClock)
                    {
                        //hideClock = true;
                    }
                    else
                    {
                        hideClock = false;
                    }
                    foreach (IB2Panel pnl in mainUiLayout.panelList)
                    {
                        if (pnl.tag != "arrowPanel")
                        {
                            /*
                            //hides left
                            if (pnl.hidingXIncrement < 0)
                            {
                                if (pnl.currentLocX < pnl.shownLocX)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }
                            */
                            //hides right
                            if (pnl.hidingXIncrement > 0)
                            {
                                if (pnl.currentLocX > pnl.shownLocX)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                            //hides down
                            else if (pnl.hidingYIncrement > 0)
                            {
                                if (pnl.currentLocY > pnl.shownLocY)
                                {
                                    if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                                    {
                                        continue;
                                    }
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                            //hides up
                            else if (pnl.hidingYIncrement < 0)
                            {
                                if (pnl.currentLocY < pnl.shownLocY || gv.mod.hideInterfaceNextMove)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    //pnl.hiding = true;
                                }
                            }
                        }
                    }
                }
                gv.mod.hideInterfaceNextMove = false;
            }
        }

        private bool moveDelay()
        {
            long elapsed = DateTime.Now.Ticks - timeStamp;
            if (elapsed > 10000 * movementDelayInMiliseconds) //10,000 ticks in 1 ms
            {
                timeStamp = DateTime.Now.Ticks;
                return true;
            }
            return false;
        }
        public void moveLeft(bool affectTimer)
        {
            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
            bool bumpPropExists = false;
            bool bumpTriggerExists = false;
            Trigger bumpTrigger = new Trigger();
            Prop bumpProp = new Prop();

            if (gv.mod.PlayerLocationX > 0)
            {
                foreach (Trigger t in gv.mod.currentArea.Triggers)
                {
                    //migh add isBumpTRigger requirement here
                    if (t.Enabled)
                    {
                        foreach (Coordinate p in t.TriggerSquaresList)
                        {
                            if ((p.X == gv.mod.PlayerLocationX - 1) && (p.Y == gv.mod.PlayerLocationY))
                            {
                                //check grid timer
                                bool crateFound = false;
                                foreach (Prop crate in gv.mod.currentArea.Props)
                                {
                                    if (!crateFound)
                                    {
                                        if (crate.isPushable && crate.pushableGridTriggerTag == t.TriggerTag && crate.turnsBeforeGridResets > 0 && affectTimer)
                                        {
                                            crateFound = true;
                                            if (crate.timerTurnsBeforeGridResets > 0)
                                            {
                                                //add floaty and log countdown
                                                //gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, crate.timerTurnsBeforeGridResets.ToString(), "red", 1000);
                                                gv.cc.addLogText("red", crate.timerTurnsBeforeGridResets.ToString() + " moves left");

                                                crate.timerTurnsBeforeGridResets--;
                                                //restore after reset (via g or when end of timer reached) 
                                            }
                                            //reset grid as 0 turns have been reached
                                            else
                                            {
                                                int resetLocX = 0;
                                                int resetLocY = 0;
                                                string resetDrawDirection = "left";
                                                foreach (Prop p2 in gv.mod.currentArea.Props)
                                                {
                                                    if (p2.pushableGridTriggerTag == t.TriggerTag)
                                                    {
                                                        p2.LocationX = p2.pushableStartPositionX;
                                                        p2.LocationY = p2.pushableStartPositionY;
                                                        resetLocX = p2.partyDefaultPushableGridPositionX;
                                                        resetLocY = p2.partyDefaultPushableGridPositionY;
                                                        resetDrawDirection = p2.partyDefaultDrawDirection;
                                                        p2.timerTurnsBeforeGridResets = p2.turnsBeforeGridResets;
                                                        //sekiro
                                                    }
                                                }

                                                gv.mod.PlayerLocationX = resetLocX;
                                                gv.mod.PlayerLocationY = resetLocY;
                                                gv.mod.drawPartyDirection = resetDrawDirection;
                                                //messaging
                                                gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "A sense of déjà-vu overcomes the party...", "green", 3000);
                                                gv.cc.addLogText("lime", "A sense of déjà-vu overcomes the party...");
                                                //XXXXXXXXXXXXXXXXXXXXX
                                            }
                                        }
                                    }
                                }


                                bumpTriggerExists = true;
                                bumpTrigger = t;
                                break;
                            }
                        }
                    }
                }

                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                    {
                        if ((p.LocationX == gv.mod.PlayerLocationX - 1) && (p.LocationY == gv.mod.PlayerLocationY))
                        {
                            bumpPropExists = true;
                            bumpProp = p;
                            gv.sf.ThisProp = bumpProp;
                            break;
                        }
                    }
                }
            }

            if (gv.mod.PlayerLocationX > 0)
            {
                bool isSuccesfulClimbAction = false;
                //First: current square
                //wesseling nord
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.LocationX == gv.mod.PlayerLocationX && p.LocationY == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "west")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }


                    //Second: target square is west 
                    if (p.LocationX + 1 == gv.mod.PlayerLocationX && p.LocationY == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "east")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }
                }

                if (isSuccesfulClimbAction)
                {
                    //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationX--;
                    gv.mod.drawPartyDirection = "right";
                    gv.cc.doUpdate();
                }

                else if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false || gv.mod.currentArea.isOverviewMap)
                {
                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;
                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX - 1].isSecretPassage)
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationX--;
                        gv.mod.PlayerLocationX--;
                        gv.mod.drawPartyDirection = "right";
                        foreach (Player pc in gv.mod.playerList)
                        {
                            if (!pc.combatFacingLeft)
                            {
                                pc.combatFacingLeft = true;
                            }
                        }
                        gv.cc.doUpdate();
                    }
                    else
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationX--;
                        gv.mod.drawPartyDirection = "right";
                        foreach (Player pc in gv.mod.playerList)
                        {
                            if (!pc.combatFacingLeft)
                            {
                                pc.combatFacingLeft = true;
                            }
                        }
                        if (!gv.mod.wasSuccessfulPush)
                        {
                            gv.cc.doUpdate();
                        }
                        else
                        {
                            gv.mod.wasSuccessfulPush = false;
                        }
                    }
                }
                else if (bumpPropExists || bumpTriggerExists)
                {
                    StopScrollingOnBlocked();
                    if (bumpPropExists)
                    {
                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                        {
                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                        }

                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                        {
                            //called from prop add?
                            //gv.cc.calledConvoFromProp = true;
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                        }

                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                        {
                            gv.mod.EncounterOfTurnDone = true;
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.calledEncounterFromProp = true;
                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                        }
                        if (bumpProp.scriptFilename != "none")
                        {
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                            //code for floaty shown on prop upon script activation
                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                            {
                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                            }

                            //code for log, to do
                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                            {
                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                            }

                            if (bumpProp.onlyOnce)
                            {
                                bumpProp.isShown = false;
                                bumpProp.isActive = false;
                            }
                        }
                    }
                    else if (bumpTriggerExists)
                    {
                        gv.cc.doBumpTrigger(bumpTrigger);
                    }

                    gv.cc.doUpdate();
                }
                else
                {
                    StopScrollingOnBlocked();
                    gv.cc.doUpdate();
                }
            }
        }
        public void moveRight(bool affectTimer)
        {
            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;

            int mapwidth = gv.mod.currentArea.MapSizeX;
            bool bumpPropExists = false;
            bool bumpTriggerExists = false;
            Trigger bumpTrigger = new Trigger();
            Prop bumpProp = new Prop();

            if (gv.mod.PlayerLocationX < (mapwidth - 1))
            {
                foreach (Trigger t in gv.mod.currentArea.Triggers)
                {
                    //migh add isBumpTRigger requirement here
                    if (t.Enabled)
                    {
                        foreach (Coordinate p in t.TriggerSquaresList)
                        {
                            if ((p.X == gv.mod.PlayerLocationX + 1) && (p.Y == gv.mod.PlayerLocationY))
                            {
                                //check grid timer
                                bool crateFound = false;
                                foreach (Prop crate in gv.mod.currentArea.Props)
                                {
                                    if (!crateFound)
                                    {
                                        if (crate.isPushable && crate.pushableGridTriggerTag == t.TriggerTag && crate.turnsBeforeGridResets > 0 && affectTimer)
                                        {
                                            crateFound = true;
                                            if (crate.timerTurnsBeforeGridResets > 0)
                                            {
                                                //add floaty and log countdown
                                                //gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, crate.timerTurnsBeforeGridResets.ToString(), "red", 1000);
                                                gv.cc.addLogText("red", crate.timerTurnsBeforeGridResets.ToString() + " moves left");

                                                crate.timerTurnsBeforeGridResets--;
                                                //restore after reset (via g or when end of timer reached) 
                                            }
                                            //reset grid as 0 turns have been reached
                                            else
                                            {
                                                int resetLocX = 0;
                                                int resetLocY = 0;
                                                string resetDrawDirection = "left";
                                                foreach (Prop p2 in gv.mod.currentArea.Props)
                                                {
                                                    if (p2.pushableGridTriggerTag == t.TriggerTag)
                                                    {
                                                        p2.LocationX = p2.pushableStartPositionX;
                                                        p2.LocationY = p2.pushableStartPositionY;
                                                        resetLocX = p2.partyDefaultPushableGridPositionX;
                                                        resetLocY = p2.partyDefaultPushableGridPositionY;
                                                        resetDrawDirection = p2.partyDefaultDrawDirection;
                                                        p2.timerTurnsBeforeGridResets = p2.turnsBeforeGridResets;
                                                        //sekiro
                                                    }
                                                }

                                                gv.mod.PlayerLocationX = resetLocX;
                                                gv.mod.PlayerLocationY = resetLocY;
                                                gv.mod.drawPartyDirection = resetDrawDirection;
                                                //messaging
                                                gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "A sense of déjà-vu overcomes the party...", "green", 3000);
                                                gv.cc.addLogText("lime", "A sense of déjà-vu overcomes the party...");
                                                //XXXXXXXXXXXXXXXXXXXXX
                                            }
                                        }
                                    }
                                }


                                bumpTriggerExists = true;
                                bumpTrigger = t;
                                break;
                            }
                        }
                    }
                }

                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                    {
                        if ((p.LocationX == gv.mod.PlayerLocationX + 1) && (p.LocationY == gv.mod.PlayerLocationY))
                        {
                            bumpPropExists = true;
                            bumpProp = p;
                            gv.sf.ThisProp = bumpProp;
                            break;
                        }
                    }
                }
            }


            if (gv.mod.PlayerLocationX < (mapwidth - 1))
            {

                bool isSuccesfulClimbAction = false;
                //First: current square
                //wesseling nord
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.LocationX == gv.mod.PlayerLocationX && p.LocationY == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "east")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }


                    //Second: target square is east 
                    if (p.LocationX - 1 == gv.mod.PlayerLocationX && p.LocationY == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "west")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(gv.sf.ThisProp.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(gv.sf.ThisProp.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }
                }

                if (isSuccesfulClimbAction)
                {
                    //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationX++;
                    gv.mod.drawPartyDirection = "left";
                    gv.cc.doUpdate();
                }

                else if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false || gv.mod.currentArea.isOverviewMap)
                {

                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;
                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX + 1].isSecretPassage)
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationX++;
                        gv.mod.PlayerLocationX++;
                        gv.mod.drawPartyDirection = "left";
                        foreach (Player pc in gv.mod.playerList)
                        {
                            if (pc.combatFacingLeft) 
                            {
                                pc.combatFacingLeft = false;
                            }
                        }
                        gv.cc.doUpdate();
                    }
                    else
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationX++;
                        gv.mod.drawPartyDirection = "left";
                        foreach (Player pc in gv.mod.playerList)
                        {
                            if (pc.combatFacingLeft)
                            {
                                pc.combatFacingLeft = false;
                            }
                        }
                        if (!gv.mod.wasSuccessfulPush)
                        {
                            gv.cc.doUpdate();
                        }
                        else
                        {
                            gv.mod.wasSuccessfulPush = false;
                        }
                    }
                }
                else if (bumpPropExists || bumpTriggerExists)
                {
                    StopScrollingOnBlocked();
                    if (bumpPropExists)
                    {
                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                        {
                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                        }

                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                        {
                            //called from prop add?
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                        }

                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                        {
                            gv.mod.EncounterOfTurnDone = true;
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.calledEncounterFromProp = true;
                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                        }

                        if (bumpProp.scriptFilename != "none")
                        {
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                            //code for floaty shown on prop upon script activation
                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                            {
                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                            }

                            //code for log, to do
                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                            {
                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                            }

                            if (bumpProp.onlyOnce)
                            {
                                bumpProp.isShown = false;
                                bumpProp.isActive = false;
                            }
                        }

                    }
                    else if (bumpTriggerExists)
                    {
                        gv.cc.doBumpTrigger(bumpTrigger);
                    }

                    gv.cc.doUpdate();
                }
                else
                {
                    StopScrollingOnBlocked();
                    gv.cc.doUpdate();
                }
            }
        }
        public void moveUp(bool affectTimer)
        {

            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;

            bool bumpPropExists = false;
            bool bumpTriggerExists = false;
            Trigger bumpTrigger = new Trigger();
            Prop bumpProp = new Prop();

            if (gv.mod.PlayerLocationY > 0)
            {
                foreach (Trigger t in gv.mod.currentArea.Triggers)
                {
                    //migh add isBumpTRigger requirement here
                    if (t.Enabled)
                    {
                        foreach (Coordinate p in t.TriggerSquaresList)
                        {
                            if ((p.X == gv.mod.PlayerLocationX) && (p.Y == gv.mod.PlayerLocationY - 1))
                            {
                                //todo: other diections for grid timer: right, down, left
                                //check grid timer
                                bool crateFound = false;
                                foreach (Prop crate in gv.mod.currentArea.Props)
                                {
                                    if (!crateFound)
                                    {
                                        if (crate.isPushable && crate.pushableGridTriggerTag == t.TriggerTag && crate.turnsBeforeGridResets > 0 && affectTimer)
                                        {
                                            crateFound = true;
                                            if (crate.timerTurnsBeforeGridResets > 0)
                                            {
                                                //add floaty and log countdown
                                                //gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, crate.timerTurnsBeforeGridResets.ToString(), "red", 1000);
                                                gv.cc.addLogText("red", crate.timerTurnsBeforeGridResets.ToString() + " moves left");

                                                crate.timerTurnsBeforeGridResets--;
                                                //restore after reset (via g or when end of timer reached) 
                                            }
                                            //reset grid as 0 turns have been reached
                                            else
                                            {
                                                    int resetLocX = 0;
                                                    int resetLocY = 0;
                                                    string resetDrawDirection = "left";
                                                    foreach (Prop p2 in gv.mod.currentArea.Props)
                                                    {
                                                        if (p2.pushableGridTriggerTag == t.TriggerTag)
                                                        {
                                                            p2.LocationX = p2.pushableStartPositionX;
                                                            p2.LocationY = p2.pushableStartPositionY;
                                                            resetLocX = p2.partyDefaultPushableGridPositionX;
                                                            resetLocY = p2.partyDefaultPushableGridPositionY;
                                                            resetDrawDirection = p2.partyDefaultDrawDirection;
                                                            p2.timerTurnsBeforeGridResets = p2.turnsBeforeGridResets;
                                                        //sekiro
                                                        }
                                                    }
                               
                                                gv.mod.PlayerLocationX = resetLocX;
                                                gv.mod.PlayerLocationY = resetLocY;
                                                gv.mod.drawPartyDirection = resetDrawDirection;
                                                //messaging
                                                gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "A sense of déjà-vu overcomes the party...", "green", 3000);
                                                gv.cc.addLogText("lime", "A sense of déjà-vu overcomes the party...");
                                                //XXXXXXXXXXXXXXXXXXXXX
                                            }
                                        }
                                    }
                                }

                                bumpTriggerExists = true;
                                bumpTrigger = t;
                                break;
                            }
                        }
                    }
                }

                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                    {
                        if ((p.LocationX == gv.mod.PlayerLocationX) && (p.LocationY == gv.mod.PlayerLocationY - 1))
                        {
                            bumpPropExists = true;
                            bumpProp = p;
                            gv.sf.ThisProp = bumpProp;
                            break;
                        }
                    }
                }
            }


            if (gv.mod.PlayerLocationY > 0)
            {
                //section for climbing
                //1. walking in direction of the climbable side of a climb prop  on CURRENT square
                //2.  walking in direction of the climbable side of a climb prop  on TARGET square

                bool isSuccesfulClimbAction = false;
                //First: current square
                //wesseling nord
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.LocationX == gv.mod.PlayerLocationX && p.LocationY == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "north")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }


                    //Second: target square is north
                    if (p.LocationX == gv.mod.PlayerLocationX && p.LocationY+1 == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "south")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }
                }
                
                if (isSuccesfulClimbAction)
                {
                    //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationY--;
                    gv.mod.drawPartyDirection = "down";
                    gv.cc.doUpdate();
                }
                else if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false || gv.mod.currentArea.isOverviewMap)
                {

                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;

                    //section for secret passage (old)
                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY - 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isSecretPassage)
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationY--;
                        gv.mod.PlayerLocationY--;
                        gv.mod.drawPartyDirection = "down";
                        gv.cc.doUpdate();
                        /*
                        if (!gv.mod.wasSuccessfulPush)
                        {
                            gv.cc.doUpdate();
                        }
                        else
                        {
                            gv.mod.wasSuccessfulPush = false;
                        }
                        */
                    }
                    else
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationY--;
                        gv.mod.drawPartyDirection = "down";
                        if (!gv.mod.wasSuccessfulPush)
                        {
                            gv.cc.doUpdate();
                        }
                        else
                        {
                            gv.mod.wasSuccessfulPush = false;
                        }
                    }
                }
                else if (bumpPropExists || bumpTriggerExists)
                {
                    StopScrollingOnBlocked();
                    if (bumpPropExists)
                    {
                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                        {
                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                        }

                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                        {
                            //called from prop add?
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                        }

                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                        {
                            gv.mod.EncounterOfTurnDone = true;
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.calledEncounterFromProp = true;
                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                        }

                        if (bumpProp.scriptFilename != "none")
                        {
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                            //code for floaty shown on prop upon script activation
                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                            {
                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                            }

                            //code for log, to do
                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                            {
                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                            }

                            if (bumpProp.onlyOnce)
                            {
                                bumpProp.isShown = false;
                                bumpProp.isActive = false;
                            }
                        }
                    }
                    else if (bumpTriggerExists)
                    {
                        gv.cc.doBumpTrigger(bumpTrigger);
                    }

                    gv.cc.doUpdate();
                }
                else
                {
                    StopScrollingOnBlocked();
                    gv.cc.doUpdate();
                }
            }
        }
        public void moveDown(bool affectTimer)
        {
            gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
            gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;

            int mapheight = gv.mod.currentArea.MapSizeY;
            bool bumpPropExists = false;
            bool bumpTriggerExists = false;
            Trigger bumpTrigger = new Trigger();
            Prop bumpProp = new Prop();
             
            if (gv.mod.PlayerLocationY < (mapheight - 1))
            {
                foreach (Trigger t in gv.mod.currentArea.Triggers)
                {
                    //migh add isBumpTRigger requirement here
                    if (t.Enabled)
                    {
                        foreach (Coordinate p in t.TriggerSquaresList)
                        {
                            if ((p.X == gv.mod.PlayerLocationX) && (p.Y == gv.mod.PlayerLocationY + 1))
                            {
                                //check grid timer
                                bool crateFound = false;
                                foreach (Prop crate in gv.mod.currentArea.Props)
                                {
                                    if (!crateFound)
                                    {
                                        if (crate.isPushable && crate.pushableGridTriggerTag == t.TriggerTag && crate.turnsBeforeGridResets > 0 && affectTimer)
                                        {
                                            crateFound = true;
                                            if (crate.timerTurnsBeforeGridResets > 0)
                                            {
                                                //add floaty and log countdown
                                                //gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, crate.timerTurnsBeforeGridResets.ToString(), "red", 1000);
                                                gv.cc.addLogText("red", crate.timerTurnsBeforeGridResets.ToString() + " moves left");

                                                crate.timerTurnsBeforeGridResets--;
                                                //restore after reset (via g or when end of timer reached) 
                                            }
                                            //reset grid as 0 turns have been reached
                                            else
                                            {
                                                int resetLocX = 0;
                                                int resetLocY = 0;
                                                string resetDrawDirection = "left";
                                                foreach (Prop p2 in gv.mod.currentArea.Props)
                                                {
                                                    if (p2.pushableGridTriggerTag == t.TriggerTag)
                                                    {
                                                        p2.LocationX = p2.pushableStartPositionX;
                                                        p2.LocationY = p2.pushableStartPositionY;
                                                        resetLocX = p2.partyDefaultPushableGridPositionX;
                                                        resetLocY = p2.partyDefaultPushableGridPositionY;
                                                        resetDrawDirection = p2.partyDefaultDrawDirection;
                                                        p2.timerTurnsBeforeGridResets = p2.turnsBeforeGridResets;
                                                        //sekiro
                                                    }
                                                }

                                                gv.mod.PlayerLocationX = resetLocX;
                                                gv.mod.PlayerLocationY = resetLocY;
                                                gv.mod.drawPartyDirection = resetDrawDirection;
                                                //messaging
                                                gv.screenMainMap.addFloatyText(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, "A sense of déjà-vu overcomes the party...", "green", 3000);
                                                gv.cc.addLogText("lime", "A sense of déjà-vu overcomes the party...");
                                                //XXXXXXXXXXXXXXXXXXXXX
                                            }
                                        }
                                    }
                                }


                                bumpTriggerExists = true;
                                bumpTrigger = t;
                                break;
                            }
                        }
                    }
                }

                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.isActive && (p.ConversationWhenOnPartySquare != "none" || p.EncounterWhenOnPartySquare != "none" || p.scriptFilename != "none" || p.MouseOverText != "none"))
                    {
                        if ((p.LocationX == gv.mod.PlayerLocationX) && (p.LocationY == gv.mod.PlayerLocationY + 1))
                        {
                            bumpPropExists = true;
                            bumpProp = p;
                            gv.sf.ThisProp = bumpProp;
                            break;
                        }
                    }
                }
            }

            if (gv.mod.PlayerLocationY < (mapheight - 1))
            {

                bool isSuccesfulClimbAction = false;
                //First: current square
                //wesseling nord
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if (p.LocationX == gv.mod.PlayerLocationX && p.LocationY == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "south")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }


                    //Second: target square is south
                    if (p.LocationX == gv.mod.PlayerLocationX && p.LocationY - 1 == gv.mod.PlayerLocationY && p.isClimbable && p.climbDirection == "north")
                    {

                        //prepare skill check
                        string traitName = "";
                        string traitMethod = "leader";
                        foreach (Trait t in gv.mod.moduleTraitsList)
                        {
                            if (t.tag.Contains(p.climbTrait))
                            {
                                traitMethod = t.methodOfChecking;
                                traitName = t.nameOfTraitGroup;
                            }
                        }
                        int parm1 = gv.mod.selectedPartyLeader;
                        if (traitMethod.Equals("-1") || traitMethod.Equals("leader") || traitMethod.Equals("Leader"))
                        {
                            parm1 = gv.mod.selectedPartyLeader;
                        }
                        else if (traitMethod.Equals("-2") || traitMethod.Equals("highest") || traitMethod.Equals("Highest"))
                        {
                            parm1 = -2;
                        }
                        else if (traitMethod.Equals("-3") || traitMethod.Equals("lowest") || traitMethod.Equals("Lowest"))
                        {
                            parm1 = -3;
                        }
                        else if (traitMethod.Equals("-4") || traitMethod.Equals("average") || traitMethod.Equals("Average"))
                        {
                            parm1 = -4;
                        }
                        else if (traitMethod.Equals("-5") || traitMethod.Equals("allMustSucceed") || traitMethod.Equals("AllMustSucceed"))
                        {
                            parm1 = -5;
                        }
                        else if (traitMethod.Equals("-6") || traitMethod.Equals("oneMustSucceed") || traitMethod.Equals("OneMustSucceed"))
                        {
                            parm1 = -6;
                        }

                        int darkAdder = 0;

                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "night", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 4;
                        }
                        if (gv.sf.CheckPropByTagIsInDarknessPerArea(p.PropTag, "noLight", gv.mod.currentArea.Filename))
                        {
                            darkAdder = 12;
                        }

                        //skill check and messages
                        if (gv.sf.CheckPassSkill(parm1, p.climbTrait, p.climbDC + darkAdder, true, true))
                        {
                            isSuccesfulClimbAction = true;
                            //gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched", "green", 2000);
                            gv.cc.addLogText("lime", "Success: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " matched");
                        }
                        else
                        {
                            if (darkAdder == 4)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+4 for poor visibility)");
                            }
                            else if (darkAdder == 12)
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required (+12 for poor visibility)");

                            }
                            else
                            {
                                gv.screenMainMap.addFloatyText(p.LocationX, p.LocationY, "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required", "red", 2000);
                                gv.cc.addLogText("red", "Failure: " + traitName + " level " + (p.climbDC + darkAdder - 10).ToString() + " required");
                            }
                        }
                    }
                }

                if (isSuccesfulClimbAction)
                {
                    //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationY++;
                    gv.mod.drawPartyDirection = "up";
                    //gv.cc.doUpdate();

                    if (!gv.mod.wasSuccessfulPush)
                    {
                        gv.cc.doUpdate();
                    }
                    else
                    {
                        gv.mod.wasSuccessfulPush = false;
                    }
                }

                else if(gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false || gv.mod.currentArea.isOverviewMap)
                {

                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;
                    if (gv.mod.currentArea.Tiles[(gv.mod.PlayerLocationY + 1) * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].isSecretPassage)
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationY++;
                        gv.mod.PlayerLocationY++;
                        gv.mod.drawPartyDirection = "up";
                        gv.cc.doUpdate();
                    }
                    else
                    {
                        //gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                        //gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                        gv.mod.PlayerLocationY++;
                        gv.mod.drawPartyDirection = "up";
                        //gv.cc.doUpdate();
                        if (!gv.mod.wasSuccessfulPush)
                        {
                            gv.cc.doUpdate();
                        }
                        else
                        {
                            gv.mod.wasSuccessfulPush = false;
                        }
                    }
                }
                else if (bumpPropExists || bumpTriggerExists)
                {
                    StopScrollingOnBlocked();
                    if (bumpPropExists)
                    {
                        if ((!bumpProp.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[bumpProp.LocationY * gv.mod.currentArea.MapSizeX + bumpProp.LocationX].Visible))
                        {
                            gv.cc.showFloatyStepOrBumpPropInfo(bumpProp);
                        }

                        if (bumpProp.ConversationWhenOnPartySquare != "none")
                        {
                            //called from prop add?
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doConversationBasedOnTag(bumpProp.ConversationWhenOnPartySquare);
                        }

                        if (bumpProp.EncounterWhenOnPartySquare != "none")
                        {
                            gv.mod.EncounterOfTurnDone = true;
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.calledEncounterFromProp = true;
                            gv.cc.doEncounterBasedOnTag(bumpProp.EncounterWhenOnPartySquare);
                        }

                        if (bumpProp.scriptFilename != "none")
                        {
                            gv.sf.ThisProp = bumpProp;
                            gv.cc.doScriptBasedOnFilename(bumpProp.scriptFilename, bumpProp.parm1, bumpProp.parm2, bumpProp.parm3, bumpProp.parm4);

                            //code for floaty shown on prop upon script activation
                            if (bumpProp.scriptActivationFloaty != "none" && bumpProp.scriptActivationFloaty != "None" && bumpProp.scriptActivationFloaty != "")
                            {
                                gv.screenMainMap.addFloatyText(bumpProp.LocationX, bumpProp.LocationY, bumpProp.scriptActivationFloaty, "red", 2000);
                            }

                            //code for log, to do
                            if (bumpProp.scriptActivationLogEntry != "none" && bumpProp.scriptActivationLogEntry != "None" && bumpProp.scriptActivationLogEntry != "")
                            {
                                gv.cc.addLogText("red", bumpProp.scriptActivationLogEntry);
                            }

                            if (bumpProp.onlyOnce)
                            {
                                bumpProp.isShown = false;
                                bumpProp.isActive = false;
                            }
                        }
                    }
                    else if (bumpTriggerExists)
                    {
                        gv.cc.doBumpTrigger(bumpTrigger);
                    }

                    gv.cc.doUpdate();
                }
                else
                {
                    StopScrollingOnBlocked();
                    gv.cc.doUpdate();
                }
            }
        }
        public List<string> wrapList(string str, int wrapLength)
        {
            if (str == null)
            {
                return null;
            }
            if (wrapLength < 1)
            {
                wrapLength = 1;
            }
            int inputLineLength = str.Length;
            int offset = 0;
            List<string> returnList = new List<string>();

            while ((inputLineLength - offset) > wrapLength)
            {
                if (str.ElementAt(offset) == ' ')
                {
                    offset++;
                    continue;
                }

                int spaceToWrapAt = str.LastIndexOf(' ', wrapLength + offset);

                if (spaceToWrapAt >= offset)
                {
                    // normal case
                    returnList.Add(str.Substring(offset, spaceToWrapAt));
                    offset = spaceToWrapAt + 1;
                }
                else
                {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.IndexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0)
                    {
                        returnList.Add(str.Substring(offset, spaceToWrapAt));
                        offset = spaceToWrapAt + 1;
                    }
                    else
                    {
                        returnList.Add(str.Substring(offset));
                        offset = inputLineLength;
                    }
                }
            }

            // Whatever is left in line is short enough to just pass through
            returnList.Add(str.Substring(offset));
            return returnList;
        }
        
        public void setExploredForConnectedDiscoveryTriggers()
        {   
                foreach (Trigger t in gv.mod.currentArea.Triggers)
                {
                    if (t.connectedDiscovery)
                    {
                        bool oneDiscovered = false;
                    foreach (Coordinate c in t.TriggerSquaresList)
                    {
                        for (int i = 0; i < gv.mod.currentArea.Tiles.Count; i++)
                        {
                            int iX = i % gv.mod.currentArea.MapSizeX;
                            int iY = i / gv.mod.currentArea.MapSizeX;
                            if (c.X == iX && c.Y == iY)
                            {
                                if (gv.mod.currentArea.Tiles[i].Visible)
                                {
                                    oneDiscovered = true;
                                    break;
                                }
                            }
                        }

                        if (oneDiscovered)
                        {
                            break;
                        }
                    }

                        if (oneDiscovered)
                        {

                            foreach (Coordinate c2 in t.TriggerSquaresList)
                            {
                                gv.mod.currentArea.Tiles[c2.Y * gv.mod.currentArea.MapSizeX + c2.X].Visible = true;
                            }
                        }
                            
                        }
                    }
                }

        public void setExplored()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region New System
                //XXXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if ((gv.mod.currentArea.northernNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < 1))
                {
                    seamlessModififierMinY = 1;
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - 2)))
                {
                    seamlessModififierMaxY = 1;
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < 1))
                {
                    seamlessModififierMinX = 1;
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - 2)))
                {
                    seamlessModififierMaxX = 1;
                }

                
                //this block draws teh saquares immediately around the player
                int minX = gv.mod.PlayerLocationX - 1;
                if (minX < -seamlessModififierMinX) { minX = -seamlessModififierMinX; }
                int minY = gv.mod.PlayerLocationY - 1;
                if (minY < -seamlessModififierMinY) { minY = -seamlessModififierMinY; }

                int maxX = gv.mod.PlayerLocationX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX - 1 + seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX - 1 + seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY - 1 + seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY - 1 + seamlessModififierMaxY; }

                for (int xx = minX; xx <= maxX; xx++)
                {
                    for (int yy = minY; yy <= maxY; yy++)
                    {
                        //YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((xx < 0) && (yy < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + xx;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + yy;
                                tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((xx < 0) && (yy > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + xx;
                                int transformedY = yy - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((xx > (gv.mod.currentArea.MapSizeX - 1)) && (yy > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = xx - gv.mod.currentArea.MapSizeX;
                                int transformedY = yy - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((xx > (gv.mod.currentArea.MapSizeX - 1)) && (yy < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = xx - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + yy;
                                tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((xx < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + xx;
                                int transformedY = yy;
                                tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((yy > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = xx;
                                int transformedY = yy - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((xx > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = xx - gv.mod.currentArea.MapSizeX;
                                int transformedY = yy;
                                tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((yy < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = xx;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + yy;
                                tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx];
                            //gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                        }

                        if (drawTile)
                        {
                            tile.Visible = true;
                            
                            //tile.lightRadius = 0;
                            //tile.isCentreOfLightCircle = false;
                            //tile.isOtherPartOfLightCircle = false;
                        }

                        //YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
                        //gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                    }
                }

                int x = 0;
                int y = 0;

                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {

                    //1. check left-top (current, west, north, nortwest)
                    x = gv.mod.PlayerLocationX - 1;
                    y = gv.mod.PlayerLocationY - 1;

                    //current the second tier diagonal (NW) tile is on current map 
                    if ((x - 1 >= 0) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                    }

                    //west (inside check left top)
                    //the second tier diagonal (NW) tile is ONE square in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NW) tile is TWO squares in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y - 1 >= 0) && (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //north (inside check left top)
                    //the second tier diagonal (NW) tile is ONE square in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (NW) tile is TWO squares in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //northwest (inside check left top)
                    //the second tier diagonal (NW) tile is ONE square in northwestern map
                    if (indexOfNorthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NW) tile is TWO squares in northwestern map
                    if (indexOfNorthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 2;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                    //2. check left-bottom (current, west, south, southwest)
                    x = gv.mod.PlayerLocationX - 1;
                    y = gv.mod.PlayerLocationY + 1;

                    //current the second tier diagonal (SW) tile is on current map 
                    if ((x - 1 >= 0) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                    }

                    //west (inside check left bottom)
                    //the second tier diagonal (SW) tile is ONE square in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y + 1 < gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SW) tile is TWO squares in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y + 1 < gv.mod.currentArea.MapSizeY) && (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //south (inside check left bottom)
                    //the second tier diagonal (SW) tile is ONE square in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (SW) tile is TWO squares in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //southwest (inside check left top)
                    //the second tier diagonal (SW) tile is ONE square in southwestern map
                    if (indexOfSouthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SW) tile is TWO squares in southwestern map
                    if (indexOfSouthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(0) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 2;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                    //3. check right-bottom (current, east, south, southeast)
                    x = gv.mod.PlayerLocationX + 1;
                    y = gv.mod.PlayerLocationY + 1;

                    //current the second tier diagonal (SE) tile is on current map 
                    if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                    }

                    //east (inside check right bottom)
                    //the second tier diagonal (SE) tile is ONE square in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SE) tile is TWO squares in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //south (inside check right bottom)
                    //the second tier diagonal (SE) tile is ONE square in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (SE) tile is TWO squares in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //southeast (inside check right bottom)
                    //the second tier diagonal (SE) tile is ONE square in southeastern map
                    if (indexOfSouthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SE) tile is TWO squares in southeastern map
                    if (indexOfSouthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(0) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }
                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                    //4.check right-top (current, east, north, northeast)
                    x = gv.mod.PlayerLocationX + 1;
                    y = gv.mod.PlayerLocationY - 1;

                    //current: the second tier diagonal (NE) tile is on current map 
                    if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                    }

                    //east (inside check right top)
                    //the second tier diagonal (NE) tile is ONE square in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NE) tile is TWO squares in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y - 1 >= 0) && (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //north (inside check right top)
                    //the second tier diagonal (NE) tile is ONE square in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (NE) tile is TWO squares in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //northeast (inside check right top)
                    //the second tier diagonal (NE) tile is ONE square in northeastern map
                    if (indexOfNorthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[0 * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NE) tile is TWO squares in northeastern map
                    if (indexOfNorthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }
                } 

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check left
                    x = gv.mod.PlayerLocationX - 1;
                    y = gv.mod.PlayerLocationY;
                    //the second tier row is not on western map (|210)
                    if ((x - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on current map
                        if (y > 0)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier north tile is on norhtern map
                        else if (y == 0)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;

                        //the second tier south tile is on current map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier south tile is on southern map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on western map, but the potential LoS blocker still on current map (2|10)
                    else if ((x - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on western map
                        if (y > 0)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //the second tier north tile is on north-western map
                        else if (y == 0)
                        {
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on western map
                        if (indexOfWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier south tile is on western map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                        //the second tier south tile is on south-western map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on western map, but the party is still on current map (21|0)
                    else if (x - 1 == -2)
                    {
                        if (indexOfWesternNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked)
                            {
                                //the second tier north tile is on western map
                                if (y > 0)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                                //the second tier north tile is on north-western map
                                else if (y == 0)
                                {
                                    if (indexOfNorthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 2;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                        gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                //draw the second tier base tile on western map
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier south tile is on western map
                                if (y < gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                }
                                //the second tier south tile is on south-western map
                                else if (y == gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfSouthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 2;
                                        int transformedY = 0;
                                        gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                bool loSCheck1 = false;
                bool loSCheck2 = false;
                int tempX = 0;
                int tempY = 0;

                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check left of left
                    x = gv.mod.PlayerLocationX - 2;
                    y = gv.mod.PlayerLocationY;
                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempX = 0;

                    //loSCheck1
                    tempX = x + 1;
                    if (((tempX) < 0) && (indexOfWesternNeighbour != -1))
                    {
                        tempX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX;
                        if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((x + 1) >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x + 1].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempX = x;
                    if ((tempX < 0) && (indexOfWesternNeighbour != -1))
                    {
                        tempX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX;
                        if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (x >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on western map (|210)
                        if ((x - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on current map
                            if (y > 0)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier north tile is on norhtern map
                            else if (y == 0)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;

                            //the second tier south tile is on current map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier south tile is on southern map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on western map, but the potential LoS blocker still on current map (2|10)
                        else if ((x - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on western map
                            if (y > 0)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //the second tier north tile is on north-western map
                            else if (y == 0)
                            {
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on western map
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier south tile is on western map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                            //the second tier south tile is on south-western map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on western map, but the party is still on current map (21|0)
                        else if (x - 1 == -2)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked)
                                {
                                    //the second tier north tile is on western map
                                    if (y > 0)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-western map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 2;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on western map
                                    if (indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on western map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-western map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 2;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                        //utmost left situation (321|0)
                        else if (x - 1 == -3)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2)].LoSBlocked)
                                {
                                    //the second tier north tile is on western map
                                    if (y > 0)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 3;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-western map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 3;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on western map
                                    if (indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 3;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on western map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 3;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-western map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 3;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check right
                    x = gv.mod.PlayerLocationX + 1;
                    y = gv.mod.PlayerLocationY;
                    //the second tier row is not on eastern map (012|)
                    if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on current map
                        if (y > 0)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier north tile is on norhtern map
                        else if (y == 0)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;

                        //the second tier south tile is on current map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier south tile is on southern map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on eastern map, but the potential LoS blocker still on current map (01|2)
                    else if ((x + 1 == gv.mod.currentArea.MapSizeX) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on eastern map
                        if (y > 0)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //the second tier north tile is on north-eastern map
                        else if (y == 0)
                        {
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on eastern map
                        if (indexOfEasternNeighbour != -1)
                        {
                            int transformedX = 0;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier south tile is on eastern map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                        //the second tier south tile is on south-eastern map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on eastern map, but the party is still on current map (0|12)
                    else if (x + 1 == gv.mod.currentArea.MapSizeX + 1)
                    {
                        if (indexOfEasternNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked)
                            {
                                //the second tier north tile is on eastern map
                                if (y > 0)
                                {
                                    int transformedX = 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                                //the second tier north tile is on north-eastern map
                                else if (y == 0)
                                {
                                    if (indexOfNorthEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                        gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                // the second tier base tile on eastern map
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier south tile is on eastern map
                                if (y < gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                }
                                //the second tier south tile is on south-eastern map
                                else if (y == gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfSouthEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = 0;
                                        gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check right of right
                    x = gv.mod.PlayerLocationX + 2;
                    y = gv.mod.PlayerLocationY;
                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempX = 0;

                    //loSCheck1
                    tempX = x - 1;
                    if ((tempX > (gv.mod.currentArea.MapSizeX - 1)) && (indexOfEasternNeighbour != -1))
                    {
                        tempX = 0;
                        if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((x - 1) <= (gv.mod.currentArea.MapSizeX - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x - 1].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempX = x;
                    if ((tempX > (gv.mod.currentArea.MapSizeX - 1)) && (indexOfEasternNeighbour != -1))
                    {
                        tempX = 1;
                        if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (x <= (gv.mod.currentArea.MapSizeX - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on eastern map (012|)
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on current map
                            if (y > 0)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier north tile is on norhtern map
                            else if (y == 0)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;

                            //the second tier south tile is on current map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier south tile is on southern map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on eastern map, but the potential LoS blocker still on current map (01|2)
                        else if ((x + 1 == gv.mod.currentArea.MapSizeX) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on eastern map
                            if (y > 0)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //the second tier north tile is on north-eastern map
                            else if (y == 0)
                            {
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on eastern map
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier south tile is on eastern map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                            //the second tier south tile is on south-eastern map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on eastern map, but the party is still on current map (0|12)
                        else if (x + 1 == gv.mod.currentArea.MapSizeX + 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked)
                                {
                                    //the second tier north tile is on eastern map
                                    if (y > 0)
                                    {
                                        int transformedX = 1;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-eastern map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 1;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    // the second tier base tile on eastern map
                                    if (indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on eastern map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfEasternNeighbour != -1)
                                        {
                                            int transformedX = 1;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-eastern map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 1;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }

                        //utmost right situation (0|123)
                        else if (x + 1 == gv.mod.currentArea.MapSizeX + 2)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 1].LoSBlocked)
                                {
                                    //the second tier north tile is on eastern map
                                    if (y > 0)
                                    {
                                        int transformedX = 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-eastern map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 2;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    // the second tier base tile on eastern map
                                    if (indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on eastern map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfEasternNeighbour != -1)
                                        {
                                            int transformedX = 2;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-eastern map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 2;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                //XXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check up
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY - 1;
                    //the second tier row is not on northern map (|210, turn 90degree clockwise)
                    if ((y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on current map
                        if (x > 0)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier west tile is on western map
                        else if (x == 0)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                        //the second tier eastern tile is on current map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier eastern tile is on eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                //hrmmmpf
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree clockwise)
                    else if ((y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on northern map
                        if (x > 0)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }
                        //the second tier west tile is on north-western map
                        else if (x == 0)
                        {
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on northern map
                        if (indexOfNorthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier eastern tile is on northern map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }
                        //the second tier eastern tile is on north-eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree clockwise)
                    else if (y - 1 == -2)
                    {
                        if (indexOfNorthernNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                            {
                                //the second tier west tile is on northern map
                                if (x > 0)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2; ;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                                //the second tier west tile is on north-western map
                                else if (x == 0)
                                {
                                    if (indexOfNorthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                //draw the second tier base tile on northern map
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier east tile is on northern map
                                if (x < gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                    }
                                }
                                //the second tier east tile is on north-eastern map
                                else if (x == gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfNorthEasternNeighbour != -1)
                                    {
                                        int transformedX = 0;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check up of up
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY - 2;
                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempY = 0;

                    //loSCheck1
                    tempY = y + 1;
                    if (((tempY) < 0) && (indexOfNorthernNeighbour != -1))
                    {
                        tempY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + tempY;
                        if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((y + 1) >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempY = y;
                    if ((tempY < 0) && (indexOfNorthernNeighbour != -1))
                    {
                        tempY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + tempY;
                        if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (y >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on northern map (|210, turn 90degree clockwise)
                        if ((y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on current map
                            if (x > 0)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier west tile is on western map
                            else if (x == 0)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                            //the second tier eastern tile is on current map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier eastern tile is on eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    //hrmmmpf
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree clockwise)
                        else if ((y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on northern map
                            if (x > 0)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }
                            //the second tier west tile is on north-western map
                            else if (x == 0)
                            {
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on northern map
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier eastern tile is on northern map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }
                            //the second tier eastern tile is on north-eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree clockwise)
                        else if (y - 1 == -2)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on northern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2; ;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on north-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 2;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on northern map
                                    if (indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on northern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on north-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 2;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                        //utmost up(321|0, turn 90 degree clockwise)
                        else if (y - 1 == -3)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on northern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 3; ;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on north-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 3;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on northern map
                                    if (indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 3;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on northern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 3;
                                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on north-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 3;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check down
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY + 1;
                    //the second tier row is not on southern map (|210, turn 90degree counterclockwise)
                    if ((y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on current map
                        if (x > 0)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier west tile is on western map
                        else if (x == 0)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                        //the second tier eastern tile is on current map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier eastern tile is on eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree counterclockwise)
                    else if ((y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on southern map
                        if (x > 0)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }
                        //the second tier west tile is on south-western map
                        else if (x == 0)
                        {
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on southern map
                        if (indexOfSouthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier eastern tile is on southern map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }
                        //the second tier eastern tile is on south-eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree counterclockwise)
                    else if (y + 1 == gv.mod.currentArea.MapSizeY + 1)
                    {
                        if (indexOfSouthernNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                            {
                                //the second tier west tile is on southern map
                                if (x > 0)
                                {
                                    int transformedX = x;
                                    int transformedY = 1;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                                //the second tier west tile is on south-western map
                                else if (x == 0)
                                {
                                    if (indexOfSouthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                //draw the second tier base tile on southern map
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 1;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier east tile is on southern map
                                if (x < gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                    }
                                }
                                //the second tier east tile is on south-eastern map
                                else if (x == gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfSouthEasternNeighbour != -1)
                                    {
                                        int transformedX = 0;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check down of down
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY + 2;

                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempX = 0;

                    //loSCheck1
                    tempY = y - 1;
                    if ((tempY > (gv.mod.currentArea.MapSizeY - 1)) && (indexOfSouthernNeighbour != -1))
                    {
                        tempY = 0;
                        if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((y - 1) <= (gv.mod.currentArea.MapSizeY - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempY = y;
                    if ((tempY > (gv.mod.currentArea.MapSizeY - 1)) && (indexOfSouthernNeighbour != -1))
                    {
                        tempY = 1;
                        if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (y <= (gv.mod.currentArea.MapSizeY - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on southern map (|210, turn 90degree counterclockwise)
                        if ((y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on current map
                            if (x > 0)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier west tile is on western map
                            else if (x == 0)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                            //the second tier eastern tile is on current map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier eastern tile is on eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree counterclockwise)
                        else if ((y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on southern map
                            if (x > 0)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }
                            //the second tier west tile is on south-western map
                            else if (x == 0)
                            {
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on southern map
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier eastern tile is on southern map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }
                            //the second tier eastern tile is on south-eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree counterclockwise)
                        else if (y + 1 == gv.mod.currentArea.MapSizeY + 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on southern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on south-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = 1;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on southern map
                                    if (indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on southern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = 1;
                                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on south-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = 1;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                        //utmost down situation(321|0, turn 90 degree counterclockwise)
                        else if (y + 1 == gv.mod.currentArea.MapSizeY + 2)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[1 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on southern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = 2;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on south-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = 2;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on southern map
                                    if (indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = 2;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on southern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = 2;
                                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on south-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = 2;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXX
                #endregion
            }
            else
            {
                #region Old System

                // set current position to visible
                //gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].Visible = true;

                if (gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX < gv.mod.currentArea.Tiles.Count)
                {
                    gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].Visible = true;
                 }


                // set tiles to visible around the PC
                for (int x = gv.mod.PlayerLocationX - gv.mod.currentArea.AreaVisibleDistance; x <= gv.mod.PlayerLocationX + gv.mod.currentArea.AreaVisibleDistance; x++)
                {
                    for (int y = gv.mod.PlayerLocationY - gv.mod.currentArea.AreaVisibleDistance; y <= gv.mod.PlayerLocationY + gv.mod.currentArea.AreaVisibleDistance; y++)
                    {
                        int xx = x;
                        int yy = y;
                        if (xx < 1) { xx = 0; }
                        if (xx > (gv.mod.currentArea.MapSizeX - 1)) { xx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (yy < 1) { yy = 0; }
                        if (yy > (gv.mod.currentArea.MapSizeY - 1)) { yy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (IsLineOfSightForEachCorner(new Coordinate(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY), new Coordinate(xx, yy)))
                        {
                            gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                        }
                    }
                }
                //make all adjacent squares visible
                int minX = gv.mod.PlayerLocationX - 1;
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - 1;
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX - 1) { maxX = this.gv.mod.currentArea.MapSizeX - 1; }
                int maxY = gv.mod.PlayerLocationY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY - 1) { maxY = this.gv.mod.currentArea.MapSizeY - 1; }

                for (int xx = minX; xx <= maxX; xx++)
                {
                    for (int yy = minY; yy <= maxY; yy++)
                    {
                        gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                    }
                }
                #endregion
            }
        }
        public bool IsTouchInMapWindow(int sqrX, int sqrY)
        {
            //all input coordinates are in Screen Location, not Map Location
            if ((sqrX < 0) || (sqrY < 0))
            {
                return false;
            }
            if ((sqrX > 16) || (sqrY > 12))
            {
                return false;
            }
            return true;
        }
        public bool IsLineOfSightForEachCorner(Coordinate s, Coordinate e)
        {
            //start is at the center of party location square
            Coordinate start = new Coordinate((s.X * gv.squareSize) + (gv.squareSize / 2), (s.Y * gv.squareSize) + (gv.squareSize / 2));
            //check center of all four sides of the end square
            int halfSquare = (gv.squareSize / 2);
            //left side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize, e.Y * gv.squareSize + halfSquare), e)) { return true; }
            //right side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize + gv.squareSize, e.Y * gv.squareSize + halfSquare), e)) { return true; }
            //top side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize + halfSquare, e.Y * gv.squareSize), e)) { return true; }
            //bottom side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize + halfSquare, e.Y * gv.squareSize + gv.squareSize), e)) { return true; }

            return false;
        }
        public bool IsVisibleLineOfSight(Coordinate s, Coordinate e, Coordinate endSquare)
        {
            // Bresenham Line algorithm
            Coordinate start = s;
            Coordinate end = e;
            int deltax = Math.Abs(end.X - start.X);
            int deltay = Math.Abs(end.Y - start.Y);
            int ystep = 10;
            int xstep = 10;
            int gridx = 0;
            int gridy = 0;
            int gridXdelayed = s.X;
            int gridYdelayed = s.Y;

            //gv.DrawLine(end.X + gv.oXshift, end.Y + gv.oYshift, start.X + gv.oXshift, start.Y + gv.oYshift, Color.Lime, 1);
            
            #region low angle version
            if (deltax > deltay) //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltax / 2;

                if (end.Y < start.Y) { ystep = -1 * ystep; } //down and right or left

                if (end.X > start.X) //down and right
                {
                    for (int x = start.X; x <= end.X; x += xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                else //down and left
                {
                    for (int x = start.X; x >= end.X; x -= xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
            }
            #endregion

            #region steep version
            else //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltay / 2;

                if (end.X < start.X) { xstep = -1 * xstep; } //up and right or left

                if (end.Y > start.Y) //up and right
                {
                    for (int y = start.Y; y <= end.Y; y += ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                else //up and right
                {
                    for (int y = start.Y; y >= end.Y; y -= ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
            }
            #endregion

            return true;
        }

        public bool hasMainMapTypeSpell(Player pc)
        {
            foreach (string s in pc.knownSpellsTags)
            {
                Spell sp = gv.mod.getSpellByTag(s);
                if (sp == null) { continue; }
                if ((sp.useableInSituation.Equals("Always")) || (sp.useableInSituation.Equals("OutOfCombat")))
                {
                    return true;
                }
            }
            return false;
        }
    }
}
//#endregion
