using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.IO;
using System.Windows.Forms;
using Bitmap = SharpDX.Direct2D1.Bitmap;
using Color = SharpDX.Color;
using Newtonsoft.Json;

namespace IceBlink2
{
    public class ScreenMainMap
    {
        //public gv.module gv.mod;
        public GameView gv;

        public IB2UILayout mainUiLayout = null;
        public bool isMoving = false;
        public bool showMiniMap = false;
        public bool showClock = false;
        public bool showFullParty = false;
        public bool showArrows = true;
        public bool hideClock = false;
        public int shifter = 0;
        public int shifterY = 0;
        public float shifterDelayCounter = 0;
        public bool shifterRise = true;
        public float shifterYDelayCounter = 0;
        public bool shifterYRise = true;
        public float flicker = 0;
        public float flicker2 = 0;
        public float flickerDelayCounter = 0;
        public bool flickerRise = true;
        public bool shifterPause = false;

        /*private IbbButton btnParty = null;
        private IbbButton btnJournal = null;
        private IbbButton btnSettings = null;
        private IbbButton btnSave = null;
        private IbbButton btnCastOnMainMap = null;
        private IbbButton btnWait = null;
        public IbbToggleButton tglFullParty = null;
        public IbbToggleButton tglMiniMap = null;
        public IbbToggleButton tglGrid = null;
        public IbbToggleButton tglInteractionState = null;
        public IbbToggleButton tglAvoidConversation = null;
        public IbbToggleButton tglClock = null;*/
        public List<FloatyText> floatyTextPool = new List<FloatyText>();
        public List<FloatyTextByPixel> floatyTextByPixelPool = new List<FloatyTextByPixel>();
        public int mapStartLocXinPixels;
        public int movementDelayInMiliseconds = 100;
        private long timeStamp = 0;
        private bool finishedMove = true;
        public Bitmap minimap = null;
        public Bitmap fullScreenEffect1 = null;
        public Bitmap fullScreenEffect2 = null;
        public Bitmap fullScreenEffect3 = null;
        public Bitmap fullScreenEffect4 = null;
        public Bitmap fullScreenEffect5 = null;
        public Bitmap fullScreenEffect6 = null;
        public Bitmap fullScreenEffect7 = null;
        public Bitmap fullScreenEffect8 = null;
        public Bitmap fullScreenEffect9 = null;
        public Bitmap fullScreenEffect10 = null;
        public List<Sprite> spriteList = new List<Sprite>();

        public ScreenMainMap(Module m, GameView g)
        {
            //gv.mod = m;
            gv = g;
            mapStartLocXinPixels = 0 * gv.squareSize + gv.oXshift;
            loadMainUILayout();
            //setControlsStart();
            //setToggleButtonsStart();            
        }
        public void loadMainUILayout()
        {
            try
            {
                if (File.Exists(gv.cc.GetModulePath() + "\\data\\MainUILayout.json"))
                {
                    using (StreamReader file = File.OpenText(gv.cc.GetModulePath() + "\\data\\MainUILayout.json"))
                    {
                        JsonSerializer serializer = new JsonSerializer();
                        mainUiLayout = (IB2UILayout)serializer.Deserialize(file, typeof(IB2UILayout));
                        mainUiLayout.setupIB2UILayout(gv);
                    }
                }
                else
                {
                    using (StreamReader file = File.OpenText(gv.mainDirectory + "\\default\\NewModule\\data\\MainUILayout.json"))
                    {
                        JsonSerializer serializer = new JsonSerializer();
                        mainUiLayout = (IB2UILayout)serializer.Deserialize(file, typeof(IB2UILayout));
                        mainUiLayout.setupIB2UILayout(gv);
                    }
                }

                IB2ToggleButton tgl = mainUiLayout.GetToggleByTag("tglMiniMap");
                if (tgl != null)
                {
                    showMiniMap = tgl.toggleOn;
                }

                IB2ToggleButton tgl2 = mainUiLayout.GetToggleByTag("tglClock");
                if (tgl2 != null)
                {
                    showClock = tgl2.toggleOn;
                }
                IB2ToggleButton tgl3 = mainUiLayout.GetToggleByTag("tglFullParty");
                if (tgl3 != null)
                {
                    showFullParty = tgl3.toggleOn;
                }
                foreach (IB2Panel pnl in mainUiLayout.panelList)
                {
                    if (pnl.tag.Equals("logPanel"))
                    {
                        float sqrW = (float)gv.screenWidth / (gv.squaresInWidth + 2f / 10f);
                        float sqrH = (float)gv.screenHeight / (gv.squaresInHeight + 3f / 10f);
                        gv.log = pnl.logList[0];
                        gv.cc.addLogText("red", "screenDensity: " + gv.screenDensity);
                        gv.cc.addLogText("fuchsia", "screenWidth: " + gv.screenWidth);
                        gv.cc.addLogText("lime", "screenHeight: " + gv.screenHeight);
                        gv.cc.addLogText("yellow", "squareSize: " + gv.squareSize);
                        gv.cc.addLogText("yellow", "sqrW: " + sqrW);
                        gv.cc.addLogText("yellow", "sqrH: " + sqrH);
                        gv.cc.addLogText("yellow", "");
                        gv.cc.addLogText("red", "Welcome to " + gv.mod.moduleLabelName);
                        gv.cc.addLogText("fuchsia", "You can scroll this message log box, use mouse wheel");
                        gv.cc.addLogText("yellow", "'x' will hide/show all UI panels");
                    }

                    if (gv.mod.useMinimalisticUI)
                    {
                        if (pnl.tag.Equals("arrowPanel"))
                        {
                            pnl.hiding = true;
                            pnl.showing = false;
                            showArrows = false;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error Loading MainUILayout.json: " + ex.ToString());
                gv.errorLog(ex.ToString());
            }
        }
        public void saveUILayout()
        {
            try
            {
                //string filepath = gv.mainDirectory + "\\MainUILayout.json";
                string filepath = gv.cc.GetModulePath() + "\\data\\MainUILayout.json";
                string json = JsonConvert.SerializeObject(mainUiLayout, Newtonsoft.Json.Formatting.Indented);
                using (StreamWriter sw = new StreamWriter(filepath))
                {
                    sw.Write(json.ToString());
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
            }
        }
        /*public void setControlsStart()
        {
            int pW = (int)((float)gv.screenWidth / 100.0f);
            int pH = (int)((float)gv.screenHeight / 100.0f);
            int padW = gv.squareSize / 6;
            int hotkeyShift = 0;
            if (gv.useLargeLayout)
            {
                hotkeyShift = 1;
            }


            if (btnWait == null)
            {
                btnWait = new IbbButton(gv, 0.8f);
                btnWait.Text = "WAIT";
                btnWait.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnWait.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnWait.X = 17 * gv.squareSize - 3*gv.oXshift;
                //btnWait.Y = 8 * gv.squareSize + pH * 2;
                btnWait.X = gv.cc.pnlArrows.LocX + 1 * gv.squareSize + gv.squareSize / 2;
                btnWait.Y = gv.cc.pnlArrows.LocY + 1 * gv.squareSize + gv.pS;
                btnWait.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnWait.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnParty == null)
            {
                btnParty = new IbbButton(gv, 0.8f);
                btnParty.HotKey = "P";
                btnParty.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnParty.Img2 = gv.cc.LoadBitmap("btnparty"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnparty);
                btnParty.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnParty.X = 7 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnParty.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnParty.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 0) * gv.squareSize;
                btnParty.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnParty.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnParty.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnJournal == null)
            {
                btnJournal = new IbbButton(gv, 0.8f);
                btnJournal.HotKey = "J";
                btnJournal.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnJournal.Img2 = gv.cc.LoadBitmap("btnjournal"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnjournal);
                btnJournal.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnJournal.X = 9 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnJournal.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnJournal.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 2) * gv.squareSize;
                btnJournal.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnJournal.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnJournal.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnSettings == null)
            {
                btnSettings = new IbbButton(gv, 1.0f);
                btnSettings.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnSettings.Img2 = gv.cc.LoadBitmap("btnsettings"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnsettings);
                btnSettings.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnSettings.X = 10 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnSettings.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnSettings.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 3) * gv.squareSize;
                btnSettings.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnSettings.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSettings.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnCastOnMainMap == null)
            {
                btnCastOnMainMap = new IbbButton(gv, 0.8f);
                btnCastOnMainMap.HotKey = "C";
                btnCastOnMainMap.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnCastOnMainMap.Img2 = gv.cc.LoadBitmap("btnspell"); // BitmapFactory.decodeResource(getResources(), R.drawable.btnspell);
                btnCastOnMainMap.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnCastOnMainMap.X = 11 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnCastOnMainMap.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnCastOnMainMap.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 4) * gv.squareSize;
                btnCastOnMainMap.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnCastOnMainMap.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnCastOnMainMap.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
            if (btnSave == null)
            {
                btnSave = new IbbButton(gv, 0.8f);
                btnSave.Img = gv.cc.LoadBitmap("btn_small"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small);
                btnSave.ImgOff = gv.cc.LoadBitmap("btn_small_off");
                btnSave.Img2 = gv.cc.LoadBitmap("btndisk"); // BitmapFactory.decodeResource(getResources(), R.drawable.btndisk);
                btnSave.Glow = gv.cc.LoadBitmap("btn_small_glow"); // BitmapFactory.decodeResource(getResources(), R.drawable.btn_small_glow);
                //btnSave.X = 12 * gv.squareSize + padW * 0 + gv.oXshift;
                //btnSave.Y = 9 * gv.squareSize + +(int)(1.75 * pH);
                btnSave.X = gv.cc.pnlHotkeys.LocX + (hotkeyShift + 5) * gv.squareSize;
                btnSave.Y = gv.cc.pnlHotkeys.LocY + 0 * gv.squareSize + gv.pS;
                btnSave.Height = (int)(gv.ibbheight * gv.screenDensity);
                btnSave.Width = (int)(gv.ibbwidthR * gv.screenDensity);
            }
        }*/
        /*public void setToggleButtonsStart()
        {
            int pW = (int)((float)gv.screenWidth / 100.0f);
            int pH = (int)((float)gv.screenHeight / 100.0f);
            int padW = gv.squareSize / 6;

            if (tglFullParty == null)
            {
                tglFullParty = new IbbToggleButton(gv);
                tglFullParty.ImgOn = gv.cc.LoadBitmap("tgl_fullparty_on");
                tglFullParty.ImgOff = gv.cc.LoadBitmap("tgl_fullparty_off");
                //tglFullParty.X = 0 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglFullParty.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglFullParty.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglFullParty.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglFullParty.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglFullParty.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglFullParty.toggleOn = true;
            }
            if (tglMiniMap == null)
            {
                tglMiniMap = new IbbToggleButton(gv);
                tglMiniMap.ImgOn = gv.cc.LoadBitmap("tgl_minimap_on");
                tglMiniMap.ImgOff = gv.cc.LoadBitmap("tgl_minimap_off");
                //tglMiniMap.X = 4 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglMiniMap.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglMiniMap.X = gv.cc.pnlToggles.LocX + 2 * gv.squareSize + gv.squareSize / 4;
                tglMiniMap.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglMiniMap.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglMiniMap.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglMiniMap.toggleOn = false;
            }
            if (tglGrid == null)
            {
                tglGrid = new IbbToggleButton(gv);
                tglGrid.ImgOn = gv.cc.LoadBitmap("tgl_grid_on");
                tglGrid.ImgOff = gv.cc.LoadBitmap("tgl_grid_off");
                //tglGrid.X = 1 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglGrid.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglGrid.X = gv.cc.pnlToggles.LocX + 1 * gv.squareSize + gv.squareSize / 4;
                tglGrid.Y = gv.cc.pnlToggles.LocY + 1 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglGrid.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglGrid.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglGrid.toggleOn = true;
            }
            if (tglClock == null)
            {
                tglClock = new IbbToggleButton(gv);
                tglClock.ImgOn = gv.cc.LoadBitmap("tgl_clock_on");
                tglClock.ImgOff = gv.cc.LoadBitmap("tgl_clock_off");
                //tglClock.X = 2 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglClock.Y = 9 * (gv.squareSize) + (gv.squareSize / 2);
                tglClock.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglClock.Y = gv.cc.pnlToggles.LocY + 2 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglClock.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglClock.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglClock.toggleOn = true;
            }
            if (tglInteractionState == null)
            {
                tglInteractionState = new IbbToggleButton(gv);
                tglInteractionState.ImgOn = gv.cc.LoadBitmap("tgl_state_on");
                tglInteractionState.ImgOff = gv.cc.LoadBitmap("tgl_state_off");
                //tglInteractionState.X = 1 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglInteractionState.Y = 8 * (gv.squareSize) + (gv.squareSize / 2);
                tglInteractionState.X = gv.cc.pnlToggles.LocX + 3 * gv.squareSize + gv.squareSize / 4;
                tglInteractionState.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglInteractionState.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglInteractionState.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglInteractionState.toggleOn = false;
            }
            if (tglAvoidConversation == null)
            {
                tglAvoidConversation = new IbbToggleButton(gv);
                tglAvoidConversation.ImgOn = gv.cc.LoadBitmap("tgl_avoidConvo_on");
                tglAvoidConversation.ImgOff = gv.cc.LoadBitmap("tgl_avoidConvo_off");
                //tglAvoidConversation.X = 0 * gv.squareSize + gv.oXshift + (gv.squareSize / 2);
                //tglAvoidConversation.Y = 8 * (gv.squareSize) + (gv.squareSize / 2);
                tglAvoidConversation.X = gv.cc.pnlToggles.LocX + 2 * gv.squareSize + gv.squareSize / 4;
                tglAvoidConversation.Y = gv.cc.pnlToggles.LocY + 0 * gv.squareSize + gv.squareSize / 4 + gv.pS;
                tglAvoidConversation.Height = (int)(gv.ibbheight / 2 * gv.screenDensity);
                tglAvoidConversation.Width = (int)(gv.ibbwidthR / 2 * gv.screenDensity);
                tglAvoidConversation.toggleOn = false;
            }
        }*/
        //MAIN SCREEN UPDATE
        public void Update(int elapsed)
        {
            //prop animation code
            doPropAnimations(elapsed);

            if (gv.moveTimerRuns)
            {
                int x = gv.mousePositionX - (int)(gv.squareSize * 15f / 100f);
                int y = gv.mousePositionY - (int)(gv.squareSize * 55f / 100f);

                int xDistanceFromCenter = x - (int)(gv.screenWidth / 2f);
                if (xDistanceFromCenter < 0)
                {
                    xDistanceFromCenter = xDistanceFromCenter * -1;
                }

                int yDistanceFromCenter = y - (int)(gv.screenHeight / 2f);
                if (yDistanceFromCenter < 0)
                {
                    yDistanceFromCenter = yDistanceFromCenter * -1;
                }

                int moveSpeed = 0;
                if (yDistanceFromCenter >= xDistanceFromCenter)
                {
                    moveSpeed = (int)(yDistanceFromCenter * 0.8f);
                }
                else
                {
                    moveSpeed = (int)(xDistanceFromCenter * 0.8f);
                }

                if (moveSpeed > 2.5f * gv.squareSize)
                {
                    moveSpeed = (int)(2.5f * gv.squareSize);
                }

                gv.moveTimerCounter += (elapsed * moveSpeed / gv.squareSize);

                if (gv.moveTimerCounter >= 150)
                {
                    isMoving = true;
                }

                if (gv.moveTimerCounter >= 300)
                {
                    gv.moveTimerCounter = 0;
                    //int x = gv.mousePositionX - (int)(gv.squareSize * 4f / 10f);
                    //int y = gv.mousePositionY - (int)(gv.squareSize * 55f / 100f);
                    int gridX = x / gv.squareSize;
                    int gridY = y / gv.squareSize;
                    int actualx = gv.mod.PlayerLocationX + (gridX - gv.playerOffsetX);
                    int actualy = gv.mod.PlayerLocationY + (gridY - gv.playerOffsetY);

                    if (gv.mod.PlayerLocationX == actualx && gv.mod.PlayerLocationY - 1 >= actualy)
                    {
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            if (gv.mod.PlayerLocationY > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationY--;
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if (gv.mod.PlayerLocationX == actualx && gv.mod.PlayerLocationY + 1 <= actualy)
                    {

                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            int mapheight = gv.mod.currentArea.MapSizeY;
                            if (gv.mod.PlayerLocationY < (mapheight - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationY++;
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if (gv.mod.PlayerLocationX - 1 >= actualx && gv.mod.PlayerLocationY == actualy)
                    {
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            if (gv.mod.PlayerLocationX > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationX--;
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        if (!pc.combatFacingLeft)
                                        {
                                            pc.combatFacingLeft = true;
                                        }
                                    }
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if (gv.mod.PlayerLocationX + 1 <= actualx && gv.mod.PlayerLocationY == actualy)
                    {
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            int mapwidth = gv.mod.currentArea.MapSizeX;
                            if (gv.mod.PlayerLocationX < (mapwidth - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                {
                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationX++;
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        if (pc.combatFacingLeft)
                                        {
                                            pc.combatFacingLeft = false;
                                        }
                                    }
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }

                }
            }

            mainUiLayout.Update(elapsed);

            //handle RealTime Timer events if gv.module uses this system
            if (gv.mod.useRealTimeTimer)
            {
                gv.realTimeTimerMilliSecondsEllapsed += elapsed;
                if (gv.realTimeTimerMilliSecondsEllapsed >= gv.mod.realTimeTimerLengthInMilliSeconds)
                {
                    gv.mod.calledByRealTimeTimer = true;
                    gv.cc.doUpdate();
                    gv.mod.calledByRealTimeTimer = false;
                    gv.realTimeTimerMilliSecondsEllapsed = 0;
                }
            }

            //weather effects
            if (gv.mod.isRaining)
            {
                gv.fullScreenEffectTimerMilliSecondsElapsedRain += elapsed;
                float rainChance2 = gv.sf.RandInt(200) + 150;
                if (gv.fullScreenEffectTimerMilliSecondsElapsedRain > rainChance2)
                {
                    gv.cc.createRain(gv.rainType);
                    gv.fullScreenEffectTimerMilliSecondsElapsedRain = 0;
                }
            }


            if (gv.mod.isSnowing)
            {
                gv.fullScreenEffectTimerMilliSecondsElapsedSnow += elapsed;
                float snowChance2 = gv.sf.RandInt(200) + 150;
                if (gv.fullScreenEffectTimerMilliSecondsElapsedSnow > snowChance2)
                {
                    gv.cc.createSnow(gv.snowType);
                    gv.fullScreenEffectTimerMilliSecondsElapsedSnow = 0;
                }
            }

            if (gv.mod.isSandstorm)
            {
                gv.fullScreenEffectTimerMilliSecondsElapsedSandstorm += elapsed;
                float sandstormChance2 = gv.sf.RandInt(200) + 150;
                if (gv.fullScreenEffectTimerMilliSecondsElapsedSandstorm > sandstormChance2)
                {
                    gv.cc.createSandstorm(gv.sandstormType);
                    gv.fullScreenEffectTimerMilliSecondsElapsedSandstorm = 0;
                }
            }

            if ((gv.mod.isCloudy) && (!gv.mod.blockCloudCreation))
            {
                //gv.fullScreenEffectTimerMilliSecondsElapsedClouds += elapsed;
                //float cloudChance = gv.sf.RandInt(10000) + 7500;
                //if (gv.fullScreenEffectTimerMilliSecondsElapsedClouds > cloudChance)
                //{
                int decider2 = gv.sf.RandInt(8);
                if (decider2 == 1)
                {
                    gv.mod.windDirection = "SE";
                }
                if (decider2 == 2)
                {
                    gv.mod.windDirection = "NE";
                }
                if (decider2 == 3)
                {
                    gv.mod.windDirection = "SW";
                }
                if (decider2 == 4)
                {
                    gv.mod.windDirection = "NW";
                }
                if (decider2 == 5)
                {
                    gv.mod.windDirection = "South";
                }
                if (decider2 == 6)
                {
                    gv.mod.windDirection = "North";
                }
                if (decider2 == 7)
                {
                    gv.mod.windDirection = "West";
                }
                if (decider2 == 8)
                {
                    gv.mod.windDirection = "East";
                }

                float speedMultiplier = 0;
                float positionmodifierX = 0;
                float positionmodifierY = 0;

                for (int i = 0; i < 7; i++)
                {
                    int decider = gv.sf.RandInt(3);
                    string layerType = "";
                    if (decider == 1)
                    {
                        layerType = "LayerA";
                    }
                    if (decider == 2)
                    {
                        layerType = "LayerB";
                    }
                    if (decider == 3)
                    {
                        layerType = "LayerC";
                    }
                    speedMultiplier = 0.39f + (i * 0.1f);
                    decider = gv.sf.RandInt(15);
                    positionmodifierX = (-7 + decider) * gv.squareSize;
                    decider = gv.sf.RandInt(9);
                    positionmodifierY = (-4 + decider) * gv.squareSize;
                    gv.cc.createClouds(gv.cloudType + layerType, speedMultiplier, positionmodifierX, positionmodifierY);
                    gv.mod.blockCloudCreation = true;

                }
            }

            if ((gv.mod.isFoggy) && (!gv.mod.blockFogCreation))
            {

                gv.mod.blockFogCreation = true;
                float speedMultiplier = 0;
                float positionmodifierX = 0;
                float positionmodifierY = 0;
                string layerType = "";
                int decider = 0;
                int iLimit = 0;
                if (gv.fogType.Contains("lightFog") || gv.fogType.Contains("LightFog"))
                {
                    iLimit = 6;
                }
                else if (gv.fogType.Contains("heavyFog") || gv.fogType.Contains("HeavyFog"))
                {
                    iLimit = 8;
                }
                else if (gv.fogType.Contains("fog") || gv.fogType.Contains("Fog"))
                {
                    iLimit = 7;
                }

                for (int i = 0; i < iLimit; i++)
                {

                    positionmodifierX = 0;
                    positionmodifierY = 0;

                    if (i == 0)
                    {
                        layerType = "fog1";
                        decider = gv.sf.RandInt(20);
                        speedMultiplier = 0.50f + (decider / 100f);
                        positionmodifierX = (-4) * gv.squareSize;
                    }

                    if (i == 1)
                    {
                        layerType = "fog2";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (4) * gv.squareSize;
                    }

                    if (i == 2)
                    {
                        layerType = "fog3";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (2) * gv.squareSize;
                        positionmodifierY = (2) * gv.squareSize;
                    }

                    if (i == 3)
                    {
                        layerType = "fog4";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-2) * gv.squareSize;
                        positionmodifierY = (-2) * gv.squareSize;
                    }

                    if (i == 4)
                    {
                        layerType = "fog5";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-6) * gv.squareSize;

                    }

                    if (i == 5)
                    {
                        layerType = "fog6";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = 6 * gv.squareSize;

                    }
                    if (i == 6)
                    {
                        layerType = "fog7";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-1) * gv.squareSize;
                        positionmodifierY = (-1) * gv.squareSize;

                    }

                    if (i == 7)
                    {
                        layerType = "fog8";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-3) * gv.squareSize;
                        positionmodifierY = (-3) * gv.squareSize;
                    }

                    if (i == 8)
                    {
                        layerType = "fog1";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (3) * gv.squareSize;
                        positionmodifierY = (3) * gv.squareSize;
                    }

                    if (i == 9)
                    {
                        layerType = "fog2";
                        decider = gv.sf.RandInt(50);
                        speedMultiplier += 0.04f;
                        positionmodifierX = (-5) * gv.squareSize;

                    }

                    gv.cc.createFog(layerType, speedMultiplier, positionmodifierX - 1.8f * gv.squareSize, positionmodifierY);
                }
            }

            if (gv.mod.isLightning)
            {
                string lightningType = "";
                float posX = 0;
                float posY = 0;
                float scalemod = 0;
                int lightningChance = 175;
                if (gv.sf.RandInt(lightningChance) == 1)
                {
                    gv.cc.setToBorderPixDistancesMainMap();
                    int deciderWestEast = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderWest + (int)gv.mod.pixDistanceToBorderEast);
                    int deciderNorthSouth = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderNorth + (int)gv.mod.pixDistanceToBorderSouth);

                    if (deciderWestEast <= (int)gv.mod.pixDistanceToBorderWest)
                    {
                        posX = -gv.sf.RandInt((int)gv.mod.pixDistanceToBorderWest) + gv.screenWidth / 2;
                    }
                    else
                    {
                        //the -3 gv.modifiier makes sure that at significant part of the lightning is onscreen
                        posX = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderEast) - (3 * gv.squareSize) + gv.screenWidth / 2;
                    }

                    if (deciderNorthSouth <= (int)gv.mod.pixDistanceToBorderNorth)
                    {
                        posY = -gv.sf.RandInt((int)gv.mod.pixDistanceToBorderNorth) + gv.screenHeight / 2;
                    }
                    else
                    {
                        //the -3 gv.modifiier makes sure that at significant part of the lightning is onscreen
                        posY = gv.sf.RandInt((int)gv.mod.pixDistanceToBorderSouth) - (3 * gv.squareSize) + gv.screenHeight / 2;
                    }

                    int lightningTypeDecider = gv.sf.RandInt(2);

                    if (lightningTypeDecider == 1)
                    {
                        lightningType = "lightningLayerA";
                    }

                    else
                    {
                        lightningType = "lightningLayerB";
                    }

                    scalemod = (gv.sf.RandInt(70) + 65) / 100;
                    gv.cc.createLightning(lightningType, posX, posY, scalemod);
                }
            }

            #region PROP AMBIENT SPRITES
            foreach (Sprite spr in spriteList)
            {
                spr.Update(elapsed, gv);
            }
            for (int x = spriteList.Count - 1; x >= 0; x--)
            {
                if (spriteList[x].timeToLiveInMilliseconds <= 0)
                {
                    try
                    {
                        if (!spriteList[x].movementMethod.Contains("clouds") && !spriteList[x].movementMethod.Contains("fog") && !spriteList[x].movementMethod.Contains("lightning"))
                        {
                            spriteList.RemoveAt(x);
                            continue;
                        }
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if (!gv.mod.isCloudy && spriteList[x].movementMethod.Contains("clouds"))
                {
                    gv.mod.blockCloudCreation = false;
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if (!gv.mod.isFoggy && spriteList[x].movementMethod.Contains("fog"))
                {
                    gv.mod.blockFogCreation = false;
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if ((!gv.mod.isRaining && spriteList[x].movementMethod.Contains("rain")) || (!gv.mod.isSnowing && spriteList[x].movementMethod.Contains("snow")) || (!gv.mod.isSandstorm && spriteList[x].movementMethod.Contains("sandStorm")))
                {
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }

                if (spriteList[x].movementMethod.Contains("lightning") && (spriteList[x].totalElapsedTime >= (spriteList[x].numberOFFramesForAnimationsMadeFromSeveralBitmaps * spriteList[x].millisecondsPerFrame)))
                {
                    try
                    {
                        spriteList.RemoveAt(x);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        gv.errorLog(ex.ToString());
                    }
                }
            }
            #endregion

            #region FLOATY TEXT            
            //move up 50pxl per second (50px/1000ms)*elapsed
            if (gv.mod.useSmoothMovement)
            {
                if (floatyTextByPixelPool.Count > 0)
                {
                    int shiftUp = (int)(0.05f * elapsed);
                    foreach (FloatyTextByPixel ft in floatyTextByPixelPool)
                    {
                        ft.z += shiftUp;
                        ft.timeToLive -= (int)(elapsed);
                    }
                    //remove expired floaty text
                    for (int i = floatyTextByPixelPool.Count - 1; i >= 0; i--)
                    {
                        if (floatyTextByPixelPool[i].timeToLive <= 0)
                        {
                            floatyTextByPixelPool.RemoveAt(i);
                        }
                    }

                    //remove if too many floats are in pool
                    for (int i = floatyTextByPixelPool.Count - 1; i >= 0; i--)
                    {
                        if (((floatyTextByPixelPool.Count - 1 - i) > 15))
                        {
                            floatyTextByPixelPool.RemoveAt(i);
                        }
                    }
                }
            }
            if (floatyTextPool.Count > 0)
            {
                int shiftUp = (int)(0.05f * elapsed);
                foreach (FloatyText ft in floatyTextPool)
                {
                    ft.z += shiftUp;
                    ft.timeToLive -= (int)(elapsed);
                }

                //remove expired floaty text
                for (int i = floatyTextPool.Count - 1; i >= 0; i--)
                {
                    if (floatyTextPool[i].timeToLive <= 0)
                    {
                        floatyTextPool.RemoveAt(i);
                    }
                }

                //remove if too many floats are in pool
                for (int i = floatyTextPool.Count - 1; i >= 0; i--)
                {
                    if (((floatyTextPool.Count - 1 - i) > 15))
                    {
                        floatyTextPool.RemoveAt(i);
                    }
                }

            }
            #endregion
        }

        public void doPropAnimations(float elapsed)
        {
            
            //need to update animated props on neighbouring areas, too
            //theflameandtheflood

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
             //XXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //player near northern border
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                {
                    seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near southern  border
                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near western border
                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                {
                    seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near eastern border
                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                bool situationFound = false;
                //int relevantIndex = -1;
                List<int> relevantIndices = new List<int>();
                int northernmodifier = 0;
                int easternmodifier = 0;
                int westernmodifier = 0;
                int southernmodifier = 0;

                //northwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthWesternNeighbour);
                }
                //northeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthEasternNeighbour);
                }
                //southwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthWesternNeighbour);
                }
                //southeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthEasternNeighbour);
                }
                //north
                if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthernNeighbour);
                }
                //south
                if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthernNeighbour);
                }
                //west
                if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfWesternNeighbour);
                }
                //east
                if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfEasternNeighbour);
                }
                
                //current map
                //if (!situationFound)
                //{
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                        {
                            relevantIndices.Add(i);
                        }
                    } 
                //}
                

                //XXXXXXXXXXXXXXXXXXXXXXXX
                for (int i = 0; i < relevantIndices.Count; i++)
                {//2

                    int backupLocationX = -1;
                    int backupLocationY = -1;

                    foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                    {


                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                        //foreach (Prop p in gv.mod.currentArea.Props)
                        //{
                        if (p.animationIsActive)
                        {
                            float fadeAmount = 0;
                            if (p.framesNeededForFullFadeInOut > 0)
                            {
                                fadeAmount = 1f / p.framesNeededForFullFadeInOut;
                                if (p.totalFramesInWholeLoopCounter <= p.framesNeededForFullFadeInOut)
                                {
                                    p.opacity = fadeAmount * p.totalFramesInWholeLoopCounter;
                                    if (p.opacity > 1)
                                    {
                                        p.opacity = 1;
                                    }
                                }

                                else if (p.totalFramesInWholeLoopCounter >= ((p.maxNumberOfFrames * p.numberOfCyclesNeededForCompletion) - p.framesNeededForFullFadeInOut))
                                {
                                    int framesLeft = (p.maxNumberOfFrames * p.numberOfCyclesNeededForCompletion) - p.totalFramesInWholeLoopCounter;
                                    p.opacity = framesLeft * fadeAmount;
                                }
                                else
                                {
                                    p.opacity = 1;
                                }
                            }

                            //p.drawAnimatedProp = true;
                            if ((p.maxNumberOfFrames > 1) && (!p.animationComplete))
                            {
                                p.animationDelayCounter += (300 / elapsed);

                                if (p.animationDelayCounter >= p.updateTicksNeededTillNextFrame)
                                {

                                #region forwardDirection
                                //if (!p.inverseAnimationDirection)
                                //{
                                    p.currentFrameNumber++;
                                    p.totalFramesInWholeLoopCounter++;
                                    p.animationDelayCounter = 0;
                                    if (p.currentFrameNumber > (p.maxNumberOfFrames - 1))
                                    {
                                        p.currentFrameNumber = 0;

                                        //enter new conditional for multiple cylces required before compleetion here
                                        if (p.numberOfCyclesNeededForCompletion <= 1)
                                        {
                                            if (p.randomAnimationDirectionEachCall)
                                            {
                                                int decider = gv.sf.RandInt(0, 100);
                                                if (decider >= 50)
                                                {
                                                    p.inverseAnimationDirection = true;
                                                }
                                                else
                                                {
                                                    p.inverseAnimationDirection = false;
                                                }
                                            }

                                            p.animationComplete = true;
                                            p.totalFramesInWholeLoopCounter = 0;
                                            if (p.hiddenWhenComplete)
                                            {
                                                p.drawAnimatedProp = false;
                                            }
                                        }
                                        else
                                        {
                                            p.cycleCounter++;
                                            if (p.cycleCounter == p.numberOfCyclesNeededForCompletion)
                                            {
                                                if (p.randomAnimationDirectionEachCall)
                                                {
                                                    int decider = gv.sf.RandInt(0, 100);
                                                    if (decider >= 50)
                                                    {
                                                        p.inverseAnimationDirection = true;
                                                    }
                                                    else
                                                    {
                                                        p.inverseAnimationDirection = false;
                                                    }
                                                }

                                                p.animationComplete = true;
                                                p.cycleCounter = 0;
                                                p.totalFramesInWholeLoopCounter = 0;
                                                if (p.hiddenWhenComplete)
                                                {
                                                    p.drawAnimatedProp = false;
                                                }
                                            }
                                        }
                                    }
                                //}
                                #endregion
                                /*
                                #region backwardsDirection
                                else
                                {
                                    p.currentFrameNumber--;
                                    p.totalFramesInWholeLoopCounter--;
                                    p.animationDelayCounter = 0;
                                    if (p.currentFrameNumber > (p.maxNumberOfFrames - 1))
                                    {
                                        p.currentFrameNumber = 0;

                                    //enter new conditional for multiple cylces required before compleetion here
                                    if (p.numberOfCyclesNeededForCompletion <= 1)
                                    {
                                        p.animationComplete = true;
                                        p.totalFramesInWholeLoopCounter = 0;
                                        if (p.hiddenWhenComplete)
                                        {
                                            p.drawAnimatedProp = false;
                                        }
                                    }
                                    else
                                    {
                                        p.cycleCounter++;
                                        if (p.cycleCounter == p.numberOfCyclesNeededForCompletion)
                                        {
                                            if (p.randomAnimationDirectionEachCall)
                                            {
                                                int decider = gv.sf.RandInt(0, 100);
                                                if (decider >= 50)
                                                {
                                                    p.inverseAnimationDirection = true;
                                                }
                                                else
                                                {
                                                    p.inverseAnimationDirection = false;
                                                }
                                            }

                                            p.animationComplete = true;
                                            p.cycleCounter = 0;
                                            p.totalFramesInWholeLoopCounter = 0;
                                            if (p.hiddenWhenComplete)
                                            {
                                                p.drawAnimatedProp = false;
                                            }
                                        }
                                    }
                                }
                            } 

                                #endregion
                                */
                            }
                            }

                            if (p.animationComplete)
                            {
                                if (p.doOnce)
                                {
                                    p.animationIsActive = false;
                                }

                                if (p.animationIsActive)
                                {
                                    if (p.chanceToTriggerAnimationCycle >= 100)
                                    {
                                        p.animationComplete = false;
                                        p.drawAnimatedProp = true;
                                    }
                                    else
                                    {
                                        p.normalizedTime += (1 / elapsed);
                                        if (p.normalizedTime >= 1)
                                        {
                                            p.normalizedTime = 0;
                                            float rollRandom = gv.sf.RandInt(100);
                                            if (rollRandom <= p.chanceToTriggerAnimationCycle)
                                            {
                                                p.animationComplete = false;
                                                p.drawAnimatedProp = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        //animation is not active
                        else
                        {
                            if (p.hiddenWhenNotActive)
                            {
                                p.drawAnimatedProp = false;
                            }
                        }
                    }
                }
        }

        //MAIN SCREEN DRAW
        public void resetMiniMapBitmap()
        {
            if (gv.mod.useAllTileSystem)
            {
                minimap = gv.cc.LoadBitmap(gv.mod.currentArea.Filename + "Minimap");
            }
            else
            {
                int minimapSquareSizeInPixels = 4 * gv.squareSize / gv.mod.currentArea.MapSizeX;
                int drawW = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeX;
                int drawH = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeY;
                using (System.Drawing.Bitmap surface = new System.Drawing.Bitmap(drawW, drawH))
                {
                    using (Graphics device = Graphics.FromImage(surface))
                    {
                        //draw background image first
                        if ((!gv.mod.currentArea.ImageFileName.Equals("none")) && (gv.cc.bmpMap != null))
                        {
                            System.Drawing.Bitmap bg = gv.cc.LoadBitmapGDI(gv.mod.currentArea.ImageFileName);
                            Rectangle srcBG = new Rectangle(0, 0, bg.Width, bg.Height);
                            Rectangle dstBG = new Rectangle(gv.mod.currentArea.backgroundImageStartLocX * minimapSquareSizeInPixels,
                                                            gv.mod.currentArea.backgroundImageStartLocY * minimapSquareSizeInPixels,
                                                            minimapSquareSizeInPixels * (bg.Width / 50),
                                                            minimapSquareSizeInPixels * (bg.Height / 50));
                            device.DrawImage(bg, dstBG, srcBG, GraphicsUnit.Pixel);
                            bg.Dispose();
                            bg = null;
                        }
                        #region Draw Layer 1
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer1Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 2
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer2Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 3
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer3Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 4
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer4Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        #region Draw Layer 5
                        for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                        {
                            for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                            {
                                Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                                Rectangle src = new Rectangle(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height);
                                float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width / 100;
                                float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height / 100;
                                int brX = (int)(minimapSquareSizeInPixels * scalerX);
                                int brY = (int)(minimapSquareSizeInPixels * scalerY);
                                Rectangle dst = new Rectangle(x * minimapSquareSizeInPixels, y * minimapSquareSizeInPixels, brX, brY);
                                device.DrawImage(gv.cc.GetFromTileGDIBitmapList(tile.Layer5Filename), dst, src, GraphicsUnit.Pixel);
                            }
                        }
                        #endregion
                        minimap = gv.cc.ConvertGDIBitmapToD2D((System.Drawing.Bitmap)surface.Clone());
                    }
                }
            }
        }

        public void drawHeightShadows()
        {

            int tileXCoordOnItsArea = -1;
            int tileYCoordOnItsArea = -1;
            #region draw Height Shadows
            gv.mod.indexOfNorthernNeighbour = -1;
            gv.mod.indexOfSouthernNeighbour = -1;
            gv.mod.indexOfEasternNeighbour = -1;
            gv.mod.indexOfWesternNeighbour = -1;
            gv.mod.indexOfNorthEasternNeighbour = -1;
            gv.mod.indexOfNorthWesternNeighbour = -1;
            gv.mod.indexOfSouthEasternNeighbour = -1;
            gv.mod.indexOfSouthWesternNeighbour = -1;
            gv.mod.indexOfCurrentArea = -1;

            gv.mod.seamlessModififierMinX = 0;
            gv.mod.seamlessModififierMaxX = 0;
            gv.mod.seamlessModififierMinY = 0;
            gv.mod.seamlessModififierMaxY = 0;

            #region neighbours

            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
            {
                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.Filename)
                {
                    gv.mod.indexOfCurrentArea = i;
                }
            }

            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
            {
                gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        gv.mod.indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        gv.mod.indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
            {
                gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        gv.mod.indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        gv.mod.indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }
            #endregion
            //foreach (Area a in gv.mod.moduleAreasObjects)

            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

            /*
            if (gv.mod.currentArea.sourceBitmapName != "")
            {
                #region Draw Layer 0
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
            */


            //*************************************************************************
            //*************************************************************************
            //*************************************************************************
            /*
                        for (int y = 0; y < gv.mod.currentArea.MapSizeY; y++)
                        {
                            for (int x = 0; x < gv.mod.currentArea.MapSizeX; x++)
                            {
                            */

            /*
            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
            int brX = gv.squareSize;
            int brY = gv.squareSize;
            IbRect src = new IbRect(0, 0, gv.cc.walkBlocked.PixelSize.Width, gv.cc.walkBlocked.PixelSize.Height);
            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
            if (gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
            {
                gv.DrawBitmap(gv.cc.losBlocked, src, dst);
            }
            */
            //gv.DrawBitmap(gv.cc.losBlocked, src, dst);
            for (int x = minX; x < maxX; x++)
            {
                for (int y = minY; y < maxY; y++)
                {

                    bool situationFound = false;
                    bool drawTile = true;
                    int index = -1;
                    Tile tile = new Tile();

                    //nine situations where a tile can be:
                    //tile on north-western map (diagonal situation)
                    if ((x < 0) && (y < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfNorthWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                            int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfNorthWesternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on south-westernmap (diagonal situation)
                    if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfSouthWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                            int transformedY = y - gv.mod.currentArea.MapSizeY;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfSouthWesternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on south-easternmap (diagonal situation)
                    if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfSouthEasternNeighbour != -1)
                        {
                            int transformedX = x - gv.mod.currentArea.MapSizeX;
                            int transformedY = y - gv.mod.currentArea.MapSizeY;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfSouthEasternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on north-easternmap (diagonal situation)
                    if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfNorthEasternNeighbour != -1)
                        {
                            int transformedX = x - gv.mod.currentArea.MapSizeX;
                            int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfNorthEasternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on western map
                    if ((x < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                            int transformedY = y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfWesternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on southern map
                    if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfSouthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = y - gv.mod.currentArea.MapSizeY;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfSouthernNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on eastern map
                    if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfEasternNeighbour != -1)
                        {
                            int transformedX = x - gv.mod.currentArea.MapSizeX;
                            int transformedY = y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfEasternNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile on northern map
                    if ((y < 0) && (!situationFound))
                    {
                        situationFound = true;
                        if (gv.mod.indexOfNorthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                            tileXCoordOnItsArea = transformedX;
                            tileYCoordOnItsArea = transformedY;
                            tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                            index = gv.mod.indexOfNorthernNeighbour;
                        }
                        else
                        {
                            drawTile = false;
                        }
                    }
                    //tile is on current map
                    if (!situationFound)
                    {
                        tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        index = gv.mod.indexOfCurrentArea;
                        tileXCoordOnItsArea = x;
                        tileYCoordOnItsArea = y;
                        //lumberjack

                    }

                    if (drawTile)
                    {
                        //*********************************************************************************
                        //*********************************************************************************
                        
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.longShadow.PixelSize.Width / 100;
                        float scalerY = gv.cc.longShadow.PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);
                        //amitee
                        IbRect dstNorth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY - gv.squareSize, brX, brY);
                        IbRect dstEast = new IbRect(tlX + gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dstSouth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY + gv.squareSize, brX, brY);
                        IbRect dstWest = new IbRect(tlX - gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst2 = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst3 = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        IbRect dst4 = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        //IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);
                        /*
                        IbRect dst = new IbRect(x * (gv.squareSize), y * gv.squareSize, (gv.squareSize), (gv.squareSize));
                        IbRect dst2 = new IbRect(x * (gv.squareSize), y * gv.squareSize, (gv.squareSize), (gv.squareSize));
                        IbRect dst3 = new IbRect(x * (gv.squareSize), y * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dst4 = new IbRect(x * (gv.squareSize), y * (gv.squareSize), gv.squareSize, gv.squareSize);
                        IbRect dstNorth = new IbRect(x * gv.squareSize, (y - 1) * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dstEast = new IbRect((x + 1) * gv.squareSize, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dstSouth = new IbRect(x * gv.squareSize, (y + 1) * gv.squareSize, gv.squareSize, gv.squareSize);
                        IbRect dstWest = new IbRect((x - 1) * gv.squareSize, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        */
                        //note: fillavergaeHEightOnThisMap each turn wth the height of the square the palyer is currently on
                        float relativeTileHeight = tile.heightLevel - gv.mod.currentArea.averageHeightOnThisMap;
                        if (relativeTileHeight > 4)
                        {
                            relativeTileHeight = 4;
                        }
                        if (relativeTileHeight < -4)
                        {
                            relativeTileHeight = -4;
                        }
                        relativeTileHeight = relativeTileHeight / 10;

                        //gv.DrawBitmap(gv.cc.losBlocked, src, dst);

                        int xAdder = 1;
                        int yAdder = 1;
                        int xSubstractor = 1;
                        int ySubstractor = 1;

                        if (x == 0)
                        {
                            xSubstractor = 0;
                        }
                        if (y == 0)
                        {
                            ySubstractor = 0;
                        }

                        if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            xAdder = 0;
                        }

                        if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            yAdder = 0;
                        }

                        //highlights
                        //if (gv.mod.currentArea.Tiles[(y + yAdder) * gv.mod.currentArea.MapSizeX + x].transitionToMasterDirection != "S")
                        if (tile.transitionToMasterDirection != "S")
                        {
                            if (tile.hasHighlightS)
                            {
                                if (tile.isEWBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst4, 0, false, 0, -1, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 0, false, 0, -1, 1, 1, 0.5f + relativeTileHeight);
                                }
                                //DrawD2DBitmap
                            }
                        }

                        //if (gv.mod.currentArea.Tiles[(y - ySubstractor) * gv.mod.currentArea.MapSizeX + x].transitionToMasterDirection != "N")
                        if (tile.transitionToMasterDirection != "N")
                        {
                            if (tile.hasHighlightN)
                            {
                                if (tile.isEWBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst, 180, false, 0, 0, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 180, false, 0, 0, 1, 1, 0.5f + relativeTileHeight);
                                }
                            }
                        }

                        //if (gv.mod.currentArea.Tiles[(y) * gv.mod.currentArea.MapSizeX + x - xSubstractor].transitionToMasterDirection != "W")
                        if (tile.transitionToMasterDirection != "W")
                        {
                            if (tile.hasHighlightW)
                            {
                                if (tile.isNSBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst, 90, false, 0, 0, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 90, false, 0, 0, 1, 1, 0.5f + relativeTileHeight);
                                }
                            }
                        }

                        //if (gv.mod.currentArea.Tiles[(y) * gv.mod.currentArea.MapSizeX + x + xAdder].transitionToMasterDirection != "E")
                        if (tile.transitionToMasterDirection != "E")
                        {
                            if (tile.hasHighlightE)
                            {
                                if (tile.isNSBridge)
                                {
                                    gv.DrawBitmap(gv.cc.highlightGreen, src, dst3, 270, false, -1, 0, 1, 1, 1f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.highlight90, src, dst, 270, false, -1, 0, 1, 1, 0.5f + relativeTileHeight);
                                }
                            }
                        }


                        if (gv.mod.currentArea.masterOfThisArea == "none")
                        {
                            //changela
                            if (tile.transitionToMasterDirection == "E")
                            {
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstEast, 90, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstEast, 90, false, 0, 1, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstEast, 90, false, 0, -1, 1, 1, 1f);
                                //allowHighLight = false;
                            }
                            if (tile.transitionToMasterDirection == "S")
                            {
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstSouth, 180, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstSouth, 180, false, 0, 1, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstSouth, 180, false, 0, -1, 1, 1, 1f);
                                //allowHighLight = false;
                            }
                            if (tile.transitionToMasterDirection == "W")
                            {
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstWest, 270, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstWest, 270, false, 0, 1, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstWest, 270, false, 0, -1, 1, 1, 1f);

                                //allowHighLight = false;0
                            }
                            if (tile.transitionToMasterDirection == "N")
                            {
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstNorth, 0, false, 0, 0, 1, 1, 1f);
                                gv.DrawBitmap(gv.cc.highlightGreen, src, dstNorth, 0, false, 0, 0, 1, 1, 1f);
                                //DrawD2DBitmap(GetFromBitmapList("highLightGreen"), src, dstNorth, 0, false, 0, 0, -1, 1, 1f);
                                //allowHighLight = false;
                            }
                        }

                        //urfeld
                        //stair shadows
                        if (tile.hasDownStairShadowN)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 180, false, 0, 0);
                            if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == 0)
                                {
                                    //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr*0.5f, sqr);
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 180, false, 0, 0);
                                    //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr * 2f, sqr);
                                }
                            }
                            if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, false, 0, 0);
                                }
                            }
                            //freedom, WIP

                            if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 90, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 270, false, 0, 0);
                                }
                            }

                            /*
                            DrawD2DBitmap(GetFromBitmapList("downStairShadow"), src, dst, 180, false, 0, 0);
                        if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                        {
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == 0)
                            {
                                //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr*0.5f, sqr);
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowLeft"), src, dst2, 180, false, 0, 0);
                                //dst = new SharpDX.RectangleF(x * sqr, y * sqr, sqr * 2f, sqr);
                            }
                        }
                        if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                        {
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == 0)
                            {
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowRight"), src, dst2, 180, false, 0, 0);
                            }
                        }
                        //freedom, WIP
                        
                        if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                        {
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -2)
                            {
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowLeft"), src, dst2, 90, false, 0, 0);
                            }
                            if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == -3)
                            {
                                DrawD2DBitmap(GetFromBitmapList("downStairFlankShadowRight"), src, dst2, 270, false, 0, 0);
                            }
                        }      


                            */
                        }
                        if (tile.hasDownStairShadowE)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 270, false, 0, 0);
                            if (!tile.isInShortShadeS && !tile.isInLongShadeS && !tile.isInMaxShadeS)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 270, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 270, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 0, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 180, false, 0, 0);
                                }
                            }

                        }
                        if (tile.hasDownStairShadowS)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 0, false, 0, 0);
                            if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 0, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeE && !tile.isInLongShadeE && !tile.isInMaxShadeE)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourE == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 0, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeS && !tile.isInLongShadeS && !tile.isInMaxShadeS)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 90, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 270, false, 0, 0);
                                }
                            }
                        }
                        if (tile.hasDownStairShadowW)
                        {
                            //gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 90, false, 0, 0);
                            if (!tile.isInShortShadeN && !tile.isInLongShadeN && !tile.isInMaxShadeN)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourN == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 90, false, 0, 0);
                                }
                            }
                            if (!tile.isInShortShadeS && !tile.isInLongShadeS && !tile.isInMaxShadeS)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourS == 0)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 90, false, 0, 0);
                                }
                            }

                            if (!tile.isInShortShadeW && !tile.isInLongShadeW && !tile.isInMaxShadeW)
                            {
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == -2)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 0, false, 0, 0);
                                }
                                if (tile.numberOfHeightLevelsThisTileisHigherThanNeighbourW == -3)
                                {
                                    gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, false, 0, 0);
                                }
                            }
                        }
                        
                        if (tile.inRampShadowWest1Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 180, true, 0, 0);
                        }
                        if (tile.inRampShadowWest1Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 0, true, 0, 0);
                        }

                        if (tile.inRampShadowWest2Long)
                        {
                            gv.DrawBitmap(gv.cc.rightCurtain, src, dst, 0, false, 0, 0);
                        }
                        if (tile.inRampShadowWest2Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, false, 0, 0);
                        }

                        if (tile.inRampShadowEast3Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 180, false, 0, 0);
                        }
                        if (tile.inRampShadowEast3Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 0, true, 0, 0);
                        }

                        if (tile.inRampShadowEast4Long)
                        {
                            gv.DrawBitmap(gv.cc.rightCurtain, src, dst, 0, true, 0, 0);
                        }
                        if (tile.inRampShadowEast4Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 180, true, 0, 0);
                        }

                        if (tile.inRampShadowNorth5Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 270, true, 0, 0);
                        }
                        if (tile.inRampShadowNorth5Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 90, true, 0, 0);
                        }

                        if (tile.inRampShadowNorth6Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 90, false, 0, 0);
                        }
                        if (tile.inRampShadowNorth6Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 270, true, 0, 0);
                        }

                        if (tile.inRampShadowSouth7Long)
                        {
                            gv.DrawBitmap(gv.cc.leftCurtain, src, dst, 270, false, 0, 0);
                        }
                        if (tile.inRampShadowSouth7Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowLeft, src, dst2, 90, true, 0, 0);
                        }

                        if (tile.inRampShadowSouth8Long)
                        {
                            gv.DrawBitmap(gv.cc.rightCurtain, src, dst, 90, true, 0, 0);
                        }
                        if (tile.inRampShadowSouth8Short)
                        {
                            gv.DrawBitmap(gv.cc.downStairFlankShadowRight, src, dst2, 270, true, 0, 0);
                        }

                        if (tile.inSmallStairNEVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 0, true, 0, 0);
                        }
                        if (tile.inSmallStairNEHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 90, true, 0, 0);
                        }
                        if (tile.inSmallStairSEVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 180, true, 0, 0);
                        }
                        if (tile.inSmallStairSEHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 90, true, 0, 0);
                        }
                        if (tile.inSmallStairSWVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 180, true, 0, 0);
                        }
                        if (tile.inSmallStairSWHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 270, true, 0, 0);
                        }
                        if (tile.inSmallStairNWVertical)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNENormal, src, dst2, 0, true, 0, 0);
                        }
                        if (tile.inSmallStairNWHorizontal)
                        {
                            gv.DrawBitmap(gv.cc.smallStairNEMirror, src, dst2, 270, true, 0, 0);
                        }

                        //height shadows
                        //for (int i = 0; i <= gv.mod.moduleAreasObjects[index].Tiles.Count; i++)
                        //{
                            //if (gv.mod.moduleAreasObjects[index].Tiles)
                        //}
                        
                        //gv.mod.moduleAreasObjects[index]
                        //int test = gv.mod.moduleAreasObjects.Count;

                        if (tile.isInLongShadeN)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 180, false, 0, 0);
                        }
                        else if (tile.isInShortShadeN)
                        {
                            if (tileYCoordOnItsArea - 1 >= 0)
                            {
                                if (!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea - 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].isEWBridge && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea - 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].transitionToMasterDirection != "S")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 180, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 180, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 180, false, 0, 0);
                            }
                        }

                        if (tile.isInLongShadeE)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 270, false, 0, 0);
                        }
                        else if (tile.isInShortShadeE)
                        {
                            if (tileXCoordOnItsArea + 1 <= gv.mod.moduleAreasObjects[index].MapSizeX - 1)
                            {
                                if (!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea + 1)].isNSBridge && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea + 1].transitionToMasterDirection != "W")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 270, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 270, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 270, false, 0, 0);
                            }

                        }

                        if (tile.isInLongShadeS)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 0, false, 0, 0);
                        }
                        else if (tile.isInShortShadeS)
                        {
                            if (tileYCoordOnItsArea + 1 <= gv.mod.moduleAreasObjects[index].MapSizeY - 1)
                            {
                                if (!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea + 1) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea)].isEWBridge && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea + 1) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea].transitionToMasterDirection != "N")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 0, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 0, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 0, false, 0, 0);
                            }
                        }

                        if (tile.isInLongShadeW)
                        {
                            gv.DrawBitmap(gv.cc.longShadow, src, dst, 90, false, 0, 0);
                        }
                        else if (tile.isInShortShadeW)
                        {
                            if (tileXCoordOnItsArea - 1 >= 0)
                            {
                                if (!gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + (tileXCoordOnItsArea - 1)].isNSBridge && gv.mod.moduleAreasObjects[index].Tiles[(tileYCoordOnItsArea) * gv.mod.moduleAreasObjects[index].MapSizeX + tileXCoordOnItsArea - 1].transitionToMasterDirection != "E")
                                {
                                    gv.DrawBitmap(gv.cc.shortShadow, src, dst, 90, false, 0, 0);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.bridgeShadow, src, dst, 90, false, 0, 0, 1, 1, 1f);
                                }
                            }
                            else
                            {
                                gv.DrawBitmap(gv.cc.shortShadow, src, dst, 90, false, 0, 0);
                            }
                        }

                        //if (!tile.isRamp)
                        //{
                        //if (!tile.inRampShadowWest1Short && !tile.inRampShadowWest1Long && !tile.inRampShadowWest2Short && !tile.inRampShadowWest2Long && !tile.inRampShadowNorth5Long && !tile.inRampShadowNorth5Short && !tile.inRampShadowNorth6Long && !tile.inRampShadowNorth6Short)
                        //{
                        if (!tile.isInLongShadeN && !tile.isInShortShadeN && !tile.isInLongShadeW && !tile.isInShortShadeW)
                        {
                            if (tile.isInMaxShadeNW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 180, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNW)
                            {
                                if ((!tile.inRampShadowNorth5Long) && (!tile.inRampShadowWest2Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 180, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeNW) && (!tile.inRampShadowNorth5Short) && (!tile.inRampShadowWest2Short) && (!tile.inRampShadowNorth5Long) && (!tile.inRampShadowWest2Long))
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 180, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeN && !tile.isInLongShadeW)
                        {

                            if (tile.isInMaxShadeNW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 180, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNW)
                            {
                                if ((!tile.inRampShadowNorth5Long) && (!tile.inRampShadowWest2Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 180, false, 0, 0);
                                }
                            }
                        }
                        //}

                        //if (!tile.inRampShadowEast3Long && !tile.inRampShadowEast3Short && !tile.inRampShadowEast4Short && !tile.inRampShadowEast4Long && !tile.inRampShadowNorth5Long && !tile.inRampShadowNorth5Short && !tile.inRampShadowNorth6Long && !tile.inRampShadowNorth6Short)
                        //{
                        if (!tile.isInLongShadeN && !tile.isInShortShadeN && !tile.isInLongShadeE && !tile.isInShortShadeE)
                        {
                            if (tile.isInMaxShadeNE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 270, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNE)
                            {
                                if ((!tile.inRampShadowNorth6Long) && (!tile.inRampShadowEast4Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 270, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeNE) && (!tile.inRampShadowEast4Short) && (!tile.inRampShadowNorth6Short) && (!tile.inRampShadowEast4Long) && (!tile.inRampShadowNorth6Long))
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 270, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeN && !tile.isInLongShadeE)
                        {
                            if (tile.isInMaxShadeNE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 270, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeNE)
                            {
                                if ((!tile.inRampShadowNorth6Long) && (!tile.inRampShadowEast4Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 270, false, 0, 0);
                                }
                            }
                        }
                        //}

                        //if (!tile.inRampShadowEast3Short && !tile.inRampShadowEast3Long && !tile.inRampShadowEast4Short && !tile.inRampShadowEast4Long && !tile.inRampShadowSouth7Long && !tile.inRampShadowSouth7Short && !tile.inRampShadowSouth8Long && !tile.inRampShadowSouth8Short)
                        //{
                        if (!tile.isInLongShadeS && !tile.isInShortShadeS && !tile.isInLongShadeE && !tile.isInShortShadeE)
                        {
                            if (tile.isInMaxShadeSE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 0, false, 0, 0);
                            }
                            else
                                    if (tile.isInLongShadeSE)
                            {
                                if ((!tile.inRampShadowSouth8Long) && (!tile.inRampShadowEast3Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 0, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeSE) && (!tile.inRampShadowEast3Short) && (!tile.inRampShadowSouth8Short) && (!tile.inRampShadowEast3Long) && (!tile.inRampShadowSouth8Long))
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 0, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeS && !tile.isInLongShadeE)
                        {
                            if (tile.isInMaxShadeSE)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 0, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeSE)
                            {
                                if ((!tile.inRampShadowSouth8Long) && (!tile.inRampShadowEast3Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 0, false, 0, 0);
                                }
                            }
                        }
                        //}

                        //if (!tile.inRampShadowWest1Short && !tile.inRampShadowWest1Long && !tile.inRampShadowWest2Short && !tile.inRampShadowWest2Long && !tile.inRampShadowSouth7Long && !tile.inRampShadowSouth7Short && !tile.inRampShadowSouth8Long && !tile.inRampShadowSouth8Short)
                        //{
                        if (!tile.isInLongShadeS && !tile.isInShortShadeS && !tile.isInLongShadeW && !tile.isInShortShadeW)
                        {
                            if (tile.isInMaxShadeSW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 90, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeSW)
                            {
                                if ((!tile.inRampShadowSouth7Long) && (!tile.inRampShadowWest1Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 90, false, 0, 0);
                                }
                            }
                            else if ((tile.isInShortShadeSW) && (!tile.inRampShadowWest1Short) && (!tile.inRampShadowSouth7Short) && (!tile.inRampShadowSouth7Long) && (!tile.inRampShadowWest1Long))
                            {
                                gv.DrawBitmap(gv.cc.shortShadowCorner, src, dst, 90, false, 0, 0);
                            }
                        }

                        else if (!tile.isInLongShadeS && !tile.isInLongShadeW)
                        {
                            if (tile.isInMaxShadeSW)
                            {
                                gv.DrawBitmap(gv.cc.corner3, src, dst, 90, false, 0, 0);
                            }
                            else
                            if (tile.isInLongShadeSW)
                            {
                                if ((!tile.inRampShadowSouth7Long) && (!tile.inRampShadowWest1Long))
                                {
                                    gv.DrawBitmap(gv.cc.longShadowCorner, src, dst, 90, false, 0, 0);
                                }
                            }
                        }
                        //entrance lights
                        /*
                        if (tile.hasEntranceLightNorth)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 0, false, 0, 0);
                        }
                        if (tile.hasEntranceLightEast)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 90, false, 0, 0);
                        }
                        if (tile.hasEntranceLightSouth)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 180, false, 0, 0);
                        }
                        if (tile.hasEntranceLightWest)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dst, 270, false, 0, 0);
                        }
                        */
                        /*
                        if (tile.isEWBridge)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstNorth, 0, false, 0, 0);
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstSouth, 180, false, 0, 0);
                        }

                        if (tile.isNSBridge)
                        {
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstWest, 270, false, 0, 0);
                            gv.DrawBitmap(gv.cc.entranceLightNorth"), src, dstEast, 90, false, 0, 0);
                        }
                        */
                    }
                }
            }
            #endregion
        }

        
        public void setBridgeStateForMovingProps()
        {
            //note: player bridge state is handled by gv.mod.currentArea.PlayerIsUnderBridge
            //note: for moving props it is then p.isUnderBridge

            foreach (Prop p in gv.mod.currentArea.Props)
            {
                if ((p.isShown) && (p.isMover))
                {
                    if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isEWBridge || gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isNSBridge)
                    {
                        if (gv.mod.currentArea.Tiles[p.lastLocationY * gv.mod.currentArea.MapSizeX + p.lastLocationX].heightLevel + 1 == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                        {
                            p.isUnderBridge = true;
                        }
                        else
                        {
                            p.isUnderBridge = false;
                        }
                    }
                    else
                    {
                        p.isUnderBridge = false;
                    }
                }
            }
        }
        

        public void redrawMain(float elapsed)
        {

            if (gv.mod.currentArea.areaWeatherName == "")
            {
                gv.weatherSounds1.controls.stop();
                gv.weatherSounds2.controls.stop();
                gv.weatherSounds3.controls.stop();
            }
            setBridgeStateForMovingProps();
            setExplored();
            if (!gv.mod.currentArea.areaDark)
            {
                drawBottomFullScreenEffects();
                if ((!gv.mod.currentArea.ImageFileName.Equals("none")) && (gv.cc.bmpMap != null))
                {
                    drawMap();
                }
                drawWorldMap();

                //CommonCode.addLogText("red", "Failed to setup Music Player...Audio will be disabled. Most likely due to not having Windows Media Player installed or having an incompatible version.");

                //drawProps();
                if (gv.mod.map_showGrid)
                {
                    drawGrid();
                }
            }
            if (gv.mod.currentArea.areaDark)
            {
                drawProps();
                drawPlayer();
                drawHeightShadows();
                //new method for drawing shade for linked tiles on links
                drawLinkShades();
            }
            if (!gv.mod.currentArea.areaDark)
            {
                //drawMovingProps();
            }
            //drawMainMapFloatyText();
            //drawFloatyTextPool();
            //if (gv.mod.useSmoothMovement)
            //{
            //drawFloatyTextByPixelPool();
            //}

            //drawSprites();
            //drawTopFullScreenEffects();

            if (!gv.mod.currentArea.areaDark)
            {
                //drawMovingPropsUnderBridge(elapsed);
                drawProps();
                drawMovingProps(elapsed);
                if ((!gv.mod.currentArea.useLightSystem) || (!gv.mod.partyLightOn))
                {
                    //drawProps();
                    //drawMovingProps();
                    drawPlayer();
                    drawHeightShadows();
                    //new method for drawing shade for linked tiles on links
                    //drawLinkShades();
                    //drawBrigdePropsOverPlayer();
                }

                //if (gv.mod.useAllTileSystem)
                //{
                    //drawLightAndDarkness(elapsed);
                //}
                //drawProps();
                //drawMovingProps();
                if ((gv.mod.currentArea.useLightSystem) && (gv.mod.partyLightOn))
                {
                    //drawProps();
                    //drawMovingProps();
                    drawPartyHalo(elapsed);
                    drawPlayer();
                    drawHeightShadows();
                    //new method for drawing shade for linked tiles on links
                    //drawLinkShades();
                    //drawBrigdePropsOverPlayer();
                }

                if (gv.mod.spritesUnderOverlays)
                {
                    drawSprites();
                    drawTopFullScreenEffects();
                }

                if (gv.mod.useAllTileSystem)
                {
                    //if (gv.mod.fogOfWarOpacity == 1.0f)
                    //{
                        drawLightAndDarkness(elapsed);
                    //}
                }

                //new method for drawing shade for linked tiles on links
                drawLinkShades();
                drawFogOfWar();
                drawMainMapFloatyText();
                drawFloatyTextPool();
                if (gv.mod.useSmoothMovement)
                {
                    drawFloatyTextByPixelPool();
                }
                //drawLightAndDarkness(elapsed);

                //test weather under fog of war, darkness and tint of daytime
                if (!gv.mod.spritesUnderOverlays)
                {
                   drawSprites();
                   drawTopFullScreenEffects();
                }

                    bool hideOverlayNeeded = false;
                if (gv.mod.currentArea.UseDayNightCycle)
                {
                    //drawOverlayTints();
                    hideOverlayNeeded = true;
                }

                if (hideOverlayNeeded)
                {
                    drawBlackTilesOverTints();
                    hideOverlayNeeded = false;
                }
                //drawFogOfWar();
            }

            //drawLightAndDarkness(elapsed);

            //drawSprites();
            //drawTopFullScreenEffects();

            if ((showClock) && (!hideClock))
            {
                drawMainMapClockText();
            }
            //finalBlackenOffMapScreen();
            drawUiLayout();
            drawMiniMap();
            if (gv.mod.useMinimalisticUI)
            {
                if (gv.mod.logFadeCounter > 0)
                {
                    gv.mod.logFadeCounter--;
                }

                if ((gv.mod.logFadeCounter <= 0) && (gv.mod.logOpacity >= 0.006))
                {
                    gv.mod.logOpacity -= 0.006f;
                }
            }
        }

        //not used anymore (With extended playerOffsetY)
        public void finalBlackenOffMapScreen()
        {
            drawRowOfBlack(gv.playerOffsetY * 2 + 1);
            drawRowOfBlack(gv.playerOffsetY * 2 + 2);
            //gv.cc.setToBorderPixDistancesMainMap();
        }

        public void drawLinkShades()
        {

            //#region new system
            gv.mod.indexOfNorthernNeighbour = -1;
            gv.mod.indexOfSouthernNeighbour = -1;
            gv.mod.indexOfEasternNeighbour = -1;
            gv.mod.indexOfWesternNeighbour = -1;
            gv.mod.indexOfNorthEasternNeighbour = -1;
            gv.mod.indexOfNorthWesternNeighbour = -1;
            gv.mod.indexOfSouthEasternNeighbour = -1;
            gv.mod.indexOfSouthWesternNeighbour = -1;

            gv.mod.seamlessModififierMinX = 0;
            gv.mod.seamlessModififierMaxX = 0;
            gv.mod.seamlessModififierMinY = 0;
            gv.mod.seamlessModififierMaxY = 0;

            #region neighbours
            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
            {
                gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        gv.mod.indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        gv.mod.indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                    {
                        gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                    {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
            {
                gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        gv.mod.indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                {

                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        gv.mod.indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                    {
                        gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    }

                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                    {
                        gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    }
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }
            #endregion

            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
            if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

            //if (gv.mod.currentArea.sourceBitmapName != "")
            //{
            for (int x = minX; x < maxX; x++)
            {
                for (int y = minY; y < maxY; y++)
                {

                    bool situationFound = false;
            bool drawTile = true;
            int index = -1;
            Tile tile = new Tile();

            //nine situations where a tile can be:
            //tile on north-western map (diagonal situation)
            if ((x < 0) && (y < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                {
                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfNorthWesternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on south-westernmap (diagonal situation)
            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                {
                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfSouthWesternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on south-easternmap (diagonal situation)
            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                {
                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfSouthEasternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on north-easternmap (diagonal situation)
            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                {
                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfNorthEasternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on western map
            if ((x < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfWesternNeighbour != -1)
                {
                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                    int transformedY = y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfWesternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on southern map
            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfSouthernNeighbour != -1)
                {
                    int transformedX = x;
                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfSouthernNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on eastern map
            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfEasternNeighbour != -1)
                {
                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                    int transformedY = y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfEasternNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile on northern map
            if ((y < 0) && (!situationFound))
            {
                situationFound = true;
                if (gv.mod.indexOfNorthernNeighbour != -1)
                {
                    int transformedX = x;
                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                    index = gv.mod.indexOfNorthernNeighbour;
                }
                else
                {
                    drawTile = false;
                }
            }
            //tile is on current map
            if (!situationFound)
            {
                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
            }

            if (drawTile)
            {

                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                        //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                        //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                        float scalerX = 1;
                        float scalerY = 1;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);
                        //IbRect src = new IbRect(0, 0, tile.tileBitmap0.PixelSize.Width, tile.tileBitmap0.PixelSize.Height);
                        //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                        //for (int x = minX; x < maxX; x++)
                        //{
                        //for (int y = minY; y < maxY; y++)
                        //{
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        if (tile.linkedToMasterMap)
                        {
                            IbRect srcBlackTile = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                            //IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst, false, 0.75f);
                        }
                    }
                }
                //}
            }
        }

        public void drawWorldMap()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                gv.mod.indexOfNorthernNeighbour = -1;
                gv.mod.indexOfSouthernNeighbour = -1;
                gv.mod.indexOfEasternNeighbour = -1;
                gv.mod.indexOfWesternNeighbour = -1;
                gv.mod.indexOfNorthEasternNeighbour = -1;
                gv.mod.indexOfNorthWesternNeighbour = -1;
                gv.mod.indexOfSouthEasternNeighbour = -1;
                gv.mod.indexOfSouthWesternNeighbour = -1;

                gv.mod.seamlessModififierMinX = 0;
                gv.mod.seamlessModififierMaxX = 0;
                gv.mod.seamlessModififierMinY = 0;
                gv.mod.seamlessModififierMaxY = 0;

                #region neighbours
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion
                //foreach (Area a in gv.mod.moduleAreasObjects)

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                if (gv.mod.currentArea.sourceBitmapName != "")
                {
                    #region Draw Layer 0
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            //check whether x or y extreme, use tile from neighbour then
                            //loop thruogh are with neigbhour names and find index
                            //adjust black tile for border
                            //this is inside layer 0, adjust for all
                            //handle corner, ie draw to two side situations
                            //use tile 1 and tile2 in this case, to draw in two directions
                            //IMPORTANT NOTE:  disable cache cleaning on area change
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile)
                            {
                                try
                                {

                                    bool tileBitmapIsLoadedAlready = false;
                                    int indexOfLoadedTile = -1;
                                    for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                    {
                                        if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer0Filename)
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = i;
                                            break;
                                        }
                                    }

                                    //hurghx
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(tile.Layer0Filename);
                                        string backup = gv.mod.currentArea.sourceBitmapName;
                                        if (index != -1)
                                        {
                                            gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                        }
                                        tile.tileBitmap0 = gv.cc.LoadBitmap(tile.Layer0Filename);
                                        //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                        gv.mod.currentArea.sourceBitmapName = backup;

                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                        //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                        //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                        float scalerX = 1;
                                        float scalerY = 1;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, tile.tileBitmap0.PixelSize.Width, tile.tileBitmap0.PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.mod.loadedTileBitmaps.Add(tile.tileBitmap0);
                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst); 

                                        //gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated = true;
                                        if (gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated)
                                        {
                                            gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                        }
                                        else
                                        {
                                            gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, false);
                                        }

                                    }
                                    else
                                    {
                                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                        //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                        //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                        //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                        float scalerX = 1;
                                        float scalerY = 1;
                                        int brX = (int)(gv.squareSize * scalerX);
                                        int brY = (int)(gv.squareSize * scalerY);
                                        IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);

                                        //gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated = true;
                                        if (gv.mod.currentArea.drawWithLessVisibleSeamsButMorePixelated)
                                        {
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, false, 1f, true);
                                        }
                                        else
                                        {
                                            gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, false, 1f, false);
                                        }


                                    }

                                    //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                                }
                                catch
                                {
                                    //int i = 2;
                                }
                            }
                        }
                    }
                    #endregion
                }
                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer1Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer1Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;

                                    //tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap1.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap1.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap1.PixelSize.Width, tile.tileBitmap1.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap1);
                                    //gv.DrawBitmap(tile.tileBitmap1, src, dst);
                                    gv.DrawBitmap(tile.tileBitmap1, src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale, tile.Layer1Opacity);
                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale, tile.Layer1Opacity);

                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion
                #region Draw Layer 2
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer2Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer2Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;
                                    //tile.tileBitmap2 = gv.cc.LoadBitmap(tile.Layer2Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap2.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap2.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap2.PixelSize.Width, tile.tileBitmap2.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap2);
                                    //gv.DrawBitmap(tile.tileBitmap2, src, dst);
                                    gv.DrawBitmap(tile.tileBitmap2, src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale, tile.Layer2Opacity);

                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale, tile.Layer2Opacity);

                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion
                #region Draw Layer 3
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer3Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer3Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;
                                    //tile.tileBitmap3 = gv.cc.LoadBitmap(tile.Layer3Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap3.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap3.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap3.PixelSize.Width, tile.tileBitmap3.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap3);
                                    //gv.DrawBitmap(tile.tileBitmap3, src, dst);
                                    gv.DrawBitmap(tile.tileBitmap3, src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale, tile.Layer3Opacity);

                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale, tile.Layer3Opacity);
                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion
                #region Draw Layer 4
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer4Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer4Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap4 = gv.cc.LoadBitmap(tile.Layer4Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;
                                    //tile.tileBitmap4 = gv.cc.LoadBitmap(tile.Layer4Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap4.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap4.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap4.PixelSize.Width, tile.tileBitmap4.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap4);
                                    //gv.DrawBitmap(tile.tileBitmap4, src, dst);
                                    gv.DrawBitmap(tile.tileBitmap4, src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale, tile.Layer4Opacity);

                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale, tile.Layer4Opacity);

                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion

                #region Draw Entrance lights
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            /*
                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                            float scalerX = tile.tileBitmap5.PixelSize.Width / 100;
                            float scalerY = tile.tileBitmap5.PixelSize.Height / 100;
                            int brX = (int)(gv.squareSize * scalerX);
                            int brY = (int)(gv.squareSize * scalerY);
                            IbRect src = new IbRect(0, 0, tile.tileBitmap5.PixelSize.Width, tile.tileBitmap5.PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            */
                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                            float scalerX = gv.cc.longShadow.PixelSize.Width / 100;
                            float scalerY = gv.cc.longShadow.PixelSize.Height / 100;
                            int brX = (int)(gv.squareSize * scalerX);
                            int brY = (int)(gv.squareSize * scalerY);

                            IbRect src = new IbRect(0, 0, gv.cc.longShadow.PixelSize.Width, gv.cc.longShadow.PixelSize.Height);

                            IbRect dstNorth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY - gv.squareSize, brX, brY);
                            IbRect dstEast = new IbRect(tlX + gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            IbRect dstSouth = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY + gv.squareSize, brX, brY);
                            IbRect dstWest = new IbRect(tlX - gv.squareSize + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                            //**********************************
                            if (tile.transitionToMasterDirection == "E")
                            {
                                if (gv.mod.currentArea.masterOfThisArea != "none")
                                {
                                    //krah
                                    // gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.25f);
                                    gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 90, false, 0, 0, 1, 1, 0.3f);
                                    //gv.DrawBitmap()
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstEast, 90, false, 0, 0, 1, 1, 0.3f);
                                }

                            }
                            if (tile.transitionToMasterDirection == "W")
                            {
                                if (gv.mod.currentArea.masterOfThisArea != "none")
                                {
                                    //krah
                                    gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 270, false, 0, 0, 1, 1, 0.3f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstWest, 270, false, 0, 0, 1, 1, 0.3f);
                                }
                            }
                            if (tile.transitionToMasterDirection == "N")
                            {
                                if (gv.mod.currentArea.masterOfThisArea != "none")
                                {
                                    //krah
                                    gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 0, false, 0, 0, 1, 1, 0.3f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.3f);
                                }
                            }
                            if (tile.transitionToMasterDirection == "S")
                            {
                                if (gv.mod.currentArea.masterOfThisArea != "none")
                                {
                                    //krah
                                    gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0, 0, 0, 0, 0.5f);

                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dst, 180, false, 0, 0, 1, 1, 0.3f);
                                }
                                else
                                {
                                    gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstSouth, 180, false, 0, 0, 1, 1, 0.3f);
                                }
                            }

                            //**********************************

                            if (tile.isEWBridge)
                            {
                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstNorth, 0, false, 0, 0, 1, 1, 0.25f);
                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstSouth, 180, false, 0, 0, 1, 1, 0.25f);
                                //DrawD2DBitmap(GetFromBitmapList("shortShadow"), src, dst, 180, false, 0, 0, 1, 1, 0.6f);
                                //gv.mod.currentArea.PlayerIsUnderBridge = 

                            }

                            if (tile.isNSBridge)
                            {
                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstWest, 270, false, 0, 0, 1, 1, 0.25f);
                                gv.DrawBitmap(gv.cc.entranceLightNorth2, src, dstEast, 90, false, 0, 0, 1, 1, 0.25f);
                            }

                            if (tile.hasDownStairShadowS)
                            {
                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 0, false, 0, 0);
                            }

                            if (tile.hasDownStairShadowW)
                            {
                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 90, false, 0, 0);
                            }

                            if (tile.hasDownStairShadowN)
                            {
                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 180, false, 0, 0);
                            }

                            if (tile.hasDownStairShadowE)
                            {
                                gv.DrawBitmap(gv.cc.downStairShadow, src, dst, 270, false, 0, 0);
                            }
                        }
                    }
                }
                #endregion



                #region Draw Layer 5
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer5Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer5Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap5 = gv.cc.LoadBitmap(tile.Layer5Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;
                                    //tile.tileBitmap5 = gv.cc.LoadBitmap(tile.Layer5Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap5.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap5.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap5.PixelSize.Width, tile.tileBitmap5.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap5);
                                    //gv.DrawBitmap(tile.tileBitmap5, src, dst);
                                    gv.DrawBitmap(tile.tileBitmap5, src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);

                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    //gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale, tile.Layer5Opacity);
                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion

                #region Draw Black Squares
                //drawColumnOfBlack(gv.playerOffsetX*2+2);
                //MAY NOT NEED THIS WITH NEW FULL SCREEN gv.modE
                //draw black squares to make sure and hide any large tiles that have over drawn outside the visible map area
                /*int mapStartLocationInSquares = 6;
                int mapSizeInSquares = gv.playerOffset + gv.playerOffset + 1;
                int mapRightEndSquare = mapStartLocationInSquares + mapSizeInSquares;
                if (!gv.useLargeLayout) { mapStartLocationInSquares = 4; }
                IbRect srcBlackTile = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);

                //draw left side squares
                for (int x = mapStartLocationInSquares - 2; x < mapStartLocationInSquares; x++)
                {
                    for (int y = 0; y < mapSizeInSquares; y++)
                    {
                        IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                    }
                }
                //draw right side squares
                for (int x = mapRightEndSquare; x < mapRightEndSquare + 2; x++)
                {
                    for (int y = 0; y < mapSizeInSquares; y++)
                    {
                        IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                    }
                }
                //draw top squares
                for (int x = mapStartLocationInSquares - 2; x < mapRightEndSquare + 2; x++)
                {
                    IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, -1 * gv.squareSize, gv.squareSize, gv.squareSize);
                    gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                }
                //draw bottom squares
                for (int x = mapStartLocationInSquares - 2; x < mapRightEndSquare + 2; x++)
                {
                    for (int y = mapSizeInSquares; y < mapSizeInSquares + 2; y++)
                    {
                        IbRect dst = new IbRect(x * gv.squareSize + gv.oXshift, y * gv.squareSize, gv.squareSize, gv.squareSize);
                        gv.DrawBitmap(gv.cc.black_tile, srcBlackTile, dst);
                    }
                }*/
                //draw black tiles over large tiles when party is near edges of map
                //drawBlackTilesOverTints();
                #endregion

                #endregion
            }
            else //old system using single image background and no load tile images on demand
            {
                #region old system
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 2; // use 2 so that extends down to bottom of screen
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 2
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer2Filename), src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 3
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer3Filename), src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 4
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer4Filename), src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 5
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer5Filename), src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale);
                        }
                        catch { }
                    }
                }
                #endregion

                #endregion
            }
        }

        /*
        public void drawHeightLevelShadows()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                gv.mod.indexOfNorthernNeighbour = -1;
                gv.mod.indexOfSouthernNeighbour = -1;
                gv.mod.indexOfEasternNeighbour = -1;
                gv.mod.indexOfWesternNeighbour = -1;
                gv.mod.indexOfNorthEasternNeighbour = -1;
                gv.mod.indexOfNorthWesternNeighbour = -1;
                gv.mod.indexOfSouthEasternNeighbour = -1;
                gv.mod.indexOfSouthWesternNeighbour = -1;

                gv.mod.seamlessModififierMinX = 0;
                gv.mod.seamlessModififierMaxX = 0;
                gv.mod.seamlessModififierMinY = 0;
                gv.mod.seamlessModififierMaxY = 0;

                #region neighbours
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX) 
                        {
                        gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }
                        
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }
                        
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion
                //foreach (Area a in gv.mod.moduleAreasObjects)

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX -1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY +1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;

                                //now we know the potentially shaded tile, we need information on how it is shaded
                                //this requires information on the height levels of all neighbouring tiles, relative to the current tile's height
                                //this requires a loop checking the tiles neighbouring the current tile
                                //main difficulty is that the neighbouring tiles can very well be on different maps than the currrent tile
                                //consequence is we will need to nest the above mechanism again 
                                for (int nx = -1; nx < 2; nx++)
                                {
                                    for (int ny = -1; ny < 2; ny++)
                                    {
                                        //nine situations where a shadow granting tile can be:
                                        //shadow granting tile on north-western map (diagonal situation)
                                        if ((x + nx < 0) && (y + ny < 0) && (!situationFound))
                                        {

                                        }
                                    }
                                }
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {

                                bool tileBitmapIsLoadedAlready = false;
                                int indexOfLoadedTile = -1;
                                for (int i = 0; i < gv.mod.loadedTileBitmapsNames.Count; i++)
                                {
                                    if (gv.mod.loadedTileBitmapsNames[i] == tile.Layer1Filename)
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = i;
                                        break;
                                    }
                                }

                                //hurghx
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(tile.Layer1Filename);
                                    string backup = gv.mod.currentArea.sourceBitmapName;
                                    if (index != -1)
                                    {
                                        gv.mod.currentArea.sourceBitmapName = gv.mod.moduleAreasObjects[index].sourceBitmapName;
                                    }
                                    tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);
                                    //tile.tileBitmap0 = gv.cc.LoadBitmapSubdirectory(tile.Layer0Filename, gv.mod.currentArea);
                                    gv.mod.currentArea.sourceBitmapName = backup;

                                    //tile.tileBitmap1 = gv.cc.LoadBitmap(tile.Layer1Filename);

                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = tile.tileBitmap1.PixelSize.Width / 100;
                                    float scalerY = tile.tileBitmap1.PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, tile.tileBitmap1.PixelSize.Width, tile.tileBitmap1.PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.mod.loadedTileBitmaps.Add(tile.tileBitmap1);
                                    gv.DrawBitmap(tile.tileBitmap1, src, dst);
                                }
                                else
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                                    float scalerX = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / 100;
                                    float scalerY = gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / 100;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    IbRect src = new IbRect(0, 0, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst);
                                }

                                //gv.DrawBitmap(gv.cc.tileBitmapList[tile.Layer1Filename], src, dst);
                            }
                            catch { }
                        }
                    }
                }
                #endregion
                
                #endregion
            }
            else //old system using single image background and no load tile images on demand
            {
                #region old system
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 2; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 2; // use 2 so that extends down to bottom of screen
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                #region Draw Layer 1
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer1Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer1Filename), src, dst, tile.Layer1Rotate, tile.Layer1Mirror, tile.Layer1Xshift, tile.Layer1Yshift, tile.Layer1Xscale, tile.Layer1Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 2
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer2Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer2Filename), src, dst, tile.Layer2Rotate, tile.Layer2Mirror, tile.Layer2Xshift, tile.Layer2Yshift, tile.Layer2Xscale, tile.Layer2Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 3
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer3Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer3Filename), src, dst, tile.Layer3Rotate, tile.Layer3Mirror, tile.Layer3Xshift, tile.Layer3Yshift, tile.Layer3Xscale, tile.Layer3Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 4
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer4Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer4Filename), src, dst, tile.Layer4Rotate, tile.Layer4Mirror, tile.Layer4Xshift, tile.Layer4Yshift, tile.Layer4Xscale, tile.Layer4Yscale);
                        }
                        catch { }
                    }
                }
                #endregion
                #region Draw Layer 5
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        float scalerX = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width / 100;
                        float scalerY = gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height / 100;
                        int brX = (int)(gv.squareSize * scalerX);
                        int brY = (int)(gv.squareSize * scalerY);

                        try
                        {
                            IbRect src = new IbRect(0, 0, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Width, gv.cc.GetFromTileBitmapList(tile.Layer5Filename).PixelSize.Height);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                            gv.DrawBitmap(gv.cc.GetFromTileBitmapList(tile.Layer5Filename), src, dst, tile.Layer5Rotate, tile.Layer5Mirror, tile.Layer5Xshift, tile.Layer5Yshift, tile.Layer5Xscale, tile.Layer5Yscale);
                        }
                        catch { }
                    }
                }
                #endregion

                #endregion
            }
        }
        */

        public void drawTopFullScreenEffects()
        {
            #region dst tile preparation (min and max)  

            int indexOfNorthernNeighbour = -1;
            int indexOfSouthernNeighbour = -1;
            int indexOfEasternNeighbour = -1;
            int indexOfWesternNeighbour = -1;
            int indexOfNorthEasternNeighbour = -1;
            int indexOfNorthWesternNeighbour = -1;
            int indexOfSouthEasternNeighbour = -1;
            int indexOfSouthWesternNeighbour = -1;

            int seamlessModififierMinX = 0;
            int seamlessModififierMaxX = 0;
            int seamlessModififierMinY = 0;
            int seamlessModififierMaxY = 0;

            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
            {
                seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
            {
                seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            //set up teh min and max dst tiles to iterate through, ie draw on into the map area and that on a tile by tile basis 
            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX;
            if (minX < -seamlessModififierMinX) { minX = -seamlessModififierMinX; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY;
            if (minY < -seamlessModififierMinY) { minY = -seamlessModififierMinY; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY; }
            #endregion
            //hurgh
            #region Draw full screen layer 1
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer1 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer1) && (gv.mod.currentArea.FullScreenEffectLayer1IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive1))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect1);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride1 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 15;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 750;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1.0f;
                    float defaultOverrideSpeedY1 = 1.0f;
                    int defaultOverrideDelayLimit1 = 110;
                    string defaultOverrideIsNoScrollSource1 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.075f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.075f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.45f;
                    float defaultOverrideSpeedY1 = -0.55f;
                    int defaultOverrideDelayLimit1 = 470;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }


                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.15f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = -2.8f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1f;
                    float defaultOverrideSpeedY1 = 1f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                    gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX1;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY1;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed1 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride1 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter1 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter1 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter1 >= (gv.mod.currentArea.numberOfCyclesPerOccurence1))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter1 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence1 * -1;
                        if (gv.mod.currentArea.changeFrameCounter1 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade1)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == (gv.mod.currentArea.numberOfCyclesPerOccurence1 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging1)
                    {
                        gv.mod.currentArea.changeCounter1 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter1 > gv.mod.currentArea.changeLimit1)
                        {
                            gv.mod.currentArea.changeCounter1 = 0;
                            gv.mod.currentArea.changeFrameCounter1 += 1;
                            if (gv.mod.currentArea.changeFrameCounter1 > gv.mod.currentArea.changeNumberOfFrames1)
                            {
                                gv.mod.currentArea.changeFrameCounter1 = 1;
                            }
                        }
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1 + gv.mod.currentArea.changeFrameCounter1.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect1.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX1;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX1 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY1 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX1 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {

                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer1)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;


                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;

                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders1)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion


                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource1 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);

                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion

            #region Draw full screen layer 2
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer2 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer2) && (gv.mod.currentArea.FullScreenEffectLayer2IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive2))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect2);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride2 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 15;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 750;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1.0f;
                    float defaultOverrideSpeedY2 = 1.0f;
                    int defaultOverrideDelayLimit2 = 110;
                    string defaultOverrideIsNoScrollSource2 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.075f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.075f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.45f;
                    float defaultOverrideSpeedY2 = -0.55f;
                    int defaultOverrideDelayLimit2 = 470;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }


                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.15f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = -2.8f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1f;
                    float defaultOverrideSpeedY2 = 1f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                    gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX2;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY2;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed2 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride2 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter2 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter2 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter2 >= (gv.mod.currentArea.numberOfCyclesPerOccurence2))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter2 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence2 * -1;
                        if (gv.mod.currentArea.changeFrameCounter2 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade2)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == (gv.mod.currentArea.numberOfCyclesPerOccurence2 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging2)
                    {
                        gv.mod.currentArea.changeCounter2 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter2 > gv.mod.currentArea.changeLimit2)
                        {
                            gv.mod.currentArea.changeCounter2 = 0;
                            gv.mod.currentArea.changeFrameCounter2 += 1;
                            if (gv.mod.currentArea.changeFrameCounter2 > gv.mod.currentArea.changeNumberOfFrames2)
                            {
                                gv.mod.currentArea.changeFrameCounter2 = 1;
                            }
                        }
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2 + gv.mod.currentArea.changeFrameCounter2.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect2.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX2;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX2 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY2 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX2 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer2)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource2 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 3
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer3 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer3) && (gv.mod.currentArea.FullScreenEffectLayer3IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive3))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect3);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride3 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 15;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 750;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1.0f;
                    float defaultOverrideSpeedY3 = 1.0f;
                    int defaultOverrideDelayLimit3 = 110;
                    string defaultOverrideIsNoScrollSource3 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.075f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.075f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.45f;
                    float defaultOverrideSpeedY3 = -0.55f;
                    int defaultOverrideDelayLimit3 = 470;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }


                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.15f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = -2.8f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1f;
                    float defaultOverrideSpeedY3 = 1f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                    gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX3;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY3;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed3 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride3 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter3 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter3 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter3 >= (gv.mod.currentArea.numberOfCyclesPerOccurence3))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter3 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence3 * -1;
                        if (gv.mod.currentArea.changeFrameCounter3 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade3)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == (gv.mod.currentArea.numberOfCyclesPerOccurence3 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging3)
                    {
                        gv.mod.currentArea.changeCounter3 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter3 > gv.mod.currentArea.changeLimit3)
                        {
                            gv.mod.currentArea.changeCounter3 = 0;
                            gv.mod.currentArea.changeFrameCounter3 += 1;
                            if (gv.mod.currentArea.changeFrameCounter3 > gv.mod.currentArea.changeNumberOfFrames3)
                            {
                                gv.mod.currentArea.changeFrameCounter3 = 1;
                            }
                        }
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3 + gv.mod.currentArea.changeFrameCounter3.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect3.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX3;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY3;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX3 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY3 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX3 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY3 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer3)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource3 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 4
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer4 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer4) && (gv.mod.currentArea.FullScreenEffectLayer4IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive4))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect4);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride4 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 15;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 750;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1.0f;
                    float defaultOverrideSpeedY4 = 1.0f;
                    int defaultOverrideDelayLimit4 = 110;
                    string defaultOverrideIsNoScrollSource4 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.075f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.075f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.45f;
                    float defaultOverrideSpeedY4 = -0.55f;
                    int defaultOverrideDelayLimit4 = 470;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }


                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.15f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = -2.8f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1f;
                    float defaultOverrideSpeedY4 = 1f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                    gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX4;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY4;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed4 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride4 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter4 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter4 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter4 >= (gv.mod.currentArea.numberOfCyclesPerOccurence4))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter4 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence4 * -1;
                        if (gv.mod.currentArea.changeFrameCounter4 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade4)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == (gv.mod.currentArea.numberOfCyclesPerOccurence4 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging4)
                    {
                        gv.mod.currentArea.changeCounter4 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter4 > gv.mod.currentArea.changeLimit4)
                        {
                            gv.mod.currentArea.changeCounter4 = 0;
                            gv.mod.currentArea.changeFrameCounter4 += 1;
                            if (gv.mod.currentArea.changeFrameCounter4 > gv.mod.currentArea.changeNumberOfFrames4)
                            {
                                gv.mod.currentArea.changeFrameCounter4 = 1;
                            }
                        }
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4 + gv.mod.currentArea.changeFrameCounter4.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect4.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX4;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY4;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX4 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY4 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX4 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY4 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer4)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource4 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 5
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer5 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer5) && (gv.mod.currentArea.FullScreenEffectLayer5IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive5) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect5);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride5 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 15;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 750;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1.0f;
                    float defaultOverrideSpeedY5 = 1.0f;
                    int defaultOverrideDelayLimit5 = 110;
                    string defaultOverrideIsNoScrollSource5 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.075f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.075f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.45f;
                    float defaultOverrideSpeedY5 = -0.55f;
                    int defaultOverrideDelayLimit5 = 470;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }


                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.15f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = -2.8f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1f;
                    float defaultOverrideSpeedY5 = 1f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                    gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX5;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY5;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed5 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride5 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter5 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter5 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter5 >= (gv.mod.currentArea.numberOfCyclesPerOccurence5))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter5 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence5 * -1;
                        if (gv.mod.currentArea.changeFrameCounter5 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade5)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == (gv.mod.currentArea.numberOfCyclesPerOccurence5 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5));
                        }
                    }

                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }

                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging5)
                    {
                        gv.mod.currentArea.changeCounter5 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter5 > gv.mod.currentArea.changeLimit5)
                        {
                            gv.mod.currentArea.changeCounter5 = 0;
                            gv.mod.currentArea.changeFrameCounter5 += 1;
                            if (gv.mod.currentArea.changeFrameCounter5 > gv.mod.currentArea.changeNumberOfFrames5)
                            {
                                gv.mod.currentArea.changeFrameCounter5 = 1;
                            }
                        }
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5 + gv.mod.currentArea.changeFrameCounter5.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect5.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX5;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY5;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX5 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY5 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX5 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY5 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer5)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource5 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 6
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer6 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer6) && (gv.mod.currentArea.FullScreenEffectLayer6IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive6) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect6);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride6 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 15;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 750;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1.0f;
                    float defaultOverrideSpeedY6 = 1.0f;
                    int defaultOverrideDelayLimit6 = 110;
                    string defaultOverrideIsNoScrollSource6 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.075f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.075f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.45f;
                    float defaultOverrideSpeedY6 = -0.55f;
                    int defaultOverrideDelayLimit6 = 470;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }


                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.15f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = -2.8f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1f;
                    float defaultOverrideSpeedY6 = 1f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                    gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX6;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY6;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed6 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride6 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter6 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter6 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter6 >= (gv.mod.currentArea.numberOfCyclesPerOccurence6))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter6 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence6 * -1;
                        if (gv.mod.currentArea.changeFrameCounter6 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade6)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == (gv.mod.currentArea.numberOfCyclesPerOccurence6 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging6)
                    {
                        gv.mod.currentArea.changeCounter6 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter6 > gv.mod.currentArea.changeLimit6)
                        {
                            gv.mod.currentArea.changeCounter6 = 0;
                            gv.mod.currentArea.changeFrameCounter6 += 1;
                            if (gv.mod.currentArea.changeFrameCounter6 > gv.mod.currentArea.changeNumberOfFrames6)
                            {
                                gv.mod.currentArea.changeFrameCounter6 = 1;
                            }
                        }
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6 + gv.mod.currentArea.changeFrameCounter6.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect6.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX6;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY6;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX6 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY6 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX6 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY6 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer6)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource6 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 7
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer7 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer7) && (gv.mod.currentArea.FullScreenEffectLayer7IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive7) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect7);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride7 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 15;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 750;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1.0f;
                    float defaultOverrideSpeedY7 = 1.0f;
                    int defaultOverrideDelayLimit7 = 110;
                    string defaultOverrideIsNoScrollSource7 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.075f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.075f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.45f;
                    float defaultOverrideSpeedY7 = -0.55f;
                    int defaultOverrideDelayLimit7 = 470;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }


                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.15f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = -2.8f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1f;
                    float defaultOverrideSpeedY7 = 1f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                    gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX7;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY7;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed7 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride7 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter7 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter7 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter7 >= (gv.mod.currentArea.numberOfCyclesPerOccurence7))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter7 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence7 * -1;
                        if (gv.mod.currentArea.changeFrameCounter7 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade7)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == (gv.mod.currentArea.numberOfCyclesPerOccurence7 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging7)
                    {
                        gv.mod.currentArea.changeCounter7 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter7 > gv.mod.currentArea.changeLimit7)
                        {
                            gv.mod.currentArea.changeCounter7 = 0;
                            gv.mod.currentArea.changeFrameCounter7 += 1;
                            if (gv.mod.currentArea.changeFrameCounter7 > gv.mod.currentArea.changeNumberOfFrames7)
                            {
                                gv.mod.currentArea.changeFrameCounter7 = 1;
                            }
                        }
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7 + gv.mod.currentArea.changeFrameCounter7.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect7.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX7;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY7;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX7 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY7 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX7 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY7 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer7)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource7 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 8
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X800 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer8 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer8) && (gv.mod.currentArea.FullScreenEffectLayer8IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive8) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect8);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride8 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 15;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 750;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1.0f;
                    float defaultOverrideSpeedY8 = 1.0f;
                    int defaultOverrideDelayLimit8 = 110;
                    string defaultOverrideIsNoScrollSource8 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.075f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.075f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.45f;
                    float defaultOverrideSpeedY8 = -0.55f;
                    int defaultOverrideDelayLimit8 = 470;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }


                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.15f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = -2.8f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1f;
                    float defaultOverrideSpeedY8 = 1f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                    gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX8;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY8;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed8 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride8 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter8 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter8 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter8 >= (gv.mod.currentArea.numberOfCyclesPerOccurence8))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter8 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence8 * -1;
                        if (gv.mod.currentArea.changeFrameCounter8 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade8)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == (gv.mod.currentArea.numberOfCyclesPerOccurence8 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging8)
                    {
                        gv.mod.currentArea.changeCounter8 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter8 > gv.mod.currentArea.changeLimit8)
                        {
                            gv.mod.currentArea.changeCounter8 = 0;
                            gv.mod.currentArea.changeFrameCounter8 += 1;
                            if (gv.mod.currentArea.changeFrameCounter8 > gv.mod.currentArea.changeNumberOfFrames8)
                            {
                                gv.mod.currentArea.changeFrameCounter8 = 1;
                            }
                        }
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8 + gv.mod.currentArea.changeFrameCounter8.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect8.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX8;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY8;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX8 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY8 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX8 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY8 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer8)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource8 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 9
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X900 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer9 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer9) && (gv.mod.currentArea.FullScreenEffectLayer9IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive9) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect9);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride9 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 15;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 750;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1.0f;
                    float defaultOverrideSpeedY9 = 1.0f;
                    int defaultOverrideDelayLimit9 = 110;
                    string defaultOverrideIsNoScrollSource9 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.075f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.075f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.45f;
                    float defaultOverrideSpeedY9 = -0.55f;
                    int defaultOverrideDelayLimit9 = 470;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }


                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.15f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = -2.8f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1f;
                    float defaultOverrideSpeedY9 = 1f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                    gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX9;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY9;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed9 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride9 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter9 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter9 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter9 >= (gv.mod.currentArea.numberOfCyclesPerOccurence9))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter9 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence9 * -1;
                        if (gv.mod.currentArea.changeFrameCounter9 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade9)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == (gv.mod.currentArea.numberOfCyclesPerOccurence9 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging9)
                    {
                        gv.mod.currentArea.changeCounter9 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter9 > gv.mod.currentArea.changeLimit9)
                        {
                            gv.mod.currentArea.changeCounter9 = 0;
                            gv.mod.currentArea.changeFrameCounter9 += 1;
                            if (gv.mod.currentArea.changeFrameCounter9 > gv.mod.currentArea.changeNumberOfFrames9)
                            {
                                gv.mod.currentArea.changeFrameCounter9 = 1;
                            }
                        }
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9 + gv.mod.currentArea.changeFrameCounter9.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect9.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX9;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY9;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX9 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY9 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX9 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY9 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer9)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource9 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 10
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X1000 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer10 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer10) && (gv.mod.currentArea.FullScreenEffectLayer10IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive10) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect10);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride10 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 15;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 750;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1.0f;
                    float defaultOverrideSpeedY10 = 1.0f;
                    int defaultOverrideDelayLimit10 = 110;
                    string defaultOverrideIsNoScrollSource10 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.075f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.075f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.45f;
                    float defaultOverrideSpeedY10 = -0.55f;
                    int defaultOverrideDelayLimit10 = 470;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }


                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.15f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = -2.8f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1f;
                    float defaultOverrideSpeedY10 = 1f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                    gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX10;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY10;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed10 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride10 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter10 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter10 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter10 >= (gv.mod.currentArea.numberOfCyclesPerOccurence10))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter10 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence10 * -1;
                        if (gv.mod.currentArea.changeFrameCounter10 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade10)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == (gv.mod.currentArea.numberOfCyclesPerOccurence10 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging10)
                    {
                        gv.mod.currentArea.changeCounter10 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter10 > gv.mod.currentArea.changeLimit10)
                        {
                            gv.mod.currentArea.changeCounter10 = 0;
                            gv.mod.currentArea.changeFrameCounter10 += 1;
                            if (gv.mod.currentArea.changeFrameCounter10 > gv.mod.currentArea.changeNumberOfFrames10)
                            {
                                gv.mod.currentArea.changeFrameCounter10 = 1;
                            }
                        }
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10 + gv.mod.currentArea.changeFrameCounter10.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect10.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX10;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY10;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX10 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY10 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX10 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY10 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer10)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource10 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion   
        }

        public void drawBottomFullScreenEffects()
        {
            #region dst tile preparation (min and max)  

            int indexOfNorthernNeighbour = -1;
            int indexOfSouthernNeighbour = -1;
            int indexOfEasternNeighbour = -1;
            int indexOfWesternNeighbour = -1;
            int indexOfNorthEasternNeighbour = -1;
            int indexOfNorthWesternNeighbour = -1;
            int indexOfSouthEasternNeighbour = -1;
            int indexOfSouthWesternNeighbour = -1;

            int seamlessModififierMinX = 0;
            int seamlessModififierMaxX = 0;
            int seamlessModififierMinY = 0;
            int seamlessModififierMaxY = 0;

            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
            {
                seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                    {
                        indexOfNorthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
            {

                seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                    {
                        indexOfSouthernNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
            {
                seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                    {
                        indexOfWesternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthWesternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthWesternNeighbour = i;
                        }
                    }
                }
            }

            if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
            {
                seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                {
                    if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                    {
                        indexOfEasternNeighbour = i;
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                        {
                            indexOfNorthEasternNeighbour = i;
                        }
                    }
                }

                if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                        {
                            indexOfSouthEasternNeighbour = i;
                        }
                    }
                }
            }

            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            //set up teh min and max dst tiles to iterate through, ie draw on into the map area and that on a tile by tile basis 
            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX;
            if (minX < -seamlessModififierMinX) { minX = -seamlessModififierMinX; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY;
            if (minY < -seamlessModififierMinY) { minY = -seamlessModififierMinY; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + seamlessModififierMaxX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + seamlessModififierMaxY; }
            #endregion
            //hurgh
            #region Draw full screen layer 1
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer1 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer1) && (!gv.mod.currentArea.FullScreenEffectLayer1IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive1))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect1);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride1 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 15;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 = -defaultOverrideSpeedX1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 = -defaultOverrideSpeedY1;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = 0.5f;
                    int defaultOverrideDelayLimit1 = 750;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1.0f;
                    float defaultOverrideSpeedY1 = 1.0f;
                    int defaultOverrideDelayLimit1 = 110;
                    string defaultOverrideIsNoScrollSource1 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.075f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.25f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = ((0.075f * directional) + (decider * defaultOverrideSpeedY1 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.45f;
                    float defaultOverrideSpeedY1 = -0.55f;
                    int defaultOverrideDelayLimit1 = 470;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }


                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.15f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 0.5f;
                    float defaultOverrideSpeedY1 = -2.8f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }

                    gv.mod.currentArea.overrideDelayCounter1++;
                    if (gv.mod.currentArea.overrideDelayCounter1 > defaultOverrideDelayLimit1)
                    {

                        gv.mod.currentArea.overrideDelayCounter1 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX1 = ((0.25f * directional) + (decider * defaultOverrideSpeedX1 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride1 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX1 = 1f;
                    float defaultOverrideSpeedY1 = 1f;
                    int defaultOverrideDelayLimit1 = 100;
                    string defaultOverrideIsNoScrollSource1 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource1 = defaultOverrideIsNoScrollSource1;
                    }

                    if (gv.mod.currentArea.overrideSpeedX1 != -100)
                    {
                        defaultOverrideSpeedX1 = gv.mod.currentArea.overrideSpeedX1;
                    }
                    if (gv.mod.currentArea.overrideSpeedY1 != -100)
                    {
                        defaultOverrideSpeedY1 = gv.mod.currentArea.overrideSpeedY1;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit1 != -100)
                    {
                        defaultOverrideDelayLimit1 = gv.mod.currentArea.overrideDelayLimit1;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX1 = defaultOverrideSpeedX1;
                    gv.mod.currentArea.fullScreenAnimationSpeedY1 = defaultOverrideSpeedY1;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX1;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY1;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed1 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride1 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter1 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter1 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed1 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter1 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter1 >= (gv.mod.currentArea.numberOfCyclesPerOccurence1))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter1 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence1 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence1 * -1;
                        if (gv.mod.currentArea.changeFrameCounter1 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive1 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter1 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter1 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter1 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive1 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade1)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter1 == (gv.mod.currentArea.numberOfCyclesPerOccurence1 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence1 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed1 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter1));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging1)
                    {
                        gv.mod.currentArea.changeCounter1 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter1 > gv.mod.currentArea.changeLimit1)
                        {
                            gv.mod.currentArea.changeCounter1 = 0;
                            gv.mod.currentArea.changeFrameCounter1 += 1;
                            if (gv.mod.currentArea.changeFrameCounter1 > gv.mod.currentArea.changeNumberOfFrames1)
                            {
                                gv.mod.currentArea.changeFrameCounter1 = 1;
                            }
                        }
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1 + gv.mod.currentArea.changeFrameCounter1.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect1 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName1);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect1.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX1;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX1 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY1 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX1 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY1 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX1 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {

                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer1)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;


                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;

                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders1)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion


                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource1 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource1 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource1 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);

                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect1, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion

            #region Draw full screen layer 2
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer2 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer2) && (!gv.mod.currentArea.FullScreenEffectLayer2IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive2))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect2);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride2 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 15;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 = -defaultOverrideSpeedX2;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 = -defaultOverrideSpeedY2;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = 0.5f;
                    int defaultOverrideDelayLimit2 = 750;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1.0f;
                    float defaultOverrideSpeedY2 = 1.0f;
                    int defaultOverrideDelayLimit2 = 110;
                    string defaultOverrideIsNoScrollSource2 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.075f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.25f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = ((0.075f * directional) + (decider * defaultOverrideSpeedY2 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.45f;
                    float defaultOverrideSpeedY2 = -0.55f;
                    int defaultOverrideDelayLimit2 = 470;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }


                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.15f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 0.5f;
                    float defaultOverrideSpeedY2 = -2.8f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }

                    gv.mod.currentArea.overrideDelayCounter2++;
                    if (gv.mod.currentArea.overrideDelayCounter2 > defaultOverrideDelayLimit2)
                    {

                        gv.mod.currentArea.overrideDelayCounter2 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX2 = ((0.25f * directional) + (decider * defaultOverrideSpeedX2 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride2 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX2 = 1f;
                    float defaultOverrideSpeedY2 = 1f;
                    int defaultOverrideDelayLimit2 = 100;
                    string defaultOverrideIsNoScrollSource2 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource2 = defaultOverrideIsNoScrollSource2;
                    }

                    if (gv.mod.currentArea.overrideSpeedX2 != -100)
                    {
                        defaultOverrideSpeedX2 = gv.mod.currentArea.overrideSpeedX2;
                    }
                    if (gv.mod.currentArea.overrideSpeedY2 != -100)
                    {
                        defaultOverrideSpeedY2 = gv.mod.currentArea.overrideSpeedY2;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit2 != -100)
                    {
                        defaultOverrideDelayLimit2 = gv.mod.currentArea.overrideDelayLimit2;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX2 = defaultOverrideSpeedX2;
                    gv.mod.currentArea.fullScreenAnimationSpeedY2 = defaultOverrideSpeedY2;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX2;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY2;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed2 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride2 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter2 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter2 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed2 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter2 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter2 >= (gv.mod.currentArea.numberOfCyclesPerOccurence2))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter2 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence2 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence2 * -1;
                        if (gv.mod.currentArea.changeFrameCounter2 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive2 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter2 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter2 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter2 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive2 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade2)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter2 == (gv.mod.currentArea.numberOfCyclesPerOccurence2 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence2 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed2 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter2));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging2)
                    {
                        gv.mod.currentArea.changeCounter2 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter2 > gv.mod.currentArea.changeLimit2)
                        {
                            gv.mod.currentArea.changeCounter2 = 0;
                            gv.mod.currentArea.changeFrameCounter2 += 1;
                            if (gv.mod.currentArea.changeFrameCounter2 > gv.mod.currentArea.changeNumberOfFrames2)
                            {
                                gv.mod.currentArea.changeFrameCounter2 = 1;
                            }
                        }
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2 + gv.mod.currentArea.changeFrameCounter2.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect2 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName2);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect2.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX2;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY1;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX2 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY2 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX2 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY2 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX2 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY1 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer2)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource2 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource2 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource2 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 3
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer3 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer3) && (!gv.mod.currentArea.FullScreenEffectLayer3IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive3))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect3);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride3 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 15;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 = -defaultOverrideSpeedX3;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 = -defaultOverrideSpeedY3;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = 0.5f;
                    int defaultOverrideDelayLimit3 = 750;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1.0f;
                    float defaultOverrideSpeedY3 = 1.0f;
                    int defaultOverrideDelayLimit3 = 110;
                    string defaultOverrideIsNoScrollSource3 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.075f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.25f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = ((0.075f * directional) + (decider * defaultOverrideSpeedY3 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.45f;
                    float defaultOverrideSpeedY3 = -0.55f;
                    int defaultOverrideDelayLimit3 = 470;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }


                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.15f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 0.5f;
                    float defaultOverrideSpeedY3 = -2.8f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }

                    gv.mod.currentArea.overrideDelayCounter3++;
                    if (gv.mod.currentArea.overrideDelayCounter3 > defaultOverrideDelayLimit3)
                    {

                        gv.mod.currentArea.overrideDelayCounter3 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX3 = ((0.25f * directional) + (decider * defaultOverrideSpeedX3 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride3 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX3 = 1f;
                    float defaultOverrideSpeedY3 = 1f;
                    int defaultOverrideDelayLimit3 = 100;
                    string defaultOverrideIsNoScrollSource3 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource3 = defaultOverrideIsNoScrollSource3;
                    }

                    if (gv.mod.currentArea.overrideSpeedX3 != -100)
                    {
                        defaultOverrideSpeedX3 = gv.mod.currentArea.overrideSpeedX3;
                    }
                    if (gv.mod.currentArea.overrideSpeedY3 != -100)
                    {
                        defaultOverrideSpeedY3 = gv.mod.currentArea.overrideSpeedY3;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit3 != -100)
                    {
                        defaultOverrideDelayLimit3 = gv.mod.currentArea.overrideDelayLimit3;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX3 = defaultOverrideSpeedX3;
                    gv.mod.currentArea.fullScreenAnimationSpeedY3 = defaultOverrideSpeedY3;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX3;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY3;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed3 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride3 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter3 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter3 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed3 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter3 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter3 >= (gv.mod.currentArea.numberOfCyclesPerOccurence3))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter3 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence3 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence3 * -1;
                        if (gv.mod.currentArea.changeFrameCounter3 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive3 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter3 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter3 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter3 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive3 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade3)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter3 == (gv.mod.currentArea.numberOfCyclesPerOccurence3 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence3 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed3 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter3));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging3)
                    {
                        gv.mod.currentArea.changeCounter3 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter3 > gv.mod.currentArea.changeLimit3)
                        {
                            gv.mod.currentArea.changeCounter3 = 0;
                            gv.mod.currentArea.changeFrameCounter3 += 1;
                            if (gv.mod.currentArea.changeFrameCounter3 > gv.mod.currentArea.changeNumberOfFrames3)
                            {
                                gv.mod.currentArea.changeFrameCounter3 = 1;
                            }
                        }
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3 + gv.mod.currentArea.changeFrameCounter3.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect3 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName3);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect3.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX3;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY3;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX3 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY3 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX3 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY3 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX3 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY3 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer3)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource3 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource3 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource3 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect3, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 4
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer4 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer4) && (!gv.mod.currentArea.FullScreenEffectLayer4IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive4))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect4);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride4 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 15;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 = -defaultOverrideSpeedX4;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 = -defaultOverrideSpeedY4;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = 0.5f;
                    int defaultOverrideDelayLimit4 = 750;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1.0f;
                    float defaultOverrideSpeedY4 = 1.0f;
                    int defaultOverrideDelayLimit4 = 110;
                    string defaultOverrideIsNoScrollSource4 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.075f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.25f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = ((0.075f * directional) + (decider * defaultOverrideSpeedY4 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.45f;
                    float defaultOverrideSpeedY4 = -0.55f;
                    int defaultOverrideDelayLimit4 = 470;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }


                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.15f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 0.5f;
                    float defaultOverrideSpeedY4 = -2.8f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }

                    gv.mod.currentArea.overrideDelayCounter4++;
                    if (gv.mod.currentArea.overrideDelayCounter4 > defaultOverrideDelayLimit4)
                    {

                        gv.mod.currentArea.overrideDelayCounter4 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX4 = ((0.25f * directional) + (decider * defaultOverrideSpeedX4 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride4 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX4 = 1f;
                    float defaultOverrideSpeedY4 = 1f;
                    int defaultOverrideDelayLimit4 = 100;
                    string defaultOverrideIsNoScrollSource4 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource4 = defaultOverrideIsNoScrollSource4;
                    }

                    if (gv.mod.currentArea.overrideSpeedX4 != -100)
                    {
                        defaultOverrideSpeedX4 = gv.mod.currentArea.overrideSpeedX4;
                    }
                    if (gv.mod.currentArea.overrideSpeedY4 != -100)
                    {
                        defaultOverrideSpeedY4 = gv.mod.currentArea.overrideSpeedY4;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit4 != -100)
                    {
                        defaultOverrideDelayLimit4 = gv.mod.currentArea.overrideDelayLimit4;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX4 = defaultOverrideSpeedX4;
                    gv.mod.currentArea.fullScreenAnimationSpeedY4 = defaultOverrideSpeedY4;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX4;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY4;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed4 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride4 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter4 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter4 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed4 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter4 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter4 >= (gv.mod.currentArea.numberOfCyclesPerOccurence4))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter4 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence4 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence4 * -1;
                        if (gv.mod.currentArea.changeFrameCounter4 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive4 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter4 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter4 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter4 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive4 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade4)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter4 == (gv.mod.currentArea.numberOfCyclesPerOccurence4 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence4 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed4 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter4));
                        }
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging4)
                    {
                        gv.mod.currentArea.changeCounter4 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter4 > gv.mod.currentArea.changeLimit4)
                        {
                            gv.mod.currentArea.changeCounter4 = 0;
                            gv.mod.currentArea.changeFrameCounter4 += 1;
                            if (gv.mod.currentArea.changeFrameCounter4 > gv.mod.currentArea.changeNumberOfFrames4)
                            {
                                gv.mod.currentArea.changeFrameCounter4 = 1;
                            }
                        }
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4 + gv.mod.currentArea.changeFrameCounter4.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect4 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName4);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect4.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX4;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY4;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX4 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY4 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX4 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY4 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX4 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY4 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer4)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource4 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource4 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect2, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource4 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect4, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 5
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer5 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer5) && (!gv.mod.currentArea.FullScreenEffectLayer5IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive5) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect5);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride5 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 15;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 = -defaultOverrideSpeedX5;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 = -defaultOverrideSpeedY5;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = 0.5f;
                    int defaultOverrideDelayLimit5 = 750;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1.0f;
                    float defaultOverrideSpeedY5 = 1.0f;
                    int defaultOverrideDelayLimit5 = 110;
                    string defaultOverrideIsNoScrollSource5 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.075f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.25f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = ((0.075f * directional) + (decider * defaultOverrideSpeedY5 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.45f;
                    float defaultOverrideSpeedY5 = -0.55f;
                    int defaultOverrideDelayLimit5 = 470;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }


                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.15f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 0.5f;
                    float defaultOverrideSpeedY5 = -2.8f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }

                    gv.mod.currentArea.overrideDelayCounter5++;
                    if (gv.mod.currentArea.overrideDelayCounter5 > defaultOverrideDelayLimit5)
                    {

                        gv.mod.currentArea.overrideDelayCounter5 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX5 = ((0.25f * directional) + (decider * defaultOverrideSpeedX5 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride5 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX5 = 1f;
                    float defaultOverrideSpeedY5 = 1f;
                    int defaultOverrideDelayLimit5 = 100;
                    string defaultOverrideIsNoScrollSource5 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource5 = defaultOverrideIsNoScrollSource5;
                    }

                    if (gv.mod.currentArea.overrideSpeedX5 != -100)
                    {
                        defaultOverrideSpeedX5 = gv.mod.currentArea.overrideSpeedX5;
                    }
                    if (gv.mod.currentArea.overrideSpeedY5 != -100)
                    {
                        defaultOverrideSpeedY5 = gv.mod.currentArea.overrideSpeedY5;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit5 != -100)
                    {
                        defaultOverrideDelayLimit5 = gv.mod.currentArea.overrideDelayLimit5;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX5 = defaultOverrideSpeedX5;
                    gv.mod.currentArea.fullScreenAnimationSpeedY5 = defaultOverrideSpeedY5;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX5;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY5;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed5 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride5 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter5 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter5 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed5 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter5 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter5 >= (gv.mod.currentArea.numberOfCyclesPerOccurence5))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter5 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence5 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence5 * -1;
                        if (gv.mod.currentArea.changeFrameCounter5 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive5 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter5 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter5 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter5 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive5 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade5)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter5 == (gv.mod.currentArea.numberOfCyclesPerOccurence5 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence5 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed5 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter5));
                        }
                    }

                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }

                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging5)
                    {
                        gv.mod.currentArea.changeCounter5 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter5 > gv.mod.currentArea.changeLimit5)
                        {
                            gv.mod.currentArea.changeCounter5 = 0;
                            gv.mod.currentArea.changeFrameCounter5 += 1;
                            if (gv.mod.currentArea.changeFrameCounter5 > gv.mod.currentArea.changeNumberOfFrames5)
                            {
                                gv.mod.currentArea.changeFrameCounter5 = 1;
                            }
                        }
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5 + gv.mod.currentArea.changeFrameCounter5.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect5 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName5);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect5.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX5;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY5;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX5 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY5 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX5 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY5 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX5 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY5 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer5)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource5 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource5 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource5 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect5, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 6
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer6 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer6) && (!gv.mod.currentArea.FullScreenEffectLayer6IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive6) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect6);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride6 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 15;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 = -defaultOverrideSpeedX6;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 = -defaultOverrideSpeedY6;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = 0.5f;
                    int defaultOverrideDelayLimit6 = 750;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1.0f;
                    float defaultOverrideSpeedY6 = 1.0f;
                    int defaultOverrideDelayLimit6 = 110;
                    string defaultOverrideIsNoScrollSource6 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.075f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.25f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = ((0.075f * directional) + (decider * defaultOverrideSpeedY6 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.45f;
                    float defaultOverrideSpeedY6 = -0.55f;
                    int defaultOverrideDelayLimit6 = 470;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }


                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.15f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 0.5f;
                    float defaultOverrideSpeedY6 = -2.8f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }

                    gv.mod.currentArea.overrideDelayCounter6++;
                    if (gv.mod.currentArea.overrideDelayCounter6 > defaultOverrideDelayLimit6)
                    {

                        gv.mod.currentArea.overrideDelayCounter6 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX6 = ((0.25f * directional) + (decider * defaultOverrideSpeedX6 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride6 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX6 = 1f;
                    float defaultOverrideSpeedY6 = 1f;
                    int defaultOverrideDelayLimit6 = 100;
                    string defaultOverrideIsNoScrollSource6 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource6 = defaultOverrideIsNoScrollSource6;
                    }

                    if (gv.mod.currentArea.overrideSpeedX6 != -100)
                    {
                        defaultOverrideSpeedX6 = gv.mod.currentArea.overrideSpeedX6;
                    }
                    if (gv.mod.currentArea.overrideSpeedY6 != -100)
                    {
                        defaultOverrideSpeedY6 = gv.mod.currentArea.overrideSpeedY6;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit6 != -100)
                    {
                        defaultOverrideDelayLimit6 = gv.mod.currentArea.overrideDelayLimit6;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX6 = defaultOverrideSpeedX6;
                    gv.mod.currentArea.fullScreenAnimationSpeedY6 = defaultOverrideSpeedY6;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX6;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY6;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed6 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride6 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter6 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter6 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed6 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter6 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter6 >= (gv.mod.currentArea.numberOfCyclesPerOccurence6))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter6 += 1;
                    }
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence6 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence6 * -1;
                        if (gv.mod.currentArea.changeFrameCounter6 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive6 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter6 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter6 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter6 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive6 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade6)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter6 == (gv.mod.currentArea.numberOfCyclesPerOccurence6 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence6 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed6 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter6));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging6)
                    {
                        gv.mod.currentArea.changeCounter6 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter6 > gv.mod.currentArea.changeLimit6)
                        {
                            gv.mod.currentArea.changeCounter6 = 0;
                            gv.mod.currentArea.changeFrameCounter6 += 1;
                            if (gv.mod.currentArea.changeFrameCounter6 > gv.mod.currentArea.changeNumberOfFrames6)
                            {
                                gv.mod.currentArea.changeFrameCounter6 = 1;
                            }
                        }
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6 + gv.mod.currentArea.changeFrameCounter6.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect6 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName6);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect6.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX6;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY6;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX6 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY6 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX6 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY6 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX6 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY6 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer6)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource6 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource6 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource6 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect6, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 7
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100x100 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer7 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer7) && (!gv.mod.currentArea.FullScreenEffectLayer7IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive7) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect7);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride7 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 15;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 = -defaultOverrideSpeedX7;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 = -defaultOverrideSpeedY7;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = 0.5f;
                    int defaultOverrideDelayLimit7 = 750;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1.0f;
                    float defaultOverrideSpeedY7 = 1.0f;
                    int defaultOverrideDelayLimit7 = 110;
                    string defaultOverrideIsNoScrollSource7 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.075f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.25f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = ((0.075f * directional) + (decider * defaultOverrideSpeedY7 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.45f;
                    float defaultOverrideSpeedY7 = -0.55f;
                    int defaultOverrideDelayLimit7 = 470;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }


                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.15f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 0.5f;
                    float defaultOverrideSpeedY7 = -2.8f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }

                    gv.mod.currentArea.overrideDelayCounter7++;
                    if (gv.mod.currentArea.overrideDelayCounter7 > defaultOverrideDelayLimit7)
                    {

                        gv.mod.currentArea.overrideDelayCounter7 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX7 = ((0.25f * directional) + (decider * defaultOverrideSpeedX7 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride7 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX7 = 1f;
                    float defaultOverrideSpeedY7 = 1f;
                    int defaultOverrideDelayLimit7 = 100;
                    string defaultOverrideIsNoScrollSource7 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource7 = defaultOverrideIsNoScrollSource7;
                    }

                    if (gv.mod.currentArea.overrideSpeedX7 != -100)
                    {
                        defaultOverrideSpeedX7 = gv.mod.currentArea.overrideSpeedX7;
                    }
                    if (gv.mod.currentArea.overrideSpeedY7 != -100)
                    {
                        defaultOverrideSpeedY7 = gv.mod.currentArea.overrideSpeedY7;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit7 != -100)
                    {
                        defaultOverrideDelayLimit7 = gv.mod.currentArea.overrideDelayLimit7;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX7 = defaultOverrideSpeedX7;
                    gv.mod.currentArea.fullScreenAnimationSpeedY7 = defaultOverrideSpeedY7;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX7;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY7;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed7 = speedComponentX + speedComponentY;

                        //based on subjective trial and error
                        if (gv.mod.currentArea.directionalOverride7 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter7 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter7 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed7 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter7 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter7 >= (gv.mod.currentArea.numberOfCyclesPerOccurence7))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter7 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence7 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence7 * -1;
                        if (gv.mod.currentArea.changeFrameCounter7 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive7 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter7 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter7 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter7 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive7 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade7)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter7 == (gv.mod.currentArea.numberOfCyclesPerOccurence7 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence7 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed7 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter7));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging7)
                    {
                        gv.mod.currentArea.changeCounter7 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter7 > gv.mod.currentArea.changeLimit7)
                        {
                            gv.mod.currentArea.changeCounter7 = 0;
                            gv.mod.currentArea.changeFrameCounter7 += 1;
                            if (gv.mod.currentArea.changeFrameCounter7 > gv.mod.currentArea.changeNumberOfFrames7)
                            {
                                gv.mod.currentArea.changeFrameCounter7 = 1;
                            }
                        }
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7 + gv.mod.currentArea.changeFrameCounter7.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect7 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName7);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect7.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX7;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY7;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX7 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY7 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX7 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY7 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX7 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY7 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer7)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource7 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource7 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {

                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource7 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect7, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }


                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 8
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X800 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer8 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer8) && (!gv.mod.currentArea.FullScreenEffectLayer8IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive8) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect8);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride8 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 15;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 = -defaultOverrideSpeedX8;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 = -defaultOverrideSpeedY8;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = 0.5f;
                    int defaultOverrideDelayLimit8 = 750;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1.0f;
                    float defaultOverrideSpeedY8 = 1.0f;
                    int defaultOverrideDelayLimit8 = 110;
                    string defaultOverrideIsNoScrollSource8 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.075f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.25f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = ((0.075f * directional) + (decider * defaultOverrideSpeedY8 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.45f;
                    float defaultOverrideSpeedY8 = -0.55f;
                    int defaultOverrideDelayLimit8 = 470;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }


                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.15f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 0.5f;
                    float defaultOverrideSpeedY8 = -2.8f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }

                    gv.mod.currentArea.overrideDelayCounter8++;
                    if (gv.mod.currentArea.overrideDelayCounter8 > defaultOverrideDelayLimit8)
                    {

                        gv.mod.currentArea.overrideDelayCounter8 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX8 = ((0.25f * directional) + (decider * defaultOverrideSpeedX8 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride8 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX8 = 1f;
                    float defaultOverrideSpeedY8 = 1f;
                    int defaultOverrideDelayLimit8 = 100;
                    string defaultOverrideIsNoScrollSource8 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource8 = defaultOverrideIsNoScrollSource8;
                    }

                    if (gv.mod.currentArea.overrideSpeedX8 != -100)
                    {
                        defaultOverrideSpeedX8 = gv.mod.currentArea.overrideSpeedX8;
                    }
                    if (gv.mod.currentArea.overrideSpeedY8 != -100)
                    {
                        defaultOverrideSpeedY8 = gv.mod.currentArea.overrideSpeedY8;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit8 != -100)
                    {
                        defaultOverrideDelayLimit8 = gv.mod.currentArea.overrideDelayLimit8;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX8 = defaultOverrideSpeedX8;
                    gv.mod.currentArea.fullScreenAnimationSpeedY8 = defaultOverrideSpeedY8;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX8;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY8;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed8 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride8 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter8 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter8 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed8 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter8 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter8 >= (gv.mod.currentArea.numberOfCyclesPerOccurence8))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter8 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence8 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence8 * -1;
                        if (gv.mod.currentArea.changeFrameCounter8 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive8 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter8 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter8 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter8 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive8 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade8)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter8 == (gv.mod.currentArea.numberOfCyclesPerOccurence8 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence8 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed8 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter8));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging8)
                    {
                        gv.mod.currentArea.changeCounter8 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter8 > gv.mod.currentArea.changeLimit8)
                        {
                            gv.mod.currentArea.changeCounter8 = 0;
                            gv.mod.currentArea.changeFrameCounter8 += 1;
                            if (gv.mod.currentArea.changeFrameCounter8 > gv.mod.currentArea.changeNumberOfFrames8)
                            {
                                gv.mod.currentArea.changeFrameCounter8 = 1;
                            }
                        }
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8 + gv.mod.currentArea.changeFrameCounter8.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect8 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName8);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect8.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX8;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY8;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX8 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY8 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX8 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY8 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX8 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY8 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer8)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource8 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource8 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource8 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect8, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 9
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X900 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer9 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer9) && (!gv.mod.currentArea.FullScreenEffectLayer9IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive9) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect9);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride9 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 15;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 = -defaultOverrideSpeedX9;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 = -defaultOverrideSpeedY9;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = 0.5f;
                    int defaultOverrideDelayLimit9 = 750;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1.0f;
                    float defaultOverrideSpeedY9 = 1.0f;
                    int defaultOverrideDelayLimit9 = 110;
                    string defaultOverrideIsNoScrollSource9 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.075f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.25f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = ((0.075f * directional) + (decider * defaultOverrideSpeedY9 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.45f;
                    float defaultOverrideSpeedY9 = -0.55f;
                    int defaultOverrideDelayLimit9 = 470;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }


                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.15f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 0.5f;
                    float defaultOverrideSpeedY9 = -2.8f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }

                    gv.mod.currentArea.overrideDelayCounter9++;
                    if (gv.mod.currentArea.overrideDelayCounter9 > defaultOverrideDelayLimit9)
                    {

                        gv.mod.currentArea.overrideDelayCounter9 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX9 = ((0.25f * directional) + (decider * defaultOverrideSpeedX9 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride9 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX9 = 1f;
                    float defaultOverrideSpeedY9 = 1f;
                    int defaultOverrideDelayLimit9 = 100;
                    string defaultOverrideIsNoScrollSource9 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource9 = defaultOverrideIsNoScrollSource9;
                    }

                    if (gv.mod.currentArea.overrideSpeedX9 != -100)
                    {
                        defaultOverrideSpeedX9 = gv.mod.currentArea.overrideSpeedX9;
                    }
                    if (gv.mod.currentArea.overrideSpeedY9 != -100)
                    {
                        defaultOverrideSpeedY9 = gv.mod.currentArea.overrideSpeedY9;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit9 != -100)
                    {
                        defaultOverrideDelayLimit9 = gv.mod.currentArea.overrideDelayLimit9;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX9 = defaultOverrideSpeedX9;
                    gv.mod.currentArea.fullScreenAnimationSpeedY9 = defaultOverrideSpeedY9;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX9;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY9;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed9 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride9 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter9 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter9 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed9 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter9 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter9 >= (gv.mod.currentArea.numberOfCyclesPerOccurence9))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter9 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence9 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence9 * -1;
                        if (gv.mod.currentArea.changeFrameCounter9 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive9 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter9 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter9 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter9 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive9 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade9)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter9 == (gv.mod.currentArea.numberOfCyclesPerOccurence9 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence9 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed9 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter9));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging9)
                    {
                        gv.mod.currentArea.changeCounter9 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter9 > gv.mod.currentArea.changeLimit9)
                        {
                            gv.mod.currentArea.changeCounter9 = 0;
                            gv.mod.currentArea.changeFrameCounter9 += 1;
                            if (gv.mod.currentArea.changeFrameCounter9 > gv.mod.currentArea.changeNumberOfFrames9)
                            {
                                gv.mod.currentArea.changeFrameCounter9 = 1;
                            }
                        }
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9 + gv.mod.currentArea.changeFrameCounter9.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect9 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName9);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect9.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX9;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY9;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX9 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY9 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX9 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY9 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX9 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY9 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer9)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource9 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource9 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource9 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect9, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion
            #region Draw full screen layer 10
            //there will be six layers for effects usable by either the top (eg.sky) or bottom (eg sea) full scren draw methods 
            //I would guess that combined about 60.000 pix are ok for performance,so like 6 x 100X1000 source bitmaps or fewer, but with higer resolution
            //that's for my laptop

            //check whether the layer10 is activated and set to top level
            if ((gv.mod.currentArea.useFullScreenEffectLayer10) && (!gv.mod.currentArea.FullScreenEffectLayer10IsTop) && (gv.mod.currentArea.fullScreenEffectLayerIsActive10) && (gv.mod.currentArea.areaWeatherName != ""))
            {

                gv.cc.DisposeOfBitmap(ref fullScreenEffect10);

                //these replace the normal, linear scroll in direction of vector x,y pattern
                //in the toolset different values for overrides can be set than the defaults they come with
                //this way an author can make use of the non-linear algorithms with different input parameters to bend their shape
                //basically it works like the override would call scripts whose paratmeters can be set by the authors
                //just with the added comfort that teh paarmeters ahve own fields in the toolset and descritive text
                //also when just letting all override values sit at zero,the override will use its own defaults, working out of the box like e.g. snow

                #region override movement patterns

                if (gv.mod.currentArea.directionalOverride10 == "randStraight")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 15;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(8);
                        //right
                        if (rollRandom == 1)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //left
                        if (rollRandom == 2)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = 0.0f;
                        }
                        //up
                        if (rollRandom == 3)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //down
                        if (rollRandom == 4)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = 0.0f;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //up right
                        if (rollRandom == 5)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //upleft
                        if (rollRandom == 6)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                        }
                        //downright
                        if (rollRandom == 7)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                        //downleft
                        if (rollRandom == 8)
                        {
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 = -defaultOverrideSpeedX10;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 = -defaultOverrideSpeedY10;
                        }
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "clouds")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = 0.5f;
                    int defaultOverrideDelayLimit10 = 750;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);

                        //for y
                        rollRandom = gv.sf.RandInt(100);
                        rollRandom2 = gv.sf.RandInt(2);
                        directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "fog")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1.0f;
                    float defaultOverrideSpeedY10 = 1.0f;
                    int defaultOverrideDelayLimit10 = 110;
                    string defaultOverrideIsNoScrollSource10 = "True";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        //for x
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(100);
                        int directional = 1;
                        if (rollRandom2 >= 50)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.075f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (0.09f);

                        //for y
                        int rollRandom3 = gv.sf.RandInt(100);
                        int rollRandom4 = gv.sf.RandInt(100);
                        directional = 1;
                        if (rollRandom4 >= 50)
                        {
                            rollRandom3 = rollRandom3 * -1;
                            directional = -1;
                        }
                        decider = rollRandom3 / 100f;
                        //gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.25f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = ((0.075f * directional) + (decider * defaultOverrideSpeedY10 * 0.5f)) * (0.09f);
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "snow")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.45f;
                    float defaultOverrideSpeedY10 = -0.55f;
                    int defaultOverrideDelayLimit10 = 470;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }


                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            rollRandom = rollRandom * -1;
                            directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.15f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "rain")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 0.5f;
                    float defaultOverrideSpeedY10 = -2.8f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }

                    gv.mod.currentArea.overrideDelayCounter10++;
                    if (gv.mod.currentArea.overrideDelayCounter10 > defaultOverrideDelayLimit10)
                    {

                        gv.mod.currentArea.overrideDelayCounter10 = 0;
                        int rollRandom = gv.sf.RandInt(100);
                        int rollRandom2 = gv.sf.RandInt(2);
                        int directional = 1;
                        if (rollRandom2 == 1)
                        {
                            //rollRandom = rollRandom * -1;
                            //directional = -1;
                        }
                        float decider = rollRandom / 100f;
                        gv.mod.currentArea.fullScreenAnimationSpeedX10 = ((0.25f * directional) + (decider * defaultOverrideSpeedX10 * 0.5f)) * (1.5f);
                        gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10 * 1.5f;
                    }
                }

                if (gv.mod.currentArea.directionalOverride10 == "linear")
                {
                    //set up the default values and allow individiual override based on toolset values
                    float defaultOverrideSpeedX10 = 1f;
                    float defaultOverrideSpeedY10 = 1f;
                    int defaultOverrideDelayLimit10 = 100;
                    string defaultOverrideIsNoScrollSource10 = "False";

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "")
                    {
                        gv.mod.currentArea.overrideIsNoScrollSource10 = defaultOverrideIsNoScrollSource10;
                    }

                    if (gv.mod.currentArea.overrideSpeedX10 != -100)
                    {
                        defaultOverrideSpeedX10 = gv.mod.currentArea.overrideSpeedX10;
                    }
                    if (gv.mod.currentArea.overrideSpeedY10 != -100)
                    {
                        defaultOverrideSpeedY10 = gv.mod.currentArea.overrideSpeedY10;
                    }
                    if (gv.mod.currentArea.overrideDelayLimit10 != -100)
                    {
                        defaultOverrideDelayLimit10 = gv.mod.currentArea.overrideDelayLimit10;
                    }
                    gv.mod.currentArea.fullScreenAnimationSpeedX10 = defaultOverrideSpeedX10;
                    gv.mod.currentArea.fullScreenAnimationSpeedY10 = defaultOverrideSpeedY10;
                }


                #endregion

                if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                {
                    #region limited cycle animation
                    //check whether we got an effect that is supposed to happen only once in a while
                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0)
                    {

                        //added speed
                        float speedComponentX = gv.mod.currentArea.fullScreenAnimationSpeedX10;
                        if (speedComponentX < 0)
                        {
                            speedComponentX *= -1;
                        }
                        float speedComponentY = gv.mod.currentArea.fullScreenAnimationSpeedY10;
                        if (speedComponentY < 0)
                        {
                            speedComponentY *= -1;
                        }
                        gv.mod.currentArea.fullScreenAnimationSpeed10 = speedComponentX + speedComponentY;

                        //based on subjective trial and error

                        if (gv.mod.currentArea.directionalOverride10 == "snow")
                        {
                            if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > ((50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1) * 1.6f)))
                            {
                                gv.mod.currentArea.cycleCounter10 += 1;
                                gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            }
                        }
                        else if ((gv.mod.currentArea.fullScreenAnimationFrameCounter10 > (50f / (gv.mod.currentArea.fullScreenAnimationSpeed10 * gv.mod.allAnimationSpeedMultiplier) - 1)))
                        {
                            gv.mod.currentArea.cycleCounter10 += 1;
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                        }

                        //a little extra delay added by on intuition how long a cycle takes here
                        if (gv.mod.currentArea.cycleCounter10 >= (gv.mod.currentArea.numberOfCyclesPerOccurence10))
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }

                        gv.mod.currentArea.fullScreenAnimationFrameCounter10 += 1;
                    }

                    if (gv.mod.currentArea.numberOfCyclesPerOccurence10 < 0)
                    {
                        int counterLimit = gv.mod.currentArea.numberOfCyclesPerOccurence10 * -1;
                        if (gv.mod.currentArea.changeFrameCounter10 >= counterLimit)
                        {
                            //turn the animation off, in common code's doudate method a chance per turn is rolled for turning on again
                            gv.mod.currentArea.fullScreenEffectLayerIsActive10 = false;
                            //counts how often/long the aniamtion is displayed before stop
                            gv.mod.currentArea.cycleCounter10 = 0;
                            //just keeping track how often render calls have run through
                            gv.mod.currentArea.fullScreenAnimationFrameCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeCounter10 = 0;
                            //for changing a shape changing anim
                            gv.mod.currentArea.changeFrameCounter10 = 1;
                        }
                    }
                    #endregion

                    //if (gv.mod.currentArea.fullScreenEffectLayerIsActive10 == true)
                    //{
                    float fullScreenEffectOpacity = 1f;
                    #region opacity code
                    if (gv.mod.currentArea.useCyclicFade10)
                    {
                        //fade in within first cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == 0) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10);
                        }

                        //fade out within last cycle of cyclic animation
                        if ((gv.mod.currentArea.cycleCounter10 == (gv.mod.currentArea.numberOfCyclesPerOccurence10 - 1)) && (gv.mod.currentArea.numberOfCyclesPerOccurence10 > 0))
                        {
                            fullScreenEffectOpacity = 1f - (1f / ((50f / ((float)gv.mod.currentArea.fullScreenAnimationSpeed10 * (float)gv.mod.allAnimationSpeedMultiplier)) / (float)gv.mod.currentArea.fullScreenAnimationFrameCounter10));
                        }
                    }
                    if (gv.mod.fullScreenEffectOpacityWeather != 1)
                    {
                        fullScreenEffectOpacity = gv.mod.fullScreenEffectOpacityWeather;
                    }
                    #endregion

                    //use weather system per area specific later on
                    //utilizing weather type defined by area weather settings
                    //add check for square specific punch hole that prevents drawing weather, e.g. house inside or spaceship interior

                    #region only for shape changing animation
                    if (gv.mod.currentArea.isChanging10)
                    {
                        gv.mod.currentArea.changeCounter10 += (1 * gv.mod.allAnimationSpeedMultiplier);
                        if (gv.mod.currentArea.changeCounter10 > gv.mod.currentArea.changeLimit10)
                        {
                            gv.mod.currentArea.changeCounter10 = 0;
                            gv.mod.currentArea.changeFrameCounter10 += 1;
                            if (gv.mod.currentArea.changeFrameCounter10 > gv.mod.currentArea.changeNumberOfFrames10)
                            {
                                gv.mod.currentArea.changeFrameCounter10 = 1;
                            }
                        }
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10 + gv.mod.currentArea.changeFrameCounter10.ToString());
                    }
                    #endregion

                    else
                    {
                        fullScreenEffect10 = gv.cc.LoadBitmap(gv.mod.currentArea.fullScreenEffectLayerName10);
                    }

                    #region handle framecounter
                    //assuming a square shaped source here
                    float sizeOfWholeSource = fullScreenEffect10.PixelSize.Width;

                    //reading the frames moved and added up in the last seconds
                    float pixShiftOnThisFrameX = gv.mod.currentArea.fullScreenAnimationFrameCounterX10;
                    float pixShiftOnThisFrameY = gv.mod.currentArea.fullScreenAnimationFrameCounterY10;

                    //increase by this call's movement
                    pixShiftOnThisFrameX += (gv.mod.currentArea.fullScreenAnimationSpeedX10 * gv.mod.allAnimationSpeedMultiplier);
                    pixShiftOnThisFrameY += (gv.mod.currentArea.fullScreenAnimationSpeedY10 * gv.mod.allAnimationSpeedMultiplier);

                    if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                    {
                        if (pixShiftOnThisFrameX > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameX = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY > ((sizeOfWholeSource * 0.5f) - 1))
                        {
                            pixShiftOnThisFrameY = (sizeOfWholeSource * 0.5f) - 1;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }

                        if (pixShiftOnThisFrameX < 0)
                        {
                            pixShiftOnThisFrameX = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedX10 *= -1;
                        }

                        if (pixShiftOnThisFrameY < 0)
                        {
                            pixShiftOnThisFrameY = 0;
                            gv.mod.currentArea.fullScreenAnimationSpeedY10 *= -1;
                        }
                    }

                    //reset it in case it grwos too large (note: just to avoid an overflow in the far future)
                    //the actual reset happens later below
                    if (pixShiftOnThisFrameX >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY >= ((2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY - ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameX <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameX = pixShiftOnThisFrameX + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    if (pixShiftOnThisFrameY <= ((-2000 * gv.playerOffset) * gv.squareSize))
                    {
                        pixShiftOnThisFrameY = pixShiftOnThisFrameY + ((2000 * gv.playerOffset) * gv.squareSize);
                    }

                    gv.mod.currentArea.fullScreenAnimationFrameCounterX10 = pixShiftOnThisFrameX;
                    gv.mod.currentArea.fullScreenAnimationFrameCounterY10 = pixShiftOnThisFrameY;
                    #endregion

                    #region iterate through the dst tiles
                    Tile tile = new Tile();
                    for (int x = minX; x < maxX; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            //Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }
                            //Tile tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];

                            //each tile can block the effects run on the six effect channels, each e.g. simualting shelter from rain
                            if (!tile.blockFullScreenEffectLayer10)
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;

                                float scalerX = 100 / 100f;
                                float scalerY = 100 / 100f;
                                float brX = gv.squareSize * scalerX;
                                float brY = gv.squareSize * scalerY;

                                float numberOfPicturePartsX = gv.playerOffsetX * 2 + 1;
                                float numberOfPicturePartsY = gv.playerOffsetY * 2 + 1;

                                #region is effect contained inside borders or always centered on party?
                                //code section for handling borders of the area
                                int modX = x;
                                int modY = y;
                                int modMinX = minX;
                                int modMinY = minY;
                                /*
                                if (gv.mod.currentArea.containEffectInsideAreaBorders2)
                                {
                                    //code for for always keeping the effect contained in the area box, break center on player near map border
                                    if ((gv.mod.PlayerLocationX + 4) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 1;
                                    }
                                    if ((gv.mod.PlayerLocationX + 3) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 2;
                                    }
                                    if ((gv.mod.PlayerLocationX + 2) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 3;
                                    }
                                    if ((gv.mod.PlayerLocationX + 1) == this.gv.mod.currentArea.MapSizeX)
                                    {
                                        modX += 4;
                                    }


                                    if ((gv.mod.PlayerLocationY + 4) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 1;
                                    }
                                    if ((gv.mod.PlayerLocationY + 3) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 2;
                                    }
                                    if ((gv.mod.PlayerLocationY + 2) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 3;
                                    }
                                    if ((gv.mod.PlayerLocationY + 1) == this.gv.mod.currentArea.MapSizeY)
                                    {
                                        modY += 4;
                                    }
                                }

                                else
                                {
                                    //code for always centering the effect on player, even near map border (e.g. light source carried by party)
                                    if ((gv.mod.PlayerLocationX - 3) == 0)
                                    {
                                        modMinX = -1;
                                    }
                                    if ((gv.mod.PlayerLocationX - 2) == 0)
                                    {
                                        modMinX = -2;
                                    }
                                    if ((gv.mod.PlayerLocationX - 1) == 0)
                                    {
                                        modMinX = -3;
                                    }
                                    if ((gv.mod.PlayerLocationX) == 0)
                                    {
                                        modMinX = -4;
                                    }


                                    if ((gv.mod.PlayerLocationY - 3) == 0)
                                    {
                                        modMinY = -1;
                                    }
                                    if ((gv.mod.PlayerLocationY - 2) == 0)
                                    {
                                        modMinY = -2;
                                    }
                                    if ((gv.mod.PlayerLocationY - 1) == 0)
                                    {
                                        modMinY = -3;
                                    }
                                    if ((gv.mod.PlayerLocationY) == 0)
                                    {
                                        modMinY = -4;
                                    }
                                }
                                */
                                #endregion

                                //get the correct chunk on source
                                //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                float floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                float floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                #region handle border situations on source (bottom and right)     
                                //the following four sections help to set the top left x,y of our square incase we ae close to bottom or right border of source

                                if (gv.mod.currentArea.overrideIsNoScrollSource10 == "True")
                                {
                                    sizeOfWholeSource = 0.5f * sizeOfWholeSource;
                                    //get the correct chunk on source
                                    //subject to movement of the animation expressed by pixShiftOnThisFrameX/Y
                                    floatSourceChunkCoordX = ((float)(modX - modMinX) / numberOfPicturePartsX) * sizeOfWholeSource + pixShiftOnThisFrameX;
                                    floatSourceChunkCoordY = ((float)(modY - modMinY ) / numberOfPicturePartsY) * sizeOfWholeSource + pixShiftOnThisFrameY;

                                    //float smallSourceChunk = sizeOfWholeSource / numberOfPictureParts;
                                    sizeOfWholeSource = 2.0f * sizeOfWholeSource;
                                    /*
                                    //stop at border
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = 0;
                                        
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordY >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordY = sizeOfWholeSource - smallSourceChunk - 1;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = 0;
                                    }

                                    //stop at border
                                    if (floatSourceChunkCoordX >= (sizeOfWholeSource - smallSourceChunk - 1))
                                    {
                                        floatSourceChunkCoordX = sizeOfWholeSource - smallSourceChunk - 1;
                                    }
                                    */

                                }

                                else
                                {

                                    //leave source in negative direction (vertical)
                                    if (floatSourceChunkCoordY < 0)
                                    {
                                        floatSourceChunkCoordY = (floatSourceChunkCoordY * -1f);
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                        floatSourceChunkCoordY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    }

                                    //leave source in positive direction (vertical)
                                    if (floatSourceChunkCoordY >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordY = floatSourceChunkCoordY % sizeOfWholeSource;
                                    }

                                    //leave source in negative direction (horizontal)
                                    if (floatSourceChunkCoordX < 0)
                                    {
                                        floatSourceChunkCoordX = (floatSourceChunkCoordX * -1f);
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                        floatSourceChunkCoordX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    }

                                    //leave source in positive direction (horizontal)
                                    if (floatSourceChunkCoordX >= sizeOfWholeSource)
                                    {
                                        floatSourceChunkCoordX = floatSourceChunkCoordX % sizeOfWholeSource;
                                    }
                                }
                                #endregion

                                #region handle the four different draw situations, based on position of chunk on source
                                //next task is to actaully draw up to four pieces of  square source to one target dst
                                //let's go through the differdnt situations that can occur

                                #region Situation 1 (complex, 4 to 1)
                                //Situation 1 (most complex): touching four source squares, we are in the far low right corner
                                //there will be two more 2 source square situations, one for x and one for y direction
                                //also there's of course the standard situation that we just need one coherent source
                                if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && ((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts four source chunks from four different source squares and draw them onto the dst square

                                    //first: top left corner
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: top right corner
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * dstScalerX)), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //third: bottom left corner
                                    float oldHeight = (brY * dstScalerY);
                                    availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldHeight, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //fourth: bottom right corner
                                    oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY + oldHeight, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    continue;

                                }
                                #endregion

                                #region Situation 2 (2 to 1, x near border)
                                //Situation 2: only x is near right border, y is high/small enough
                                else if (((floatSourceChunkCoordX + (sizeOfWholeSource / numberOfPicturePartsX)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: left hand side
                                    float availableLengthX = sizeOfWholeSource - floatSourceChunkCoordX;
                                    float availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: right hand side
                                    float oldWidth = (brX * dstScalerX);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX) - availableLengthX;
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY);
                                    dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    srcCoordY2 = floatSourceChunkCoordY;
                                    srcCoordX2 = 0;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels + oldWidth, tlY, (brX - (brX * (dstScalerX))), (brY * (dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;

                                }
                                #endregion

                                #region Situation 3 (2 to 1, y near border)
                                //Situation 3: only y is near bottom border, x is left/small enough WIP
                                else if (((floatSourceChunkCoordY + (sizeOfWholeSource / numberOfPicturePartsY)) >= sizeOfWholeSource) && (gv.mod.currentArea.overrideIsNoScrollSource10 != "True"))
                                {

                                    //need to use parts of two source chunks from two different source squares and draw them onto the dst square

                                    //first: top square
                                    float availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    float availableLengthY = sizeOfWholeSource - floatSourceChunkCoordY;
                                    float dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    float dstScalerY = availableLengthY / (sizeOfWholeSource / numberOfPicturePartsY);
                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (brX * dstScalerX), (brY * dstScalerY));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                    //second: bottom square
                                    float oldLength = 0;
                                    oldLength = (float)(brY * dstScalerY);
                                    availableLengthX = (sizeOfWholeSource / numberOfPicturePartsX);
                                    availableLengthY = (sizeOfWholeSource / numberOfPicturePartsY) - availableLengthY;
                                    dstScalerX = availableLengthX / (sizeOfWholeSource / numberOfPicturePartsX);
                                    srcCoordY2 = 0;
                                    srcCoordX2 = floatSourceChunkCoordX;

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, availableLengthX, availableLengthY);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY + oldLength, (brX * dstScalerX), (brY - (brY * dstScalerY)));
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }
                                    continue;
                                }
                                #endregion

                                #region Situation 4 (default, neither x or y near border)
                                //Situation 4: the default situation, x and y are sufficiently distant from bottom and right border
                                else
                                {


                                    float srcCoordY2 = floatSourceChunkCoordY;
                                    float srcCoordX2 = floatSourceChunkCoordX;
                                    float sizeOfSourceChunk2X = 0;
                                    float sizeOfSourceChunk2Y = 0;
                                    if (gv.mod.currentArea.overrideIsNoScrollSource10 != "True")
                                    {
                                        sizeOfSourceChunk2X = (sizeOfWholeSource / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = (sizeOfWholeSource / numberOfPicturePartsY);
                                    }
                                    else
                                    {
                                        sizeOfSourceChunk2X = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsX);
                                        sizeOfSourceChunk2Y = ((sizeOfWholeSource * 0.5f) / numberOfPicturePartsY);
                                    }

                                    try
                                    {
                                        IbRectF src = new IbRectF(srcCoordX2, srcCoordY2, sizeOfSourceChunk2X, sizeOfSourceChunk2Y);
                                        IbRectF dst = new IbRectF(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        gv.DrawBitmap(fullScreenEffect10, src, dst, false, fullScreenEffectOpacity);
                                    }
                                    catch { }

                                }
                                #endregion

                            }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #endregion   
        }

        public void drawMap()
        {
            int bmpWidth = gv.cc.bmpMap.PixelSize.Width;
            int bmpHeight = gv.cc.bmpMap.PixelSize.Height;
            int dstX = (gv.playerOffsetX - gv.mod.PlayerLocationX) * gv.squareSize;
            int dstY = (gv.playerOffsetY - gv.mod.PlayerLocationY) * gv.squareSize;
            int dstWidth = (int)(bmpWidth * 2 * gv.screenDensity); //assumes squares are 50x50 in this image
            int dstHeight = (int)(bmpHeight * 2 * gv.screenDensity); //assumes squares are 50x50 in this image

            IbRect src = new IbRect(0, 0, bmpWidth, bmpHeight);
            IbRect dst = new IbRect(dstX + gv.oXshift + mapStartLocXinPixels, dstY, dstWidth, dstHeight);
            gv.DrawBitmap(gv.cc.bmpMap, src, dst);

            drawColumnOfBlack(-1);
            drawColumnOfBlack(-2);
            drawRowOfBlack(-1);
            drawColumnOfBlack(gv.playerOffsetX * 2 + 1);
            drawColumnOfBlack(gv.playerOffsetX * 2 + 2);
            //hurgh16
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 3);
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 4);
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 5);
            //drawColumnOfBlack(gv.playerOffsetX * 2 + 6);
            drawRowOfBlack(gv.playerOffsetY * 2 + 2);
        }

        public void drawProps()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region new system
                //1
                //think I am gonna use the drawworldmap routines here, too

                //XXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //player near northern border
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                {
                    seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near southern  border
                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near western border
                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                {
                    seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                //player near eastern border
                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                bool situationFound = false;
                //int relevantIndex = -1;
                List<int> relevantIndices = new List<int>();
                int northernmodifier = 0;
                int easternmodifier = 0;
                int westernmodifier = 0;
                int southernmodifier = 0;

                //northwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthWesternNeighbour);
                }
                //northeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthEasternNeighbour);
                }
                //southwest
                if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthWesternNeighbour);
                }
                //southeast
                if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthEasternNeighbour);
                }
                //north
                if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfNorthernNeighbour);
                }
                //south
                if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfSouthernNeighbour);
                }
                //west
                if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfWesternNeighbour);
                }
                //east
                if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                {
                    situationFound = true;
                    relevantIndices.Add(indexOfEasternNeighbour);
                }
                /*
                //current map
                if (!situationFound)
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                        {
                            relevantIndex = i;
                        }
                    } 
                }
                */

                //XXXXXXXXXXXXXXXXXXXXXXXX
                for (int i = 0; i < relevantIndices.Count; i++)
                {//2

                    int backupLocationX = -1;
                    int backupLocationY = -1;

                    foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                    {//3
                     //only for on-movers (the movers use drawMovingProps below)
                     //if ((p.isShown) && (!p.isMover) && (p.token != null))
                        bool nonTimeDriven = true;
                        if (p.MoverType == "daily" || p.MoverType == "weekly" || p.MoverType == "monthly" || p.MoverType == "yearly")
                        {
                            nonTimeDriven = false;
                        }
                        int indexOfLoadedTile = -1;
                        if ((p.isShown) && (nonTimeDriven == true))
                        {//hurghkarl

                            //try
                            //{
                            //gv.cc.DisposeOfBitmap(ref p.token);
                            //}
                            //catch { }

                            //p.token = gv.cc.LoadBitmap(p.ImageFileName);

                            try
                            {
                                //insert1                        
                                bool tileBitmapIsLoadedAlready = false;
                                //int indexOfLoadedTile = -1;
                                for (int j = 0; j < gv.mod.loadedTileBitmapsNames.Count; j++)
                                {
                                    if ((gv.mod.loadedTileBitmapsNames[j] == p.ImageFileName) && (!gv.mod.loadedTileBitmaps[j].IsDisposed))
                                    {
                                        tileBitmapIsLoadedAlready = true;
                                        indexOfLoadedTile = j;
                                        break;
                                    }
                                }

                                //insert2
                                if (!tileBitmapIsLoadedAlready)
                                {
                                    gv.mod.loadedTileBitmapsNames.Add(p.ImageFileName);
                                    p.token = gv.cc.LoadBitmap(p.ImageFileName);
                                    gv.mod.loadedTileBitmaps.Add(p.token);
                                    indexOfLoadedTile = gv.mod.loadedTileBitmaps.Count - 1;

                                }
                            }
                            catch
                            { }



                            backupLocationX = p.LocationX;
                            backupLocationY = p.LocationY;

                            //XXXXXXXXXXXXXXXXXXX
                            situationFound = false;

                            //northwest
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Filename))
                                //if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //northeast
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //southwest
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Filename))

                                //if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //southeast
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //north
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Filename))

                                //if ((seamlessModififierMinY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                }
                            }

                            //south
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Filename))

                                //if ((seamlessModififierMaxY > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                }
                            }

                            //west
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Filename))

                                //if ((seamlessModififierMinX > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                }
                            }

                            //east
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Filename))

                                //if ((seamlessModififierMaxX > 0) && !situationFound)
                                {
                                    situationFound = true;
                                    p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                }
                            }

                            //XXXXXXXXXXXXXXXXXXXXXXXX

                            //distance check
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {//5
                             //prop X - playerX
                             //get dst rct based on distance of prop to  palyer
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames-1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                //adjust size of props
                                if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                }
                                else if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                                }

                                //draw the prop
                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                if (gv.mod.showInteractionState == true)
                                {//6
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (p.unavoidableConversation)
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }
                                }//6
                            }//5

                            p.LocationX = backupLocationX;
                            p.LocationY = backupLocationY;

                        }//4
                    }//3


                }//2

                //normal prop draw routine
                foreach (Prop p in gv.mod.currentArea.Props)
                {//3
                 //only for on-movers (the movers use drawMovingProps below)
                    if ((p.isShown) && (!p.isMover) && (p.token != null))
                    {//4

                        //distance check
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {//5
                         //prop X - playerX
                         //get dst rct based on distance of prop to  palyer
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                            //adjust size of props
                            if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                            }
                            else if (gv.mod.currentArea.useMiniProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                            }

                            //draw the prop
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                            if (gv.mod.showInteractionState == true)
                            {//6
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (p.unavoidableConversation)
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }
                            }//6
                        }//5
                    }//4
                }//3
                #endregion
            }
            else //old system
            {
                #region old system
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (!p.isMover))
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                            if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                            }
                            else if (gv.mod.currentArea.useMiniProps)
                            {
                                dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                            }
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState == true)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (p.unavoidableConversation)
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }
                            }
                        }
                    }
                }
                #endregion
            }
        }

        public void drawBrigdePropsOverPlayer()
        {
            if (gv.mod.currentArea.PlayerIsUnderBridge)
            {
                if (gv.mod.useAllTileSystem)
                {
                    #region new system
                    //1
                    //think I am gonna use the drawworldmap routines here, too

                    //XXXXXXXXXXXXXXXXXXXXXXXX
                    int indexOfNorthernNeighbour = -1;
                    int indexOfSouthernNeighbour = -1;
                    int indexOfEasternNeighbour = -1;
                    int indexOfWesternNeighbour = -1;
                    int indexOfNorthEasternNeighbour = -1;
                    int indexOfNorthWesternNeighbour = -1;
                    int indexOfSouthEasternNeighbour = -1;
                    int indexOfSouthWesternNeighbour = -1;

                    int seamlessModififierMinX = 0;
                    int seamlessModififierMaxX = 0;
                    int seamlessModififierMinY = 0;
                    int seamlessModififierMaxY = 0;

                    //player near northern border
                    if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < gv.playerOffsetY))
                    {
                        seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                            {
                                indexOfNorthernNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                                {
                                    indexOfNorthEasternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                                {
                                    indexOfNorthWesternNeighbour = i;
                                }
                            }
                        }
                    }

                    //player near southern  border
                    if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                    {

                        seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                            {
                                indexOfSouthernNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                                {
                                    indexOfSouthEasternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                                {
                                    indexOfSouthWesternNeighbour = i;
                                }
                            }
                        }
                    }

                    //player near western border
                    if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < gv.playerOffsetX))
                    {
                        seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                            {
                                indexOfWesternNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                                {
                                    indexOfNorthWesternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                                {
                                    indexOfSouthWesternNeighbour = i;
                                }
                            }
                        }
                    }

                    //player near eastern border
                    if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                    {
                        seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                            {
                                indexOfEasternNeighbour = i;
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                                {
                                    indexOfNorthEasternNeighbour = i;
                                }
                            }
                        }

                        if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                        {
                            for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                            {
                                if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                                {
                                    indexOfSouthEasternNeighbour = i;
                                }
                            }
                        }
                    }

                    bool situationFound = false;
                    //int relevantIndex = -1;
                    List<int> relevantIndices = new List<int>();
                    int northernmodifier = 0;
                    int easternmodifier = 0;
                    int westernmodifier = 0;
                    int southernmodifier = 0;

                    //northwest
                    if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthWesternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfNorthWesternNeighbour);
                    }
                    //northeast
                    if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && (indexOfNorthEasternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfNorthEasternNeighbour);
                    }
                    //southwest
                    if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthWesternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfSouthWesternNeighbour);
                    }
                    //southeast
                    if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && (indexOfSouthEasternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfSouthEasternNeighbour);
                    }
                    //north
                    if ((seamlessModififierMinY > 0) && (indexOfNorthernNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfNorthernNeighbour);
                    }
                    //south
                    if ((seamlessModififierMaxY > 0) && (indexOfSouthernNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfSouthernNeighbour);
                    }
                    //west
                    if ((seamlessModififierMinX > 0) && (indexOfWesternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfWesternNeighbour);
                    }
                    //east
                    if ((seamlessModififierMaxX > 0) && (indexOfEasternNeighbour != -1))
                    {
                        situationFound = true;
                        relevantIndices.Add(indexOfEasternNeighbour);
                    }
                    /*
                    //current map
                    if (!situationFound)
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.currentArea.Filename == gv.mod.moduleAreasObjects[i].Filename)
                            {
                                relevantIndex = i;
                            }
                        } 
                    }
                    */

                    //XXXXXXXXXXXXXXXXXXXXXXXX
                    for (int i = 0; i < relevantIndices.Count; i++)
                    {//2

                        int backupLocationX = -1;
                        int backupLocationY = -1;

                        foreach (Prop p in gv.mod.moduleAreasObjects[relevantIndices[i]].Props)
                        {//3
                         //only for on-movers (the movers use drawMovingProps below)
                         //if ((p.isShown) && (!p.isMover) && (p.token != null))
                            bool nonTimeDriven = true;
                            if (p.MoverType == "daily" || p.MoverType == "weekly" || p.MoverType == "monthly" || p.MoverType == "yearly")
                            {
                                nonTimeDriven = false;
                            }
                            int indexOfLoadedTile = -1;
                            if ((p.isShown) && (nonTimeDriven == true))
                            {//hurghkarl

                                //try
                                //{
                                //gv.cc.DisposeOfBitmap(ref p.token);
                                //}
                                //catch { }

                                //p.token = gv.cc.LoadBitmap(p.ImageFileName);

                                try
                                {
                                    //insert1                        
                                    bool tileBitmapIsLoadedAlready = false;
                                    //int indexOfLoadedTile = -1;
                                    for (int j = 0; j < gv.mod.loadedTileBitmapsNames.Count; j++)
                                    {
                                        if ((gv.mod.loadedTileBitmapsNames[j] == p.ImageFileName) && (!gv.mod.loadedTileBitmaps[j].IsDisposed))
                                        {
                                            tileBitmapIsLoadedAlready = true;
                                            indexOfLoadedTile = j;
                                            break;
                                        }
                                    }

                                    //insert2
                                    if (!tileBitmapIsLoadedAlready)
                                    {
                                        gv.mod.loadedTileBitmapsNames.Add(p.ImageFileName);
                                        p.token = gv.cc.LoadBitmap(p.ImageFileName);
                                        gv.mod.loadedTileBitmaps.Add(p.token);
                                        indexOfLoadedTile = gv.mod.loadedTileBitmaps.Count - 1;

                                    }
                                }
                                catch
                                { }



                                backupLocationX = p.LocationX;
                                backupLocationY = p.LocationY;

                                //XXXXXXXXXXXXXXXXXXX
                                situationFound = false;

                                //northwest
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Filename))
                                    //if ((seamlessModififierMinX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                        p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                    }
                                }

                                //northeast
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Filename))

                                    //if ((seamlessModififierMaxX > 0) && (seamlessModififierMinY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                        p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                    }
                                }

                                //southwest
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Filename))

                                    //if ((seamlessModififierMinX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                        p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                    }
                                }

                                //southeast
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Filename))

                                    //if ((seamlessModififierMaxX > 0) && (seamlessModififierMaxY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                        p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                    }
                                }

                                //north
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Filename))

                                    //if ((seamlessModififierMinY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationY = p.LocationY - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeY;

                                    }
                                }

                                //south
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Filename))

                                    //if ((seamlessModififierMaxY > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationY = p.LocationY + gv.mod.currentArea.MapSizeY;

                                    }
                                }

                                //west
                                if (indexOfWesternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Filename))

                                    //if ((seamlessModififierMinX > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX - gv.mod.moduleAreasObjects[relevantIndices[i]].MapSizeX;
                                    }
                                }

                                //east
                                if (indexOfEasternNeighbour != -1)
                                {
                                    if (gv.mod.moduleAreasObjects[relevantIndices[i]].Filename.Contains(gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Filename))

                                    //if ((seamlessModififierMaxX > 0) && !situationFound)
                                    {
                                        situationFound = true;
                                        p.LocationX = p.LocationX + gv.mod.currentArea.MapSizeX;
                                    }
                                }

                                //XXXXXXXXXXXXXXXXXXXXXXXX

                                //distance check
                                if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                    && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                                {//5
                                 //prop X - playerX
                                 //get dst rct based on distance of prop to  palyer
                                    int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                    int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                    int dstW = (int)((((float)gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                    int dstH = (int)((((float)(gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                    int dstXshift = (dstW - gv.squareSize) / 2;
                                    int dstYshift = (dstH - gv.squareSize) / 2;
                                    int framePosition = p.currentFrameNumber;
                                    if (p.inverseAnimationDirection)
                                    {
                                        framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                    }
                                    IbRect src = new IbRect(0, framePosition * p.propFrameHeight, gv.mod.loadedTileBitmaps[indexOfLoadedTile].PixelSize.Width, p.propFrameHeight);
                                    IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                    //adjust size of props
                                    if (gv.mod.currentArea.useSuperTinyProps)
                                    {
                                        dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                    }
                                    else if (gv.mod.currentArea.useMiniProps)
                                    {
                                        dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                                    }

                                    //draw the prop
                                    if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                    {
                                        gv.DrawBitmap(gv.mod.loadedTileBitmaps[indexOfLoadedTile], src, dst, !p.PropFacingLeft, p.opacity);
                                    }

                                    //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                    if (gv.mod.showInteractionState == true)
                                    {//6
                                        if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                        {
                                            Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                            src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                            gv.DrawBitmap(interactionStateIndicator, src, dst);
                                            gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            continue;
                                        }

                                        if (p.unavoidableConversation)
                                        {
                                            Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                            src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                            gv.DrawBitmap(interactionStateIndicator, src, dst);
                                            gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            continue;
                                        }

                                        if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                        {
                                            Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                            src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                            gv.DrawBitmap(interactionStateIndicator, src, dst);
                                            gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                            continue;
                                        }
                                    }//6
                                }//5

                                p.LocationX = backupLocationX;
                                p.LocationY = backupLocationY;

                            }//4
                        }//3


                    }//2

                    //normal prop draw routine
                    foreach (Prop p in gv.mod.currentArea.Props)
                    {//3
                     //only for on-movers (the movers use drawMovingProps below)
                        if ((p.isShown) && (!p.isMover) && (p.token != null))
                        {//4

                            //distance check
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {//5
                             //prop X - playerX
                             //get dst rct based on distance of prop to  palyer
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                //adjust size of props
                                if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                }
                                else if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                                }

                                //draw the prop
                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                //for shwoign whetehr prop is encounte,r optional or mandatory conversation
                                if (gv.mod.showInteractionState == true)
                                {//6
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (p.unavoidableConversation)
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }
                                }//6
                            }//5
                        }//4
                    }//3
                    #endregion
                }
                else //old system
                {
                    #region old system
                    foreach (Prop p in gv.mod.currentArea.Props)
                    {
                        if ((p.isShown) && (!p.isMover))
                        {
                            if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                                && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                            {
                                //prop X - playerX
                                int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                                int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;
                                //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                                int framePosition = p.currentFrameNumber;
                                if (p.inverseAnimationDirection)
                                {
                                    framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                                }
                                IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);

                                if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift, (int)(dstW / 4), (int)(dstH / 4));
                                }
                                else if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift, (int)(dstW / 2), (int)(dstH / 2));
                                }
                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                if (gv.mod.showInteractionState == true)
                                {
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (p.unavoidableConversation)
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
            }
        }

        public void drawMovingProps(float elapsed)
        {
            if (gv.mod.useSmoothMovement == true)
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (!p.isUnderBridge))
                    {
                        if ((p.LocationX + 1 >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX - 1 <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY + 1 >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY - 1 <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            //float xDimension = p.token.PixelSize.Width * p.sizeFactor;
                            //float yDimension = p.propFrameHeight * p.sizeFactor;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            if (p.destinationPixelPositionXList.Count > 0)
                            {
                                if ((p.destinationPixelPositionXList[0] >= (p.currentPixelPositionX - 0)) && (p.destinationPixelPositionXList[0] <= (p.currentPixelPositionX + 0)))
                                {
                                    if (p.destinationPixelPositionYList[0] > p.currentPixelPositionY)
                                    {
                                        p.currentPixelPositionY += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY >= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);

                                        }
                                    }
                                    else
                                    {
                                        p.currentPixelPositionY -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY <= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);
                                        }

                                    }
                                }
                                else if ((p.destinationPixelPositionYList[0] >= (p.currentPixelPositionY - 0)) && (p.destinationPixelPositionYList[0] <= (p.currentPixelPositionY + 0)))
                                {
                                    {
                                        if (p.destinationPixelPositionXList[0] > p.currentPixelPositionX)
                                        {
                                            p.currentPixelPositionX += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX >= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                        else
                                        {
                                            p.currentPixelPositionX -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX <= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                    }
                                }

                            }//end, set dst

                            int playerPositionXInPix = 0;
                            int playerPositionYInPix = 0;

                            if (p.destinationPixelPositionXList.Count <= 0)
                            {
                                p.destinationPixelPositionXList.Clear();
                                p.destinationPixelPositionXList = new List<int>();
                                p.destinationPixelPositionYList.Clear();
                                p.destinationPixelPositionYList = new List<int>();

                                //set the currentPixel position of the props
                                int xOffSetInSquares = p.LocationX - gv.mod.PlayerLocationX;
                                int yOffSetInSquares = p.LocationY - gv.mod.PlayerLocationY;
                                playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                                playerPositionYInPix = gv.playerOffsetY * gv.squareSize;

                                p.currentPixelPositionX = playerPositionXInPix + (xOffSetInSquares * gv.squareSize);
                                p.currentPixelPositionY = playerPositionYInPix + (yOffSetInSquares * gv.squareSize);
                            }


                            playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                            playerPositionYInPix = gv.playerOffsetY * gv.squareSize + gv.oYshift;

                            float floatConvertedToSquareDistanceX = (p.currentPixelPositionX - playerPositionXInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceX = (int)Math.Ceiling(floatConvertedToSquareDistanceX);

                            float floatConvertedToSquareDistanceY = (p.currentPixelPositionY - playerPositionYInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceY = (int)Math.Ceiling(floatConvertedToSquareDistanceY);

                            int SquareThatPixIsOnX = gv.mod.PlayerLocationX + ConvertedToSquareDistanceX;
                            int SquareThatPixIsOnY = gv.mod.PlayerLocationY + ConvertedToSquareDistanceY;

                            int tileNumberOfPropSquare = SquareThatPixIsOnX + (SquareThatPixIsOnY * gv.mod.currentArea.MapSizeX);

                            //cast the pix position to int in order to draw it at nearly exact loc
                            int pixDistanceOfPropToPlayerX = ((int)p.currentPixelPositionX - playerPositionXInPix);
                            if (pixDistanceOfPropToPlayerX < 0)
                            {
                                pixDistanceOfPropToPlayerX *= -1;
                            }
                            int pixDistanceOfPropToPlayerY = ((int)p.currentPixelPositionY - playerPositionYInPix);
                            if (pixDistanceOfPropToPlayerY < 0)
                            {
                                pixDistanceOfPropToPlayerY *= -1;
                            }

                            if ((pixDistanceOfPropToPlayerX <= ((gv.playerOffsetX + 1) * gv.squareSize)) && (pixDistanceOfPropToPlayerY <= ((gv.playerOffsetY + 1) * gv.squareSize)))
                            {
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;


                                //set up idle move code

                                int randXInt = 0;
                                int randYInt = 0;
                                float randX = 0;
                                float randY = 0;
                                int decider = 0;
                                int moveChance = 100;

                                //the lower the number, the sooner and more often it stops
                                int stopIdleChance = (int)(30f * (30f / elapsed));

                                decider = gv.sf.RandInt(stopIdleChance);
                                if ((decider == 1) && (p.inactiveTimer == 0))
                                {
                                    p.inactiveTimer += gv.sf.RandInt(2);
                                }

                                if (p.inactiveTimer != 0)
                                {
                                    int decider2 = gv.sf.RandInt(100);
                                    int waitPeriodIncreaseChance = (int)(50f * (elapsed / 30f));

                                    if (decider2 < waitPeriodIncreaseChance)
                                    {
                                        p.inactiveTimer += gv.sf.RandInt(4);
                                    }
                                }

                                if (p.inactiveTimer > 240)
                                {
                                    p.inactiveTimer = 0;
                                }

                                if ((gv.sf.RandInt(100) <= moveChance) && (p.inactiveTimer == 0))
                                {
                                    randXInt = gv.sf.RandInt(100);
                                    randX = ((randXInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = -1 * randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = true;
                                            p.straightLineDistanceX = 0;
                                        }

                                    }
                                    else if (p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = false;
                                            p.straightLineDistanceX = 0;
                                        }
                                    }

                                    randYInt = gv.sf.RandInt(100);
                                    randY = ((randYInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = -1 * randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = true;
                                            p.straightLineDistanceY = 0;
                                        }

                                    }
                                    else if (p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = false;
                                            p.straightLineDistanceY = 0;
                                        }
                                    }

                                    p.roamDistanceX += (randX * 7f / 10f);
                                    p.roamDistanceY += (randY * 7f / 10f);
                                }


                                IbRect dst = new IbRect((int)p.currentPixelPositionX - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY - dstYshift + (int)p.roamDistanceY, dstW, dstH);

                                if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY, (int)(dstW / 4), (int)(dstH / 4));
                                }
                                else if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift + (int)p.roamDistanceY, (int)(dstW / 2), (int)(dstH / 2));
                                }

                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                if (gv.mod.showInteractionState == true)
                                {
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (p.unavoidableConversation)
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }
                                }
                            }

                        }
                    }
                }
                for (int i = 0; i < gv.mod.currentArea.Tiles.Count; i++)
                {

                    float floatPositionY = i / gv.mod.currentArea.MapSizeX;
                    int positionY = (int)Math.Floor(floatPositionY);
                    int positionX = i % gv.mod.currentArea.MapSizeY;
                    int dist = 0;
                    int deltaX = (int)Math.Abs((positionX - gv.mod.PlayerLocationX));
                    int deltaY = (int)Math.Abs((positionY - gv.mod.PlayerLocationY));
                    if (deltaX > deltaY)
                    {
                        dist = deltaX;
                    }
                    else
                    {
                        dist = deltaY;
                    }
                    if ((dist == (gv.playerOffsetX + 1)) || (dist == (gv.playerOffsetX + 2)))
                    {
                        int squareInPixelsX = ((positionX - gv.mod.PlayerLocationX) * gv.squareSize) + gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                        int squareInPixelsY = ((positionY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                        IbRect src2 = new IbRect(0, 0, gv.squareSize, gv.squareSize);
                        IbRect dst2 = new IbRect(squareInPixelsX, squareInPixelsY, gv.squareSize, gv.squareSize);
                        //NOT USEDgv.DrawBitmap(gv.cc.black_tile, src2, dst2);
                    }
                }

            }
            else
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (!p.isUnderBridge))
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (p.unavoidableConversation)
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }
                            }
                        }
                    }
                }
            }
        }

        public void drawMovingPropsUnderBridge(float elapsed)
        {
            foreach (Prop p in gv.mod.currentArea.Props)
            {
                if ((p.isShown) && (p.isMover))
                {
                    if ((p.LocationX == 2) && (p.LocationY == 3))
                    {
                        int i = 0;
                    }

                    if (gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isEWBridge || gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].isNSBridge)
                    {
                        if (gv.mod.currentArea.Tiles[p.lastLocationY * gv.mod.currentArea.MapSizeX + p.lastLocationX].heightLevel + 1 == gv.mod.currentArea.Tiles[p.LocationY * gv.mod.currentArea.MapSizeX + p.LocationX].heightLevel)
                        {
                            p.isUnderBridge = true;
                        }
                        else
                        {
                            p.isUnderBridge = false;
                        }
                    }
                    else
                    {
                        p.isUnderBridge = false;
                    }
                }
            }

            if (gv.mod.useSmoothMovement == true)
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (p.isUnderBridge))
                    {
                        if ((p.LocationX + 1 >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX - 1 <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY + 1 >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY - 1 <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            //float xDimension = p.token.PixelSize.Width * p.sizeFactor;
                            //float yDimension = p.propFrameHeight * p.sizeFactor;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            if (p.destinationPixelPositionXList.Count > 0)
                            {
                                if ((p.destinationPixelPositionXList[0] >= (p.currentPixelPositionX - 0)) && (p.destinationPixelPositionXList[0] <= (p.currentPixelPositionX + 0)))
                                {
                                    if (p.destinationPixelPositionYList[0] > p.currentPixelPositionY)
                                    {
                                        p.currentPixelPositionY += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY >= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);

                                        }
                                    }
                                    else
                                    {
                                        p.currentPixelPositionY -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                        if (p.currentPixelPositionY <= p.destinationPixelPositionYList[0])
                                        {
                                            p.currentPixelPositionY = p.destinationPixelPositionYList[0];
                                            p.destinationPixelPositionYList.RemoveAt(0);
                                            p.destinationPixelPositionXList.RemoveAt(0);
                                        }

                                    }
                                }
                                else if ((p.destinationPixelPositionYList[0] >= (p.currentPixelPositionY - 0)) && (p.destinationPixelPositionYList[0] <= (p.currentPixelPositionY + 0)))
                                {
                                    {
                                        if (p.destinationPixelPositionXList[0] > p.currentPixelPositionX)
                                        {
                                            p.currentPixelPositionX += (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX >= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                        else
                                        {
                                            p.currentPixelPositionX -= (gv.floatPixMovedPerTick * p.pixelMoveSpeed);
                                            if (p.currentPixelPositionX <= p.destinationPixelPositionXList[0])
                                            {
                                                p.currentPixelPositionX = p.destinationPixelPositionXList[0];
                                                p.destinationPixelPositionXList.RemoveAt(0);
                                                p.destinationPixelPositionYList.RemoveAt(0);
                                            }
                                        }
                                    }
                                }

                            }//end, set dst

                            int playerPositionXInPix = 0;
                            int playerPositionYInPix = 0;

                            if (p.destinationPixelPositionXList.Count <= 0)
                            {
                                p.destinationPixelPositionXList.Clear();
                                p.destinationPixelPositionXList = new List<int>();
                                p.destinationPixelPositionYList.Clear();
                                p.destinationPixelPositionYList = new List<int>();

                                //set the currentPixel position of the props
                                int xOffSetInSquares = p.LocationX - gv.mod.PlayerLocationX;
                                int yOffSetInSquares = p.LocationY - gv.mod.PlayerLocationY;
                                playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                                playerPositionYInPix = gv.playerOffsetY * gv.squareSize;

                                p.currentPixelPositionX = playerPositionXInPix + (xOffSetInSquares * gv.squareSize);
                                p.currentPixelPositionY = playerPositionYInPix + (yOffSetInSquares * gv.squareSize);
                            }


                            playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                            playerPositionYInPix = gv.playerOffsetY * gv.squareSize + gv.oYshift;

                            float floatConvertedToSquareDistanceX = (p.currentPixelPositionX - playerPositionXInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceX = (int)Math.Ceiling(floatConvertedToSquareDistanceX);

                            float floatConvertedToSquareDistanceY = (p.currentPixelPositionY - playerPositionYInPix) / gv.squareSize;
                            int ConvertedToSquareDistanceY = (int)Math.Ceiling(floatConvertedToSquareDistanceY);

                            int SquareThatPixIsOnX = gv.mod.PlayerLocationX + ConvertedToSquareDistanceX;
                            int SquareThatPixIsOnY = gv.mod.PlayerLocationY + ConvertedToSquareDistanceY;

                            int tileNumberOfPropSquare = SquareThatPixIsOnX + (SquareThatPixIsOnY * gv.mod.currentArea.MapSizeX);

                            //cast the pix position to int in order to draw it at nearly exact loc
                            int pixDistanceOfPropToPlayerX = ((int)p.currentPixelPositionX - playerPositionXInPix);
                            if (pixDistanceOfPropToPlayerX < 0)
                            {
                                pixDistanceOfPropToPlayerX *= -1;
                            }
                            int pixDistanceOfPropToPlayerY = ((int)p.currentPixelPositionY - playerPositionYInPix);
                            if (pixDistanceOfPropToPlayerY < 0)
                            {
                                pixDistanceOfPropToPlayerY *= -1;
                            }

                            if ((pixDistanceOfPropToPlayerX <= ((gv.playerOffsetX + 1) * gv.squareSize)) && (pixDistanceOfPropToPlayerY <= ((gv.playerOffsetY + 1) * gv.squareSize)))
                            {
                                int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                                int dstXshift = (dstW - gv.squareSize) / 2;
                                int dstYshift = (dstH - gv.squareSize) / 2;


                                //set up idle move code

                                int randXInt = 0;
                                int randYInt = 0;
                                float randX = 0;
                                float randY = 0;
                                int decider = 0;
                                int moveChance = 100;

                                //the lower the number, the sooner and more often it stops
                                int stopIdleChance = (int)(30f * (30f / elapsed));

                                decider = gv.sf.RandInt(stopIdleChance);
                                if ((decider == 1) && (p.inactiveTimer == 0))
                                {
                                    p.inactiveTimer += gv.sf.RandInt(2);
                                }

                                if (p.inactiveTimer != 0)
                                {
                                    int decider2 = gv.sf.RandInt(100);
                                    int waitPeriodIncreaseChance = (int)(50f * (elapsed / 30f));

                                    if (decider2 < waitPeriodIncreaseChance)
                                    {
                                        p.inactiveTimer += gv.sf.RandInt(4);
                                    }
                                }

                                if (p.inactiveTimer > 240)
                                {
                                    p.inactiveTimer = 0;
                                }

                                if ((gv.sf.RandInt(100) <= moveChance) && (p.inactiveTimer == 0))
                                {
                                    randXInt = gv.sf.RandInt(100);
                                    randX = ((randXInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = -1 * randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = true;
                                            p.straightLineDistanceX = 0;
                                        }

                                    }
                                    else if (p.goRight)
                                    {
                                        p.straightLineDistanceX += randX;
                                        randX = randX;
                                        if (p.straightLineDistanceX >= 1.5f * gv.pS)
                                        {
                                            p.goRight = false;
                                            p.straightLineDistanceX = 0;
                                        }
                                    }

                                    randYInt = gv.sf.RandInt(100);
                                    randY = ((randYInt + 75) / 250f * (elapsed / 30f));
                                    if (!p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = -1 * randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = true;
                                            p.straightLineDistanceY = 0;
                                        }

                                    }
                                    else if (p.goDown)
                                    {
                                        p.straightLineDistanceY += randY;
                                        randY = randY;
                                        if (p.straightLineDistanceY >= 1.5 * gv.pS)
                                        {
                                            p.goDown = false;
                                            p.straightLineDistanceY = 0;
                                        }
                                    }

                                    p.roamDistanceX += (randX * 7f / 10f);
                                    p.roamDistanceY += (randY * 7f / 10f);
                                }


                                IbRect dst = new IbRect((int)p.currentPixelPositionX - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY - dstYshift + (int)p.roamDistanceY, dstW, dstH);

                                if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize * 3 / 8) - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY + (int)(gv.squareSize * 3 / 8) - dstYshift + +(int)p.roamDistanceY, (int)(dstW / 4), (int)(dstH / 4));
                                }
                                else if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst = new IbRect((int)p.currentPixelPositionX + (int)(gv.squareSize / 4) - dstXshift + (int)p.roamDistanceX, (int)p.currentPixelPositionY + (int)(gv.squareSize / 4) - dstYshift + (int)p.roamDistanceY, (int)(dstW / 2), (int)(dstH / 2));
                                }

                                if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                                {
                                    gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                                }

                                if (gv.mod.showInteractionState == true)
                                {
                                    if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (p.unavoidableConversation)
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }

                                    if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                    {
                                        Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                        src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                        gv.DrawBitmap(interactionStateIndicator, src, dst);
                                        gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                        continue;
                                    }
                                }
                            }

                        }
                    }
                }
                for (int i = 0; i < gv.mod.currentArea.Tiles.Count; i++)
                {

                    float floatPositionY = i / gv.mod.currentArea.MapSizeX;
                    int positionY = (int)Math.Floor(floatPositionY);
                    int positionX = i % gv.mod.currentArea.MapSizeY;
                    int dist = 0;
                    int deltaX = (int)Math.Abs((positionX - gv.mod.PlayerLocationX));
                    int deltaY = (int)Math.Abs((positionY - gv.mod.PlayerLocationY));
                    if (deltaX > deltaY)
                    {
                        dist = deltaX;
                    }
                    else
                    {
                        dist = deltaY;
                    }
                    if ((dist == (gv.playerOffsetX + 1)) || (dist == (gv.playerOffsetX + 2)))
                    {
                        int squareInPixelsX = ((positionX - gv.mod.PlayerLocationX) * gv.squareSize) + gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                        int squareInPixelsY = ((positionY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                        IbRect src2 = new IbRect(0, 0, gv.squareSize, gv.squareSize);
                        IbRect dst2 = new IbRect(squareInPixelsX, squareInPixelsY, gv.squareSize, gv.squareSize);
                        //NOT USEDgv.DrawBitmap(gv.cc.black_tile, src2, dst2);
                    }
                }

            }
            else
            {
                foreach (Prop p in gv.mod.currentArea.Props)
                {
                    if ((p.isShown) && (p.isMover) && (p.isUnderBridge))
                    {
                        if ((p.LocationX >= gv.mod.PlayerLocationX - gv.playerOffsetX) && (p.LocationX <= gv.mod.PlayerLocationX + gv.playerOffsetX)
                            && (p.LocationY >= gv.mod.PlayerLocationY - gv.playerOffsetY) && (p.LocationY <= gv.mod.PlayerLocationY + gv.playerOffsetY))
                        {
                            //prop X - playerX
                            int x = ((p.LocationX - gv.mod.PlayerLocationX) * gv.squareSize) + (gv.playerOffsetX * gv.squareSize);
                            int y = ((p.LocationY - gv.mod.PlayerLocationY) * gv.squareSize) + (gv.playerOffsetY * gv.squareSize);
                            int dstW = (int)((((float)p.token.PixelSize.Width / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstH = (int)((((float)(p.token.PixelSize.Height / p.maxNumberOfFrames) / (float)gv.squareSizeInPixels) * (float)gv.squareSize) * (p.sizeFactor / 100f));
                            int dstXshift = (dstW - gv.squareSize) / 2;
                            int dstYshift = (dstH - gv.squareSize) / 2;
                            int framePosition = p.currentFrameNumber;
                            if (p.inverseAnimationDirection)
                            {
                                framePosition = (p.maxNumberOfFrames - 1) - p.currentFrameNumber;
                            }
                            IbRect src = new IbRect(0, framePosition * p.propFrameHeight, p.token.PixelSize.Width, p.propFrameHeight);
                            //IbRect src = new IbRect(0, 0, p.token.PixelSize.Width, p.token.PixelSize.Width);
                            IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels - dstXshift, y - dstYshift, dstW, dstH);
                            if ((p.maxNumberOfFrames == 1) || (p.drawAnimatedProp))
                            {
                                gv.DrawBitmap(p.token, src, dst, !p.PropFacingLeft, p.opacity);
                            }

                            if (gv.mod.showInteractionState)
                            {
                                if (!p.EncounterWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("encounter_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (p.unavoidableConversation)
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("mandatory_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }

                                if (!p.ConversationWhenOnPartySquare.Equals("none"))
                                {
                                    Bitmap interactionStateIndicator = gv.cc.LoadBitmap("optional_conversation_indicator");
                                    src = new IbRect(0, 0, interactionStateIndicator.PixelSize.Width, interactionStateIndicator.PixelSize.Height);
                                    gv.DrawBitmap(interactionStateIndicator, src, dst);
                                    gv.cc.DisposeOfBitmap(ref interactionStateIndicator);
                                    continue;
                                }
                            }
                        }
                    }
                }
            }
        }

        public void drawMiniMap()
        {
            if (showMiniMap)
            {
                int pW = (int)((float)gv.screenWidth / 100.0f);
                int pH = (int)((float)gv.screenHeight / 100.0f);
                int shift = pW;

                //minimap should be 4 squares wide
                int minimapSquareSizeInPixels = 4 * gv.squareSize / gv.mod.currentArea.MapSizeX;
                int drawW = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeX;
                int drawH = minimapSquareSizeInPixels * gv.mod.currentArea.MapSizeY;

                /*TODO
                    //draw a dark border
                    Paint pnt = new Paint();
                    pnt.setColor(Color.DKGRAY);
                    pnt.setStrokeWidth(pW * 2);
                    pnt.setStyle(Paint.Style.STROKE);	
                    canvas.drawRect(new Rect(gv.oXshift, pH, gv.oXshift + drawW + pW, pH + drawH + pW), pnt);
                */
                //draw minimap
                if (minimap == null) { resetMiniMapBitmap(); }
                IbRect src = new IbRect(0, 0, minimap.PixelSize.Width, minimap.PixelSize.Height);
                IbRect dst = new IbRect(pW, pH, drawW, drawH);
                gv.DrawBitmap(minimap, src, dst);

                //draw Fog of War
                if (gv.mod.currentArea.UseMiniMapFogOfWar)
                {
                    for (int x = 0; x < this.gv.mod.currentArea.MapSizeX; x++)
                    {
                        for (int y = 0; y < this.gv.mod.currentArea.MapSizeY; y++)
                        {
                            int xx = x * minimapSquareSizeInPixels;
                            int yy = y * minimapSquareSizeInPixels;
                            src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                            dst = new IbRect(pW + xx, pH + yy, minimapSquareSizeInPixels, minimapSquareSizeInPixels);
                            if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Visible)
                            {
                                gv.DrawBitmap(gv.cc.black_tile, src, dst);
                            }
                        }
                    }
                }

                //draw a location marker square RED
                int x2 = gv.mod.PlayerLocationX * minimapSquareSizeInPixels;
                int y2 = gv.mod.PlayerLocationY * minimapSquareSizeInPixels;
                src = new IbRect(0, 0, gv.cc.pc_dead.PixelSize.Width, gv.cc.pc_dead.PixelSize.Height);
                dst = new IbRect(pW + x2, pH + y2, minimapSquareSizeInPixels, minimapSquareSizeInPixels);
                gv.DrawBitmap(gv.cc.pc_dead, src, dst);
            }
        }

        public void drawPlayer()
        {
            if (!gv.mod.currentArea.PlayerIsUnderBridge)
            {
                if (gv.mod.selectedPartyLeader >= gv.mod.playerList.Count)
                {
                    gv.mod.selectedPartyLeader = 0;
                }
                int x = gv.playerOffsetX * gv.squareSize;
                int y = gv.playerOffsetY * gv.squareSize;
                int shift = gv.squareSize / 3;
                if (gv.mod.currentArea.useMiniProps)
                {
                    shift = (int)shift / 2;
                }
                else if (gv.mod.currentArea.useSuperTinyProps)
                {
                    shift = (int)shift / 4;
                }
                IbRect src = new IbRect(0, 0, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width, gv.mod.playerList[gv.mod.selectedPartyLeader].token.PixelSize.Width);
                IbRect dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                if (gv.mod.showPartyToken)
                {

                    if (gv.mod.currentArea.useMiniProps)
                    {
                        dst.Top += (int)(gv.squareSize * 1 / 8);
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                        {
                            dst.Left += (int)(gv.squareSize / 4);
                        }
                        else
                        {
                            dst.Left -= (int)(gv.squareSize / 4);
                        }
                        dst.Height -= (int)(dst.Height / 2);
                        dst.Width -= (int)(dst.Width / 2);
                    }
                    else if (gv.mod.currentArea.useSuperTinyProps)
                    {
                        dst.Top += (int)(gv.squareSize * 1 / 8);
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                        {
                            dst.Left += (int)(gv.squareSize * 3 / 8);
                        }
                        else
                        {
                            dst.Left -= (int)(gv.squareSize * 3 / 8);
                        }
                        dst.Height -= (int)(dst.Height * 3 / 4);
                        dst.Width -= (int)(dst.Width * 3 / 4);
                    }

                    gv.DrawBitmap(gv.mod.partyTokenBitmap, src, dst, !gv.mod.playerList[0].combatFacingLeft);
                }
                else
                {
                    if ((showFullParty) && (gv.mod.playerList.Count > 1))
                    {
                        if (gv.mod.playerList[0].combatFacingLeft == true)
                        {
                            gv.oXshift = gv.oXshift + shift / 2;
                            shift = shift / 4 * 3;
                        }
                        else
                        {
                            shift = shift / 4 * 3;
                        }
                        int reducedSquareSize = gv.squareSize * 2 / 3;
                        for (int i = gv.mod.playerList.Count - 1; i >= 0; i--)
                        {
                            if ((i == 0) && (i != gv.mod.selectedPartyLeader))
                            {

                                if (gv.mod.playerList[0].combatFacingLeft == false)
                                {
                                    dst = new IbRect(x + gv.oXshift + (5 * shift / 2) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                //dst = new IbRect(x + gv.oXshift + shift + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);

                                if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize / 4);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                                        dst.Left += gv.squareSize * 2 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height / 2);
                                    dst.Width -= (int)(dst.Width / 2);
                                }
                                else if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize * 3 / 8);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                                        dst.Left += gv.squareSize * 3 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height * 3 / 4);
                                    dst.Width -= (int)(dst.Width * 3 / 4);
                                }

                                gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                            }
                            if ((i == 1) && (i != gv.mod.selectedPartyLeader))
                            {
                                dst = new IbRect(x + gv.oXshift - shift + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);

                                if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize / 4);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                                        dst.Left += gv.squareSize * 2 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height / 2);
                                    dst.Width -= (int)(dst.Width / 2);
                                }

                                else if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize * 3 / 8);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                                        dst.Left += gv.squareSize * 3 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height * 3 / 4);
                                    dst.Width -= (int)(dst.Width * 3 / 4);
                                }

                                gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                            }
                            if ((i == 2) && (i != gv.mod.selectedPartyLeader))
                            {
                                if (gv.mod.selectedPartyLeader == 0)
                                {
                                    if (gv.mod.playerList[0].combatFacingLeft == false)
                                    {
                                        dst = new IbRect(x + gv.oXshift + (5 * shift / 2) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                    }
                                    else
                                    {
                                        dst = new IbRect(x + gv.oXshift + (shift) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                    }
                                }
                                else if (gv.mod.selectedPartyLeader == 1)
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }

                                if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize / 4);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                                        dst.Left += gv.squareSize * 2 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height / 2);
                                    dst.Width -= (int)(dst.Width / 2);
                                }
                                else if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize * 3 / 8);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                                        dst.Left += gv.squareSize * 3 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height * 3 / 4);
                                    dst.Width -= (int)(dst.Width * 3 / 4);
                                }

                                gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                            }
                            if ((i == 3) && (i != gv.mod.selectedPartyLeader))
                            {

                                if (gv.mod.selectedPartyLeader == 0)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 1)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 2)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 125 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }

                                if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize / 4);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                                        dst.Left += gv.squareSize * 2 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height / 2);
                                    dst.Width -= (int)(dst.Width / 2);
                                }
                                else if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize * 3 / 8);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                                        dst.Left += gv.squareSize * 3 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height * 3 / 4);
                                    dst.Width -= (int)(dst.Width * 3 / 4);
                                }

                                gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                            }
                            if ((i == 4) && (i != gv.mod.selectedPartyLeader))
                            {
                                if (gv.mod.selectedPartyLeader == 0)
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 1)
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 2)
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 3)
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 175 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }

                                if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize / 4);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                                        dst.Left += gv.squareSize * 2 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height / 2);
                                    dst.Width -= (int)(dst.Width / 2);
                                }
                                else if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize * 3 / 8);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                                        dst.Left += gv.squareSize * 3 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height * 3 / 4);
                                    dst.Width -= (int)(dst.Width * 3 / 4);
                                }

                                gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                            }

                            if ((i == 5) && (i != gv.mod.selectedPartyLeader))
                            {
                                if (gv.mod.selectedPartyLeader == 0)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 250 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 1)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 2)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 3)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else if (gv.mod.selectedPartyLeader == 4)
                                {
                                    dst = new IbRect(x + gv.oXshift + (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }
                                else
                                {
                                    dst = new IbRect(x + gv.oXshift - (shift * 50 / 100) + mapStartLocXinPixels, y + reducedSquareSize * 47 / 100, reducedSquareSize, reducedSquareSize);
                                }

                                if (gv.mod.currentArea.useMiniProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize / 4);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                                        dst.Left += gv.squareSize * 2 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height / 2);
                                    dst.Width -= (int)(dst.Width / 2);
                                }
                                else if (gv.mod.currentArea.useSuperTinyProps)
                                {
                                    dst.Top += (int)(gv.squareSize * 1 / 8);
                                    if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                                    {
                                        dst.Left += (int)(gv.squareSize * 3 / 8);
                                    }
                                    else
                                    {
                                        dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                                        dst.Left += gv.squareSize * 3 / 4;
                                    }
                                    dst.Height -= (int)(dst.Height * 3 / 4);
                                    dst.Width -= (int)(dst.Width * 3 / 4);
                                }

                                gv.DrawBitmap(gv.mod.playerList[i].token, src, dst, !gv.mod.playerList[i].combatFacingLeft);
                            }
                        }

                        if (gv.mod.playerList[0].combatFacingLeft == true)
                        {
                            shift = gv.squareSize / 3;
                            if (gv.mod.currentArea.useMiniProps)
                            {
                                shift = (int)shift / 2;
                            }
                            else if (gv.mod.currentArea.useSuperTinyProps)
                            {
                                shift = (int)shift / 4;
                            }
                            gv.oXshift = gv.oXshift - shift / 2;
                        }
                        else
                        {
                            //gv.oXshift = gv.oXshift + shift / 2;
                        }
                    }
                    //always draw party leader on top
                    int storeShift = shift;
                    shift = 0;
                    if (gv.mod.selectedPartyLeader == 0)
                    {
                        if (showFullParty)
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                        else
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                    }
                    else if (gv.mod.selectedPartyLeader == 1)
                    {
                        if (showFullParty)
                        {
                            dst = new IbRect(x + gv.oXshift + shift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                        else
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                    }
                    else if (gv.mod.selectedPartyLeader == 2)
                    {
                        if (showFullParty)
                        {
                            dst = new IbRect(x + gv.oXshift - shift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                        else
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                    }
                    else if (gv.mod.selectedPartyLeader == 3)
                    {
                        if (showFullParty)
                        {
                            dst = new IbRect(x + gv.oXshift + (shift * 2) + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                        else
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                    }
                    else if (gv.mod.selectedPartyLeader == 4)
                    {
                        if (showFullParty)
                        {
                            dst = new IbRect(x + gv.oXshift - (shift * 2) + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                        else
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                    }
                    else if (gv.mod.selectedPartyLeader == 5)
                    {
                        if (showFullParty)
                        {
                            dst = new IbRect(x + gv.oXshift - (shift * 3) + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                        else
                        {
                            dst = new IbRect(x + gv.oXshift + mapStartLocXinPixels, y, gv.squareSize, gv.squareSize);
                        }
                    }

                    if (gv.mod.currentArea.useMiniProps)
                    {
                        dst.Top += (int)(gv.squareSize / 4);
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                        {
                            dst.Left += (int)(gv.squareSize / 4);
                        }
                        else
                        {
                            dst.Left -= (int)(gv.squareSize / 4 * 100 / 100);
                            dst.Left += gv.squareSize * 2 / 4;
                        }
                        dst.Height -= (int)(dst.Height / 2);
                        dst.Width -= (int)(dst.Width / 2);
                    }
                    else if (gv.mod.currentArea.useSuperTinyProps)
                    {
                        dst.Top += (int)(gv.squareSize * 3 / 8);
                        if (gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft == true)
                        {
                            dst.Left += (int)(gv.squareSize * 3 / 8);
                        }
                        else
                        {
                            dst.Left -= (int)(gv.squareSize * 3 / 8 * 100 / 100);
                            dst.Left += gv.squareSize * 3 / 4;
                        }
                        dst.Height -= (int)(dst.Height * 3 / 4);
                        dst.Width -= (int)(dst.Width * 3 / 4);
                    }
                    gv.DrawBitmap(gv.mod.playerList[gv.mod.selectedPartyLeader].token, src, dst, !gv.mod.playerList[gv.mod.selectedPartyLeader].combatFacingLeft);
                    shift = storeShift;
                }
            }
        }

        public void drawGrid()
        {
            int minX = gv.mod.PlayerLocationX - gv.playerOffsetX;
            if (minX < 0) { minX = 0; }
            int minY = gv.mod.PlayerLocationY - gv.playerOffsetY;
            if (minY < 0) { minY = 0; }

            int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
            if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
            int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
            if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

            for (int x = minX; x < maxX; x++)
            {
                for (int y = minY; y < maxY; y++)
                {
                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.walkBlocked.PixelSize.Width, gv.cc.walkBlocked.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                    if (gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                    {
                        gv.DrawBitmap(gv.cc.losBlocked, src, dst);
                    }
                    if (gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Walkable != true)
                    {
                        gv.DrawBitmap(gv.cc.walkBlocked, src, dst);
                    }
                    else
                    {
                        gv.DrawBitmap(gv.cc.walkPass, src, dst);
                    }
                }
            }
        }
    
        public void drawMainMapFloatyText()
        {
            int txtH = (int)gv.drawFontRegHeight;

            for (int x = -2; x <= 2; x++)
            {
                for (int y = -2; y <= 2; y++)
                {
                    gv.DrawText(gv.cc.floatyText, new IbRect(gv.cc.floatyTextLoc.X + x + gv.oXshift + mapStartLocXinPixels, gv.cc.floatyTextLoc.Y + y + txtH, gv.squareSize * 2, 1000), 0.8f, Color.Black);
                }
            }
            
            gv.DrawText(gv.cc.floatyText, new IbRect(gv.cc.floatyTextLoc.X + gv.oXshift + mapStartLocXinPixels, gv.cc.floatyTextLoc.Y + txtH, gv.squareSize * 2, 1000), 0.8f, Color.White);
        }
        public void drawOverlayTints()
        {
            IbRect src = new IbRect(0, 0, gv.cc.tint_sunset.PixelSize.Width, gv.cc.tint_sunset.PixelSize.Height);
            //IbRect dst = new IbRect(gv.oXshift + mapStartLocXinPixels, 0, (gv.squareSize * (gv.playerOffsetX * 2 + 1)), (gv.squareSize * (gv.playerOffsetY * 2 + 2)));
            IbRect dst = new IbRect(mapStartLocXinPixels-gv.oXshift, -gv.oYshift, (gv.squareSize * (gv.playerOffsetX * 2 + 1))+ 2*gv.oXshift + gv.pS, (gv.squareSize * (gv.playerOffsetY * 2 + 2)) + gv.pS);

            int dawn = 5 * 60;
            int sunrise = 6 * 60;
            int day = 7 * 60;
            int sunset = 17 * 60;
            int dusk = 18 * 60;
            int night = 20 * 60;
            int time = gv.mod.WorldTime % 1440;
            if ((time >= dawn) && (time < sunrise))
            {
                gv.DrawBitmap(gv.cc.tint_dawn, src, dst);
            }
            else if ((time >= sunrise) && (time < day))
            {
                gv.DrawBitmap(gv.cc.tint_sunrise, src, dst);
            }
            else if ((time >= day) && (time < sunset))
            {
                //no tint for day
            }
            else if ((time >= sunset) && (time < dusk))
            {
                gv.DrawBitmap(gv.cc.tint_sunset, src, dst);
            }
            else if ((time >= dusk) && (time < night))
            {
                gv.DrawBitmap(gv.cc.tint_dusk, src, dst);
            }
            else if ((time >= night) || (time < dawn))
            {
                gv.DrawBitmap(gv.cc.tint_night, src, dst, false, 0.75f);
            }

        }
        public void drawSprites()
        {
           if (gv.mod.currentArea.areaWeatherName != "" && gv.mod.currentArea.areaWeatherName != "none")
           {
           //hurgh1000
           //gv.cc.addLogText("lime", gv.mod.currentArea.areaWeatherName.ToString());

            foreach (Sprite spr in spriteList)
                {
                    if (spr.movementMethod.Contains("rain") || spr.movementMethod.Contains("snow") || spr.movementMethod.Contains("sandStorm"))
                    {
                        spr.Draw(gv);
                    }
                }


                foreach (Sprite spr in spriteList)
                {
                    if (spr.movementMethod.Contains("lightning") || spr.movementMethod.Contains("fog") || spr.movementMethod.Contains("clouds"))
                    {
                        spr.Draw(gv);
                    }
                }
            }

            foreach (Sprite spr in spriteList)
            {
                if (!spr.movementMethod.Contains("lightning") && !spr.movementMethod.Contains("fog") && !spr.movementMethod.Contains("clouds") &&!spr.movementMethod.Contains("rain") && !spr.movementMethod.Contains("snow") && !spr.movementMethod.Contains("sandStorm"))
                {
                    spr.Draw(gv);
                }
            }

            drawBlackTilesOverTints();
        }
        //not used for now; later :-)
        /*public void drawOverlayWeather()
        {
            //memo to self: in second step do animation by drawing two partial rectangles of same source that change size with time, upper and lower rect, and cast to same target dst, but shifted
            //the source picture must be identical top and bottom lines, other wise we will see a clear dividing line
            //idea that one source bitmap can be used all itself to simulate scrolling down if called in shifting chunks
            //part that scrolls out of lower screen border appears again at top screen border
            //second memo to self: in game settings implement several speed settings for animation speed (pixel move per call multiplier) so that players can adjust prop anim and weatehr anim speed themselves
            //third memo to self: descripe current weather type next to current time in the game ui
            IbRect src = new IbRect(0, 0, gv.cc.tint_rain.PixelSize.Width, gv.cc.tint_rain.PixelSize.Height);
            IbRect dst = new IbRect(gv.oXshift + mapStartLocXinPixels, 0, (gv.squareSize * 9), (gv.squareSize * 9));
            int dawn = 5 * 60;
            int sunrise = 6 * 60;
            int day = 7 * 60;
            int sunset = 17 * 60;
            int dusk = 18 * 60;
            int night = 20 * 60;
            int time = gv.mod.WorldTime % 1440;
            if ((time >= dawn) && (time < sunrise))
            {
                gv.DrawBitmap(gv.cc.tint_dawn, src, dst);
            }
            else if ((time >= sunrise) && (time < day))
            {
                gv.DrawBitmap(gv.cc.tint_sunrise, src, dst);
            }
            else if ((time >= day) && (time < sunset))
            {
                //no tint for day
            }
            else if ((time >= sunset) && (time < dusk))
            {
                gv.DrawBitmap(gv.cc.tint_sunset, src, dst);
            }
            else if ((time >= dusk) && (time < night))
            {
                gv.DrawBitmap(gv.cc.tint_dusk, src, dst);
            }
            else if ((time >= night) || (time < dawn))
            {
                gv.DrawBitmap(gv.cc.tint_night, src, dst);
            }

        }*/
        
        public void drawMainMapClockText()
        {
            int timeofday = gv.mod.WorldTime % (24 * 60);
            int hour = timeofday / 60;
            int minute = timeofday % 60;
            string sMinute = minute + "";
            if (minute < 10)
            {
                sMinute = "0" + minute;
            }

            int txtH = (int)gv.drawFontRegHeight;

            //assuming 28 days in 12 Months, ie 336 days a year
            //notation example: 13:17, Tuesday, 9th of March 1213

            /*
            public string weekDayNameToDisplay = "";
            public string monthDayCounterNumberToDisplay = "";
            public string monthDayCounterAddendumToDisplay = "";
            public string monthNameToDisplay = "";
            */



            if (gv.mod.useMinimalisticUI)
            {
                for (int x = -2; x <= 2; x++)
                {
                    for (int y = -2; y <= 2; y++)
                    {
                        if (gv.mod.partyLightOn)
                        {
                            gv.DrawText(hour + ":" + sMinute +", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 600, 100), 1.0f, Color.Black);
                            if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                            {
                                if (gv.mod.useRationSystem)
                                {
                                    gv.DrawText(gv.mod.currentArea.inGameAreaName + ", " + "Rations(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                                else 
                                {
                                    gv.DrawText(gv.mod.currentArea.inGameAreaName + ", " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                            }
                            else
                            {
                                if (gv.mod.useRationSystem)
                                {
                                    gv.DrawText("Rations(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                                else 
                                {
                                    gv.DrawText(gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                            }
                            //gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 600, 100), 1.0f, Color.Black);
                        }
                        else
                        {
                            gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 600, 100), 1.0f, Color.Black);
                            if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                            {
                                if (gv.mod.useRationSystem)
                                {
                                    gv.DrawText(gv.mod.currentArea.inGameAreaName + ", " + "Rations(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                                else 
                                {
                                    gv.DrawText(gv.mod.currentArea.inGameAreaName, new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                            }
                            else
                            {
                                if (gv.mod.useRationSystem)
                                {
                                    gv.DrawText("Rations(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                                else 
                                {
                                    //gv.DrawText("Rations(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + x + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + y + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.Black);
                                }
                            }
                        }
                    }
                }
                if (gv.mod.partyLightOn)
                {
                    gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);
                    if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                    {
                        if (gv.mod.useRationSystem)
                        {
                            gv.DrawText(gv.mod.currentArea.inGameAreaName + ", " + "Rations(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);
                        }
                        else 
                        {
                            gv.DrawText(gv.mod.currentArea.inGameAreaName + ", " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);

                        }

                    }
                    else
                    {
                        if (gv.mod.useRationSystem)
                        {
                            gv.DrawText("Rations(" + gv.mod.numberOfRationsRemaining.ToString() + "), " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);
                        }
                        else 
                        {
                            gv.DrawText(gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5 * gv.pS), 600, 100), 1.0f, Color.White);

                        }
                    }
                    //gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.partyLightName + "(" + gv.mod.currentLightUnitsLeft.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);
                }
                else
                {
                    gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);
                    if ((gv.mod.currentArea.inGameAreaName != "") && (gv.mod.currentArea.inGameAreaName != "newArea"))
                    {
                        if (gv.mod.useRationSystem)
                        {
                            gv.DrawText(gv.mod.currentArea.inGameAreaName + ", " + "Rations(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5f * gv.pS), 600, 100), 1.0f, Color.White);
                        }
                        else 
                        {
                            gv.DrawText(gv.mod.currentArea.inGameAreaName, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5f * gv.pS), 600, 100), 1.0f, Color.White);

                        }
                    }
                    else
                    {
                        if (gv.mod.useRationSystem)
                        {
                            gv.DrawText("Rations(" + gv.mod.numberOfRationsRemaining.ToString() + ")", new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH + (int)(2.5f * gv.pS), 600, 100), 1.0f, Color.White);
                        }

                    }
                    //gv.DrawText(hour + ":" + sMinute, new IbRect(gv.oXshift + (gv.playerOffsetY - 5) * gv.squareSize + 2 * gv.pS, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 600, 100), 1.0f, Color.White);

                }
            }
            else
            {
                for (int x = -2; x <= 2; x++)
                {
                    for (int y = -2; y <= 2; y++)
                    {
                        gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + x + (gv.playerOffsetY - 1) * gv.squareSize, gv.playerOffsetX * gv.squareSize - txtH + y - gv.pS, 100, 100), 1.0f, Color.Black);
                    }
                }
                gv.DrawText(hour + ":" + sMinute + ", " + gv.mod.weekDayNameToDisplay + ", " + gv.mod.monthDayCounterNumberToDisplay + gv.mod.monthDayCounterAddendumToDisplay + " of " + gv.mod.monthNameToDisplay + " " + gv.mod.currentYear.ToString(), new IbRect(gv.oXshift + (gv.playerOffsetY - 1) * gv.squareSize, gv.playerOffsetX * gv.squareSize - txtH - gv.pS, 100, 100), 1.0f, Color.White);

            }

        }
        public void drawFogOfWar()
        {
            #region new system
            if (gv.mod.useAllTileSystem)
            {
                /*
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;
                 * */



            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

            #region neighbours
            if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                #region go through tiles
                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {

                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            try
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (int)gv.squareSize;
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (int)gv.squareSize;
                                //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                float scalerX = 1.0f;
                                float scalerY = 1.0f;
                                int brX = gv.squareSize;
                                int brY = gv.squareSize;
                                IbRect src = new IbRect(0, 0, 100, 100);
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.2f), (int)(brY * 1.2f));
                                if (gv.mod.fogOfWarOpacity != 1.0f)
                                {
                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX), (int)(brY));
                                }
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * 1.09f), (int)(brY * 1.1f));
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, gv.squareSize, gv.squareSize);
                                //IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX + gv.ox, brY + 3);



                                if (tile.Visible == false)
                                {
                                    if (gv.mod.useMathGridFade)
                                    {
                                        gv.DrawBitmap(gv.cc.offScreen, src, dst, false, 1.0f, false);
                                    }
                                    else
                                    {
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, false, 1.0f * gv.mod.fogOfWarOpacity, false);
                                    }
                                }

                                //code for math grid fade, ie diferent fade speeds for fading tiles
                                else if ((tile.Visible == true) && ( (tile.opacity > 0) ) && (gv.mod.useMathGridFade) )
                                {
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + (int)(brX * 0.05f), tlY + (int)(brY * 0.05f), brX - (int)(brX * 0.05f), brY - (int)(brY * 0.05f));
                                   
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    if (tile.fadeMode == 0)
                                    {
                                        tile.fadeMode = gv.sf.RandInt(3);
                                    }

                                    int chance = gv.sf.RandInt(75);
                                    if (tile.fadeMode == 1)
                                    {
                                        if (chance > 50)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreen5, src, dst, 0, false, 1.0f * tile.opacity5);
                                        gv.DrawBitmap(gv.cc.offScreen6, src, dst, 0, false, 0.5f * tile.opacity6);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity5, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity6, false);

                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                    }
                                    if (tile.fadeMode == 2)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreen6, src, dst, 0, false, 1.0f * tile.opacity6);
                                        gv.DrawBitmap(gv.cc.offScreen7, src, dst, 0, false, 0.5f * tile.opacity7);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 1.0f * tile.opacity6, false);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 0.5f * tile.opacity7, false);
                                    }

                                    if (tile.fadeMode == 3)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreen7, src, dst, 0, false, 1.0f * tile.opacity7);
                                        gv.DrawBitmap(gv.cc.offScreen5, src, dst, 0, false, 0.5f * tile.opacity5);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity7, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity5, false);
                                    }
                                    tile.opacity = tile.opacity - 0.07f;
                                }

                                //code for black tile fade, fade with same speed
                                //to do
                                else if ((tile.Visible == true) && ((tile.opacity > 0)) && (!gv.mod.useMathGridFade) && (gv.mod.fogOfWarOpacity == 1.0f))
                                {
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + (int)(brX * 0.05f), tlY + (int)(brY * 0.05f), brX - (int)(brX * 0.05f), brY - (int)(brY * 0.05f));

                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    if (tile.fadeMode == 0)
                                    {
                                        tile.fadeMode = gv.sf.RandInt(3);
                                    }

                                    int chance = gv.sf.RandInt(75);
                                    if (tile.fadeMode == 1)
                                    {
                                        if (chance > 50)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity5);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity6);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity5, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity6, false);

                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                    }
                                    if (tile.fadeMode == 2)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity6);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity7);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 1.0f * tile.opacity6, false);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 0.5f * tile.opacity7, false);
                                    }

                                    if (tile.fadeMode == 3)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity7);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity5);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity7, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity5, false);
                                    }
                                    tile.opacity = tile.opacity - 0.07f;
                                }

                                //semi transparent fog of war
                                else if ((tile.Visible == true) && ((tile.opacity > 0)) && (!gv.mod.useMathGridFade) && (gv.mod.fogOfWarOpacity != 1.0f))
                                {
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + (int)(brX * 0.05f), tlY + (int)(brY * 0.05f), brX - (int)(brX * 0.05f), brY - (int)(brY * 0.05f));
                                    float transparencyFactor = (gv.mod.fogOfWarOpacity / 2.0f);

                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                                    if (tile.fadeMode == 0)
                                    {
                                        tile.fadeMode = gv.sf.RandInt(3);
                                    }

                                    int chance = gv.sf.RandInt(75);
                                    if (tile.fadeMode == 1)
                                    {
                                        if (chance > 50)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity5 * transparencyFactor);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity6 * transparencyFactor);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity5, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity6, false);

                                        //gv.DrawBitmap(tile.tileBitmap0, src, dst, false, 1f, true);
                                    }
                                    if (tile.fadeMode == 2)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity6 = tile.opacity6 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity6 * transparencyFactor);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity7 * transparencyFactor);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 1.0f * tile.opacity6, false);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 0.5f * tile.opacity7, false);
                                    }

                                    if (tile.fadeMode == 3)
                                    {
                                        chance = gv.sf.RandInt(75);
                                        if (chance > 50)
                                        {
                                            tile.opacity7 = tile.opacity7 - 0.14f;
                                        }
                                        if (chance > 30)
                                        {
                                            tile.opacity5 = tile.opacity5 - 0.1f;
                                        }
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * tile.opacity7 * transparencyFactor);
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.5f * tile.opacity5 * transparencyFactor);
                                        //gv.DrawBitmap(gv.cc.black_tile4, src, dst, false, 1.0f * tile.opacity7, false);
                                        //gv.DrawBitmap(gv.cc.black_tile5, src, dst, false, 0.5f * tile.opacity5, false);
                                    }
                                    tile.opacity = tile.opacity - 0.07f;
                                }

                                //else if (tile.Visible == false)
                                //{
                                //gv.DrawBitmap(gv.cc.black_tile2, src, dst, false, 1.0f, false);
                                //}
                            }
                            catch { }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #region old system
            else //old system using single image background and no load tile images on demand
            {
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX-1;
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY-1;
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 2;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 3;
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Visible)
                        {
                            gv.DrawBitmap(gv.cc.black_tile, src, dst);
                        }
                    }
                }
            }
            #endregion
        }

        public void drawPartyHalo (float elapsed)
        {
            #region halo pass: go through tiles only for halos
            int minX = gv.mod.PlayerLocationX;
            int minY = gv.mod.PlayerLocationY;
            int maxX = gv.mod.PlayerLocationX;
            int maxY = gv.mod.PlayerLocationY;

            for (int x = minX; x < maxX + 1; x++)
            {
                for (int y = minY; y < maxY+1; y++)
                {
                    bool situationFound = false;
                    bool drawTile = true;
                    int index = -1;
                    Tile tile = new Tile();

                   tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                    
                    if (drawTile)
                    {
                        bool lightOn = false;
                        foreach (bool light in tile.isLit)
                        {
                            if (light)
                            {
                                lightOn = true;
                                break;
                            }
                        }

                        try
                        {
                            int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (gv.squareSize);
                            int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (gv.squareSize);
                            //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                            //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                            //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                            float scalerX = 1;
                            float scalerY = 1;
                            int brX = (int)(gv.squareSize * scalerX);
                            int brY = (int)(gv.squareSize * scalerY);
                            float scaler = gv.sf.RandInt(30);
                            //int shifter = gv.sf.RandInt(5);
                            //scaler = 1 + (scaler / 100f);
                            scaler = 1f;
                            //shifter = 0;
                            if (gv.mod.currentArea.UseDayNightCycle)
                            {
                                //shifter = 0;
                                //shifterY = 0;
                            }
                            IbRect src = new IbRect(0, 0, 100, 100);
                            IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                            float flickerReduction = 1;
                            if (gv.mod.currentArea.UseDayNightCycle)
                            {
                                flickerReduction = 1.5f;
                            }

                            if ((tile.isFocalPoint) && (lightOn))
                            {
                                //color of light source
                                //if (!gv.mod.currentArea.UseDayNightCycle)
                                //{
                                //if (lightOn)
                                //{
                                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - (int)(0.125f * gv.squareSize), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - (int)(0.125f * gv.squareSize), (int)(brX * scaler) + (int)(0.25f * gv.squareSize), (int)(brY * scaler) + (int)(0.25f * gv.squareSize));

                                bool drawLightHalo = false;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    int dawn = 5 * 60;
                                    int sunrise = 6 * 60;
                                    int day = 7 * 60;
                                    int sunset = 17 * 60;
                                    int dusk = 18 * 60;
                                    int night = 20 * 60;
                                    int time = gv.mod.WorldTime % 1440;
                                    if ((time >= night) || (time < dawn))
                                    {
                                        drawLightHalo = true;
                                    }
                                }
                                else
                                {
                                    drawLightHalo = true;
                                }

                                if ((!gv.mod.currentArea.useLightSystem) || (!tile.hasHalo))
                                {
                                    drawLightHalo = false;
                                }

                                if (drawLightHalo)
                                {
                                    //int extension = 6 - (int)(flicker / 7f);
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5, (int)(brX * scaler) + 2 * extension - 10, (int)(brY * scaler) + 2 * extension - 10);
                                    //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                    if ((x == gv.mod.PlayerLocationX) && (y == gv.mod.PlayerLocationY) && gv.mod.partyLightOn)
                                    {
                                        int extension = 6 - (int)(flicker / 7f);
                                        int extension2 = 13 - (int)(flicker / 3f);
                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                        if (gv.mod.partyLightColor.Contains("yellow"))
                                        {
                                            gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                            gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                        }
                                        else if (gv.mod.partyLightColor.Contains("blue"))
                                        {
                                            gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                            gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                        }
                                        else if (gv.mod.partyLightColor.Contains("green"))
                                        {
                                            gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                            gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                        }
                                        else if (gv.mod.partyLightColor.Contains("red"))
                                        {
                                            gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                            gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                        }
                                        else if (gv.mod.partyLightColor.Contains("orange"))
                                        {
                                            gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                            gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                        }
                                        else if (gv.mod.partyLightColor.Contains("purple"))
                                        {
                                            gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                            gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                        }
                                    }


                                    //for (int z = 0; z < tile.tileLightSourceTag.Count; z++)
                                    for (int z = 0; z < tile.lightSourceFocalHaloIntensity.Count; z++)
                                    //foreach (string s in tile.tileLightSourceTag)
                                    {

                                        if (tile.isLit[z])
                                        {
                                            if (tile.tileLightSourceTag[z].Contains("prp_lightYellow"))
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, tile.lightSourceRingHaloIntensity[z] * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, (0.10f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));

                                                //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.10f + 2.25f * 0.3f * (0.425f - flicker / 200f));

                                            }

                                            if (tile.tileLightSourceTag[z].Contains("prp_lightGreen"))
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                            }

                                            if (tile.tileLightSourceTag[z].Contains("prp_lightRed"))
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                            }

                                            if (tile.tileLightSourceTag[z].Contains("prp_lightBlue"))
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                            }

                                            if (tile.tileLightSourceTag[z].Contains("prp_lightPurple"))
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                            }

                                            if (tile.tileLightSourceTag[z].Contains("prp_lightOrange"))
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                            }
                                        }
                                    }

                                }
                            }//close focal light
                        }//close try
                        catch
                        { }
                    }//close draw tile condition
                }//close inner tile loop
            }//clsoe outer tile loop

            #endregion
        }

        public void drawLightAndDarkness(float elapsed)
        {
            #region new system
            if (gv.mod.useAllTileSystem)
            {
                #region neighbours
                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY <= gv.playerOffsetY))
                {
                    gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            gv.mod.indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1)))
                {

                    gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            gv.mod.indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                        {
                            gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationX <= gv.playerOffsetX)
                        {
                            gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX <= gv.playerOffsetX))
                {
                    gv.mod.seamlessModififierMinX = gv.playerOffsetX - gv.mod.PlayerLocationX;
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            gv.mod.indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea != "")
                    {

                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1)))
                {
                    gv.mod.seamlessModififierMaxX = gv.mod.PlayerLocationX - (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1);
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            gv.mod.indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY <= gv.playerOffsetY)
                        {
                            gv.mod.seamlessModififierMinY = gv.playerOffsetY - gv.mod.PlayerLocationY;
                        }

                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                gv.mod.indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                        {
                            gv.mod.seamlessModififierMaxY = gv.mod.PlayerLocationY - (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1);
                        }
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                gv.mod.indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }
                #endregion

                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minX < -gv.mod.seamlessModififierMinX - 1) { minX = -gv.mod.seamlessModififierMinX - 1; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 3; //using -2 in case a large tile (3x3) needs to start off the visible map space to be seen
                if (minY < -gv.mod.seamlessModififierMinY - 1) { minY = -gv.mod.seamlessModififierMinY - 1; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX + gv.mod.seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY + gv.mod.seamlessModififierMaxY; }

                flickerDelayCounter += elapsed / 1000f * 30f;

                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (tile.lightRadius * gv.squareSize), tlY - (tile.lightRadius * gv.squareSize), brX * (1 + tile.lightRadius * 2), brY * (1 + tile.lightRadius * 2));
                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                //tile.flicker = 0;
                //flicker = 1.15f;
                if (flickerDelayCounter > (0.635f * gv.mod.currentArea.flickerSlowDownFactor))
                {
                    if (flickerRise)
                    {
                        flicker2++;
                        //flicker2++;
                        //tile.affectedByFlickerAlready = true;
                        /*
                        int decider = gv.sf.RandInt(2);
                        if (decider == 1)
                        {
                            flicker++;
                        }
                        else
                        {
                            
                        }
                        
                        else
                        {
                            flicker++;
                            flicker++;
                            flicker++;
                        }
                        */
                    }
                    else
                    {
                        //tile.affectedByFlickerAlready = true;
                        //flicker2--;
                        //int decider = gv.sf.RandInt(3);
                        //if (decider >= 2)
                        //{
                            //flicker2--;
                        flicker2--;
                        //}
                        //else
                        //{

                        //}

                        /*
                        int decider = gv.sf.RandInt(1);
                        if (decider == 1)
                        {
                            flicker--;
                        }
                        else if (decider == 2)
                        {
                            flicker--;
                            flicker--;
                        }
                        else
                        {
                            flicker--;
                            flicker--;
                            flicker--;
                        }
                        */
                    }

                    if (flicker2 == 10)
                    {
                        int decider = gv.sf.RandInt(100);
                        if (decider <= 20)
                        {
                            if (flickerRise == false)
                            {
                                flickerRise = true;
                            }
                            else
                            {
                                flickerRise = false;
                            }
                        }
                    }

                    if (flicker2 == 20)
                    {
                        int decider = gv.sf.RandInt(100);
                        if (decider <= 20)
                        {
                            if (flickerRise == false)
                            {
                                //flickerRise = true;
                            }
                            else
                            {
                                flickerRise = false;
                            }
                        }
                    }

                    if (flicker2 == 30)
                    {
                        int decider = gv.sf.RandInt(100);
                        if (decider <= 20)
                        {
                            if (flickerRise == false)
                            {
                                //flickerRise = true;
                            }
                            else
                            {
                                flickerRise = false;
                            }
                        }
                    }

                    if (flicker2 >= 45)
                    {
                        flickerRise = false;
                    }
                    if (flicker2 <= 0)
                    {
                        flickerRise = true;
                    }

                    flickerDelayCounter = 0;
                }

                //flicker = 9 + (flicker2/2.75f);
                flicker = gv.mod.currentArea.minimumDarkness + gv.mod.currentArea.maxLightMultiplier*(flicker2*3f/4f);

                if(gv.mod.currentArea.noFlicker)
                {
                    flicker = gv.mod.currentArea.minimumDarkness + 8;
                }
                //flicker = flicker2;
                /*
                int decider3 = gv.sf.RandInt(30);
                if (decider3 == 1)
                {
                    shifterPause = true;
                }

                if (shifterPause == true)
                {
                     int decider4 = gv.sf.RandInt(15);
                     if (decider4 == 1)
                     {
                         shifterPause = false;
                     }
                }
                 */
                //shifterPause = true;

                if (shifterPause == false)
                {
                    shifterDelayCounter += elapsed / 1000f * 30f;
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (tile.lightRadius * gv.squareSize), tlY - (tile.lightRadius * gv.squareSize), brX * (1 + tile.lightRadius * 2), brY * (1 + tile.lightRadius * 2));
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                    //tile.flicker = 0;
                    //1.15
                    if (shifterDelayCounter > (1.75f * gv.mod.currentArea.shifterSlowDownFactor))
                    {
                        if (shifterRise)
                        {

                            //int decider = gv.sf.RandInt(1);
                            //if (decider == 1)
                            //{
                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifter++;
                            }
                            //tile.affectedByFlickerAlready = true;
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker++;
                            }
                            else if (decider == 2)
                            {
                                flicker++;
                                flicker++;
                            }
                            else
                            {
                                flicker++;
                                flicker++;
                                flicker++;
                            }
                            */
                        }
                        else
                        {
                            //tile.affectedByFlickerAlready = true;
                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifter--;
                            }
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker--;
                            }
                            else if (decider == 2)
                            {
                                flicker--;
                                flicker--;
                            }
                            else
                            {
                                flicker--;
                                flicker--;
                                flicker--;
                            }
                            */
                        }
                        if (shifter >= 2)
                        {
                            shifterRise = false;
                        }
                        if (shifter <= -2)
                        {
                            shifterRise = true;
                        }

                        shifterDelayCounter = 0;
                    }

                    shifterYDelayCounter += elapsed / 1000f * 30f;
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (tile.lightRadius * gv.squareSize), tlY - (tile.lightRadius * gv.squareSize), brX * (1 + tile.lightRadius * 2), brY * (1 + tile.lightRadius * 2));
                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);

                    //tile.flicker = 0;
                    if (shifterYDelayCounter > (1.75f * gv.mod.currentArea.flickerSlowDownFactor))
                    {
                        if (shifterYRise)
                        {

                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifterY++;
                            }
                            //tile.affectedByFlickerAlready = true;
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker++;
                            }
                            else if (decider == 2)
                            {
                                flicker++;
                                flicker++;
                            }
                            else
                            {
                                flicker++;
                                flicker++;
                                flicker++;
                            }
                            */
                        }
                        else
                        {
                            //tile.affectedByFlickerAlready = true;
                            int decider = gv.sf.RandInt(2);
                            if (decider == 1)
                            {
                                shifterY--;
                            }
                            /*
                            int decider = gv.sf.RandInt(1);
                            if (decider == 1)
                            {
                                flicker--;
                            }
                            else if (decider == 2)
                            {
                                flicker--;
                                flicker--;
                            }
                            else
                            {
                                flicker--;
                                flicker--;
                                flicker--;
                            }
                            */
                        }
                        if (shifterY >= 2)
                        {
                            shifterYRise = false;
                        }
                        if (shifterY <= -2)
                        {
                            shifterYRise = true;
                        }

                        shifterYDelayCounter = 0;
                    }
                }

                /*
                int shifter = 0;
                int shifterY = 0;
                
                int decider2 = gv.sf.RandInt(100);
                int decider3 = gv.sf.RandInt(2);
                if (decider2 <= 3)
                {
                    shifter = gv.sf.RandInt(1);
                    if (decider3 == 1)
                    {
                        //shifter++;
                        shifter = shifter * -1;
                    }
                    //else
                    //{
                        //shifter--;
                    //}

                    //if (shifter > 10)
                    //{
                        //shifter
                    //}
                }

                decider2 = gv.sf.RandInt(100);
                decider3 = gv.sf.RandInt(2);
                if (decider2 <= 3)
                {
                    shifterY = gv.sf.RandInt(1);
                    if (decider3 == 1)
                    {
                        shifterY = shifterY * -1;
                    }
                }
                */
                if (gv.mod.currentArea.noPositionShift)
                {
                    shifterY = 0;
                    shifter = 0;
                }

                if (gv.mod.fogOfWarOpacity != 1.0f)
                {
                    shifterY = 0;
                    shifter = 0;
                }

                //if (gv.mod.fogOfWarOpacity == 1.0f)
                //{
                    #region halo pass: go through tiles only for halos
                    for (int x = minX; x < maxX + 1; x++)
                    {
                        for (int y = minY; y < maxY; y++)
                        {
                            if ((gv.mod.PlayerLocationX == x) && (gv.mod.PlayerLocationY == y))
                            {
                                continue;
                            }
                            bool situationFound = false;
                            bool drawTile = true;
                            int index = -1;
                            Tile tile = new Tile();

                            //nine situations where a tile can be:
                            //tile on north-western map (diagonal situation)
                            if ((x < 0) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-westernmap (diagonal situation)
                            if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on south-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on north-easternmap (diagonal situation)
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on western map
                            if ((x < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfWesternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on southern map
                            if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = y - gv.mod.currentArea.MapSizeY;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfSouthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on eastern map
                            if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = x - gv.mod.currentArea.MapSizeX;
                                    int transformedY = y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfEasternNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile on northern map
                            if ((y < 0) && (!situationFound))
                            {
                                situationFound = true;
                                if (gv.mod.indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                    tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                    index = gv.mod.indexOfNorthernNeighbour;
                                }
                                else
                                {
                                    drawTile = false;
                                }
                            }
                            //tile is on current map
                            if (!situationFound)
                            {
                                tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                            }

                            if (drawTile)
                            {
                                bool lightOn = false;
                                foreach (bool light in tile.isLit)
                                {
                                    if (light)
                                    {
                                        lightOn = true;
                                        break;
                                    }
                                }

                                try
                                {
                                    int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (gv.squareSize);
                                    int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (gv.squareSize);
                                    //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                    //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                    //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                    float scalerX = 1;
                                    float scalerY = 1;
                                    int brX = (int)(gv.squareSize * scalerX);
                                    int brY = (int)(gv.squareSize * scalerY);
                                    float scaler = gv.sf.RandInt(30);
                                    //int shifter = gv.sf.RandInt(5);
                                    //scaler = 1 + (scaler / 100f);
                                    scaler = 1f;
                                    //shifter = 0;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        //shifter = 0;
                                        //shifterY = 0;
                                    }
                                    IbRect src = new IbRect(0, 0, 100, 100);
                                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                    float flickerReduction = 1;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        flickerReduction = 1.5f;
                                    }

                                    if ((tile.isFocalPoint) && (lightOn))
                                    {
                                        //color of light source
                                        //if (!gv.mod.currentArea.UseDayNightCycle)
                                        //{
                                        //if (lightOn)
                                        //{
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - (int)(0.125f * gv.squareSize), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - (int)(0.125f * gv.squareSize), (int)(brX * scaler) + (int)(0.25f * gv.squareSize), (int)(brY * scaler) + (int)(0.25f * gv.squareSize));

                                        bool drawLightHalo = false;
                                        if (gv.mod.currentArea.UseDayNightCycle)
                                        {
                                            int dawn = 5 * 60;
                                            int sunrise = 6 * 60;
                                            int day = 7 * 60;
                                            int sunset = 17 * 60;
                                            int dusk = 18 * 60;
                                            int night = 20 * 60;
                                            int time = gv.mod.WorldTime % 1440;
                                            if ((time >= night) || (time < dawn))
                                            {
                                                drawLightHalo = true;
                                            }
                                        }
                                        else
                                        {
                                            drawLightHalo = true;
                                        }

                                        if ((!gv.mod.currentArea.useLightSystem) || (!tile.hasHalo))
                                        {
                                            drawLightHalo = false;
                                        }

                                        if (drawLightHalo)
                                        {
                                            //int extension = 6 - (int)(flicker / 7f);
                                            //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5, (int)(brX * scaler) + 2 * extension - 10, (int)(brY * scaler) + 2 * extension - 10);
                                            //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                            //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                            if ((x == gv.mod.PlayerLocationX) && (y == gv.mod.PlayerLocationY) && gv.mod.partyLightOn)
                                            {
                                                int extension = 6 - (int)(flicker / 7f);
                                                int extension2 = 13 - (int)(flicker / 3f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                if (gv.mod.partyLightColor.Contains("yellow"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                                }
                                                else if (gv.mod.partyLightColor.Contains("blue"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                                }
                                                else if (gv.mod.partyLightColor.Contains("green"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                                }
                                                else if (gv.mod.partyLightColor.Contains("red"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                                }
                                                else if (gv.mod.partyLightColor.Contains("orange"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                                }
                                                else if (gv.mod.partyLightColor.Contains("purple"))
                                                {
                                                    gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, gv.mod.partyRingHaloIntensity * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension2, (int)(brX * scaler) + 2 * extension2, (int)(brY * scaler) + 2 * extension2);
                                                    gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.25f * gv.mod.partyFocalHaloIntensity) + (gv.mod.partyFocalHaloIntensity) * (2.25f * 0.75f * (0.425f - flicker / 200f)));
                                                }
                                            }


                                            //for (int z = 0; z < tile.tileLightSourceTag.Count; z++)
                                            for (int z = 0; z < tile.lightSourceFocalHaloIntensity.Count; z++)
                                            //foreach (string s in tile.tileLightSourceTag)
                                            {
                                                bool draw = false;
                                                //determine whether tile is onscreen
                                                //(x - gv.mod.PlayerLocationX + gv.playerOffsetX)
                                                if ((x <= gv.mod.PlayerLocationX + gv.playerOffsetX) && (x >= gv.mod.PlayerLocationX - gv.playerOffsetX))
                                                {
                                                    if ((y <= gv.mod.PlayerLocationY + gv.playerOffsetY) && (y >= gv.mod.PlayerLocationY - gv.playerOffsetY))
                                                    {
                                                        draw = true;
                                                    }
                                                }


                                                if ((tile.isLit[z]) && (draw))
                                                {
                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightYellow"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, tile.lightSourceRingHaloIntensity[z] * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightYellow, src, dst, 0, false, (0.10f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));

                                                        //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                        //gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, 0.15f + 1.75f * 0.10f + 2.25f * 0.3f * (0.425f - flicker / 200f));

                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightGreen"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightGreen, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightRed"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightRed, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightBlue"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightBlue, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightPurple"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightPurple, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }

                                                    if (tile.tileLightSourceTag[z].Contains("prp_lightOrange"))
                                                    {
                                                        int extension = 6 - (int)(flicker / 7f);
                                                        int extension2 = 13 - (int)(flicker / 3f);
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - 2 * gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - 2 * gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 4 * gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 4 * gv.squareSize);
                                                        gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.15f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceRingHaloIntensity[z]) * 1.75f * 0.7f * 0.45f * 0.75f * (0.425f - flicker / 200f));
                                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + extension2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + extension2, (int)(brX * scaler) - 2 * extension2, (int)(brY * scaler) - 2 * extension2);
                                                        gv.DrawBitmap(gv.cc.prp_lightOrange, src, dst, 0, false, (0.325f * tile.lightSourceFocalHaloIntensity[z]) + (tile.lightSourceFocalHaloIntensity[z]) * (2.25f * 0.3f * (0.425f - flicker / 200f)));
                                                    }
                                                }
                                            }

                                        }
                                    }//close focal light
                                }//close try
                                catch
                                { }
                            }//close draw tile condition
                        }//close inner tile loop
                    }//clsoe outer tile loop

                    #endregion
                //}  
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                #region go through tiles
                for (int x = minX; x < maxX+1; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {

                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((x < 0) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((x < 0) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((x < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + x;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((y > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = y - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((x > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfEasternNeighbour != -1)
                            {
                                int transformedX = x - gv.mod.currentArea.MapSizeX;
                                int transformedY = y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((y < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (gv.mod.indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeY + y;
                                tile = gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[gv.mod.indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = gv.mod.indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x];
                        }

                        if (drawTile)
                        {
                            bool lightOn = false;
                            foreach (bool light in tile.isLit)
                            {
                                if (light)
                                {
                                    lightOn = true;
                                    break;
                                }
                            }

                            try
                            {
                                int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * (gv.squareSize);
                                int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * (gv.squareSize);
                                //float scalerX = tile.tileBitmap0.PixelSize.Width / 100;
                                //float scalerY = tile.tileBitmap0.PixelSize.Height / 100;
                                //the tiles0 arrive as 50x50px but we want to have them 100% square size, therefore scaler to 1, ie 100%
                                float scalerX = 1;
                                float scalerY = 1;
                                int brX = (int)(gv.squareSize * scalerX);
                                int brY = (int)(gv.squareSize * scalerY);
                                float scaler = gv.sf.RandInt(30);
                                //int shifter = gv.sf.RandInt(5);
                                //scaler = 1 + (scaler / 100f);
                                scaler = 1f;
                                //shifter = 0;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    //shifter = 0;
                                    //shifterY = 0;
                                }
                                IbRect src = new IbRect(0, 0, 100, 100);
                                IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler-1)*brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                int indexOfRelevantLightSource = 0;
                                int sorter = -1;
                                string oldTilePosition = "none";
                                string comparePosition = "";
                                for (int p = 0; p < tile.priority.Count; p++)
                                {
                                    if (tile.priority[p] == sorter)
                                    {
                                        //treat as special cornerOverlay tile (like an N2 tile but going up to full dark, like brigher part of N4)
                                        if (sorter == 1)
                                        {
                                           
                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                            }
                                        }
                                        else if (sorter == 2)
                                        {
                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlayBright";
                                            }
                                            /*
                                            /*
                                                                                        if (tile.tilePositionInLitArea[p] == "S4")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        if (tile.tilePositionInLitArea[p] == "S0")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        if (tile.tilePositionInLitArea[p] == "N4")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        if (tile.tilePositionInLitArea[p] == "N0")
                                                                                        {
                                                                                            tile.tilePositionInLitArea[indexOfRelevantLightSource] = "cornerOverlay";
                                                                                        }
                                                                                        */
                                        }
                                        //treat as N2 tile
                                        else if (sorter == 3)
                                        {

                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "N2";
                                            }
                                        }
                                        
                                        //treat as N tile
                                        else
                                        {

                                            if (comparePosition != tile.tilePositionInLitArea[p])
                                            {
                                                oldTilePosition = tile.tilePositionInLitArea[p];
                                                tile.tilePositionInLitArea[indexOfRelevantLightSource] = "N";
                                            }
                                        }
                                    }

                                    if (tile.priority[p] > sorter)
                                    {
                                        sorter = tile.priority[p];
                                        indexOfRelevantLightSource = p;
                                        comparePosition = tile.tilePositionInLitArea[indexOfRelevantLightSource];
                                        //tagOFLightSource = tile.tileLightSourceTag;
                                        //if (oldTilePosition != "none")
                                        //{
                                        //tile.tilePositionInLitArea[indexOfRelevantLightSource] = oldTilePosition;
                                        // }
                                    }
                                }

                                float flickerReduction = 1;
                                if (gv.mod.currentArea.UseDayNightCycle)
                                {
                                    flickerReduction = 1.5f;
                                }

                                if ((tile.isFocalPoint)  && (lightOn))
                                {
                                    //color of light source
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //if (lightOn)
                                    //{
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - (int)(0.125f * gv.squareSize), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - (int)(0.125f * gv.squareSize), (int)(brX * scaler) + (int)(0.25f * gv.squareSize), (int)(brY * scaler) + (int)(0.25f * gv.squareSize));
                                    /*
                                    bool drawLightHalo = false;
                                    if (gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= night) || (time < dawn))
                                        {
                                            drawLightHalo = true;
                                        }
                                    }
                                    else
                                    {
                                        drawLightHalo = true;
                                    }

                                    if (drawLightHalo)
                                    {
                                        //int extension = 6 - (int)(flicker / 7f);
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5, (int)(brX * scaler) + 2 * extension - 10, (int)(brY * scaler) + 2 * extension - 10);
                                        //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                        int extension = 6 - (int)(flicker / 7f);
                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - extension + 5 - gv.squareSize, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - extension + 5 - gv.squareSize, (int)(brX * scaler) + 2 * extension - 10 + 2*gv.squareSize, (int)(brY * scaler) + 2 * extension - 10 + 2*gv.squareSize);
                                        gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 2f * 0.75f * (0.425f - flicker / 200f));
                                        dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                }
                                */

                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false,0.75f *0.75f * (0.225f - flicker / 400f));
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));

                                    //}
                                    //}

                                    //flicker the area light (black darkness or time of day ususally)
                                    if (gv.mod.currentArea.UseDayNightCycle && tile.Visible)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            //gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f / flickerReduction * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            //zach
                                            //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.75f / flickerReduction * 1.0f * flicker / 100f);
                                            if ((gv.mod.currentArea.useLightSystem))
                                            {
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.25f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                            }

                                        }
                                    }
                                    //dark area
                                    //connect to area is dark?
                                    else if (tile.Visible)
                                    {
                                        if ((gv.mod.currentArea.useLightSystem))
                                        {
                                            //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0.075f * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 0.75f * flicker / 100f);
                                            //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                        }


                                    }

                                    if ((!tile.Visible) && (gv.mod.fogOfWarOpacity == 1.0f))
                                    {
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * scaler), (int)(brY * scaler));
                                        gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f);
                                    }
                                }

                                else if ((tile.isCentreOfLightCircle)  && (lightOn))
                                {
                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false, 0.75f * 0.75f * (0.225f - flicker / 400f));
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //gv.DrawBitmap(gv.cc.light_torch, src, dst, 0, false, 0.9f * (0.125f - flicker/400f));
                                    //}
                                    float extraDarkness = 1;
                                   
                                        if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NE") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NW") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SE") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SW"))
                                        {
                                            extraDarkness = 1.25f;
                                        }
                                        //to DO XXX
                                    if (gv.mod.currentArea.UseDayNightCycle && tile.Visible)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            //gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, extraDarkness * 0.85f * 2.75f / flickerReduction * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            //hurgh10000
                                            if (gv.mod.currentArea.useLightSystem)
                                            {
                                                if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NW"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.25f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NE"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.25f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SW"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.25f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SE"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.25f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);

                                                }
                                                else
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.25f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);

                                                }
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                            }

                                            }//night closing closing

                                    }//use time of day closing 

                                    //dark area
                                    //connect to area is dark?
                                    else if (tile.Visible)
                                    {
                                        if (gv.mod.currentArea.useLightSystem)
                                        {

                                            if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NW"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler));
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "NE"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler));
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SW"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "SE"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.75f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);


                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);
                                            }
                                        }

                                        //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);
                                        
                                    }
                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0.55f * flicker / 100f);
                                    if (!tile.Visible)
                                    {
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * scaler), (int)(brY * scaler));
                                        if (gv.mod.fogOfWarOpacity == 1.0f)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f);
                                        }
                                    }
                                }

                                else if ((tile.isOtherPartOfLightCircle) && (lightOn))
                                {
                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false, 0.75f * 0.75f * (0.225f - flicker / 400f));
                                    //do nothing,the overlapping and scaled light circle graphic does t already
                                    //if (!gv.mod.currentArea.UseDayNightCycle)
                                    //{
                                    //gv.DrawBitmap(gv.cc.light_torchOLD, src, dst, 0, false, 0.9f * (0.125f - flicker/400f));
                                    //}
                                    float extraDarkness = 1;
                                    foreach (string position in tile.tilePositionInLitArea)
                                    {
                                        if  ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N3") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E1") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N0") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N4") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S0") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S4") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W1"))
                                        {
                                            extraDarkness = 1.5f;
                                        }
                                        if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlay") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S1") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S3") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E3") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "") || (tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W3"))
                                        {
                                            extraDarkness = 1.5f;
                                        }
                                    }
                                    if (gv.mod.currentArea.UseDayNightCycle && tile.Visible)
                                    {
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            //gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, extraDarkness * 0.65f * 3.75f / flickerReduction * flicker / 100f);
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1.0f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            if (gv.mod.currentArea.useLightSystem)
                                            {
                                                if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                                {

                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler));
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 1.0f * 0.65f * flicker / 100f * 1.2f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);


                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W1"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);

                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E1"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S1"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);

                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);

                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E3"))
                                                {
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                }

                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N0"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N4"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S0"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SW, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NE, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S4"))
                                                {
                                                    gv.DrawBitmap(gv.cc.night_tile_SE, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                                    gv.DrawBitmap(gv.cc.night_tile_NW, src, dst, 0, false, 0.8f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlay"))
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.15f + 0.8f * 1.75f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.75f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                                }
                                                else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlayBright"))
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.75f * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f * flicker / 100f);
                                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                    //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                                }

                                                //normal tile
                                                else
                                                {
                                                    gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 1.5f * 0.5f * 1.5f * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.65f * flicker / 100f * 1.2f);
                                                    //gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, extraDarkness * 0.65f * 1.7f * 1.5f / flickerReduction * flicker / 100f);
                                                }
                                            }
                                            else
                                            {
                                                //hurgh54
                                                gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                            }
                                        }//night time closing

                                    }//use time of day closing


                                    //dark area
                                    //connect to area is dark?
                                    else if (tile.Visible)
                                    {
                                        /*
                                        if (position == "NE")
                                        {
                                            dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler), (int)(brY * scaler));
                                            gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);

                                            gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);

                                            gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.75f * flicker / 100f);

                                        }
                                        */
                                        if (gv.mod.currentArea.useLightSystem)
                                        {
                                            float darknessWeighter = 0.15f + 1.05f * 0.675f * 2.5f * flicker / 100f;
                                            if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, darknessWeighter);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "W3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 1);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, darknessWeighter);
                                            }

                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "E3"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 1, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 1, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, darknessWeighter);
                                            }
                                            /*
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N1"))
                                            {
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.675f * 2.5f * flicker / 100f);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 1, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                            }
                                            */


                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N0"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 4);
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "N4"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 4, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 4, (int)(brY * scaler) + 4);
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S0"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SW, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 2, (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                gv.DrawBitmap(gv.cc.black_tile_NE, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "S4"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, darknessWeighter);
                                                dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) - 2, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) - 3, (int)(brX * scaler) + 3, (int)(brY * scaler) + 3);
                                                gv.DrawBitmap(gv.cc.black_tile_NW, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlay"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, darknessWeighter);
                                                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                            }
                                            else if ((tile.tilePositionInLitArea[indexOfRelevantLightSource] == "cornerOverlayBright"))
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                                //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, darknessWeighter * 2f / 3f);
                                                //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f), tlY + shifterY - (int)((scaler - 1) * brY * 0.5f), (int)(brX * scaler) + 2, (int)(brY * scaler) + 2);
                                                //gv.DrawBitmap(gv.cc.black_tile_SE, src, dst, 0, false, 0.975f);
                                            }
                                            else
                                            {
                                                gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, extraDarkness * 0.675f * 2.5f * flicker / 100f);
                                            }
                                        }
                                    }
                                    //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 1.20f * flicker/100f);
                                    if (!tile.Visible)
                                    {
                                        //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                                        if (gv.mod.fogOfWarOpacity == 1.0f)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f);
                                        }
                                    }
                                }
                                else if ((tile.Visible)) 
                                {
                                    int flickerExtensionX = 0;
                                    int flickerExtensionY = 0;
                                    int flickerEarlyStartX = 0;
                                    int flickerEarlyStartY = 0;

                                    if (!gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        //flickerExtensionX = 4;
                                        //flickerExtensionY = 4;
                                        //flickerEarlyStartX = -2;
                                        //flickerEarlyStartY = -2;
                                    }
                                    /*
                                    if (x == (maxX - 1))
                                    {
                                        flickerExtensionX = 10;
                                    }
                                    if (y == (maxY - 1))
                                    {
                                        flickerExtensionY = 10;
                                    }
                                    if (x == (minX))
                                    {
                                        flickerExtensionX = 20;
                                        flickerEarlyStartX = -20;
                                    }
                                    if (y == (minY))
                                    {
                                        flickerExtensionY = 20;
                                        flickerEarlyStartY = -20;
                                    }
                                    */
                                    dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels + shifter - (int)((scaler - 1) * brX * 0.5f) + flickerEarlyStartX, tlY + shifterY - (int)((scaler - 1) * brY * 0.5f) + flickerEarlyStartY, (int)(brX * scaler)+ flickerExtensionX, (int)(brY * scaler) + flickerExtensionY);

                                    //draw black tile
                                    //dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, (int)(brX * scaler), (int)(brY * scaler));
                                    if (!gv.mod.currentArea.UseDayNightCycle)
                                    {
                                        if (gv.mod.currentArea.useLightSystem)
                                        {
                                            gv.DrawBitmap(gv.cc.offScreenBlack, src, dst, 0, false, 1.0f * gv.mod.fogOfWarOpacity);
                                        }
                                    }
                                    else if (tile.Visible)
                                    {
                                        //do daytime tinting here
                                        int dawn = 5 * 60;
                                        int sunrise = 6 * 60;
                                        int day = 7 * 60;
                                        int sunset = 17 * 60;
                                        int dusk = 18 * 60;
                                        int night = 20 * 60;
                                        int time = gv.mod.WorldTime % 1440;
                                        if ((time >= dawn) && (time < sunrise))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dawn, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= sunrise) && (time < day))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunrise, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= day) && (time < sunset))
                                        {
                                            //no tint for day
                                        }
                                        else if ((time >= sunset) && (time < dusk))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_sunset, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= dusk) && (time < night))
                                        {
                                            gv.DrawBitmap(gv.cc.tint_dusk, src, dst, 0, false, 1f);
                                        }
                                        else if ((time >= night) || (time < dawn))
                                        {
                                            //gv.DrawBitmap(gv.cc.black_tile, src, dst, 0, false, 0.55f);
                                            gv.DrawBitmap(gv.cc.tint_night, src, dst, 0, false, 0.8f);
                                        }
                                    }
                                } 
                            }
                            catch { }
                        }
                    }
                }
                #endregion

            }
            #endregion
            #region old system
            else //old system using single image background and no load tile images on demand
            {
                int minX = gv.mod.PlayerLocationX - gv.playerOffsetX - 1;
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - gv.playerOffsetY - 1;
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + gv.playerOffsetX + 2;
                if (maxX > this.gv.mod.currentArea.MapSizeX) { maxX = this.gv.mod.currentArea.MapSizeX; }
                int maxY = gv.mod.PlayerLocationY + gv.playerOffsetY + 3;
                if (maxY > this.gv.mod.currentArea.MapSizeY) { maxY = this.gv.mod.currentArea.MapSizeY; }

                for (int x = minX; x < maxX; x++)
                {
                    for (int y = minY; y < maxY; y++)
                    {
                        int tlX = (x - gv.mod.PlayerLocationX + gv.playerOffsetX) * gv.squareSize;
                        int tlY = (y - gv.mod.PlayerLocationY + gv.playerOffsetY) * gv.squareSize;
                        int brX = gv.squareSize;
                        int brY = gv.squareSize;
                        IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                        IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].Visible)
                        {
                            gv.DrawBitmap(gv.cc.black_tile, src, dst);
                        }
                    }
                }
            }
            #endregion
        }
        public void drawBlackTilesOverTints()
        {
            #region new system
            if (gv.mod.useAllTileSystem)
            {
                int width = gv.playerOffsetX * 2 + 1;
                int height = gv.playerOffsetY * 2 + 1;

                //if (gv.mod.currentArea.westernNeighbourArea == "")
                //{
                    //at left edge
                    for (int i = -1; i < gv.playerOffsetX - gv.mod.PlayerLocationX + 1; i++)
                    {
                         drawColumnOfBlack(i);
                    }
                //}

                //if (gv.mod.currentArea.northernNeighbourArea == "")
                //{
                    //at top edge
                    for (int i = -1; i < gv.playerOffsetY - gv.mod.PlayerLocationY; i++)
                    {
                        drawRowOfBlack(i);
                    }
                //}
                //if (gv.mod.currentArea.easternNeighbourArea == "")
                //{
                    //at right edge
                    for (int i = 0; i <= gv.playerOffsetX + gv.mod.PlayerLocationX - gv.mod.currentArea.MapSizeX; i++)
                    {
                        drawColumnOfBlack(width - i);
                    }
                //}
                //if (gv.mod.currentArea.southernNeighbourArea == "")
                //{
                    //at bottom edge
                    for (int i = -1; i <= gv.playerOffsetY + gv.mod.PlayerLocationY - gv.mod.currentArea.MapSizeY + 1; i++)
                    {
                        drawRowOfBlack(height - i);
                    }
                //}
            }
            #endregion
            #region old system
            else //old system using single image background and no load tile images on demand
            {
                int width = gv.playerOffsetX * 2 + 1;
                int height = gv.playerOffsetY * 2 + 1;

                //at left edge
                for (int i = -2; i < gv.playerOffsetX - gv.mod.PlayerLocationX; i++)
                {
                    drawColumnOfBlack(i);                    
                }

                //at top edge
                for (int i = -2; i < gv.playerOffsetY - gv.mod.PlayerLocationY; i++)
                {
                    drawRowOfBlack(i);
                }

                //at right edge
                for (int i = -1; i <= gv.playerOffsetX + gv.mod.PlayerLocationX - gv.mod.currentArea.MapSizeX + 1; i++)
                {
                    drawColumnOfBlack(width - i);                    
                }

                //at bottom edge
                for (int i = -1; i <= gv.playerOffsetY + gv.mod.PlayerLocationY - gv.mod.currentArea.MapSizeY + 1; i++)
                {
                    drawRowOfBlack(height - i);
                }
            }
            #endregion
        }
        public void drawFloatyTextPool()
        {
            if (floatyTextPool.Count > 0)
            {
                int txtH = (int)gv.drawFontRegHeight;
                //int pH = (int)((float)gv.screenHeight / 200.0f);

                foreach (FloatyText ft in floatyTextPool)
                {
                    if (gv.cc.getDistance(ft.location, new Coordinate(gv.mod.PlayerLastLocationX, gv.mod.PlayerLocationY)) > 3)
                    {
                        continue; //out of range from view so skip drawing floaty message
                    }

                    //location.X should be the the props actual map location in squares (not screen location)
                    int xLoc = (ft.location.X + gv.playerOffsetX - gv.mod.PlayerLocationX) * gv.squareSize;
                    int yLoc = ((ft.location.Y + gv.playerOffsetY - gv.mod.PlayerLocationY) * gv.squareSize) - (ft.z);

                    for (int x = -2; x <= 2; x++)
                    {
                        for (int y = -2; y <= 2; y++)
                        {
                            gv.DrawText(ft.value, new IbRect(xLoc + x + gv.oXshift + mapStartLocXinPixels, yLoc + y + txtH, gv.squareSize * 2, 1000), 0.8f, Color.Black);
                        }
                    }
                    Color colr = Color.Yellow;
                    if (ft.color.Equals("yellow"))
                    {
                        colr = Color.Yellow;
                    }
                    else if (ft.color.Equals("blue"))
                    {
                        colr = Color.Blue;
                    }
                    else if (ft.color.Equals("green"))
                    {
                        colr = Color.Lime;
                    }
                    else if (ft.color.Equals("red"))
                    {
                        colr = Color.Red;
                    }
                    else
                    {
                        colr = Color.White;
                    }
                    gv.DrawText(ft.value, new IbRect(xLoc + gv.oXshift + mapStartLocXinPixels, yLoc + txtH, gv.squareSize * 2, 1000), 0.8f, colr);
                }
            }
        }

        public void drawFloatyTextByPixelPool()
        {
            if (floatyTextByPixelPool.Count > 0)
            {
                int txtH = (int)gv.drawFontRegHeight;
                
                foreach (FloatyTextByPixel ft in floatyTextByPixelPool)
                {
                    int playerPositionXInPix = gv.oXshift + gv.screenMainMap.mapStartLocXinPixels + (gv.playerOffsetX * gv.squareSize);
                    int playerPositionYInPix = gv.playerOffsetY * gv.squareSize + gv.oYshift;

                    float floatConvertedToSquareDistanceX = (ft.floatyCarrier2.currentPixelPositionX - playerPositionXInPix) / gv.squareSize;
                    int ConvertedToSquareDistanceX = (int)Math.Ceiling(floatConvertedToSquareDistanceX);

                    float floatConvertedToSquareDistanceY = (ft.floatyCarrier2.currentPixelPositionY - playerPositionYInPix) / gv.squareSize;
                    int ConvertedToSquareDistanceY = (int)Math.Ceiling(floatConvertedToSquareDistanceY);

                    int SquareThatPixIsOnX = gv.mod.PlayerLocationX + ConvertedToSquareDistanceX;
                    int SquareThatPixIsOnY = gv.mod.PlayerLocationY + ConvertedToSquareDistanceY;


                    if (gv.cc.getDistance(new Coordinate (SquareThatPixIsOnX, SquareThatPixIsOnY), new Coordinate(gv.mod.PlayerLastLocationX, gv.mod.PlayerLocationY)) > 3)
                    {
                        continue; //out of range from view so skip drawing floaty message
                    }

                   

                    //location.X should be the the props actual map location in squares (not screen location)
                    int xLoc = (int)(ft.floatyCarrier2.currentPixelPositionX);
                    int yLoc = (int)(ft.floatyCarrier2.currentPixelPositionY) - (ft.z);

                    for (int x = -2; x <= 2; x++)
                    {
                        for (int y = -2; y <= 2; y++)
                        {
                            gv.DrawText(ft.value, new IbRect(xLoc + x, yLoc + y + txtH, gv.squareSize * 2, 1000), 0.8f, Color.Black);
                        }
                    }
                    Color colr = Color.Yellow;
                    if (ft.color.Equals("yellow"))
                    {
                        colr = Color.Yellow;
                    }
                    else if (ft.color.Equals("blue"))
                    {
                        colr = Color.Blue;
                    }
                    else if (ft.color.Equals("green"))
                    {
                        colr = Color.Lime;
                    }
                    else if (ft.color.Equals("red"))
                    {
                        colr = Color.Red;
                    }
                    else
                    {
                        colr = Color.White;
                    }
                    gv.DrawText(ft.value, new IbRect(xLoc, yLoc + txtH, gv.squareSize * 2, 1000), 0.8f, colr);
                }
            }
        }

        public void drawColumnOfBlack(int col)
        {
            if (gv.mod.useAllTileSystem)
            {
                int delayedStart = 0;
                int earlyEnd = 0;
                bool isLeftCall = false;
                bool isRightCall = false;

                //left side
                if (gv.mod.PlayerLocationX < gv.playerOffsetX + 1)
                {
                    isLeftCall = true;
                    if ((gv.mod.indexOfNorthWesternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinY + 2;
                    }

                    if ((gv.mod.indexOfSouthWesternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxY + 1;
                    }
                }

                //right side
                if (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - gv.playerOffsetX - 1))
                {
                    isRightCall = true;
                    if ((gv.mod.indexOfNorthEasternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinY + 2;
                    }

                    if ((gv.mod.indexOfSouthEasternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxY + 1;
                    }

                }


                for (int y = -1 + delayedStart; y < gv.playerOffsetY * 2 + 1 + 2 - earlyEnd; y++)
                {
                    int tlX = col * gv.squareSize;
                    int tlY = y * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 1.0f), tlY - (int)(brY * 1.1f), (int)(brX * 1.3f), (int)(brY * 1.25f));
                    /*
                    if (col >= (gv.playerOffsetX * 2 + 2))
                    {
                        dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 1.0f), tlY - (int)(brY * 1.1f), (int)(brX * 1.4f), (int)(brY * 1.1));
                    }
                    else
                    {
                        dst = new IbRect(tlX + mapStartLocXinPixels - (int)(brX * 1.0f), tlY - (int)(brY * 1.1f), (int)(brX * 1.2f), (int)(brY * 1.1));
                    }
                    */

                    bool skipDraw = false;

                    float pixDistanceToBorderOfThisAreaNorth = gv.mod.PlayerLocationY;
                    if (pixDistanceToBorderOfThisAreaNorth > gv.playerOffsetY)
                    {
                        pixDistanceToBorderOfThisAreaNorth = gv.playerOffsetY;
                    }
                    pixDistanceToBorderOfThisAreaNorth = (pixDistanceToBorderOfThisAreaNorth + 1.5f) * gv.squareSize;

                    float pixDistanceToBorderOfThisAreaSouth = (gv.mod.currentArea.MapSizeY - 1) - gv.mod.PlayerLocationY;
                    if (pixDistanceToBorderOfThisAreaSouth > gv.playerOffsetY)
                    {
                        pixDistanceToBorderOfThisAreaSouth = gv.playerOffsetY;
                    }
                    pixDistanceToBorderOfThisAreaSouth = (pixDistanceToBorderOfThisAreaSouth + 1.5f) * gv.squareSize;

                    if ((isLeftCall) && (gv.mod.indexOfWesternNeighbour != -1))
                    {
                        if (((y - 2) * gv.squareSize >= ((gv.playerOffsetY * gv.squareSize) - pixDistanceToBorderOfThisAreaNorth)) && (y * gv.squareSize <= gv.screenHeight / 2 + pixDistanceToBorderOfThisAreaSouth))
                        {
                            if (col <= gv.playerOffsetX)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if ((isRightCall) && (gv.mod.indexOfEasternNeighbour != -1))
                    {
                        if (((y - 2) * gv.squareSize >= ((gv.playerOffsetY * gv.squareSize) - pixDistanceToBorderOfThisAreaNorth)) && (y * gv.squareSize <= gv.screenHeight / 2 + pixDistanceToBorderOfThisAreaSouth))
                        {
                            if (col > gv.playerOffsetX)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if (!skipDraw)
                    {
                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                        //gv.DrawBitmap(gv.cc.hitSymbol, src, dst);
                    }
                }
            }
            else
            {
                for (int y = -1; y < gv.playerOffsetY * 2 + 1 + 2; y++)
                {
                    int tlX = col * gv.squareSize;
                    int tlY = y * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + mapStartLocXinPixels + gv.oXshift, tlY, brX, brY);

                    gv.DrawBitmap(gv.cc.black_tile, src, dst);
                }
            }
            
        }
        public void drawRowOfBlack(int row)
        {
            if (gv.mod.useAllTileSystem)
            {
                int delayedStart = 0;
                int earlyEnd = 0;
                bool isTopCall = false;
                bool isDownCall = false;

                //top side
                if (gv.mod.PlayerLocationY < gv.playerOffsetY + 1)
                {
                    isTopCall = true;
                    if ((gv.mod.indexOfNorthWesternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinX + 1;
                    }

                    if ((gv.mod.indexOfNorthEasternNeighbour != -1) && (gv.mod.seamlessModififierMinY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxX + 2;
                    }

                }

                //down side
                else if (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - gv.playerOffsetY - 1))
                {
                    isDownCall = true;
                    if ((gv.mod.indexOfSouthWesternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMinX > 0))
                    {
                        delayedStart = gv.mod.seamlessModififierMinX + 1;
                    }

                    if ((gv.mod.indexOfSouthEasternNeighbour != -1) && (gv.mod.seamlessModififierMaxY > 0) && (gv.mod.seamlessModififierMaxX > 0))
                    {
                        earlyEnd = gv.mod.seamlessModififierMaxX + 2;
                    }

                }

                for (int x = -1 + delayedStart; x < gv.playerOffsetX * 2 + 1 + 2 - earlyEnd; x++)
                {
                    int tlX = x * gv.squareSize;
                    int tlY = row * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels - (int)(brX * 0.1f), tlY - (int)(brY * 0.1f), (int)(brX * 1.2f), (int)(brY * 1.25f));
                    bool skipDraw = false;

                    float pixDistanceToBorderOfThisAreaWest = gv.mod.PlayerLocationX;
                    if (pixDistanceToBorderOfThisAreaWest > gv.playerOffsetX)
                    {
                        pixDistanceToBorderOfThisAreaWest = gv.playerOffsetX;
                    }
                    pixDistanceToBorderOfThisAreaWest = (pixDistanceToBorderOfThisAreaWest + 1.5f) * gv.squareSize;

                    float pixDistanceToBorderOfThisAreaEast = (gv.mod.currentArea.MapSizeX - 1) - gv.mod.PlayerLocationX;
                    if (pixDistanceToBorderOfThisAreaEast > gv.playerOffsetX)
                    {
                        pixDistanceToBorderOfThisAreaEast = gv.playerOffsetX;
                    }
                    pixDistanceToBorderOfThisAreaEast = (pixDistanceToBorderOfThisAreaEast + 1.5f) * gv.squareSize;


                    if ((isTopCall) && (gv.mod.indexOfNorthernNeighbour != -1))
                    {
                        if ((x * gv.squareSize >= (((gv.playerOffsetX+1) * gv.squareSize) - pixDistanceToBorderOfThisAreaWest)) && ((x+2) * gv.squareSize <= gv.screenWidth / 2 + pixDistanceToBorderOfThisAreaEast))
                        {
                            if (row <= gv.playerOffsetY)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if ((isDownCall) && (gv.mod.indexOfSouthernNeighbour != -1))
                    {
                        if ((x * gv.squareSize >= (((gv.playerOffsetX+1) * gv.squareSize) - pixDistanceToBorderOfThisAreaWest)) && ((x+2) * gv.squareSize <= gv.screenWidth / 2 + pixDistanceToBorderOfThisAreaEast))
                        {
                            if (row > gv.playerOffsetY)
                            {
                                skipDraw = true;
                            }
                        }
                    }

                    if (!skipDraw)
                    {
                        gv.DrawBitmap(gv.cc.black_tile2, src, dst);
                        //gv.DrawBitmap(gv.cc.hitSymbol, src, dst);
                    }
                }
            }
            else
            {
                for (int x = -1; x < gv.playerOffsetX * 2 + 1 + 2; x++)
                {
                    int tlX = x * gv.squareSize;
                    int tlY = row * gv.squareSize;
                    int brX = gv.squareSize;
                    int brY = gv.squareSize;
                    IbRect src = new IbRect(0, 0, gv.cc.black_tile.PixelSize.Width, gv.cc.black_tile.PixelSize.Height);
                    IbRect dst = new IbRect(tlX + gv.oXshift + mapStartLocXinPixels, tlY, brX, brY);
                    gv.DrawBitmap(gv.cc.black_tile, src, dst);
                }
            }
        }
         
               
        public void drawUiLayout()
        {
            //SET PORTRAITS
            foreach (IB2Panel pnl in mainUiLayout.panelList)
            {
                if (pnl.tag.Equals("portraitPanel"))
                {
                    foreach (IB2Portrait ptr in pnl.portraitList)
                    {
                        ptr.show = false;
                    }
                    int index = 0;
                    foreach (Player pc in gv.mod.playerList)
                    {
                        pnl.portraitList[index].show = true;
                        pnl.portraitList[index].ImgFilename = pc.portraitFilename;
                        pnl.portraitList[index].TextHP = pc.hp + "/" + pc.hpMax;
                        pnl.portraitList[index].TextSP = pc.sp + "/" + pc.spMax;
                        if (gv.mod.selectedPartyLeader == index)
                        {
                            pnl.portraitList[index].glowOn = true;
                        }
                        else
                        {
                            pnl.portraitList[index].glowOn = false;
                        }
                        index++;
                    }
                    break;
                }
            }

            mainUiLayout.Draw();
        }

        public void addFloatyText(int sqrX, int sqrY, String value, String color, int length)
        {
            floatyTextPool.Add(new FloatyText(sqrX, sqrY, value, color, length));
        }

        public void addFloatyText(Prop floatyCarrier, String value, String color, int length)
        {
            floatyTextByPixelPool.Add(new FloatyTextByPixel (floatyCarrier, value, color, length));
        }

        public void buildWeatherEffectObject (string name, string tag)
        {
            //not needed anymore, was for converting weather script 
            WeatherEffect we = new WeatherEffect();
            we.name = name;
            we.tag = tag;
            for (int j = 0; j < 6; j++)
            {
                if (j == 0)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer5;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName5;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer5IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur5;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence5;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders5;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel5;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging5;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit5;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames5;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade5;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride5;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX5;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY5;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit5;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource5;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript5;
                }

                if (j == 1)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer6;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName6;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer6IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur6;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence6;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders6;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel6;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging6;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit6;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames6;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade6;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride6;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX6;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY6;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit6;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource6;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript6;
                }

                if (j == 2)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer7;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName7;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer7IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur7;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence7;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders7;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel7;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging7;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit7;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames7;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade7;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride7;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX7;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY7;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit7;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource7;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript7;
                }

                if (j == 3)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer8;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName8;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer8IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur8;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence8;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders8;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel8;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging8;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit8;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames8;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade8;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride8;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX8;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY8;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit8;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource8;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript8;
                }

                if (j == 4)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer9;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName9;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer9IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur9;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence9;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders9;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel9;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging9;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit9;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames9;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade9;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride9;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX9;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY9;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit9;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource9;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript9;
                }

                if (j == 5)
                {
                    //#region full screen effect layer 5
                    //full screen effect layer 5
                    we.WeatherLayers[j].useFullScreenEffectLayer = gv.mod.currentArea.useFullScreenEffectLayer10;
                    we.WeatherLayers[j].fullScreenEffectLayerName = gv.mod.currentArea.fullScreenEffectLayerName10;
                    we.WeatherLayers[j].fullScreenEffectLayerIsTop = gv.mod.currentArea.FullScreenEffectLayer10IsTop;
                    we.WeatherLayers[j].fullScreenEffectChanceToOccur = gv.mod.currentArea.fullScreenEffectChanceToOccur10;
                    we.WeatherLayers[j].numberOfCyclesPerOccurence = gv.mod.currentArea.numberOfCyclesPerOccurence10;
                    we.WeatherLayers[j].containEffectInsideAreaBorders = gv.mod.currentArea.containEffectInsideAreaBorders10;
                    we.WeatherLayers[j].activateTargetChannelInParallelToThisChannel = gv.mod.currentArea.activateTargetChannelInParallelToThisChannel10;
                    we.WeatherLayers[j].isChanging = gv.mod.currentArea.isChanging10;
                    we.WeatherLayers[j].changeLimit = gv.mod.currentArea.changeLimit10;
                    we.WeatherLayers[j].changeNumberOfFrames = gv.mod.currentArea.changeNumberOfFrames10;
                    we.WeatherLayers[j].useCyclicFade = gv.mod.currentArea.useCyclicFade10;
                    we.WeatherLayers[j].directionalOverride = gv.mod.currentArea.directionalOverride10;
                    we.WeatherLayers[j].overrideSpeedX = gv.mod.currentArea.overrideSpeedX10;
                    we.WeatherLayers[j].overrideSpeedY = gv.mod.currentArea.overrideSpeedY10;
                    we.WeatherLayers[j].overrideDelayLimit = gv.mod.currentArea.overrideDelayLimit10;
                    we.WeatherLayers[j].overrideIsNoScrollSource = gv.mod.currentArea.overrideIsNoScrollSource10;
                    we.WeatherLayers[j].changeableByWeatherScript = gv.mod.currentArea.changeableByWeatherScript10;
                }

            }
            gv.mod.moduleWeatherEffectsList.Add(we);
        }

        //to test new layout system, change this to onTouchMain
        public void onTouchMain(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                    int x2 = (int)e.X;
                    int y2 = (int)e.Y;
                    if (y2 < (gv.screenHeight - 2 * gv.squareSize) && x2 < (gv.screenWidth - 2 * gv.squareSize))
                    {
                        gv.moveTimerRuns = true;
                    }
                    //isMoving = true;
                    break;

                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;

                    //NEW SYSTEM
                    mainUiLayout.setHover(x, y);
                    

                    //Draw Floaty Text On Mouse Over Prop
                    int gridx = (int)e.X / gv.squareSize;
                    int gridy = (int)e.Y / gv.squareSize;
                    int actualX = gv.mod.PlayerLocationX + (gridx - gv.playerOffsetX);
                    int actualY = gv.mod.PlayerLocationY + (gridy - gv.playerOffsetY);
                    gv.cc.floatyText = "";
                    if (IsTouchInMapWindow(gridx, gridy))
                    {
                        foreach (Prop p in gv.mod.currentArea.Props)
                        {
                            if ((p.LocationX == actualX) && (p.LocationY == actualY))
                            {
                                bool lightIsNoProblem = false;
                                if ((!gv.mod.currentArea.useLightSystem) || (gv.mod.currentArea.UseDayNightCycle))
                                {
                                    lightIsNoProblem = true;
                                }
                                else
                                {
                                    if (gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].isLit.Count > 0)
                                    {
                                        lightIsNoProblem = true;
                                    }
                                }
                                if ( (!p.MouseOverText.Equals("none")) && (gv.mod.currentArea.Tiles[actualY * gv.mod.currentArea.MapSizeX + actualX].Visible) && lightIsNoProblem)
                                {
                                    gv.cc.floatyText = p.MouseOverText;
                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, gridy * gv.squareSize);
                                }
                            }
                        }
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    gv.moveTimerRuns = false;
                    gv.moveTimerCounter = 0;
                    int actualx = -1000;
                    int actualy = -1000;
                    if (!isMoving)
                    {
                        x = gv.mousePositionX - (int)(gv.squareSize * 15f / 100f);
                        y = gv.mousePositionY - (int)(gv.squareSize * 55f / 100f);

                        //hurgh5555

                        int gridX = x / gv.squareSize;
                        int gridY = y / gv.squareSize;
                        actualx = gv.mod.PlayerLocationX + (gridX - gv.playerOffsetX);
                        actualy = gv.mod.PlayerLocationY + (gridY - gv.playerOffsetY);
                    }

                    isMoving = false;
                    x = (int)e.X;
                    y = (int)e.Y;


                    //NEW SYSTEM
                    string rtn = mainUiLayout.getImpact(x, y);

                    //check to see if toggle or button is using IBScript and do script
                    IB2Button btnScript = mainUiLayout.GetButtonByTag(rtn);
                    if (btnScript != null)
                    {
                        if ((btnScript.IBScript.Equals("none")) || (btnScript.IBScript.Equals("")))
                        {
                            //no IBScript so move on
                        }
                        else
                        {
                            gv.cc.doIBScriptBasedOnFilename(btnScript.IBScript, "");
                        }
                    }

                    if (rtn.Equals("tglGrid"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.map_showGrid = false;
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.map_showGrid = true;
                        }
                    }
                    if (rtn.Equals("tglInteractionState"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.showInteractionState = false;
                            gv.cc.addLogText("lime", "Show info about interaction state of NPC and creatures turned OFF");
                    }     
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.showInteractionState = true;
                            gv.cc.addLogText("lime", "Show info about interaction state of NPC and creatures (encounter = red, mandatory conversation = orange and optional conversation = green");
                        }
                    }
                    if (rtn.Equals("tglAvoidConversation"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.avoidInteraction = false;
                            gv.cc.addLogText("lime", "Normal move gv.mode: party does all possible conversations");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.avoidInteraction = true;
                            gv.cc.addLogText("yellow", "In a hurry: Party is avoiding all conversations that are not mandatory");
                        }
                    }

                    if (rtn.Equals("tglClock"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        tgl.toggleOn = !tgl.toggleOn;
                        showClock = !showClock;
                    }
                    if (rtn.Equals("tglSound"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            gv.mod.playMusic = false;
                            gv.mod.playSoundFx = false;
                            //TODO gv.screenCombat.tglSoundFx.toggleOn = false;
                            gv.stopMusic();
                            gv.stopAmbient();
                            gv.cc.addLogText("lime", "Music Off, SoundFX Off");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            gv.mod.playMusic = true;
                            gv.mod.playSoundFx = true;
                            //TODO gv.screenCombat.tglSoundFx.toggleOn = true;
                            gv.startMusic();
                            gv.startAmbient();
                            gv.cc.addLogText("lime", "Music On, SoundFX On");
                        }
                    }
                    if (rtn.Equals("tglFullParty"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            showFullParty = false;
                            gv.cc.addLogText("lime", "Show Party Leader");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            showFullParty = true;
                            gv.cc.addLogText("lime", "Show Full Party");
                        }
                    }
                    if (rtn.Equals("tglMiniMap"))
                    {
                        IB2ToggleButton tgl = mainUiLayout.GetToggleByTag(rtn);
                        if (tgl == null) { return; }
                        if (tgl.toggleOn)
                        {
                            tgl.toggleOn = false;
                            showMiniMap = false;
                            gv.cc.addLogText("lime", "Hide Mini Map");
                        }
                        else
                        {
                            tgl.toggleOn = true;
                            showMiniMap = true;
                            gv.cc.addLogText("lime", "Show Mini Map");
                        }
                    }

                    if (rtn.Equals("btnJournal"))
                    {
                        gv.screenType = "journal";
                    }
                    
                    else if (rtn.Equals("btnParty"))
                    {
                        gv.screenParty.resetPartyScreen();
                        gv.screenType = "party";
                        gv.cc.tutorialMessageParty(false);
                    }
                    else if ((rtn.Equals("port0")) && (gv.mod.playerList.Count > 0))
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            gv.mod.selectedPartyLeader = 0;
                            gv.cc.partyScreenPcIndex = 0;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            gv.mod.selectedPartyLeader = 0;
                            gv.cc.partyScreenPcIndex = 0;
                        }
                    }
                    else if ((rtn.Equals("port1")) && (gv.mod.playerList.Count > 1))
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            gv.mod.selectedPartyLeader = 1;
                            gv.cc.partyScreenPcIndex = 1;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            gv.mod.selectedPartyLeader = 1;
                            gv.cc.partyScreenPcIndex = 1;
                        }
                    }
                    else if ((rtn.Equals("port2")) && (gv.mod.playerList.Count > 2))
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            gv.mod.selectedPartyLeader = 2;
                            gv.cc.partyScreenPcIndex = 2;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            gv.mod.selectedPartyLeader = 2;
                            gv.cc.partyScreenPcIndex = 2;
                        }
                    }
                    else if ((rtn.Equals("port3")) && (gv.mod.playerList.Count > 3))
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            gv.mod.selectedPartyLeader = 3;
                            gv.cc.partyScreenPcIndex = 3;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            gv.mod.selectedPartyLeader = 3;
                            gv.cc.partyScreenPcIndex = 3;
                        }
                    }
                    else if ((rtn.Equals("port4")) && (gv.mod.playerList.Count > 4))
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            gv.mod.selectedPartyLeader = 4;
                            gv.cc.partyScreenPcIndex = 4;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            gv.mod.selectedPartyLeader = 4;
                            gv.cc.partyScreenPcIndex = 4;
                        }
                    }
                    else if ((rtn.Equals("port5")) && (gv.mod.playerList.Count > 5))
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            gv.mod.selectedPartyLeader = 5;
                            gv.cc.partyScreenPcIndex = 5;
                            gv.screenParty.resetPartyScreen();
                            gv.screenType = "party";
                            gv.cc.tutorialMessageParty(false);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            gv.mod.selectedPartyLeader = 5;
                            gv.cc.partyScreenPcIndex = 5;
                        }
                    }
                    else if (rtn.Equals("btnInventory"))
                    {
                        gv.screenType = "inventory";
                        gv.screenInventory.resetInventory();
                        gv.cc.tutorialMessageInventory(false);
                    }
                    else if (rtn.Equals("btnSettings"))
                    {
                        gv.cc.doSettingsDialogs();
                    }
                    else if (rtn.Equals("btnSave"))
                    {
                        if (gv.mod.allowSave)
                        {
                            gv.cc.doSavesDialog();
                        }
                    }
                    else if (rtn.Equals("btnWait"))
                    {
                        gv.cc.doUpdate();
                    }

                    else if (rtn.Equals("btnCastOnMainMap"))
                    {

                        List<string> pcNames = new List<string>();
                        List<int> pcIndex = new List<int>();
                        pcNames.Add("cancel");

                        int cnt = 0;
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.isAlive())
                            {
                                if (hasMainMapTypeSpell(p))
                                {
                                    pcNames.Add(p.name);
                                    pcIndex.Add(cnt);
                                }
                            }
                            cnt++;
                        }

                        //If only one PC, do not show select PC dialog...just go to cast selector
                        if (pcIndex.Count == 1)
                        {
                            try
                            {
                                gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                                gv.screenCombat.spellSelectorIndex = 0;
                                gv.screenType = "mainMapCast";
                                return;
                            }
                            catch (Exception ex)
                            {
                                //print error
                                IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                gv.errorLog(ex.ToString());
                                return;
                            }
                        }

                        using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Caster"))
                        {
                            pcSel.ShowDialog();

                            if (pcSel.selectedIndex > 0)
                            {
                                try
                                {
                                    gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                    gv.screenCombat.spellSelectorIndex = 0;
                                    gv.screenType = "mainMapCast";
                                }
                                catch (Exception ex)
                                {
                                    IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                    gv.errorLog(ex.ToString());
                                    //print error
                                }
                            }
                            else if (pcSel.selectedIndex == 0) // selected "cancel"
                            {
                                //do nothing
                            }
                        }
                    }

                    //adding lines for trait use button on main map
                    else if (rtn.Equals("btnUseTraitOnMainMap"))
                    {

                        List<string> pcNames = new List<string>();
                        List<int> pcIndex = new List<int>();
                        pcNames.Add("cancel");

                        int cnt = 0;
                        foreach (Player p in gv.mod.playerList)
                        {
                            if (p.isAlive())
                            {
                                if (p.knownOutsideCombatUsableTraitsTags.Count > 0)
                                {
                                    pcNames.Add(p.name);
                                    pcIndex.Add(cnt);
                                }
                            }
                            cnt++;
                        }

                        //If only one PC, do not show select PC dialog...just go to cast selector
                        if (pcIndex.Count == 1)
                        {
                            try
                            {
                                gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                                gv.screenCombat.spellSelectorIndex = 0;
                                gv.screenType = "mainMapTraitUse";
                                return;
                            }
                            catch (Exception ex)
                            {
                                //print error
                                IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                gv.errorLog(ex.ToString());
                                return;
                            }
                        }

                        using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Character"))
                        {
                            pcSel.ShowDialog();

                            if (pcSel.selectedIndex > 0)
                            {
                                try
                                {
                                    gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                    gv.screenCombat.spellSelectorIndex = 0;
                                    gv.screenType = "mainMapTraitUse";
                                }
                                catch (Exception ex)
                                {
                                    IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                    gv.errorLog(ex.ToString());
                                    //print error
                                }
                            }
                            else if (pcSel.selectedIndex == 0) // selected "cancel"
                            {
                                //do nothing
                            }
                        }
                    }

                    else if (rtn.Equals("btnToggleArrows"))
                    {
                        foreach (IB2Panel pnl in mainUiLayout.panelList)
                        {
                            if (pnl.tag.Equals("arrowPanel"))
                            {
                                showArrows = !showArrows;
                                //hides down
                                if (pnl.currentLocY > pnl.shownLocY)
                                {
                                    pnl.showing = true;
                                }
                                else
                                {
                                    pnl.hiding = true;
                                }
                            }                            
                        }
                    }
                    else if ((rtn.Equals("ctrlUpArrow")) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY - 1) >= actualy)))
                    //if (rtn.Equals("ctrlUpArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool isTransition = gv.cc.goNorth();
                            if (!isTransition)
                            {
                                if (gv.mod.PlayerLocationY > 0)
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationY--;
                                        gv.cc.doUpdate();
                                    }
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlDownArrow")) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY + 1) <= actualy)))
                    //else if (rtn.Equals("ctrlDownArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool isTransition = gv.cc.goSouth();
                            if (!isTransition)
                            {
                                int mapheight = gv.mod.currentArea.MapSizeY;
                                if (gv.mod.PlayerLocationY < (mapheight - 1))
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationY++;
                                        gv.cc.doUpdate();
                                    }
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlLeftArrow")) || (((gv.mod.PlayerLocationX - 1) >= actualx) && (gv.mod.PlayerLocationY == actualy)))
                    //else if (rtn.Equals("ctrlLeftArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool isTransition = gv.cc.goWest();
                            if (!isTransition)
                            {
                                if (gv.mod.PlayerLocationX > 0)
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationX--;
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if (!pc.combatFacingLeft)
                                            {
                                                pc.combatFacingLeft = true;
                                            }
                                        }
                                        gv.cc.doUpdate();
                                    }
                                }
                            }
                        }
                    }
                    else if ((rtn.Equals("ctrlRightArrow")) || (((gv.mod.PlayerLocationX + 1) <= actualx) && (gv.mod.PlayerLocationY == actualy)))
                    //else if (rtn.Equals("ctrlRightArrow"))

                    {
                        if (!gv.moveTimerRuns)
                        {
                            bool isTransition = gv.cc.goEast();
                            if (!isTransition)
                            {
                                int mapwidth = gv.mod.currentArea.MapSizeX;
                                if (gv.mod.PlayerLocationX < (mapwidth - 1))
                                {
                                    if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                                    {
                                        gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                        gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                        gv.mod.PlayerLocationX++;
                                        foreach (Player pc in gv.mod.playerList)
                                        {
                                            if (pc.combatFacingLeft)
                                            {
                                                pc.combatFacingLeft = false;
                                            }
                                        }
                                        gv.cc.doUpdate();
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
        //to test new layout system, change this to onTouchMainOld
        /*public void onTouchMainOld(MouseEventArgs e, MouseEventType.EventType eventType)
        {
            gv.cc.ctrlUpArrow.glowOn = false;
            gv.cc.ctrlDownArrow.glowOn = false;
            gv.cc.ctrlLeftArrow.glowOn = false;
            gv.cc.ctrlRightArrow.glowOn = false;
            btnParty.glowOn = false;
            gv.cc.btnInventory.glowOn = false;
            btnJournal.glowOn = false;
            btnSettings.glowOn = false;
            btnSave.glowOn = false;
            btnCastOnMainMap.glowOn = false;
            btnWait.glowOn = false;

            switch (eventType)
            {
                case MouseEventType.EventType.MouseDown:
                case MouseEventType.EventType.MouseMove:
                    int x = (int)e.X;
                    int y = (int)e.Y;

                    //Draw Floaty Text On Mouse Over Prop
                    int gridx = (int)e.X / gv.squareSize;
                    int gridy = (int)e.Y / gv.squareSize;
                    int actualX = gv.mod.PlayerLocationX + (gridx - gv.playerOffsetX);
                    int actualY = gv.mod.PlayerLocationY + (gridy - gv.playerOffsetY);
                    gv.cc.floatyText = "";
                    if (IsTouchInMapWindow(gridx, gridy))
                    {
                        foreach (Prop p in gv.mod.currentArea.Props)
                        {
                            if ((p.LocationX == actualX) && (p.LocationY == actualY))
                            {
                                if (!p.MouseOverText.Equals("none"))
                                {
                                    gv.cc.floatyText = p.MouseOverText;
                                    gv.cc.floatyTextLoc = new Coordinate(gridx * gv.squareSize, gridy * gv.squareSize);
                                }
                            }
                        }
                    }

                    

                    if (gv.cc.ctrlUpArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlUpArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlDownArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlDownArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlLeftArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlLeftArrow.glowOn = true;
                    }
                    else if (gv.cc.ctrlRightArrow.getImpact(x, y))
                    {
                        gv.cc.ctrlRightArrow.glowOn = true;
                    }
                    else if (btnParty.getImpact(x, y))
                    {
                        btnParty.glowOn = true;
                    }
                    else if (gv.cc.btnInventory.getImpact(x, y))
                    {
                        gv.cc.btnInventory.glowOn = true;
                    }
                    else if (btnJournal.getImpact(x, y))
                    {
                        btnJournal.glowOn = true;
                    }
                    else if (btnSettings.getImpact(x, y))
                    {
                        btnSettings.glowOn = true;
                    }
                    else if (btnSave.getImpact(x, y))
                    {
                        if (gv.mod.allowSave)
                        {
                            btnSave.glowOn = true;
                        }
                    }
                    else if (btnCastOnMainMap.getImpact(x, y))
                    {
                        btnCastOnMainMap.glowOn = true;
                    }
                    else if (btnWait.getImpact(x, y))
                    {
                        btnWait.glowOn = true;
                    }
                    break;

                case MouseEventType.EventType.MouseUp:
                    x = (int)e.X;
                    y = (int)e.Y;
                    int gridX = (int)e.X / gv.squareSize;
                    int gridY = (int)e.Y / gv.squareSize;
                    int actualx = gv.mod.PlayerLocationX + (gridX - gv.playerOffsetX);
                    int actualy = gv.mod.PlayerLocationY + (gridY - gv.playerOffsetY);

                    gv.cc.ctrlUpArrow.glowOn = false;
                    gv.cc.ctrlDownArrow.glowOn = false;
                    gv.cc.ctrlLeftArrow.glowOn = false;
                    gv.cc.ctrlRightArrow.glowOn = false;
                    btnParty.glowOn = false;
                    gv.cc.btnInventory.glowOn = false;
                    btnJournal.glowOn = false;
                    btnSettings.glowOn = false;
                    btnSave.glowOn = false;
                    btnCastOnMainMap.glowOn = false;
                    btnWait.glowOn = false;

                    if (tglGrid.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglGrid.toggleOn)
                        {
                            tglGrid.toggleOn = false;
                            gv.mod.map_showGrid = false;
                        }
                        else
                        {
                            tglGrid.toggleOn = true;
                            gv.mod.map_showGrid = true;
                        }
                    }

                    if (tglInteractionState.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglInteractionState.toggleOn)
                        {
                            tglInteractionState.toggleOn = false;
                            gv.mod.showInteractionState = false;
                            gv.cc.addLogText("yellow", "Hide info about interaction state of NPC and creatures (encounter = red, mandatory conversation = orange and optional conversation = green");
                        }
                        else
                        {
                            tglInteractionState.toggleOn = true;
                            gv.mod.showInteractionState = true;
                            gv.cc.addLogText("lime", "Show info about interaction state of NPC and creatures (encounter = red, mandatory conversation = orange and optional conversation = green");
                        }
                    }

                    if (tglAvoidConversation.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglAvoidConversation.toggleOn)
                        {
                            tglAvoidConversation.toggleOn = false;
                            gv.mod.avoidInteraction = false;
                            gv.cc.addLogText("lime", "Normal move gv.mode: party does all possible conversations");
                        }
                        else
                        {
                            tglAvoidConversation.toggleOn = true;
                            gv.mod.avoidInteraction = true;
                            gv.cc.addLogText("yellow", "In a hurry: Party is avoiding all conversations that are not mandatory");
                        }
                    }


                    if (tglClock.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglClock.toggleOn)
                        {
                            tglClock.toggleOn = false;
                        }
                        else
                        {
                            tglClock.toggleOn = true;
                        }
                    }
                    if (gv.cc.tglSound.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (gv.cc.tglSound.toggleOn)
                        {
                            gv.cc.tglSound.toggleOn = false;
                            gv.mod.playMusic = false;
                            gv.mod.playSoundFx = false;
                            gv.screenCombat.tglSoundFx.toggleOn = false;
                            gv.stopMusic();
                            gv.stopAmbient();
                            gv.cc.addLogText("lime", "Music Off, SoundFX Off");
                        }
                        else
                        {
                            gv.cc.tglSound.toggleOn = true;
                            gv.mod.playMusic = true;
                            gv.mod.playSoundFx = true;
                            gv.screenCombat.tglSoundFx.toggleOn = true;
                            gv.startMusic();
                            gv.startAmbient();
                            gv.cc.addLogText("lime", "Music On, SoundFX On");
                        }
                    }
                    if (tglFullParty.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglFullParty.toggleOn)
                        {
                            tglFullParty.toggleOn = false;
                            gv.cc.addLogText("lime", "Show Party Leader");
                        }
                        else
                        {
                            tglFullParty.toggleOn = true;
                            gv.cc.addLogText("lime", "Show Full Party");
                        }
                    }
                    //if ((tglMiniMap.getImpact(x, y)) && (gv.mod.currentArea.IsWorldMap))
                    if (tglMiniMap.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        if (tglMiniMap.toggleOn)
                        {
                            tglMiniMap.toggleOn = false;
                            gv.cc.addLogText("lime", "Hide Mini Map");
                        }
                        else
                        {
                            tglMiniMap.toggleOn = true;
                            gv.cc.addLogText("lime", "Show Mini Map");
                        }
                    }
                    if ((gv.cc.ctrlUpArrow.getImpact(x, y)) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY - 1) == actualy)))
                    {
                        bool isTransition = gv.cc.goNorth();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            if (gv.mod.PlayerLocationY > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1) == false)
                                {
                                    
                                    //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationY--;
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                        //else
                        //{
                            //gv.cc.doUpdate();
                        //}
                    }
                    else if ((gv.cc.ctrlDownArrow.getImpact(x, y)) || ((gv.mod.PlayerLocationX == actualx) && ((gv.mod.PlayerLocationY + 1) == actualy)))
                    {

                        bool isTransition = gv.cc.goSouth();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            int mapheight = gv.mod.currentArea.MapSizeY;
                            if (gv.mod.PlayerLocationY < (mapheight - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1) == false)
                                {
                                   
                                        //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationY++;
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if ((gv.cc.ctrlLeftArrow.getImpact(x, y)) || (((gv.mod.PlayerLocationX - 1) == actualx) && (gv.mod.PlayerLocationY == actualy)))
                    {
                        bool isTransition = gv.cc.goWest();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            if (gv.mod.PlayerLocationX > 0)
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY) == false)
                                {

                                        //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationX--;
                                    if (!gv.mod.playerList[0].combatFacingLeft)
                                    {
                                        //TODO							    //gv.mod.partyTokenBitmap = gv.cc.flip(gv.mod.partyTokenBitmap);
                                    }
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        if (!pc.combatFacingLeft)
                                        {
                                            pc.combatFacingLeft = true;
                                        }
                                    }
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if ((gv.cc.ctrlRightArrow.getImpact(x, y)) || (((gv.mod.PlayerLocationX + 1) == actualx) && (gv.mod.PlayerLocationY == actualy)))
                    {
                        bool isTransition = gv.cc.goEast();
                        if (!isTransition)
                        {
                            //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                            //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                            int mapwidth = gv.mod.currentArea.MapSizeX;
                            if (gv.mod.PlayerLocationX < (mapwidth - 1))
                            {
                                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY) == false)
                                {
                                    
                                        //gv.mod.blockTrigger = false;
                                    //gv.mod.blockTriggerMovingProp = false;

                                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                                    gv.mod.PlayerLocationX++;
                                    if (gv.mod.playerList[0].combatFacingLeft)
                                    {
                                        //TODO							    gv.mod.partyTokenBitmap = gv.cc.flip(gv.mod.partyTokenBitmap);
                                    }
                                    foreach (Player pc in gv.mod.playerList)
                                    {
                                        if (pc.combatFacingLeft)
                                        {
                                            pc.combatFacingLeft = false;
                                        }
                                    }
                                    gv.cc.doUpdate();
                                }
                            }
                        }
                    }
                    else if (btnParty.getImpact(x, y))
                    {
                        //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                        //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                        
                        /*
                        //temporary weather effect object creation code
                        //hurghxxx
                        gv.cc.doIBScriptBasedOnFilename("cloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("cloudsA", "cloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("cloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("cloudsB", "cloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("cloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("cloudsC", "cloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("lightCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightCloudsA", "lightCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("lightCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightCloudsB", "lightCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("lightCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightCloudsC", "lightCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyCloudsA", "heavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyCloudsB", "heavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyCloudsC", "heavyCloudsC1001");

                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsA", "lightRainWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsB", "lightRainWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsC", "lightRainWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsA", "rainWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsB", "rainWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsC", "rainWithCloudsC1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsA", "lightSnowWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsB", "lightSnowWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsC", "lightSnowWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsA", "snowWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsB", "snowWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsC", "snowWithCloudsC1001");


                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsAShowers", "lightRainWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsBShowers", "lightRainWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithCloudsCShowers", "lightRainWithCloudsCShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsAShowers", "rainWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsBShowers", "rainWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithCloudsCShowers", "rainWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsAShowers", "lightSnowWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsBShowers", "lightSnowWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithCloudsCShowers", "lightSnowWithCloudsCShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsAShowers", "snowWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsBShowers", "snowWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithCloudsCShowers", "snowWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsA", "rainWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsB", "rainWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsC", "rainWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsAShowers", "rainWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsBShowers", "rainWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyCloudsCShowers", "rainWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsA", "snowWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsB", "snowWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsC", "snowWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsAShowers", "snowWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsBShowers", "snowWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyCloudsCShowers", "snowWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsA", "heavyRainWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsB", "heavyRainWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsC", "heavyRainWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsAShowers", "heavyRainWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsBShowers", "heavyRainWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyCloudsCShowers", "heavyRainWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsA", "heavySnowWithHeavyCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsB", "heavySnowWithHeavyCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsC", "heavySnowWithHeavyCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsAShowers", "heavySnowWithHeavyCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsBShowers", "heavySnowWithHeavyCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyCloudsCShowers", "heavySnowWithHeavyCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsA", "heavyRainWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsB", "heavyRainWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsC", "heavyRainWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsAShowers", "heavyRainWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsBShowers", "heavyRainWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsCShowers", "heavyRainWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsA", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsA", "heavySnowWithCloudsA1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsB", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsB", "heavySnowWithCloudsB1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsC", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsC", "heavySnowWithCloudsC1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsAShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsAShowers", "heavySnowWithCloudsAShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsBShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsBShowers", "heavySnowWithCloudsBShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsCShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsCShowers", "heavySnowWithCloudsCShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsAAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsAAndLightning", "heavyRainWithCloudsAAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsBAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsBAndLightning", "heavyRainWithCloudsBAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithCloudsCAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithCloudsCAndLightning", "heavyRainWithCloudsCAndLightning1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsAAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsAAndLightning", "heavySnowWithCloudsAAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsBAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsBAndLightning", "heavySnowWithCloudsBAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithCloudsCAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithCloudsCAndLightning", "heavySnowWithCloudsCAndLightning1001");

                        gv.cc.doIBScriptBasedOnFilename("lightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightFog", "lightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("fog", "fullScreenEffectScript");
                        buildWeatherEffectObject("fog", "fog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyFog", "heavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("lightRainWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithLightFog", "lightRainWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithFog", "lightRainWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithHeavyFog", "lightRainWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("rainWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithLightFog", "rainWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithFog", "rainWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyFog", "rainWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithLightFog", "heavyRainWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithFog", "heavyRainWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyFog", "heavyRainWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("lightRainWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithLightFogShowers", "lightRainWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithFogShowers", "lightRainWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightRainWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightRainWithHeavyFogShowers", "lightRainWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("rainWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithLightFogShowers", "rainWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithFogShowers", "rainWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("rainWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("rainWithHeavyFogShowers", "rainWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithLightFogShowers", "heavyRainWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithFogShowers", "heavyRainWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyFogShowers", "heavyRainWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithLightFogAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithLightFogAndLightning", "heavyRainWithLightFogAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithFogAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithFogAndLightning", "heavyRainWithFogAndLightning1001");
                        gv.cc.doIBScriptBasedOnFilename("heavyRainWithHeavyFogAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavyRainWithHeavyFogAndLightning", "heavyRainWithHeavyFogAndLightning1001");



                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithLightFog", "lightSnowWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithFog", "lightSnowWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithHeavyFog", "lightSnowWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("snowWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithLightFog", "snowWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithFog", "snowWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyFog", "snowWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithLightFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithLightFog", "heavySnowWithLightFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithFog", "heavySnowWithFog1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyFog", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyFog", "heavySnowWithHeavyFog1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithLightFogShowers", "lightSnowWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithFogShowers", "lightSnowWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("lightSnowWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSnowWithHeavyFogShowers", "lightSnowWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("snowWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithLightFogShowers", "snowWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithFogShowers", "snowWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("snowWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("snowWithHeavyFogShowers", "snowWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithLightFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithLightFogShowers", "heavySnowWithLightFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithFogShowers", "heavySnowWithFogShowers1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySnowWithHeavyFogShowers", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySnowWithHeavyFogShowers", "heavySnowWithHeavyFogShowers1001");

                        gv.cc.doIBScriptBasedOnFilename("lightSandStorm", "fullScreenEffectScript");
                        buildWeatherEffectObject("lightSandStorm", "lightSandStorm1001");
                        gv.cc.doIBScriptBasedOnFilename("sandStorm", "fullScreenEffectScript");
                        buildWeatherEffectObject("sandStorm", "sandStorm1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySandStorm", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySandStorm", "heavySandStorm1001");
                        gv.cc.doIBScriptBasedOnFilename("heavySandStormAndLightning", "fullScreenEffectScript");
                        buildWeatherEffectObject("heavySandStormAndLightning", "heavySandStormAndLightning1001");

                        gv.cc.doIBScriptBasedOnFilename("clear", "fullScreenEffectScript");
                        buildWeatherEffectObject("clear", "clear1001");
                        
                        //temporara end
                        */
        /*
                                gv.screenParty.resetPartyScreen();
                                gv.screenType = "party";
                                gv.cc.tutorialMessageParty(false);
                            }
                            else if ((gv.cc.ptrPc0.getImpact(x, y)) && (gv.mod.playerList.Count > 0))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 0;
                                    gv.cc.partyScreenPcIndex = 0;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 0;
                                    gv.cc.partyScreenPcIndex = 0;
                                }
                            }
                            else if ((gv.cc.ptrPc1.getImpact(x, y)) && (gv.mod.playerList.Count > 1))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 1;
                                    gv.cc.partyScreenPcIndex = 1;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 1;
                                    gv.cc.partyScreenPcIndex = 1;
                                }
                            }
                            else if ((gv.cc.ptrPc2.getImpact(x, y)) && (gv.mod.playerList.Count > 2))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 2;
                                    gv.cc.partyScreenPcIndex = 2;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 2;
                                    gv.cc.partyScreenPcIndex = 2;
                                }
                            }
                            else if ((gv.cc.ptrPc3.getImpact(x, y)) && (gv.mod.playerList.Count > 3))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 3;
                                    gv.cc.partyScreenPcIndex = 3;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 3;
                                    gv.cc.partyScreenPcIndex = 3;
                                }
                            }
                            else if ((gv.cc.ptrPc4.getImpact(x, y)) && (gv.mod.playerList.Count > 4))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 4;
                                    gv.cc.partyScreenPcIndex = 4;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 4;
                                    gv.cc.partyScreenPcIndex = 4;
                                }
                            }
                            else if ((gv.cc.ptrPc5.getImpact(x, y)) && (gv.mod.playerList.Count > 5))
                            {
                                if (e.Button == MouseButtons.Left)
                                {
                                    gv.mod.selectedPartyLeader = 5;
                                    gv.cc.partyScreenPcIndex = 5;
                                    gv.screenParty.resetPartyScreen();
                                    gv.screenType = "party";
                                    gv.cc.tutorialMessageParty(false);
                                }
                                else if (e.Button == MouseButtons.Right)
                                {
                                    gv.mod.selectedPartyLeader = 5;
                                    gv.cc.partyScreenPcIndex = 5;
                                }
                            }
                            else if (gv.cc.btnInventory.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.screenType = "inventory";
                                gv.screenInventory.resetInventory();
                                gv.cc.tutorialMessageInventory(false);
                            }
                            else if (btnJournal.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.screenType = "journal";
                            }
                            else if (btnSettings.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.cc.doSettingsDialogs();
                            }
                            else if (btnSave.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                if (gv.mod.allowSave)
                                {
                                    gv.cc.doSavesDialog();
                                }
                            }
                            else if (btnWait.getImpact(x, y))
                            {
                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}
                                gv.cc.doUpdate();
                            }
                            else if (btnCastOnMainMap.getImpact(x, y))
                            {

                                //if (gv.mod.playButtonSounds) {gv.playSoundEffect(android.view.SoundEffectConstants.CLICK);}
                                //if (gv.mod.playButtonHaptic) {gv.performHapticFeedback(android.view.HapticFeedbackConstants.VIRTUAL_KEY);}

                                List<string> pcNames = new List<string>();
                                List<int> pcIndex = new List<int>();
                                pcNames.Add("cancel");

                                int cnt = 0;
                                foreach (Player p in gv.mod.playerList)
                                {
                                    if (hasMainMapTypeSpell(p))
                                    {
                                        pcNames.Add(p.name);
                                        pcIndex.Add(cnt);
                                    }
                                    cnt++;
                                }

                                //If only one PC, do not show select PC dialog...just go to cast selector
                                if (pcIndex.Count == 1)
                                {
                                    try
                                    {
                                        gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                                        gv.screenCombat.spellSelectorIndex = 0;
                                        gv.screenType = "mainMapCast";
                                        return;
                                    }
                                    catch (Exception ex)
                                    {
                                        //print error
                                        IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                        gv.errorLog(ex.ToString());
                                        return;
                                    }
                                }

                                using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Caster"))
                                {
                                    pcSel.ShowDialog();

                                    if (pcSel.selectedIndex > 0)
                                    {
                                        try
                                        {
                                            gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                                            gv.screenCombat.spellSelectorIndex = 0;
                                            gv.screenType = "mainMapCast";
                                        }
                                        catch (Exception ex)
                                        {
                                            IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                                            gv.errorLog(ex.ToString());
                                            //print error
                                        }
                                    }
                                    else if (pcSel.selectedIndex == 0) // selected "cancel"
                                    {
                                        //do nothing
                                    }
                                }
                            }
                            break;
                    }
                }*/
        public void onKeyUp(Keys keyData)
        {
            if ((moveDelay()) && (finishedMove))
            {
                if (keyData == Keys.Left | keyData == Keys.D4 | keyData == Keys.NumPad4)
                {
                    bool isTransition = gv.cc.goWest();
                    if (!isTransition)
                    {
                        moveLeft();
                    }
                }
                else if (keyData == Keys.Right | keyData == Keys.D6 | keyData == Keys.NumPad6)
                {
                    bool isTransition = gv.cc.goEast();
                    if (!isTransition)
                    {
                        moveRight();
                    }
                }
                else if (keyData == Keys.Up | keyData == Keys.D8 | keyData == Keys.NumPad8)
                {
                    bool isTransition = gv.cc.goNorth();
                    if (!isTransition)
                    {
                        moveUp();
                    }
                }
                else if (keyData == Keys.Down | keyData == Keys.D2 | keyData == Keys.NumPad2)
                {
                    bool isTransition = gv.cc.goSouth();
                    if (!isTransition)
                    {
                        moveDown();
                    }
                }
                else { }
            }
            if (keyData == Keys.Q)
            {
                if (gv.mod.allowSave)
                {
                    gv.cc.QuickSave();
                    gv.cc.addLogText("lime", "Quicksave Completed");
                }
                else
                {
                    gv.cc.addLogText("red", "No save allowed at this time.");
                }
            }
            else if (keyData == Keys.D)
            {
                if (gv.mod.debugMode)
                {
                    gv.mod.debugMode = false;
                    gv.cc.addLogText("lime", "debugMode Turned Off");
                }
                else
                {
                    gv.mod.debugMode = true;
                    gv.cc.addLogText("lime", "debugMode Turned On");
                }
            }
            else if (keyData == Keys.I)
            {
                gv.screenType = "inventory";
                gv.screenInventory.resetInventory();
                gv.cc.tutorialMessageInventory(false);
            }
            else if (keyData == Keys.J)
            {
                gv.screenType = "journal";
            }
            else if (keyData == Keys.P)
            {
                gv.screenParty.resetPartyScreen();
                gv.screenType = "party";
                gv.cc.tutorialMessageParty(false);
            }
            else if (keyData == Keys.C)
            {
                List<string> pcNames = new List<string>();
                List<int> pcIndex = new List<int>();
                pcNames.Add("cancel");

                int cnt = 0;
                foreach (Player p in gv.mod.playerList)
                {
                    if (hasMainMapTypeSpell(p))
                    {
                        pcNames.Add(p.name);
                        pcIndex.Add(cnt);
                    }
                    cnt++;
                }

                //If only one PC, do not show select PC dialog...just go to cast selector
                if (pcIndex.Count == 1)
                {
                    try
                    {
                        gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                        gv.screenCombat.spellSelectorIndex = 0;
                        gv.screenType = "mainMapCast";
                        return;
                    }
                    catch (Exception ex)
                    {
                        //print error
                        IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                        gv.errorLog(ex.ToString());
                        return;
                    }
                }

                using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Caster"))
                {
                    pcSel.ShowDialog();

                    if (pcSel.selectedIndex > 0)
                    {
                        try
                        {
                            gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                            gv.screenCombat.spellSelectorIndex = 0;
                            gv.screenType = "mainMapCast";
                        }
                        catch (Exception ex)
                        {
                            IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                            gv.errorLog(ex.ToString());
                            //print error
                        }
                    }
                    else if (pcSel.selectedIndex == 0) // selected "cancel"
                    {
                        //do nothing
                    }
                }
            }

            //adding lines for trait use via hotkey on main map
            else if (keyData == Keys.T)
            {
                List<string> pcNames = new List<string>();
                List<int> pcIndex = new List<int>();
                pcNames.Add("cancel");

                int cnt = 0;
                foreach (Player p in gv.mod.playerList)
                {
                    if (p.knownOutsideCombatUsableTraitsTags.Count > 0)
                    {
                        pcNames.Add(p.name);
                        pcIndex.Add(cnt);
                    }
                    cnt++;
                }

                //If only one PC, do not show select PC dialog...just go to cast selector
                if (pcIndex.Count == 1)
                {
                    try
                    {
                        gv.screenCastSelector.castingPlayerIndex = pcIndex[0];
                        gv.screenCombat.spellSelectorIndex = 0;
                        gv.screenType = "mainMapTraitUse";
                        return;
                    }
                    catch (Exception ex)
                    {
                        //print error
                        IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                        gv.errorLog(ex.ToString());
                        return;
                    }
                }

                using (ItemListSelector pcSel = new ItemListSelector(gv, pcNames, "Select Character"))
                {
                    pcSel.ShowDialog();

                    if (pcSel.selectedIndex > 0)
                    {
                        try
                        {
                            gv.screenCastSelector.castingPlayerIndex = pcIndex[pcSel.selectedIndex - 1]; // pcIndex.get(item - 1);
                            gv.screenCombat.spellSelectorIndex = 0;
                            gv.screenType = "mainMapTraitUse";
                        }
                        catch (Exception ex)
                        {
                            IBMessageBox.Show(gv, "error with Pc Selector screen: " + ex.ToString());
                            gv.errorLog(ex.ToString());
                            //print error
                        }
                    }
                    else if (pcSel.selectedIndex == 0) // selected "cancel"
                    {
                        //do nothing
                    }
                }
            }


            else if (keyData == Keys.X)
            {
                if (!hideClock)
                {
                    hideClock = true;
                }
                else
                {
                    hideClock = false;
                }
                foreach (IB2Panel pnl in mainUiLayout.panelList)
                {
                    //hides left
                    if (pnl.hidingXIncrement < 0)
                    {
                        if (pnl.currentLocX < pnl.shownLocX)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                    //hides right
                    else if (pnl.hidingXIncrement > 0)
                    {
                        if (pnl.currentLocX > pnl.shownLocX)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                    //hides down
                    else if (pnl.hidingYIncrement > 0)
                    {
                        if (pnl.currentLocY > pnl.shownLocY)
                        {
                            if ((pnl.tag.Equals("arrowPanel")) && (!showArrows)) //don't show arrows
                            {
                                continue;
                            }
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                    //hides up
                    else if (pnl.hidingYIncrement < 0)
                    {
                        if (pnl.currentLocY < pnl.shownLocY)
                        {
                            pnl.showing = true;
                        }
                        else
                        {
                            pnl.hiding = true;
                        }
                    }
                }
            }
        }
        private bool moveDelay()
        {
            long elapsed = DateTime.Now.Ticks - timeStamp;
            if (elapsed > 10000 * movementDelayInMiliseconds) //10,000 ticks in 1 ms
            {
                timeStamp = DateTime.Now.Ticks;
                return true;
            }
            return false;
        }
        private void moveLeft()
        {
            if (gv.mod.PlayerLocationX > 0)
            {
                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX - 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                {
                   
                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;

                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationX--;
                    foreach (Player pc in gv.mod.playerList)
                    {
                        if (!pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = true;
                        }
                    }
                    gv.cc.doUpdate();
                }
            }
        }
        private void moveRight()
        {
            int mapwidth = gv.mod.currentArea.MapSizeX;
            if (gv.mod.PlayerLocationX < (mapwidth - 1))
            {
                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX + 1, gv.mod.PlayerLocationY, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                {
                    
                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;
                   
                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationX++;
                    foreach (Player pc in gv.mod.playerList)
                    {
                        if (pc.combatFacingLeft)
                        {
                            pc.combatFacingLeft = false;
                        }
                    }
                    gv.cc.doUpdate();
                }
            }
        }
        private void moveUp()
        {
            if (gv.mod.PlayerLocationY > 0)
            {
                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY - 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                {

                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;

                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationY--;
                    gv.cc.doUpdate();
                }
            }
        }
        private void moveDown()
        {
            int mapheight = gv.mod.currentArea.MapSizeY;
            if (gv.mod.PlayerLocationY < (mapheight - 1))
            {
                if (gv.mod.currentArea.GetBlocked(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY + 1, gv.mod.PlayerLocationX, gv.mod.PlayerLocationY, gv.mod.PlayerLastLocationX, gv.mod.PlayerLastLocationY) == false)
                {
                   
                    //gv.mod.blockTrigger = false;
                    //gv.mod.blockTriggerMovingProp = false;

                    gv.mod.PlayerLastLocationX = gv.mod.PlayerLocationX;
                    gv.mod.PlayerLastLocationY = gv.mod.PlayerLocationY;
                    gv.mod.PlayerLocationY++;
                    gv.cc.doUpdate();
                }
            }
        }
        public List<string> wrapList(string str, int wrapLength)
        {
            if (str == null)
            {
                return null;
            }
            if (wrapLength < 1)
            {
                wrapLength = 1;
            }
            int inputLineLength = str.Length;
            int offset = 0;
            List<string> returnList = new List<string>();

            while ((inputLineLength - offset) > wrapLength)
            {
                if (str.ElementAt(offset) == ' ')
                {
                    offset++;
                    continue;
                }

                int spaceToWrapAt = str.LastIndexOf(' ', wrapLength + offset);

                if (spaceToWrapAt >= offset)
                {
                    // normal case
                    returnList.Add(str.Substring(offset, spaceToWrapAt));
                    offset = spaceToWrapAt + 1;
                }
                else
                {
                    // do not wrap really long word, just extend beyond limit
                    spaceToWrapAt = str.IndexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0)
                    {
                        returnList.Add(str.Substring(offset, spaceToWrapAt));
                        offset = spaceToWrapAt + 1;
                    }
                    else
                    {
                        returnList.Add(str.Substring(offset));
                        offset = inputLineLength;
                    }
                }
            }

            // Whatever is left in line is short enough to just pass through
            returnList.Add(str.Substring(offset));
            return returnList;
        }
        
        private void setExplored()
        {
            if (gv.mod.useAllTileSystem)
            {
                #region New System
                //XXXXXXXXXXXXXXXXXXXXXXXXX
                int indexOfNorthernNeighbour = -1;
                int indexOfSouthernNeighbour = -1;
                int indexOfEasternNeighbour = -1;
                int indexOfWesternNeighbour = -1;
                int indexOfNorthEasternNeighbour = -1;
                int indexOfNorthWesternNeighbour = -1;
                int indexOfSouthEasternNeighbour = -1;
                int indexOfSouthWesternNeighbour = -1;

                int seamlessModififierMinX = 0;
                int seamlessModififierMaxX = 0;
                int seamlessModififierMinY = 0;
                int seamlessModififierMaxY = 0;

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if ((gv.mod.currentArea.northernNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.northernNeighbourArea)
                        {
                            indexOfNorthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].easternNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].westernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.southernNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.southernNeighbourArea)
                        {
                            indexOfSouthernNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].easternNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].westernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.westernNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.westernNeighbourArea)
                        {
                            indexOfWesternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthWesternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfWesternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthWesternNeighbour = i;
                            }
                        }
                    }
                }

                if ((gv.mod.currentArea.easternNeighbourArea != ""))
                {
                    for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                    {
                        if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.currentArea.easternNeighbourArea)
                        {
                            indexOfEasternNeighbour = i;
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].northernNeighbourArea)
                            {
                                indexOfNorthEasternNeighbour = i;
                            }
                        }
                    }

                    if (gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea != "")
                    {
                        for (int i = 0; i < gv.mod.moduleAreasObjects.Count; i++)
                        {
                            if (gv.mod.moduleAreasObjects[i].Filename == gv.mod.moduleAreasObjects[indexOfEasternNeighbour].southernNeighbourArea)
                            {
                                indexOfSouthEasternNeighbour = i;
                            }
                        }
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if ((gv.mod.currentArea.northernNeighbourArea != "") && (gv.mod.PlayerLocationY < 1))
                {
                    seamlessModififierMinY = 1;
                }

                if ((gv.mod.currentArea.southernNeighbourArea != "") && (gv.mod.PlayerLocationY > (gv.mod.currentArea.MapSizeY - 2)))
                {
                    seamlessModififierMaxY = 1;
                }

                if ((gv.mod.currentArea.westernNeighbourArea != "") && (gv.mod.PlayerLocationX < 1))
                {
                    seamlessModififierMinX = 1;
                }

                if ((gv.mod.currentArea.easternNeighbourArea != "") && (gv.mod.PlayerLocationX > (gv.mod.currentArea.MapSizeX - 2)))
                {
                    seamlessModififierMaxX = 1;
                }

                
                //this block draws teh saquares immediately around the player
                int minX = gv.mod.PlayerLocationX - 1;
                if (minX < -seamlessModififierMinX) { minX = -seamlessModififierMinX; }
                int minY = gv.mod.PlayerLocationY - 1;
                if (minY < -seamlessModififierMinY) { minY = -seamlessModififierMinY; }

                int maxX = gv.mod.PlayerLocationX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX - 1 + seamlessModififierMaxX) { maxX = this.gv.mod.currentArea.MapSizeX - 1 + seamlessModififierMaxX; }
                int maxY = gv.mod.PlayerLocationY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY - 1 + seamlessModififierMaxY) { maxY = this.gv.mod.currentArea.MapSizeY - 1 + seamlessModififierMaxY; }

                for (int xx = minX; xx <= maxX; xx++)
                {
                    for (int yy = minY; yy <= maxY; yy++)
                    {
                        //YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
                        bool situationFound = false;
                        bool drawTile = true;
                        int index = -1;
                        Tile tile = new Tile();

                        //nine situations where a tile can be:
                        //tile on north-western map (diagonal situation)
                        if ((xx < 0) && (yy < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + xx;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY + yy;
                                tile = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX];
                                index = indexOfNorthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-westernmap (diagonal situation)
                        if ((xx < 0) && (yy > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + xx;
                                int transformedY = yy - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX];
                                index = indexOfSouthWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on south-easternmap (diagonal situation)
                        if ((xx > (gv.mod.currentArea.MapSizeX - 1)) && (yy > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = xx - gv.mod.currentArea.MapSizeX;
                                int transformedY = yy - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX];
                                index = indexOfSouthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on north-easternmap (diagonal situation)
                        if ((xx > (gv.mod.currentArea.MapSizeX - 1)) && (yy < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = xx - gv.mod.currentArea.MapSizeX;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY + yy;
                                tile = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX];
                                index = indexOfNorthEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on western map
                        if ((xx < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + xx;
                                int transformedY = yy;
                                tile = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX];
                                index = indexOfWesternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on southern map
                        if ((yy > (gv.mod.currentArea.MapSizeY - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = xx;
                                int transformedY = yy - gv.mod.currentArea.MapSizeY;
                                tile = gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX];
                                index = indexOfSouthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on eastern map
                        if ((xx > (gv.mod.currentArea.MapSizeX - 1)) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = xx - gv.mod.currentArea.MapSizeX;
                                int transformedY = yy;
                                tile = gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX];
                                index = indexOfEasternNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile on northern map
                        if ((yy < 0) && (!situationFound))
                        {
                            situationFound = true;
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = xx;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + yy;
                                tile = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[transformedY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX];
                                index = indexOfNorthernNeighbour;
                            }
                            else
                            {
                                drawTile = false;
                            }
                        }
                        //tile is on current map
                        if (!situationFound)
                        {
                            tile = gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx];
                            //gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                        }

                        if (drawTile)
                        {
                            tile.Visible = true;
                            //tile.lightRadius = 0;
                            //tile.isCentreOfLightCircle = false;
                            //tile.isOtherPartOfLightCircle = false;
                        }

                        //YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
                        //gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                    }
                }

                int x = 0;
                int y = 0;

                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {

                    //1. check left-top (current, west, north, nortwest)
                    x = gv.mod.PlayerLocationX - 1;
                    y = gv.mod.PlayerLocationY - 1;

                    //current the second tier diagonal (NW) tile is on current map 
                    if ((x - 1 >= 0) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                    }

                    //west (inside check left top)
                    //the second tier diagonal (NW) tile is ONE square in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NW) tile is TWO squares in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y - 1 >= 0) && (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //north (inside check left top)
                    //the second tier diagonal (NW) tile is ONE square in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (NW) tile is TWO squares in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //northwest (inside check left top)
                    //the second tier diagonal (NW) tile is ONE square in northwestern map
                    if (indexOfNorthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NW) tile is TWO squares in northwestern map
                    if (indexOfNorthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 2;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                    //2. check left-bottom (current, west, south, southwest)
                    x = gv.mod.PlayerLocationX - 1;
                    y = gv.mod.PlayerLocationY + 1;

                    //current the second tier diagonal (SW) tile is on current map 
                    if ((x - 1 >= 0) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                    }

                    //west (inside check left bottom)
                    //the second tier diagonal (SW) tile is ONE square in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y + 1 < gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SW) tile is TWO squares in western map
                    if (indexOfWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y + 1 < gv.mod.currentArea.MapSizeY) && (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //south (inside check left bottom)
                    //the second tier diagonal (SW) tile is ONE square in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (SW) tile is TWO squares in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x - 1 >= 0) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX - 1].Visible = true;
                        }
                    }

                    //southwest (inside check left top)
                    //the second tier diagonal (SW) tile is ONE square in southwestern map
                    if (indexOfSouthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -1) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SW) tile is TWO squares in southwestern map
                    if (indexOfSouthWesternNeighbour != -1)
                    {
                        if ((x - 1 == -2) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(0) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1].LoSBlocked))
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 2;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                    //3. check right-bottom (current, east, south, southeast)
                    x = gv.mod.PlayerLocationX + 1;
                    y = gv.mod.PlayerLocationY + 1;

                    //current the second tier diagonal (SE) tile is on current map 
                    if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                    }

                    //east (inside check right bottom)
                    //the second tier diagonal (SE) tile is ONE square in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SE) tile is TWO squares in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //south (inside check right bottom)
                    //the second tier diagonal (SE) tile is ONE square in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (SE) tile is TWO squares in southern map
                    if (indexOfSouthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //southeast (inside check right bottom)
                    //the second tier diagonal (SE) tile is ONE square in southeastern map
                    if (indexOfSouthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (SE) tile is TWO squares in southeastern map
                    if (indexOfSouthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y + 1 == gv.mod.currentArea.MapSizeY + 1) && (!gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(0) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = 1;
                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }
                    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                    //4.check right-top (current, east, north, northeast)
                    x = gv.mod.PlayerLocationX + 1;
                    y = gv.mod.PlayerLocationY - 1;

                    //current: the second tier diagonal (NE) tile is on current map 
                    if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                    }

                    //east (inside check right top)
                    //the second tier diagonal (NE) tile is ONE square in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NE) tile is TWO squares in eastern map
                    if (indexOfEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y - 1 >= 0) && (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //north (inside check right top)
                    //the second tier diagonal (NE) tile is ONE square in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //the second tier diagonal (NE) tile is TWO squares in northern map
                    if (indexOfNorthernNeighbour != -1)
                    {
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + transformedX + 1].Visible = true;
                        }
                    }

                    //northeast (inside check right top)
                    //the second tier diagonal (NE) tile is ONE square in northeastern map
                    if (indexOfNorthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX) && (y - 1 == -1) && (!gv.mod.currentArea.Tiles[0 * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            int transformedX = 0;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }

                    //the second tier diagonal (NE) tile is TWO squares in northeastern map
                    if (indexOfNorthEasternNeighbour != -1)
                    {
                        if ((x + 1 == gv.mod.currentArea.MapSizeX + 1) && (y - 1 == -2) && (!gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + 0].LoSBlocked))
                        {
                            int transformedX = 1;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 2;
                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                        }
                    }
                } 

                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check left
                    x = gv.mod.PlayerLocationX - 1;
                    y = gv.mod.PlayerLocationY;
                    //the second tier row is not on western map (|210)
                    if ((x - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on current map
                        if (y > 0)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier north tile is on norhtern map
                        else if (y == 0)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;

                        //the second tier south tile is on current map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier south tile is on southern map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on western map, but the potential LoS blocker still on current map (2|10)
                    else if ((x - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on western map
                        if (y > 0)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //the second tier north tile is on north-western map
                        else if (y == 0)
                        {
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on western map
                        if (indexOfWesternNeighbour != -1)
                        {
                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier south tile is on western map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                        //the second tier south tile is on south-western map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on western map, but the party is still on current map (21|0)
                    else if (x - 1 == -2)
                    {
                        if (indexOfWesternNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked)
                            {
                                //the second tier north tile is on western map
                                if (y > 0)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                                //the second tier north tile is on north-western map
                                else if (y == 0)
                                {
                                    if (indexOfNorthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 2;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                        gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                //draw the second tier base tile on western map
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier south tile is on western map
                                if (y < gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                }
                                //the second tier south tile is on south-western map
                                else if (y == gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfSouthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 2;
                                        int transformedY = 0;
                                        gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                bool loSCheck1 = false;
                bool loSCheck2 = false;
                int tempX = 0;
                int tempY = 0;

                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check left of left
                    x = gv.mod.PlayerLocationX - 2;
                    y = gv.mod.PlayerLocationY;
                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempX = 0;

                    //loSCheck1
                    tempX = x + 1;
                    if (((tempX) < 0) && (indexOfWesternNeighbour != -1))
                    {
                        tempX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX;
                        if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((x + 1) >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x + 1].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempX = x;
                    if ((tempX < 0) && (indexOfWesternNeighbour != -1))
                    {
                        tempX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX;
                        if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (x >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on western map (|210)
                        if ((x - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on current map
                            if (y > 0)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier north tile is on norhtern map
                            else if (y == 0)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;

                            //the second tier south tile is on current map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier south tile is on southern map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on western map, but the potential LoS blocker still on current map (2|10)
                        else if ((x - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on western map
                            if (y > 0)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //the second tier north tile is on north-western map
                            else if (y == 0)
                            {
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on western map
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier south tile is on western map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                            //the second tier south tile is on south-western map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on western map, but the party is still on current map (21|0)
                        else if (x - 1 == -2)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1)].LoSBlocked)
                                {
                                    //the second tier north tile is on western map
                                    if (y > 0)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-western map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 2;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on western map
                                    if (indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on western map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-western map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 2;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                        //utmost left situation (321|0)
                        else if (x - 1 == -3)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 2)].LoSBlocked)
                                {
                                    //the second tier north tile is on western map
                                    if (y > 0)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 3;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-western map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 3;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on western map
                                    if (indexOfWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 3;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on western map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 3;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-western map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 3;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check right
                    x = gv.mod.PlayerLocationX + 1;
                    y = gv.mod.PlayerLocationY;
                    //the second tier row is not on eastern map (012|)
                    if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on current map
                        if (y > 0)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier north tile is on norhtern map
                        else if (y == 0)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;

                        //the second tier south tile is on current map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier south tile is on southern map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on eastern map, but the potential LoS blocker still on current map (01|2)
                    else if ((x + 1 == gv.mod.currentArea.MapSizeX) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier north tile is on eastern map
                        if (y > 0)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //the second tier north tile is on north-eastern map
                        else if (y == 0)
                        {
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on eastern map
                        if (indexOfEasternNeighbour != -1)
                        {
                            int transformedX = 0;
                            int transformedY = y;
                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier south tile is on eastern map
                        if (y < gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                        //the second tier south tile is on south-eastern map
                        else if (y == gv.mod.currentArea.MapSizeY - 1)
                        {
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on eastern map, but the party is still on current map (0|12)
                    else if (x + 1 == gv.mod.currentArea.MapSizeX + 1)
                    {
                        if (indexOfEasternNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked)
                            {
                                //the second tier north tile is on eastern map
                                if (y > 0)
                                {
                                    int transformedX = 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                                //the second tier north tile is on north-eastern map
                                else if (y == 0)
                                {
                                    if (indexOfNorthEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                        gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                // the second tier base tile on eastern map
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier south tile is on eastern map
                                if (y < gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                }
                                //the second tier south tile is on south-eastern map
                                else if (y == gv.mod.currentArea.MapSizeY - 1)
                                {
                                    if (indexOfSouthEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = 0;
                                        gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check right of right
                    x = gv.mod.PlayerLocationX + 2;
                    y = gv.mod.PlayerLocationY;
                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempX = 0;

                    //loSCheck1
                    tempX = x - 1;
                    if ((tempX > (gv.mod.currentArea.MapSizeX - 1)) && (indexOfEasternNeighbour != -1))
                    {
                        tempX = 0;
                        if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((x - 1) <= (gv.mod.currentArea.MapSizeX - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x - 1].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempX = x;
                    if ((tempX > (gv.mod.currentArea.MapSizeX - 1)) && (indexOfEasternNeighbour != -1))
                    {
                        tempX = 1;
                        if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + tempX].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (x <= (gv.mod.currentArea.MapSizeX - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on eastern map (012|)
                        if ((x + 1 <= gv.mod.currentArea.MapSizeX - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on current map
                            if (y > 0)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier north tile is on norhtern map
                            else if (y == 0)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y + 0) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;

                            //the second tier south tile is on current map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier south tile is on southern map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on eastern map, but the potential LoS blocker still on current map (01|2)
                        else if ((x + 1 == gv.mod.currentArea.MapSizeX) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier north tile is on eastern map
                            if (y > 0)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //the second tier north tile is on north-eastern map
                            else if (y == 0)
                            {
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on eastern map
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier south tile is on eastern map
                            if (y < gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                            //the second tier south tile is on south-eastern map
                            else if (y == gv.mod.currentArea.MapSizeY - 1)
                            {
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on eastern map, but the party is still on current map (0|12)
                        else if (x + 1 == gv.mod.currentArea.MapSizeX + 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 0].LoSBlocked)
                                {
                                    //the second tier north tile is on eastern map
                                    if (y > 0)
                                    {
                                        int transformedX = 1;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-eastern map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 1;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    // the second tier base tile on eastern map
                                    if (indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = 1;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on eastern map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfEasternNeighbour != -1)
                                        {
                                            int transformedX = 1;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-eastern map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 1;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }

                        //utmost right situation (0|123)
                        else if (x + 1 == gv.mod.currentArea.MapSizeX + 2)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[y * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + 1].LoSBlocked)
                                {
                                    //the second tier north tile is on eastern map
                                    if (y > 0)
                                    {
                                        int transformedX = 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                    //the second tier north tile is on north-eastern map
                                    else if (y == 0)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 2;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    // the second tier base tile on eastern map
                                    if (indexOfEasternNeighbour != -1)
                                    {
                                        int transformedX = 2;
                                        int transformedY = y;
                                        gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier south tile is on eastern map
                                    if (y < gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfEasternNeighbour != -1)
                                        {
                                            int transformedX = 2;
                                            int transformedY = y;
                                            gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                        }
                                    }
                                    //the second tier south tile is on south-eastern map
                                    else if (y == gv.mod.currentArea.MapSizeY - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 2;
                                            int transformedY = 0;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                //XXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check up
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY - 1;
                    //the second tier row is not on northern map (|210, turn 90degree clockwise)
                    if ((y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on current map
                        if (x > 0)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier west tile is on western map
                        else if (x == 0)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                        //the second tier eastern tile is on current map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier eastern tile is on eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                //hrmmmpf
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree clockwise)
                    else if ((y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on northern map
                        if (x > 0)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }
                        //the second tier west tile is on north-western map
                        else if (x == 0)
                        {
                            if (indexOfNorthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on northern map
                        if (indexOfNorthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier eastern tile is on northern map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }
                        //the second tier eastern tile is on north-eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfNorthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree clockwise)
                    else if (y - 1 == -2)
                    {
                        if (indexOfNorthernNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                            {
                                //the second tier west tile is on northern map
                                if (x > 0)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2; ;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                                //the second tier west tile is on north-western map
                                else if (x == 0)
                                {
                                    if (indexOfNorthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                //draw the second tier base tile on northern map
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier east tile is on northern map
                                if (x < gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                    }
                                }
                                //the second tier east tile is on north-eastern map
                                else if (x == gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfNorthEasternNeighbour != -1)
                                    {
                                        int transformedX = 0;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check up of up
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY - 2;
                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempY = 0;

                    //loSCheck1
                    tempY = y + 1;
                    if (((tempY) < 0) && (indexOfNorthernNeighbour != -1))
                    {
                        tempY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + tempY;
                        if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((y + 1) >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempY = y;
                    if ((tempY < 0) && (indexOfNorthernNeighbour != -1))
                    {
                        tempY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY + tempY;
                        if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (y >= 0)
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on northern map (|210, turn 90degree clockwise)
                        if ((y - 1 >= 0) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on current map
                            if (x > 0)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier west tile is on western map
                            else if (x == 0)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                            //the second tier eastern tile is on current map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier eastern tile is on eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    //hrmmmpf
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY - 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree clockwise)
                        else if ((y - 1 == -1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on northern map
                            if (x > 0)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }
                            //the second tier west tile is on north-western map
                            else if (x == 0)
                            {
                                if (indexOfNorthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on northern map
                            if (indexOfNorthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier eastern tile is on northern map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfNorthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }
                            //the second tier eastern tile is on north-eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfNorthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 1;
                                    gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree clockwise)
                        else if (y - 1 == -2)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 1) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on northern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2; ;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on north-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 2;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on northern map
                                    if (indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on northern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2;
                                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on north-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 2;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                        //utmost up(321|0, turn 90 degree clockwise)
                        else if (y - 1 == -3)
                        {
                            if (indexOfNorthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 2) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on northern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 3; ;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on north-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfNorthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeY - 3;
                                            gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on northern map
                                    if (indexOfNorthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 3;
                                        gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on northern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeY - 3;
                                            gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on north-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfNorthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeY - 3;
                                            gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfNorthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 2)
                {
                    //check down
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY + 1;
                    //the second tier row is not on southern map (|210, turn 90degree counterclockwise)
                    if ((y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on current map
                        if (x > 0)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                        }
                        //the second tier west tile is on western map
                        else if (x == 0)
                        {
                            if (indexOfWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }

                        //draw the base tile on this map
                        gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                        //the second tier eastern tile is on current map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                        }
                        //the second tier eastern tile is on eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = y;
                                gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree counterclockwise)
                    else if ((y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                    {
                        //the second tier west tile is on southern map
                        if (x > 0)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                            }
                        }
                        //the second tier west tile is on south-western map
                        else if (x == 0)
                        {
                            if (indexOfSouthWesternNeighbour != -1)
                            {
                                int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                        //draw the second tier base tile on southern map
                        if (indexOfSouthernNeighbour != -1)
                        {
                            int transformedX = x;
                            int transformedY = 0;
                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                        }
                        //the second tier eastern tile is on southern map
                        if (x < gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                            }
                        }
                        //the second tier eastern tile is on south-eastern map
                        else if (x == gv.mod.currentArea.MapSizeX - 1)
                        {
                            if (indexOfSouthEasternNeighbour != -1)
                            {
                                int transformedX = 0;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                            }
                        }
                    }
                    //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree counterclockwise)
                    else if (y + 1 == gv.mod.currentArea.MapSizeY + 1)
                    {
                        if (indexOfSouthernNeighbour != -1)
                        {
                            if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                            {
                                //the second tier west tile is on southern map
                                if (x > 0)
                                {
                                    int transformedX = x;
                                    int transformedY = 1;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                                //the second tier west tile is on south-western map
                                else if (x == 0)
                                {
                                    if (indexOfSouthWesternNeighbour != -1)
                                    {
                                        int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                                //draw the second tier base tile on southern map
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 1;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                                //the second tier east tile is on southern map
                                if (x < gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                    }
                                }
                                //the second tier east tile is on south-eastern map
                                else if (x == gv.mod.currentArea.MapSizeX - 1)
                                {
                                    if (indexOfSouthEasternNeighbour != -1)
                                    {
                                        int transformedX = 0;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                    }
                                }
                            }
                        }
                    }
                }
                //XXXXXXXXXXXXXXXXXXXXXXX


                if (gv.mod.currentArea.AreaVisibleDistance >= 3)
                {
                    //check down of down
                    x = gv.mod.PlayerLocationX;
                    y = gv.mod.PlayerLocationY + 2;

                    loSCheck1 = false;
                    loSCheck2 = false;
                    tempX = 0;

                    //loSCheck1
                    tempY = y - 1;
                    if ((tempY > (gv.mod.currentArea.MapSizeY - 1)) && (indexOfSouthernNeighbour != -1))
                    {
                        tempY = 0;
                        if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    if ((y - 1) <= (gv.mod.currentArea.MapSizeY - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[(y - 1) * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck1 = true;
                        }
                    }

                    //loSCheck2
                    tempY = y;
                    if ((tempY > (gv.mod.currentArea.MapSizeY - 1)) && (indexOfSouthernNeighbour != -1))
                    {
                        tempY = 1;
                        if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[tempY * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (y <= (gv.mod.currentArea.MapSizeY - 1))
                    {
                        if (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked)
                        {
                            loSCheck2 = true;
                        }
                    }

                    if (loSCheck1 && loSCheck2)
                    {
                        //the second tier row is not on southern map (|210, turn 90degree counterclockwise)
                        if ((y + 1 <= gv.mod.currentArea.MapSizeY - 1) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on current map
                            if (x > 0)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x - 1)].Visible = true;
                            }
                            //the second tier west tile is on western map
                            else if (x == 0)
                            {
                                if (indexOfWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX - 1;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfWesternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfWesternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }

                            //draw the base tile on this map
                            gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x)].Visible = true;

                            //the second tier eastern tile is on current map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                gv.mod.currentArea.Tiles[(y + 1) * gv.mod.currentArea.MapSizeX + (x + 1)].Visible = true;
                            }
                            //the second tier eastern tile is on eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = y;
                                    gv.mod.moduleAreasObjects[indexOfEasternNeighbour].Tiles[(transformedY + 1) * gv.mod.moduleAreasObjects[indexOfEasternNeighbour].MapSizeX + (transformedX)].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile is on northern map, but the potential LoS blocker still on current map (2|10, turn 90degree counterclockwise)
                        else if ((y + 1 == gv.mod.currentArea.MapSizeY) && (!gv.mod.currentArea.Tiles[y * gv.mod.currentArea.MapSizeX + x].LoSBlocked))
                        {
                            //the second tier west tile is on southern map
                            if (x > 0)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                }
                            }
                            //the second tier west tile is on south-western map
                            else if (x == 0)
                            {
                                if (indexOfSouthWesternNeighbour != -1)
                                {
                                    int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                            //draw the second tier base tile on southern map
                            if (indexOfSouthernNeighbour != -1)
                            {
                                int transformedX = x;
                                int transformedY = 0;
                                gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                            }
                            //the second tier eastern tile is on southern map
                            if (x < gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfSouthernNeighbour != -1)
                                {
                                    int transformedX = x;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                }
                            }
                            //the second tier eastern tile is on south-eastern map
                            else if (x == gv.mod.currentArea.MapSizeX - 1)
                            {
                                if (indexOfSouthEasternNeighbour != -1)
                                {
                                    int transformedX = 0;
                                    int transformedY = 0;
                                    gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                }
                            }
                        }
                        //the second tier base tile and the potential LoS blocker are on northern map, but the party is still on current map (21|0, turn 90 degree counterclockwise)
                        else if (y + 1 == gv.mod.currentArea.MapSizeY + 1)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[0 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on southern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on south-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = 1;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on southern map
                                    if (indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = 1;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on southern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = 1;
                                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on south-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = 1;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                        //utmost down situation(321|0, turn 90 degree counterclockwise)
                        else if (y + 1 == gv.mod.currentArea.MapSizeY + 2)
                        {
                            if (indexOfSouthernNeighbour != -1)
                            {
                                if (!gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[1 * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + x].LoSBlocked)
                                {
                                    //the second tier west tile is on southern map
                                    if (x > 0)
                                    {
                                        int transformedX = x;
                                        int transformedY = 2;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX - 1)].Visible = true;
                                    }
                                    //the second tier west tile is on south-western map
                                    else if (x == 0)
                                    {
                                        if (indexOfSouthWesternNeighbour != -1)
                                        {
                                            int transformedX = gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX - 1;
                                            int transformedY = 2;
                                            gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthWesternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                    //draw the second tier base tile on southern map
                                    if (indexOfSouthernNeighbour != -1)
                                    {
                                        int transformedX = x;
                                        int transformedY = 2;
                                        gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY + 0) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX)].Visible = true;
                                    }
                                    //the second tier east tile is on southern map
                                    if (x < gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthernNeighbour != -1)
                                        {
                                            int transformedX = x;
                                            int transformedY = 2;
                                            gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthernNeighbour].MapSizeX + (transformedX + 1)].Visible = true;
                                        }
                                    }
                                    //the second tier east tile is on south-eastern map
                                    else if (x == gv.mod.currentArea.MapSizeX - 1)
                                    {
                                        if (indexOfSouthEasternNeighbour != -1)
                                        {
                                            int transformedX = 0;
                                            int transformedY = 2;
                                            gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].Tiles[(transformedY) * gv.mod.moduleAreasObjects[indexOfSouthEasternNeighbour].MapSizeX + transformedX].Visible = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                //XXXXXXXXXXXXXXXXXXXXXXXXX
                #endregion
            }
            else
            {
                #region Old System

                // set current position to visible
                //gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].Visible = true;

                if (gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX < gv.mod.currentArea.Tiles.Count)
                {
                    gv.mod.currentArea.Tiles[gv.mod.PlayerLocationY * gv.mod.currentArea.MapSizeX + gv.mod.PlayerLocationX].Visible = true;
                 }


                // set tiles to visible around the PC
                for (int x = gv.mod.PlayerLocationX - gv.mod.currentArea.AreaVisibleDistance; x <= gv.mod.PlayerLocationX + gv.mod.currentArea.AreaVisibleDistance; x++)
                {
                    for (int y = gv.mod.PlayerLocationY - gv.mod.currentArea.AreaVisibleDistance; y <= gv.mod.PlayerLocationY + gv.mod.currentArea.AreaVisibleDistance; y++)
                    {
                        int xx = x;
                        int yy = y;
                        if (xx < 1) { xx = 0; }
                        if (xx > (gv.mod.currentArea.MapSizeX - 1)) { xx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (yy < 1) { yy = 0; }
                        if (yy > (gv.mod.currentArea.MapSizeY - 1)) { yy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (IsLineOfSightForEachCorner(new Coordinate(gv.mod.PlayerLocationX, gv.mod.PlayerLocationY), new Coordinate(xx, yy)))
                        {
                            gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                        }
                    }
                }
                //make all adjacent squares visible
                int minX = gv.mod.PlayerLocationX - 1;
                if (minX < 0) { minX = 0; }
                int minY = gv.mod.PlayerLocationY - 1;
                if (minY < 0) { minY = 0; }

                int maxX = gv.mod.PlayerLocationX + 1;
                if (maxX > this.gv.mod.currentArea.MapSizeX - 1) { maxX = this.gv.mod.currentArea.MapSizeX - 1; }
                int maxY = gv.mod.PlayerLocationY + 1;
                if (maxY > this.gv.mod.currentArea.MapSizeY - 1) { maxY = this.gv.mod.currentArea.MapSizeY - 1; }

                for (int xx = minX; xx <= maxX; xx++)
                {
                    for (int yy = minY; yy <= maxY; yy++)
                    {
                        gv.mod.currentArea.Tiles[yy * gv.mod.currentArea.MapSizeX + xx].Visible = true;
                    }
                }
                #endregion
            }
        }
        public bool IsTouchInMapWindow(int sqrX, int sqrY)
        {
            //all input coordinates are in Screen Location, not Map Location
            if ((sqrX < 0) || (sqrY < 0))
            {
                return false;
            }
            if ((sqrX > 19) || (sqrY > 10))
            {
                return false;
            }
            return true;
        }
        public bool IsLineOfSightForEachCorner(Coordinate s, Coordinate e)
        {
            //start is at the center of party location square
            Coordinate start = new Coordinate((s.X * gv.squareSize) + (gv.squareSize / 2), (s.Y * gv.squareSize) + (gv.squareSize / 2));
            //check center of all four sides of the end square
            int halfSquare = (gv.squareSize / 2);
            //left side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize, e.Y * gv.squareSize + halfSquare), e)) { return true; }
            //right side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize + gv.squareSize, e.Y * gv.squareSize + halfSquare), e)) { return true; }
            //top side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize + halfSquare, e.Y * gv.squareSize), e)) { return true; }
            //bottom side center
            if (IsVisibleLineOfSight(start, new Coordinate(e.X * gv.squareSize + halfSquare, e.Y * gv.squareSize + gv.squareSize), e)) { return true; }

            return false;
        }
        public bool IsVisibleLineOfSight(Coordinate s, Coordinate e, Coordinate endSquare)
        {
            // Bresenham Line algorithm
            Coordinate start = s;
            Coordinate end = e;
            int deltax = Math.Abs(end.X - start.X);
            int deltay = Math.Abs(end.Y - start.Y);
            int ystep = 10;
            int xstep = 10;
            int gridx = 0;
            int gridy = 0;
            int gridXdelayed = s.X;
            int gridYdelayed = s.Y;

            //gv.DrawLine(end.X + gv.oXshift, end.Y + gv.oYshift, start.X + gv.oXshift, start.Y + gv.oYshift, Color.Lime, 1);
            
            #region low angle version
            if (deltax > deltay) //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltax / 2;

                if (end.Y < start.Y) { ystep = -1 * ystep; } //down and right or left

                if (end.X > start.X) //down and right
                {
                    for (int x = start.X; x <= end.X; x += xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                else //down and left
                {
                    for (int x = start.X; x >= end.X; x -= xstep)
                    {
                        nextPoint.X = x;
                        error -= deltay;
                        if (error < 0)
                        {
                            nextPoint.Y += ystep;
                            error += deltax;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
            }
            #endregion

            #region steep version
            else //Low Angle line
            {
                Coordinate nextPoint = start;
                int error = deltay / 2;

                if (end.X < start.X) { xstep = -1 * xstep; } //up and right or left

                if (end.Y > start.Y) //up and right
                {
                    for (int y = start.Y; y <= end.Y; y += ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                else //up and right
                {
                    for (int y = start.Y; y >= end.Y; y -= ystep)
                    {
                        nextPoint.Y = y;
                        error -= deltax;
                        if (error < 0)
                        {
                            nextPoint.X += xstep;
                            error += deltay;
                        }
                        //do your checks here for LoS blocking
                        gridx = nextPoint.X / gv.squareSize;
                        gridy = nextPoint.Y / gv.squareSize;
                        if (gridx < 1) { gridx = 0; }
                        if (gridx > (gv.mod.currentArea.MapSizeX - 1)) { gridx = (gv.mod.currentArea.MapSizeX - 1); }
                        if (gridy < 1) { gridy = 0; }
                        if (gridy > (gv.mod.currentArea.MapSizeY - 1)) { gridy = (gv.mod.currentArea.MapSizeY - 1); }
                        if (gv.mod.currentArea.Tiles[gridy * gv.mod.currentArea.MapSizeX + gridx].LoSBlocked)
                        {
                            if ((gridx == endSquare.X) && (gridy == endSquare.Y))
                            {
                                //you are on the end square so return true
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
            }
            #endregion

            return true;
        }

        public bool hasMainMapTypeSpell(Player pc)
        {
            foreach (string s in pc.knownSpellsTags)
            {
                Spell sp = gv.mod.getSpellByTag(s);
                if (sp == null) { continue; }
                if ((sp.useableInSituation.Equals("Always")) || (sp.useableInSituation.Equals("OutOfCombat")))
                {
                    return true;
                }
            }
            return false;
        }
    }
}
//#endregion
